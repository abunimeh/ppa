#@ # 
#@ # Running pt_shell Version J-2014.06-SP2 for suse64 -- Aug 27, 2014
#@ # Date:   Tue Mar 31 10:15:24 2015
#@ # Run by: spalutla@chlr16420
#@ 

source /nfs/site/eda/data/disk0058/synopsys/primetime/J-2014.06-SP2/linux_2.6.32_x86-64/admin/setup/.synopsys_pt.setup
#@ # -- Starting source /nfs/site/eda/data/disk0058/synopsys/primetime/J-2014.06-SP2/linux_2.6.32_x86-64/auxx/tcllib/lib/itcl3.4/itcl.tcl

#@ #
#@ # itcl.tcl
#@ # ----------------------------------------------------------------------
#@ # Invoked automatically upon startup to customize the interpreter
#@ # for [incr Tcl].
#@ # ----------------------------------------------------------------------
#@ #   AUTHOR:  Michael J. McLennan
#@ #            Bell Labs Innovations for Lucent Technologies
#@ #            mmclennan@lucent.com
#@ #            http://www.tcltk.com/itcl
#@ #
#@ #      RCS:  $Id: itcl.tcl,v 1.12 2009/10/14 20:53:34 hobbs Exp $
#@ # ----------------------------------------------------------------------
#@ #            Copyright (c) 1993-1998  Lucent Technologies, Inc.
#@ # ======================================================================
#@ # See the file "license.terms" for information on usage and
#@ # redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ proc ::itcl::delete_helper { name args } {
#@     ::itcl::delete object $name
#@ }
#@ 
#@ # ----------------------------------------------------------------------
#@ #  USAGE:  local <className> <objName> ?<arg> <arg>...?
#@ #
#@ #  Creates a new object called <objName> in class <className>, passing
#@ #  the remaining <arg>'s to the constructor.  Unlike the usual
#@ #  [incr Tcl] objects, however, an object created by this procedure
#@ #  will be automatically deleted when the local call frame is destroyed.
#@ #  This command is useful for creating objects that should only remain
#@ #  alive until a procedure exits.
#@ # ----------------------------------------------------------------------
#@ proc ::itcl::local {class name args} {
#@     set ptr [uplevel [list $class $name] $args]
#@     uplevel [list set itcl-local-$ptr $ptr]
#@     set cmd [uplevel namespace which -command $ptr]
#@     uplevel [list trace variable itcl-local-$ptr u         "::itcl::delete_helper $cmd"]
#@     return $ptr
#@ }
#@ 
#@ # ----------------------------------------------------------------------
#@ # auto_mkindex
#@ # ----------------------------------------------------------------------
#@ # Define Itcl commands that will be recognized by the auto_mkindex
#@ # parser in Tcl...
#@ #
#@ 
#@ #
#@ # USAGE:  itcl::class name body
#@ # Adds an entry for the given class declaration.
#@ #
#@ foreach cmd {itcl::class class} {
#@     auto_mkindex_parser::command $cmd {name body} {
#@ 	variable index
#@ 	variable scriptFile
#@ 	append index "set [list auto_index([fullname $name])]"
#@ 	append index " \[list source \[file join \$dir [list $scriptFile]\]\]\n"
#@ 
#@ 	variable parser
#@ 	variable contextStack
#@ 	set contextStack [linsert $contextStack 0 $name]
#@ 	$parser eval $body
#@ 	set contextStack [lrange $contextStack 1 end]
#@     }
#@ }
#@ # -- Starting source /nfs/site/eda/data/disk0058/synopsys/primetime/J-2014.06-SP2/linux_2.6.32_x86-64/auxx/tcllib/lib/tcl8.5/auto.tcl

#@ # auto.tcl --
#@ #
#@ # utility procs formerly in init.tcl dealing with auto execution
#@ # of commands and can be auto loaded themselves.
#@ #
#@ # Copyright (c) 1991-1993 The Regents of the University of California.
#@ # Copyright (c) 1994-1998 Sun Microsystems, Inc.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ # auto_reset --
#@ #
#@ # Destroy all cached information for auto-loading and auto-execution,
#@ # so that the information gets recomputed the next time it's needed.
#@ # Also delete any commands that are listed in the auto-load index.
#@ #
#@ # Arguments: 
#@ # None.
#@ 
#@ proc auto_reset {} {
#@     if {[array exists ::auto_index]} {
#@ 	foreach cmdName [array names ::auto_index] {
#@ 	    set fqcn [namespace which $cmdName]
#@ 	    if {$fqcn eq ""} {continue}
#@ 	    rename $fqcn {}
#@ 	}
#@     }
#@     unset -nocomplain ::auto_execs ::auto_index ::tcl::auto_oldpath
#@     if {[catch {llength $::auto_path}]} {
#@ 	set ::auto_path [list [info library]]
#@     } else {
#@ 	if {[info library] ni $::auto_path} {
#@ 	    lappend ::auto_path [info library]
#@ 	}
#@     }
#@ }
#@ 
#@ # tcl_findLibrary --
#@ #
#@ #	This is a utility for extensions that searches for a library directory
#@ #	using a canonical searching algorithm. A side effect is to source
#@ #	the initialization script and set a global library variable.
#@ #
#@ # Arguments:
#@ # 	basename	Prefix of the directory name, (e.g., "tk")
#@ #	version		Version number of the package, (e.g., "8.0")
#@ #	patch		Patchlevel of the package, (e.g., "8.0.3")
#@ #	initScript	Initialization script to source (e.g., tk.tcl)
#@ #	enVarName	environment variable to honor (e.g., TK_LIBRARY)
#@ #	varName		Global variable to set when done (e.g., tk_library)
#@ 
#@ proc tcl_findLibrary {basename version patch initScript enVarName varName} {
#@     upvar #0 $varName the_library
#@     global env
#@ 
#@     set dirs {}
#@     set errors {}
#@ 
#@     # The C application may have hardwired a path, which we honor
#@ 
#@     if {[info exists the_library] && $the_library ne ""} {
#@ 	lappend dirs $the_library
#@     } else {
#@ 
#@ 	# Do the canonical search
#@ 
#@ 	# 1. From an environment variable, if it exists.
#@ 	#    Placing this first gives the end-user ultimate control
#@ 	#    to work-around any bugs, or to customize.
#@ 
#@         if {[info exists env($enVarName)]} {
#@             lappend dirs $env($enVarName)
#@         }
#@ 
#@ 	# 2. In the package script directory registered within
#@ 	#    the configuration of the package itself.
#@ 
#@ 	if {[catch {
#@ 	    ::${basename}::pkgconfig get scriptdir,runtime
#@ 	} value] == 0} {
#@ 	    lappend dirs $value
#@ 	}
#@ 
#@ 	# 3. Relative to auto_path directories.  This checks relative to the
#@ 	# Tcl library as well as allowing loading of libraries added to the
#@ 	# auto_path that is not relative to the core library or binary paths.
#@ 	foreach d $::auto_path {
#@ 	    lappend dirs [file join $d $basename$version]
#@ 	    if {$::tcl_platform(platform) eq "unix"
#@ 		&& $::tcl_platform(os) eq "Darwin"} {
#@ 		# 4. On MacOSX, check the Resources/Scripts subdir too
#@ 		lappend dirs [file join $d $basename$version Resources Scripts]
#@ 	    }
#@ 	}
#@ 
#@ 	# 3. Various locations relative to the executable
#@ 	# ../lib/foo1.0		(From bin directory in install hierarchy)
#@ 	# ../../lib/foo1.0	(From bin/arch directory in install hierarchy)
#@ 	# ../library		(From unix directory in build hierarchy)
#@ 	#
#@ 	# Remaining locations are out of date (when relevant, they ought
#@ 	# to be covered by the $::auto_path seach above) and disabled.
#@ 	#
#@ 	# ../../library		(From unix/arch directory in build hierarchy)
#@ 	# ../../foo1.0.1/library
#@ 	#		(From unix directory in parallel build hierarchy)
#@ 	# ../../../foo1.0.1/library
#@ 	#		(From unix/arch directory in parallel build hierarchy)
#@ 
#@         set parentDir [file dirname [file dirname [info nameofexecutable]]]
#@         set grandParentDir [file dirname $parentDir]
#@         lappend dirs [file join $parentDir lib $basename$version]
#@         lappend dirs [file join $grandParentDir lib $basename$version]
#@         lappend dirs [file join $parentDir library]
#@ 	if {0} {
#@ 	    lappend dirs [file join $grandParentDir library]
#@ 	    lappend dirs [file join $grandParentDir $basename$patch library]
#@ 	    lappend dirs [file join [file dirname $grandParentDir] 			      $basename$patch library]
#@ 	}
#@     }
#@     # uniquify $dirs in order
#@     array set seen {}
#@     foreach i $dirs {
#@ 	# Take note that the [file normalize] below has been noted to
#@ 	# cause difficulties for the freewrap utility.  See Bug 1072136.
#@ 	# Until freewrap resolves the matter, one might work around the
#@ 	# problem by disabling that branch.
#@ 	if {[interp issafe]} {
#@ 	    set norm $i
#@ 	} else {
#@ 	    set norm [file normalize $i]
#@ 	}
#@ 	if {[info exists seen($norm)]} { continue }
#@ 	set seen($norm) ""
#@ 	lappend uniqdirs $i
#@     }
#@     set dirs $uniqdirs
#@     foreach i $dirs {
#@         set the_library $i
#@         set file [file join $i $initScript]
#@ 
#@ 	# source everything when in a safe interpreter because
#@ 	# we have a source command, but no file exists command
#@ 
#@         if {[interp issafe] || [file exists $file]} {
#@             if {![catch {uplevel #0 [list source $file]} msg opts]} {
#@                 return
#@             } else {
#@                 append errors "$file: $msg\n"
#@ 		append errors [dict get $opts -errorinfo]\n
#@             }
#@         }
#@     }
#@     unset -nocomplain the_library
#@     set msg "Can't find a usable $initScript in the following directories: \n"
#@     append msg "    $dirs\n\n"
#@     append msg "$errors\n\n"
#@     append msg "This probably means that $basename wasn't installed properly.\n"
#@     error $msg
#@ }
#@ 
#@ 
#@ # ----------------------------------------------------------------------
#@ # auto_mkindex
#@ # ----------------------------------------------------------------------
#@ # The following procedures are used to generate the tclIndex file
#@ # from Tcl source files.  They use a special safe interpreter to
#@ # parse Tcl source files, writing out index entries as "proc"
#@ # commands are encountered.  This implementation won't work in a
#@ # safe interpreter, since a safe interpreter can't create the
#@ # special parser and mess with its commands.  
#@ 
#@ if {[interp issafe]} {
#@     return	;# Stop sourcing the file here
#@ }
#@ 
#@ # auto_mkindex --
#@ # Regenerate a tclIndex file from Tcl source files.  Takes as argument
#@ # the name of the directory in which the tclIndex file is to be placed,
#@ # followed by any number of glob patterns to use in that directory to
#@ # locate all of the relevant files.
#@ #
#@ # Arguments: 
#@ # dir -		Name of the directory in which to create an index.
#@ # args -	Any number of additional arguments giving the
#@ #		names of files within dir.  If no additional
#@ #		are given auto_mkindex will look for *.tcl.
#@ 
#@ proc auto_mkindex {dir args} {
#@     if {[interp issafe]} {
#@         error "can't generate index within safe interpreter"
#@     }
#@ 
#@     set oldDir [pwd]
#@     cd $dir
#@     set dir [pwd]
#@ 
#@     append index "# Tcl autoload index file, version 2.0\n"
#@     append index "# This file is generated by the \"auto_mkindex\" command\n"
#@     append index "# and sourced to set up indexing information for one or\n"
#@     append index "# more commands.  Typically each line is a command that\n"
#@     append index "# sets an element in the auto_index array, where the\n"
#@     append index "# element name is the name of a command and the value is\n"
#@     append index "# a script that loads the command.\n\n"
#@     if {[llength $args] == 0} {
#@ 	set args *.tcl
#@     }
#@ 
#@     auto_mkindex_parser::init
#@     foreach file [glob -- {*}$args] {
#@         if {[catch {auto_mkindex_parser::mkindex $file} msg opts] == 0} {
#@             append index $msg
#@         } else {
#@             cd $oldDir
#@ 	    return -options $opts $msg
#@         }
#@     }
#@     auto_mkindex_parser::cleanup
#@ 
#@     set fid [open "tclIndex" w]
#@     puts -nonewline $fid $index
#@     close $fid
#@     cd $oldDir
#@ }
#@ 
#@ # Original version of auto_mkindex that just searches the source
#@ # code for "proc" at the beginning of the line.
#@ 
#@ proc auto_mkindex_old {dir args} {
#@     set oldDir [pwd]
#@     cd $dir
#@     set dir [pwd]
#@     append index "# Tcl autoload index file, version 2.0\n"
#@     append index "# This file is generated by the \"auto_mkindex\" command\n"
#@     append index "# and sourced to set up indexing information for one or\n"
#@     append index "# more commands.  Typically each line is a command that\n"
#@     append index "# sets an element in the auto_index array, where the\n"
#@     append index "# element name is the name of a command and the value is\n"
#@     append index "# a script that loads the command.\n\n"
#@     if {[llength $args] == 0} {
#@ 	set args *.tcl
#@     }
#@     foreach file [glob -- {*}$args] {
#@ 	set f ""
#@ 	set error [catch {
#@ 	    set f [open $file]
#@ 	    while {[gets $f line] >= 0} {
#@ 		if {[regexp {^proc[ 	]+([^ 	]*)} $line match procName]} {
#@ 		    set procName [lindex [auto_qualify $procName "::"] 0]
#@ 		    append index "set [list auto_index($procName)]"
#@ 		    append index " \[list source \[file join \$dir [list $file]\]\]\n"
#@ 		}
#@ 	    }
#@ 	    close $f
#@ 	} msg opts]
#@ 	if {$error} {
#@ 	    catch {close $f}
#@ 	    cd $oldDir
#@ 	    return -options $opts $msg
#@ 	}
#@     }
#@     set f ""
#@     set error [catch {
#@ 	set f [open tclIndex w]
#@ 	puts -nonewline $f $index
#@ 	close $f
#@ 	cd $oldDir
#@     } msg opts]
#@     if {$error} {
#@ 	catch {close $f}
#@ 	cd $oldDir
#@ 	error $msg $info $code
#@ 	return -options $opts $msg
#@     }
#@ }
#@ 
#@ # Create a safe interpreter that can be used to parse Tcl source files
#@ # generate a tclIndex file for autoloading.  This interp contains
#@ # commands for things that need index entries.  Each time a command
#@ # is executed, it writes an entry out to the index file.
#@ 
#@ namespace eval auto_mkindex_parser {
#@     variable parser ""          ;# parser used to build index
#@     variable index ""           ;# maintains index as it is built
#@     variable scriptFile ""      ;# name of file being processed
#@     variable contextStack ""    ;# stack of namespace scopes
#@     variable imports ""         ;# keeps track of all imported cmds
#@     variable initCommands       ;# list of commands that create aliases
#@     if {![info exists initCommands]} {
#@ 	set initCommands [list]
#@     }
#@ 
#@     proc init {} {
#@ 	variable parser
#@ 	variable initCommands
#@ 
#@ 	if {![interp issafe]} {
#@ 	    set parser [interp create -safe]
#@ 	    $parser hide info
#@ 	    $parser hide rename
#@ 	    $parser hide proc
#@ 	    $parser hide namespace
#@ 	    $parser hide eval
#@ 	    $parser hide puts
#@ 	    $parser invokehidden namespace delete ::
#@ 	    $parser invokehidden proc unknown {args} {}
#@ 
#@ 	    # We'll need access to the "namespace" command within the
#@ 	    # interp.  Put it back, but move it out of the way.
#@ 
#@ 	    $parser expose namespace
#@ 	    $parser invokehidden rename namespace _%@namespace
#@ 	    $parser expose eval
#@ 	    $parser invokehidden rename eval _%@eval
#@ 
#@ 	    # Install all the registered psuedo-command implementations
#@ 
#@ 	    foreach cmd $initCommands {
#@ 		eval $cmd
#@ 	    }
#@ 	}
#@     }
#@     proc cleanup {} {
#@ 	variable parser
#@ 	interp delete $parser
#@ 	unset parser
#@     }
#@ }
#@ 
#@ # auto_mkindex_parser::mkindex --
#@ #
#@ # Used by the "auto_mkindex" command to create a "tclIndex" file for
#@ # the given Tcl source file.  Executes the commands in the file, and
#@ # handles things like the "proc" command by adding an entry for the
#@ # index file.  Returns a string that represents the index file.
#@ #
#@ # Arguments: 
#@ #	file	Name of Tcl source file to be indexed.
#@ 
#@ proc auto_mkindex_parser::mkindex {file} {
#@     variable parser
#@     variable index
#@     variable scriptFile
#@     variable contextStack
#@     variable imports
#@ 
#@     set scriptFile $file
#@ 
#@     set fid [open $file]
#@     set contents [read $fid]
#@     close $fid
#@ 
#@     # There is one problem with sourcing files into the safe
#@     # interpreter:  references like "$x" will fail since code is not
#@     # really being executed and variables do not really exist.
#@     # To avoid this, we replace all $ with \0 (literally, the null char)
#@     # later, when getting proc names we will have to reverse this replacement,
#@     # in case there were any $ in the proc name.  This will cause a problem
#@     # if somebody actually tries to have a \0 in their proc name.  Too bad
#@     # for them.
#@     set contents [string map [list \$ \0] $contents]
#@ 
#@     set index ""
#@     set contextStack ""
#@     set imports ""
#@ 
#@     $parser eval $contents
#@ 
#@     foreach name $imports {
#@         catch {$parser eval [list _%@namespace forget $name]}
#@     }
#@     return $index
#@ }
#@ 
#@ # auto_mkindex_parser::hook command
#@ #
#@ # Registers a Tcl command to evaluate when initializing the
#@ # slave interpreter used by the mkindex parser.
#@ # The command is evaluated in the master interpreter, and can
#@ # use the variable auto_mkindex_parser::parser to get to the slave
#@ 
#@ proc auto_mkindex_parser::hook {cmd} {
#@     variable initCommands
#@ 
#@     lappend initCommands $cmd
#@ }
#@ 
#@ # auto_mkindex_parser::slavehook command
#@ #
#@ # Registers a Tcl command to evaluate when initializing the
#@ # slave interpreter used by the mkindex parser.
#@ # The command is evaluated in the slave interpreter.
#@ 
#@ proc auto_mkindex_parser::slavehook {cmd} {
#@     variable initCommands
#@ 
#@     # The $parser variable is defined to be the name of the
#@     # slave interpreter when this command is used later.
#@ 
#@     lappend initCommands "\$parser eval [list $cmd]"
#@ }
#@ 
#@ # auto_mkindex_parser::command --
#@ #
#@ # Registers a new command with the "auto_mkindex_parser" interpreter
#@ # that parses Tcl files.  These commands are fake versions of things
#@ # like the "proc" command.  When you execute them, they simply write
#@ # out an entry to a "tclIndex" file for auto-loading.
#@ #
#@ # This procedure allows extensions to register their own commands
#@ # with the auto_mkindex facility.  For example, a package like
#@ # [incr Tcl] might register a "class" command so that class definitions
#@ # could be added to a "tclIndex" file for auto-loading.
#@ #
#@ # Arguments:
#@ #	name 	Name of command recognized in Tcl files.
#@ #	arglist	Argument list for command.
#@ #	body 	Implementation of command to handle indexing.
#@ 
#@ proc auto_mkindex_parser::command {name arglist body} {
#@     hook [list auto_mkindex_parser::commandInit $name $arglist $body]
#@ }
#@ 
#@ # auto_mkindex_parser::commandInit --
#@ #
#@ # This does the actual work set up by auto_mkindex_parser::command
#@ # This is called when the interpreter used by the parser is created.
#@ #
#@ # Arguments:
#@ #	name 	Name of command recognized in Tcl files.
#@ #	arglist	Argument list for command.
#@ #	body 	Implementation of command to handle indexing.
#@ 
#@ proc auto_mkindex_parser::commandInit {name arglist body} {
#@     variable parser
#@ 
#@     set ns [namespace qualifiers $name]
#@     set tail [namespace tail $name]
#@     if {$ns eq ""} {
#@         set fakeName [namespace current]::_%@fake_$tail
#@     } else {
#@         set fakeName [namespace current]::[string map {:: _} _%@fake_$name]
#@     }
#@     proc $fakeName $arglist $body
#@ 
#@     # YUK!  Tcl won't let us alias fully qualified command names,
#@     # so we can't handle names like "::itcl::class".  Instead,
#@     # we have to build procs with the fully qualified names, and
#@     # have the procs point to the aliases.
#@ 
#@     if {[string match *::* $name]} {
#@         set exportCmd [list _%@namespace export [namespace tail $name]]
#@         $parser eval [list _%@namespace eval $ns $exportCmd]
#@  
#@ 	# The following proc definition does not work if you
#@ 	# want to tolerate space or something else diabolical
#@ 	# in the procedure name, (i.e., space in $alias)
#@ 	# The following does not work:
#@ 	#   "_%@eval {$alias} \$args"
#@ 	# because $alias gets concat'ed to $args.
#@ 	# The following does not work because $cmd is somehow undefined
#@ 	#   "set cmd {$alias} \; _%@eval {\$cmd} \$args"
#@ 	# A gold star to someone that can make test
#@ 	# autoMkindex-3.3 work properly
#@ 
#@         set alias [namespace tail $fakeName]
#@         $parser invokehidden proc $name {args} "_%@eval {$alias} \$args"
#@         $parser alias $alias $fakeName
#@     } else {
#@         $parser alias $name $fakeName
#@     }
#@     return
#@ }
#@ 
#@ # auto_mkindex_parser::fullname --
#@ # Used by commands like "proc" within the auto_mkindex parser.
#@ # Returns the qualified namespace name for the "name" argument.
#@ # If the "name" does not start with "::", elements are added from
#@ # the current namespace stack to produce a qualified name.  Then,
#@ # the name is examined to see whether or not it should really be
#@ # qualified.  If the name has more than the leading "::", it is
#@ # returned as a fully qualified name.  Otherwise, it is returned
#@ # as a simple name.  That way, the Tcl autoloader will recognize
#@ # it properly.
#@ #
#@ # Arguments:
#@ # name -		Name that is being added to index.
#@ 
#@ proc auto_mkindex_parser::fullname {name} {
#@     variable contextStack
#@ 
#@     if {![string match ::* $name]} {
#@         foreach ns $contextStack {
#@             set name "${ns}::$name"
#@             if {[string match ::* $name]} {
#@                 break
#@             }
#@         }
#@     }
#@ 
#@     if {[namespace qualifiers $name] eq ""} {
#@         set name [namespace tail $name]
#@     } elseif {![string match ::* $name]} {
#@         set name "::$name"
#@     }
#@ 
#@     # Earlier, mkindex replaced all $'s with \0.  Now, we have to reverse
#@     # that replacement.
#@     return [string map [list \0 \$] $name]
#@ }
#@ 
#@ if {[llength $::auto_mkindex_parser::initCommands]} {
#@     return
#@ }
#@ 
#@ # Register all of the procedures for the auto_mkindex parser that
#@ # will build the "tclIndex" file.
#@ 
#@ # AUTO MKINDEX:  proc name arglist body
#@ # Adds an entry to the auto index list for the given procedure name.
#@ 
#@ auto_mkindex_parser::command proc {name args} {
#@     variable index
#@     variable scriptFile
#@     # Do some fancy reformatting on the "source" call to handle platform
#@     # differences with respect to pathnames.  Use format just so that the
#@     # command is a little easier to read (otherwise it'd be full of 
#@     # backslashed dollar signs, etc.
#@     append index [list set auto_index([fullname $name])] 	    [format { [list source [file join $dir %s]]} 	    [file split $scriptFile]] "\n"
#@ }
#@ 
#@ # Conditionally add support for Tcl byte code files.  There are some
#@ # tricky details here.  First, we need to get the tbcload library
#@ # initialized in the current interpreter.  We cannot load tbcload into the
#@ # slave until we have done so because it needs access to the tcl_patchLevel
#@ # variable.  Second, because the package index file may defer loading the
#@ # library until we invoke a command, we need to explicitly invoke auto_load
#@ # to force it to be loaded.  This should be a noop if the package has
#@ # already been loaded
#@ 
#@ auto_mkindex_parser::hook {
#@     if {![catch {package require tbcload}]} {
#@ 	if {[namespace which -command tbcload::bcproc] eq ""} {
#@ 	    auto_load tbcload::bcproc
#@ 	}
#@ 	load {} tbcload $auto_mkindex_parser::parser
#@ 
#@ 	# AUTO MKINDEX:  tbcload::bcproc name arglist body
#@ 	# Adds an entry to the auto index list for the given pre-compiled
#@ 	# procedure name.  
#@ 
#@ 	auto_mkindex_parser::commandInit tbcload::bcproc {name args} {
#@ 	    variable index
#@ 	    variable scriptFile
#@ 	    # Do some nice reformatting of the "source" call, to get around
#@ 	    # path differences on different platforms.  We use the format
#@ 	    # command just so that the code is a little easier to read.
#@ 	    append index [list set auto_index([fullname $name])] 		    [format { [list source [file join $dir %s]]} 		    [file split $scriptFile]] "\n"
#@ 	}
#@     }
#@ }
#@ 
#@ # AUTO MKINDEX:  namespace eval name command ?arg arg...?
#@ # Adds the namespace name onto the context stack and evaluates the
#@ # associated body of commands.
#@ #
#@ # AUTO MKINDEX:  namespace import ?-force? pattern ?pattern...?
#@ # Performs the "import" action in the parser interpreter.  This is
#@ # important for any commands contained in a namespace that affect
#@ # the index.  For example, a script may say "itcl::class ...",
#@ # or it may import "itcl::*" and then say "class ...".  This
#@ # procedure does the import operation, but keeps track of imported
#@ # patterns so we can remove the imports later.
#@ 
#@ auto_mkindex_parser::command namespace {op args} {
#@     switch -- $op {
#@         eval {
#@             variable parser
#@             variable contextStack
#@ 
#@             set name [lindex $args 0]
#@             set args [lrange $args 1 end]
#@ 
#@             set contextStack [linsert $contextStack 0 $name]
#@ 	    $parser eval [list _%@namespace eval $name] $args
#@             set contextStack [lrange $contextStack 1 end]
#@         }
#@         import {
#@             variable parser
#@             variable imports
#@             foreach pattern $args {
#@                 if {$pattern ne "-force"} {
#@                     lappend imports $pattern
#@                 }
#@             }
#@             catch {$parser eval "_%@namespace import $args"}
#@         }
#@     }
#@ }
#@ 
#@ return
#@ # -- End source /nfs/site/eda/data/disk0058/synopsys/primetime/J-2014.06-SP2/linux_2.6.32_x86-64/auxx/tcllib/lib/tcl8.5/auto.tcl

#@ 
#@ #
#@ # USAGE:  itcl::body name arglist body
#@ # Adds an entry for the given method/proc body.
#@ #
#@ foreach cmd {itcl::body body} {
#@     auto_mkindex_parser::command $cmd {name arglist body} {
#@ 	variable index
#@ 	variable scriptFile
#@ 	append index "set [list auto_index([fullname $name])]"
#@ 	append index " \[list source \[file join \$dir [list $scriptFile]\]\]\n"
#@     }
#@ }
#@ 
#@ #
#@ # USAGE:  itcl::configbody name arglist body
#@ # Adds an entry for the given method/proc body.
#@ #
#@ foreach cmd {itcl::configbody configbody} {
#@     auto_mkindex_parser::command $cmd {name body} {
#@ 	variable index
#@ 	variable scriptFile
#@ 	append index "set [list auto_index([fullname $name])]"
#@ 	append index " \[list source \[file join \$dir [list $scriptFile]\]\]\n"
#@     }
#@ }
#@ 
#@ #
#@ # USAGE:  ensemble name ?body?
#@ # Adds an entry to the auto index list for the given ensemble name.
#@ #
#@ foreach cmd {itcl::ensemble ensemble} {
#@     auto_mkindex_parser::command $cmd {name {body ""}} {
#@ 	variable index
#@ 	variable scriptFile
#@ 	append index "set [list auto_index([fullname $name])]"
#@ 	append index " \[list source \[file join \$dir [list $scriptFile]\]\]\n"
#@     }
#@ }
#@ 
#@ #
#@ # USAGE:  public arg ?arg arg...?
#@ #         protected arg ?arg arg...?
#@ #         private arg ?arg arg...?
#@ #
#@ # Evaluates the arguments as commands, so we can recognize proc
#@ # declarations within classes.
#@ #
#@ foreach cmd {public protected private} {
#@     auto_mkindex_parser::command $cmd {args} {
#@         variable parser
#@         $parser eval $args
#@     }
#@ }
#@ 
#@ # ----------------------------------------------------------------------
#@ # auto_import
#@ # ----------------------------------------------------------------------
#@ # This procedure overrides the usual "auto_import" function in the
#@ # Tcl library.  It is invoked during "namespace import" to make see
#@ # if the imported commands reside in an autoloaded library.  If so,
#@ # stubs are created to represent the commands.  Executing a stub
#@ # later on causes the real implementation to be autoloaded.
#@ #
#@ # Arguments -
#@ # pattern	The pattern of commands being imported (like "foo::*")
#@ #               a canonical namespace as returned by [namespace current]
#@ 
#@ proc auto_import {pattern} {
#@     global auto_index
#@ 
#@     set ns [uplevel namespace current]
#@     set patternList [auto_qualify $pattern $ns]
#@ 
#@     auto_load_index
#@ 
#@     foreach pattern $patternList {
#@         foreach name [array names auto_index $pattern] {
#@             if {"" == [info commands $name]} {
#@                 ::itcl::import::stub create $name
#@             }
#@         }
#@     }
#@ }
#@ 
#@ # ----------------------------------------------------------------------
#@ # itcl_class, itcl_info
#@ # ----------------------------------------------------------------------
#@ # Compat handling for itcl_class/info, set for auto_index loading only
#@ #
#@ # Only need to convert public/protected usage.
#@ # Uses Tcl 8.4+ coding style
#@ #
#@ 
#@ if {([llength [info commands itcl_class]] == 0)
#@     && [package vsatisfies $::tcl_version 8.4]} {
#@     proc ::itcl::CmdSplit {body} {
#@ 	# DGP's command split
#@ 	set commands {}
#@ 	set chunk ""
#@ 	foreach line [split $body "\n"] {
#@ 	    append chunk $line
#@ 	    if {[info complete "$chunk\n"]} {
#@ 		# $chunk ends in a complete Tcl command, and none of the
#@ 		# newlines within it end a complete Tcl command.  If there
#@ 		# are multiple Tcl commands in $chunk, they must be
#@ 		# separated by semi-colons.
#@ 		set cmd ""
#@ 		foreach part [split $chunk ";"] {
#@ 		    append cmd $part
#@ 		    if {[info complete "$cmd\n"]} {
#@ 			set cmd [string trimleft $cmd]
#@ 			# Drop empty commands and comments
#@ 			if {($cmd ne "") && ![string match #* $cmd]} {
#@ 			    lappend commands $cmd
#@ 			}
#@ 			if {[string match #* $cmd]} {
#@ 			    set cmd "#;"
#@ 			} else {
#@ 			    set cmd ""
#@ 			}
#@ 		    } else {
#@ 			# No complete command yet.
#@ 			# Replace semicolon and continue
#@ 			append cmd ";"
#@ 		    }
#@ 		}
#@ 		set chunk ""
#@ 	    } else {
#@ 		# No end of command yet.  Put the newline back and continue
#@ 		append chunk "\n"
#@ 	    }
#@ 	}
#@ 	if {[string trim $chunk] ne ""} {
#@ 	    return -code error "Can't parse body into a                sequence of commands.\n\tIncomplete command:\n$chunk"
#@ 	}
#@ 	return $commands
#@     }
#@ 
#@     proc ::itcl::itcl_class {className body} {
#@ 	# inherit baseClass ?baseClass...? ; # no change
#@ 	# constructor args ?init? body     ; # no change
#@ 	# destructor body                  ; # no change
#@ 	# method name args body            ; # no change
#@ 	# proc name args body              ; # no change
#@ 	# common varName ?init?            ; # no change
#@ 	# public varName ?init? ?config?   ; # variable ...
#@ 	# protected varName ?init?         ; # variable ... (?)
#@ 	set cmds [::itcl::CmdSplit $body]
#@ 	set newcmds [list]
#@ 	foreach cmd $cmds {
#@ 	    if {![catch {lindex $cmd 0} firstcmd]} {
#@ 		if {$firstcmd eq "public" || $firstcmd eq "protected"} {
#@ 		    set cmd [linsert $cmd 1 "variable"]
#@ 		}
#@ 	    }
#@ 	    append newcmds "$cmd\n"
#@ 	}
#@ 	return [uplevel 1 [list ::itcl::class $className $newcmds]]
#@     }
#@     set ::auto_index(itcl_class) [list interp alias {} ::itcl_class {} ::itcl::itcl_class]
#@     set ::auto_index(itcl_info) [list interp alias {} ::itcl_info {} ::itcl::find]
#@ }
#@ 
#@ # ----------------------------------------------------------------------
#@ # [namespace inscope]
#@ # ----------------------------------------------------------------------
#@ # Modify [unknown] to handle Itcl's usage of [namespace inscope]
#@ #
#@ 
#@ namespace eval ::itcl {
#@     variable UNKNOWN_ADD_84 {
#@ 	#######################################################################
#@ 	# ADDED BY Itcl
#@ 	# Itcl requires special handling for [namespace inscope]
#@ 	#
#@ 	set cmd [lindex $args 0]
#@ 	if {[regexp "^:*namespace\[ \t\n\]+inscope" $cmd] && [llength $cmd] == 4} {
#@ 
#@ 	    set arglist [lrange $args 1 end]
#@ 	    set ret [catch {uplevel 1 ::$cmd $arglist} result]
#@ 	    if {$ret == 0} {
#@ 		return $result
#@ 	    } else {
#@ 		return -code $ret -errorcode $::errorCode $result
#@ 	    }
#@ 	}
#@ 	#######################################################################
#@     }
#@     variable UNKNOWN_ADD_85 {
#@ 	#######################################################################
#@ 	# ADDED BY Itcl
#@ 	# Itcl requires special handling for [namespace inscope]
#@ 	#
#@ 	set cmd [lindex $args 0]
#@ 	if {[regexp "^:*namespace\[ \t\n\]+inscope" $cmd] && [llength $cmd] == 4} {
#@ 	    #return -code error "You need an {*}"
#@ 	    set arglist [lrange $args 1 end]
#@ 	    set ret [catch {uplevel 1 ::$cmd $arglist} result opts]
#@ 	    dict unset opts -errorinfo
#@ 	    dict incr opts -level
#@ 	    return -options $opts $result
#@ 	}
#@ 	#######################################################################
#@     }
#@     if {[package vsatisfies [package provide Tcl] 8.5]} {
#@ 	proc ::unknown args "$UNKNOWN_ADD_85\n[info body ::unknown]"
#@     } else {
#@ 	proc ::unknown args "$UNKNOWN_ADD_84\n[info body ::unknown]"
#@     }
#@ }
#@ # -- End source /nfs/site/eda/data/disk0058/synopsys/primetime/J-2014.06-SP2/linux_2.6.32_x86-64/auxx/tcllib/lib/itcl3.4/itcl.tcl

set run_type $env(run_type);set stage postlayout;set si on
source -echo -verbose /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/dot3/d04/run.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/dot3/d04/run.tcl

#@ ##############################################################################
#@ 
#@ ####################################################
#@ # The list of procedures used by this script:
#@ # 1.P_source_if_exists
#@ #
#@ ####################################################
#@ 
#@ set start_time [clock seconds]
#@ puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ #################################################################
#@ #User should set up the following dir structure for the STA flow
#@ #
#@ #`-- sta
#@ #    |-- inputs
#@ #    |-- logs
#@ #    |-- scripts
#@ #    |-- reports
#@ #    `-- runs
#@ #        |-- max
#@ #        |   |-- logs
#@ #        |   |-- snapshot
#@ #        |   `-- reports
#@ #        |-- min
#@ #        |   |-- logs
#@ #        |   |-- snapshot
#@ #        |   `-- reports
#@ #        |-- noise
#@ #        |   |-- logs
#@ #        |   |-- snapshot
#@ #        |   `-- reports
#@ #        `-- power
#@ #            |-- logs
#@ #            |-- snapshot
#@ #            `-- reports
#@ #
#@ ####################################################################
#@ 
#@ # To create directories if in case they do not exist
#@ # ----------------------------------------------------------------
#@ 
#@ set dirs {reports runs logs}
#@ foreach dir $dirs {
#@   if {![file isdirectory $dir]} {
#@     file mkdir $dir
#@     puts "==>INFORMATION: Creating directory $dir"
#@   }
#@ }
#@ 
#@ ##########################Flow Starts Here##########################
#@ 
#@ set INTEL_SCRIPTS_SEARCH_PATH "./scripts ../../scripts"
#@ set INTEL_SCRIPTS_SEARCH_PATH "$INTEL_SCRIPTS_SEARCH_PATH                              $env(INTEL_ASIC)/asicflows/synopsys/sta/dot3/d04                              $env(INTEL_ASIC)/asicflows/synopsys/sta                              $env(INTEL_ASIC)/asicflows/synopsys/common/dot3/d04                              $env(INTEL_ASIC)/asicflows/synopsys/common"
#@ 
#@ 
#@ ########################### Flow Starts here ###########################################
#@ 
#@ 
#@ 
#@ 
#@ # To setup all procedures used in the flow.
#@ source  $env(INTEL_ASIC)/asicflows/synopsys/common/procs.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/common/procs.tcl

#@ ##############################################################################
#@ # This file sets up procedures used by the synthesis, APR & STA flows        #
#@ # This file is sectioned according to steps and tcl files which use them     #
#@ ##############################################################################
#@ 
#@ ##########################################
#@ # Common Procedures - Used by DC/ICC/STA
#@ ##########################################
#@ # P_source_if_exists: Used by all flows to source scripts from a provided INTEL_SCRIPTS_SEARCH_PATH
#@ # P_rdtConvertSeconds: Used by P_source_if_exists to convert time in a specific reporting format
#@ # P_get_scr_proc_name: Used by all flows to provide additional stack info when erroring out
#@ # P_msg_info: Used by all flows to provide info messages
#@ # P_msg_warn: Used by all flows to provide warning messages
#@ # P_msg_error: Used by all flows to provide error messages
#@ # P_msg_fatal: Used by all flows to provide fatal error messages
#@ # P_find_common_collection: Utility which can be used to find overlap/common elements between two collections
#@ 
#@ #################################################
#@ # Synthesis Procedures - Used by Synthesis flow
#@ #################################################
#@ # P_smash_design: Used by the synthesis flow  for smashing hierarchies
#@ # P_smash_design_recursive: Used by P_smash_design for smashing design to the lowest hierarchy
#@ # P_remove_donttouch_on_hier_cells: Used by P_smash_design for removing dont_touch on hierachical instances.
#@ 
#@ #######################################################
#@ # Floorplan Procedures - Used by floorplan step of APR
#@ #######################################################
#@ # P_add_bonuscore_core2h_rows: Used by init_floorplan.tcl to create site rows for different core tiles
#@ # P_get_techfile_info: Used by P_add_bonuscore_core2h_rows and stdcell PG hookup to get techfile related
#@ # P_set_repeating_custom_tracks: Used by set_wiretracks.tcl to create custom tracks based on track settings
#@ # P_check_boundary_contact: Used by halo.tcl to determine if the Core Boundary contacts with any cell
#@ # P_get_abut_chain: Used by halo.tcl to get list of macros abutting each other
#@ # P_get_abutted_cells: Used by halo.tcl to get macro ells which are abutting
#@ # P_get_boundary_polygon: Used by halo.tcl to calculate boundary polygon for halo insertion
#@ # P_lcount: Used by halo.tcl to get repeated element
#@ # P_place_halo: Used by halo.tcl to place a halo at a particular location
#@ # P_find_direction: Used by halo.tcl and halo_power_voltage_island.tcl to place correct ver/horiz halo cells according to direction
#@ # P_ret_intersect_list: Used by halo_power_voltage_island.tcl to get voltage areas abutting with boundary/macro/non-va-halo
#@ # P_check_exclusion: Used by halo_power_voltage_island.tcl to get intersection points of boundary/macro/non-va-halo
#@ # P_macro_route_guide_cmd: Used by create_power_straps.tcl to create correct PG pullback from macro boundaries
#@ # P_strap_cmd: Used by create_power_strpas.tcl to create power straps
#@ # P_check_partition_dimension: Used by check_floorplan.tcl to check if the partition dimensions are a multiple of the modular grid
#@ # P_adv_polygon_size: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_adv_polygon_check: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_adv_polygon_logic: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_create_diffcheck_grid: Used by create_check_grid.tcl to create diffcheckgrid over the partition
#@ # P_create_polycheck_grid: Used by create_check_grid.tcl to create polycheckgrid over the partition
#@ # P_placement_blockage_move_or_unmove: Used by pre_place_fiducial.tcl and add_filler_cells.tcl to move placement blockages
#@ # P_insert_pre_place_cells_blockage: Used by pre_place_fib_bonus.tcl to insert placement blockages at pre_place cells location or reverse locations
#@ # P_compare: Used by P_insert_pre_place_cells_blockage to do list comparison of blockages
#@ # P_adv_polygon_get: Used by P_insert_pre_place_cells_blockage to do polygon computations
#@ 
#@ ################################################################
#@ # Place-UPF Procedures - Used by UPF flow in Place step of APR
#@ ################################################################
#@ # P_parse_pwrgrid_params: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stages
#@ # P_ret_aon_net: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stage
#@ # P_check_sec_pg_overlap: Used by P_add_sec_pg_hookup defined within upf_sec_pg_hookup.tcl to determine if a secondary PG staple overlaps with another staple.
#@ 
#@ ###########################################################
#@ # CTS-UPF Procedures - Used by UPF flow in CTS step of APR
#@ ###########################################################
#@ # P_query_voltage_pgnet: Used by stdcell PG hookup procedure to find out primary pg net for each voltage area
#@ 
#@ ################################################
#@ # Route Procedures - Used by route step of APR
#@ ################################################
#@ # P_bonus_array_blockage: Used by add_filler_cells.tcl to create blockages for bonus array addition before decap insertion
#@ 
#@ ########################################################
#@ # Focal opt Procedures - Used by Focal opt step of APR
#@ ########################################################
#@ # P_fix_min_cap args: Used by focal_opt.tcl for fixing min-cap violations on design
#@ 
#@ ##################
#@ # STA Procedures
#@ ##################
#@ # P_report_xtalk_deltas: Used by STA flow to report xtalk delta delays
#@ # P_restore_dmsa_session: Used by DMSA flows of STA to restore dmsa sessions
#@ # P_report_qor: Used by STA flow to report QoR data in a format similar to DC/ICC
#@ 
#@ #################################
#@ # Reports and Outputs Procedures
#@ #################################
#@ # P_create_xyv_icc: Used by P_outputs_xyv procedure to dump out xyv file fo use by RV tools
#@ # P_report_related_supply_net: Used by P_reports to get related supply nets for generate reportsin UPF flow
#@ # P_reports: Used by Syn, APR & STA flows to generate design reports controlled by INTEL_REPORTS variable
#@ # P_get_logic_levels: Used by P_reports procedure to get logic levels during reporting
#@ # P_create_pg_terminals: Used by P_outputs_fram
#@ # P_outputs_linkname: Used by P_outputs_* procedures to get file name used to create link
#@ # P_outputs_verilog: Used by P_outputs to write a verilog output
#@ # P_outputs_verilog_pg: Used by P_outputs to write a verilog output with PG pin and physical-only cells
#@ # P_outputs_upf: Used by P_outputs to write a upf file
#@ # P_outputs_spef: Used by P_outputs to write output spef file
#@ # P_outputs_def: Used by P_outputs to write output def file
#@ # P_syn_output_def: Used by synthesis to write output def file
#@ # P_outputs_fp: Used by P_outputs to write floorplan outputs
#@ # P_outputs_sdc: Used by P_outputs to write sdc output
#@ # P_outputs_saif: Used by P_outputs to write saif output
#@ # P_outputs_scandef: Used by P_outputs at the end of syn flow to write scandef output
#@ # P_outputs_oas: Used by P_outputs to write oas output
#@ # P_outputs_gds: Used by P_outputs to write gds output
#@ # P_outputs_fram: Used by P_outputs to write fram output
#@ # P_outputs_lteloc: Used by P_outputs to create an output xyv file used for RV flow
#@ # P_outputs: Main Output procedure used by Synthesis and APR flow to write out outputs. It is controlled by INTEL_OUTPUTS variable
#@ # P_check_place_overlap: Used by Check_* scripts in APR for checking cell overlaps
#@ # P_check_cells: Used by Check_* scripts in APR for checking if dont use cells are used in design
#@ # P_check_power_ground_nets: Used by check_route.tcl to verify shorts/opens/floating metals in design
#@ 
#@ set start_time [clock seconds]
#@ puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## These procedures/variables are not uniformly available
#@ ## for all tools used in the flow. This section of code creates
#@ ## the procedures/variables if they are not available.
#@ ## -----------------------------------------------------------------------------
#@ 
#@ if { ![info exists synopsys_root] } {
#@   set synopsys_root "synopsys_root"
#@ }
#@ 
#@ if { ![info exists synopsys_program_name] } {
#@   set synopsys_program_name "tcl"
#@ }
#@ 
#@ if { $synopsys_program_name == "tcl" } {
#@   set sh_product_version [info patchlevel]
#@ }
#@ 
#@ if { [info command parse_proc_arguments] != "parse_proc_arguments" } {
#@   proc parse_proc_arguments { cmdSwitch procArgs optsRef } {
#@     upvar $optsRef opts
#@     if { $cmdSwitch == "-args" } {
#@       foreach arg $procArgs {
#@         if { [string index $arg 0] == "-" } {
#@           set curArg $arg
#@           set opts($curArg) 1
#@         } else {
#@           if { [info exists curArg] } {
#@             set opts($curArg) $arg
#@             unset curArg
#@           } else {
#@             puts "SNPS_ERROR: Found invalid argument: '$arg', with no preceding switch."
#@             puts "SNPS_ERROR: Called from procedure: [lindex [info level -1] 0]"
#@           }
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ if { [info command define_proc_attributes] != "define_proc_attributes" } {
#@   proc define_proc_attributes args {}
#@ }
#@ 
#@ if { [info command date] != "date" } {
#@   proc date {} {
#@     return [clock format [clock seconds] -format {%a %b %e %H:%M:%S %Y}]
#@   }
#@ }
#@ 
#@ ########################
#@ # Common Procedures
#@ ########################
#@ 
#@ ################################################################################
#@ # Procedure   : P_source_if_exists
#@ # Description : This sources the specified script.  It searches through directories
#@ #               in the following order:
#@ #                Local script
#@ #                ==> Project flow path flow specific (syn, apr, ..) script
#@ #                ==> Project flow path common script
#@ #                ==> Flow default flow specific (syn, apr, ..) script
#@ #                ==> Flow default common script
#@ #               When it finds the specified script in one of the above directoreis,
#@ #               it sources the script, and stops searching for the script in the
#@ #               next directory.
#@ #               If "-inclusive" option is specified, it sources the script inclusively
#@ #               in the following order:
#@ #                Flow default common script
#@ #                ==> Flow default flow specific (syn, apr, ..) script
#@ #                ==> Project flow path common script
#@ #                ==> Project flow path flow specific (syn, apr, ..) script
#@ #                ==> Local script
#@ #               If the specified script does not exists, it prints out a warning
#@ #               message.
#@ 
#@ 
#@ proc P_source_if_exists {args} {
#@   global INTEL_SCRIPTS_SEARCH_PATH
#@   global INTEL_SOURCE_OPTIONS
#@ 
#@   #parse_proc_arguments -args $args flag
#@ 
#@   foreach arg $args {
#@     if {$arg == "-require"} {
#@       set require 1
#@     } elseif {$arg == "-inclusive"} {
#@       set inclusive 1
#@     } elseif {$arg == "-display"} {
#@       set display 1
#@     } else {
#@       set filename $arg
#@     }
#@   }
#@   if {![info exists require]} {set require 0}
#@   if {![info exists inclusive]} {set inclusive 0}
#@   if {![info exists display]} {set display 0}
#@   #  set filename $flag(filename)
#@   #  if { [info exists flag(-require) ] } {
#@   #    set require 1
#@   #  } else {
#@   #    set require 0
#@   #  }
#@   #  if {[info exists flag(-inclusive)]} {
#@   #    set inclusive 1
#@   #  } else {
#@   #    set inclusive 0
#@   #  }
#@ 
#@   set prereq_list {}
#@   # Look for the file in the search_path, if file not yet determined
#@   if {[info exists INTEL_SCRIPTS_SEARCH_PATH]} {
#@     foreach search_dir $INTEL_SCRIPTS_SEARCH_PATH {
#@       set prereq [file join $search_dir $filename]
#@       if {[file exists $prereq]} {
#@         set prereq_list [linsert $prereq_list 0 $prereq]
#@         if {! $inclusive} {
#@           break ;# Found the file, so stop looking
#@         }
#@       }
#@     }
#@   }
#@ 
#@   if {$display} {
#@     foreach prereq $prereq_list {
#@       puts $prereq
#@     }
#@     return
#@   }
#@ 
#@   if {[llength $prereq_list] == 0} {
#@     if { $require == 1 } {
#@       P_msg_error "Required file not found: $filename."
#@     } else {
#@       puts "==>WARNING: File $filename does not exist."
#@       return 0
#@     }
#@   }
#@ 
#@   foreach prereq $prereq_list {
#@     # Now that the prereq has been determined, source it.
#@     set start_time [clock seconds]
#@     set cpu_start [cputime]
#@     set dates [exec date]
#@     puts "==>INFORMATION: P_source_if_exists: Sourcing $prereq : START $dates"
#@     # Source the file in the global scope
#@     if {[info exists INTEL_SOURCE_OPTIONS] && $INTEL_SOURCE_OPTIONS != ""} {
#@       set catch_return [catch {uplevel \#0 eval source $INTEL_SOURCE_OPTIONS $prereq} catch_result]
#@     } else {
#@       set catch_return [catch {uplevel \#0 source $prereq} catch_result]
#@     }
#@     # Check to see if an error occurred in the script
#@     if {$catch_return != 0} {
#@       puts "Error: Problem with sourced file \"$prereq\". See errorInfo below"
#@       error $catch_result
#@     }
#@     set end_time [clock seconds]
#@     set cpu_end [cputime]
#@     set dates [exec date]
#@     regexp {.*\/(\S+)} $prereq t localFile
#@     #    set elapsed_time [format "%6.4f" [expr ($end_time - $start_time) / 60.0 / 60.0]]
#@     set elapsed_time [P_rdtConvertSeconds [expr ($end_time - $start_time)]]
#@     set elapsed_cpu [P_rdtConvertSeconds [expr ($cpu_end - $cpu_start)]]
#@     puts "==>INFORMATION: P_source_if_exists: $localFile : END $dates : WALLCLOCK RUNTIME in (hh:mm:ss) : $elapsed_time hrs : CPU RUNTIME in (hh:mm:ss) : $elapsed_cpu hrs : MEMORY : [mem] KB"
#@   }
#@   return 1
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_source_if_exists       -info "source script, if it exists"       -define_args {                          {filename "file name to be sourced" filename string required}                          {-require "require file" "" boolean optional}                          {-display "Shows which file will be sourced without sourcing it" "" boolean optional}                          {-inclusive "Source all files found in all paths in the order of priority. Default is to source only the first found file" "" boolean optional}                        }
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_rdtConvertSeconds #{{{
#@ # Description : This is a time conversion utility
#@ 
#@ proc P_rdtConvertSeconds {secs} {
#@ 
#@   set h [expr {$secs/3600}]
#@   incr secs [expr {$h*-3600}]
#@   set m [expr {$secs/60}]
#@   set s [expr {$secs%60}]
#@   format "%02.2d:%02.2d:%02.2d" $h $m $s
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_get_scr_proc_name #{{{
#@ # Description : This gets the name of procedures, and returns names of all procedures
#@ #               on the stack.
#@ 
#@ proc P_get_scr_proc_name { args } {
#@ 
#@   set all [string match "*-all*" $args]
#@ 
#@   # Start with the current script
#@   set proc_list "[file tail [info script]]"
#@ 
#@   set start 1
#@   set end [info level]
#@ 
#@   # Special cases
#@   if {$end == 1} {
#@     # Called from script?
#@     if {$proc_list != ""} {
#@       return "$proc_list"
#@ 
#@       # Interactive call
#@     } else {
#@       return "<interactive>"
#@     }
#@   } elseif {$end >= 2} {
#@     # Don't consider the last procedure (which is P_get_scr_proc_name)
#@     incr end -1
#@   }
#@ 
#@   for {set i $start} {$i <= $end} {incr i} {
#@     set proc_name [lindex [info level $i] 0]
#@     lappend proc_list $proc_name
#@   }
#@ 
#@   # Return all if all was specified
#@   set len_proc_list [llength $proc_list]
#@   if {!$all && $len_proc_list > 2} {
#@     # Get the name of the last two procedures
#@     # or script & procedure
#@     # or script only
#@     # or procedure only
#@ 
#@     set proc_list [lrange $proc_list [expr {$len_proc_list - 2}] end]
#@   }
#@ 
#@   # Return values joined by ":" to make it one string
#@   return [join $proc_list ":"]
#@ 
#@ }; # P_get_scr_proc_name
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   create_command_group {flow_procs}
#@ }
#@ 
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_get_scr_proc_name       -command_group "flow_procs"       -info "Procedure to get caller and callee script and procedure names \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {-all "name of all the procedures on the stack is returned" "" boolean optional}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_info #{{{
#@ # Description : This prints information messages.
#@ 
#@ proc P_msg_info { args } {
#@   set prefix "#INFO-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_info       -command_group "flow_procs"       -info "Procedure to print info messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "info message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_warn #{{{
#@ # Description : This prints warning messages.
#@ 
#@ proc P_msg_warn { args } {
#@   set prefix "#WARNING-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_warn       -command_group "flow_procs"       -info "Procedure to print warning messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "warning message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_error #{{{
#@ # Description : This prints error messages.  The flow goes through, and does not stop.
#@ 
#@ proc P_msg_error { args } {
#@   set prefix "#ERROR-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_error       -command_group "flow_procs"       -info "Procedure to print error messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "error message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_fatal #{{{
#@ # Description : This prints messages about fatal errors, and exits from the shell.
#@ 
#@ proc P_msg_fatal { args } {
#@   set prefix "\n#INFO-STACK==> [uplevel 1 {P_get_scr_proc_name -all}] \n#FATALERROR-MSG==> "
#@   puts stderr "$prefix [join [concat $args] { }]"
#@   exit 1
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_fatal       -command_group "flow_procs"       -info "Procedure to print fatal messages and exit the tool \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {target "file to create before exiting" target.db string required}
#@         {args "fatal message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ proc P_find_common_collection {a b} {
#@   set in_a_but_notin_b [remove_from_collection $a $b]
#@   set in_b_but_notin_a [remove_from_collection $b $a]
#@   set common_a_b [remove_from_collection $a $in_a_but_notin_b]
#@   if { [sizeof_collection $b] == 0 } {
#@     return $a
#@   } else {
#@     return $common_a_b
#@   }
#@ }
#@ 
#@ define_proc_attributes P_find_common_collection     -info "Returns common elements between 2 collections"     -define_args {
#@       {a "First Coll" "First Coll" string required}
#@       {b "Second Coll" "Second Coll" string required}
#@     }
#@ 
#@ ########################
#@ # Synthesis Procedures
#@ ########################
#@ 
#@ ##############################################################################
#@ # Procedure   : P_smash_design
#@ # Description : This proc smashes the design but presevers the hierarchies listed in the argument.
#@ #               It also takes the numbers of level below which the smashing has to happen.
#@ #   If 2 is given, the it descends to 2 levels of hierarchy below the top and smashes thoses levels.
#@ #               But regardless of levels specified, the list specified in \$preserve_hier_instance_list will be honored.
#@ #   If levels is less than 0, then no smashing is done
#@ 
#@ proc P_smash_design {{preserve_hier_instance_list {}} {levels 0}} {
#@   if {$levels < 0} {return 0}
#@   global smashed_designs_hash
#@   set start_time [clock seconds]
#@   set cur_design [get_attribute [current_design] name]
#@   set hiers_level_list {}
#@   foreach preserve_hier_instance $preserve_hier_instance_list {
#@     if {[get_attribute [get_cells $preserve_hier_instance] is_hierarchical] == "true"} {
#@       set hiers [split $preserve_hier_instance "/"]
#@       set mid_index [expr [llength $hiers] - 2]
#@       set end_index [expr [llength $hiers] - 1]
#@       set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
#@       set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
#@       while {([get_cells -quiet $parent_hier] == "") && ($mid_index >= 0)} {
#@         incr mid_index -1
#@         set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
#@         set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
#@       }
#@       if {$parent_hier == ""} {
#@         set parent_hier_ref $cur_design
#@       } else {
#@         set parent_hier_ref [get_attribute [get_cells $parent_hier] ref_name]
#@       }
#@       set hier_hash($preserve_hier_instance) [list $parent_hier_ref $child_inst]
#@       lappend hiers_level_list [list $preserve_hier_instance [llength $hiers] $parent_hier_ref $child_inst]
#@     }
#@   }
#@   current_design $cur_design
#@   foreach hiers_level_pair [lsort -decreasing -index 1 $hiers_level_list] {
#@     set parent_hier_ref [lindex $hiers_level_pair 2]
#@     set child_inst [lindex $hiers_level_pair 3]
#@     set preserve_hier_instance [lindex $hiers_level_pair 0]
#@     set child_hier_level [lindex $hiers_level_pair 1]
#@     if {$child_hier_level > $levels} {
#@       set preserve_hier_ref [get_attribute [get_cells $preserve_hier_instance] ref_name]
#@       current_design $preserve_hier_ref
#@       set smashed_designs_hash($preserve_hier_ref) 1
#@       ungroup -all -flatten
#@       current_design $parent_hier_ref
#@       set_dont_touch $child_inst
#@       current_design $cur_design
#@     }
#@   }
#@   current_design $cur_design
#@ 
#@   P_smash_design_recursive $levels
#@   P_remove_donttouch_on_hier_cells
#@   array unset smashed_designs_hash
#@   set end_time [clock seconds]
#@   set elapsed_time [expr ($end_time - $start_time) / 60.0 / 60.0]
#@   #echo "Runtime to smash the design = $elapsed_time hrs"
#@ }
#@ 
#@ #################################################################
#@ # Procedure   : P_smash_design_recursive
#@ # Description : This proc starts at the current design and descends into the lowest hierarchy and smashes from that level upwards.
#@ #   This proc is called from proc:P_smash_design
#@ 
#@ proc P_smash_design_recursive {levels} {
#@   global smashed_designs_hash
#@   set cur_design [current_design]
#@   set cur_design_name [get_attribute $cur_design name]
#@   if {[info exists smashed_designs_hash($cur_design_name)]} {
#@     return 0
#@   }
#@   if {$levels <= 0} {
#@     ungroup -all -flatten
#@     set smashed_designs_hash($cur_design_name) 1
#@   } else {
#@     set ref_designs {}
#@     set insts_col [get_cells -filter is_hierarchical==true]
#@     set insts_count [sizeof_collection $insts_col]
#@     foreach_in_collection inst_col $insts_col {
#@       lappend ref_designs [get_attribute $inst_col ref_name]
#@     }
#@     foreach ref_design $ref_designs {
#@       if {![info exists smashed_designs_hash($ref_design)]} {
#@         current_design $ref_design
#@         P_smash_design_recursive [expr $levels - 1]
#@       }
#@     }
#@     current_design $cur_design
#@   }
#@ }
#@ 
#@ ##################################################################
#@ # Procedure   : P_remove_donttouch_on_hier_cells
#@ # Description : This proc recursively traverses the hierarchies in the design.
#@ #   If a hiararchical instance as a dont touch on it remove that dont touch attribute
#@ 
#@ proc P_remove_donttouch_on_hier_cells {} {
#@   set cur_design [current_design]
#@   set ref_designs {}
#@   set insts_col [get_cells -filter is_hierarchical==true]
#@   foreach_in_collection inst_col $insts_col {
#@     lappend ref_designs [get_attribute $inst_col ref_name]
#@     remove_attribute $inst_col dont_touch -quiet
#@   }
#@   foreach ref_design $ref_designs {
#@     current_design $ref_design
#@     P_remove_donttouch_on_hier_cells
#@   }
#@   current_design $cur_design
#@ }
#@ 
#@ ########################
#@ # Floorplan Procedures
#@ ########################
#@ 
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_add_bonuscore_core2h_rows
#@ # __description:  add bonuscore & core2h site_rows to an existing FP
#@ # __proc returns: 0 = successful
#@ #                 1 = error
#@ # __required_args:  -unit_tile    = name of base unit tile
#@ # __optional_args:  -bonus_tile   = name of bonus tile
#@ #                   -unit_2h_tile = name of double height tile
#@ # __end
#@ #-------------------------------------------------------------------
#@ #
#@ proc P_add_bonuscore_core2h_rows { args } {
#@   parse_proc_arguments -args $args flag
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   # set up error outputs
#@   set puts "puts"
#@   set puts_nnl "puts -nonewline"
#@   set info_stack "\n#INFO-STACK==> $func_name"
#@   set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
#@   set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
#@   if { [llength [info commands da_error]] > 0 } { set da_error da_error
#@   } else { set da_error [eval $fmte ERROR] }
#@   if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
#@   } else { set da_warn [eval $fmt WARNING] }
#@   if { [llength [info commands da_info]] > 0 } { set da_info da_info
#@   } else { set da_info [eval $fmt INFO] }
#@ 
#@   ###########################################################################
#@   # procedure P_add_bonuscore_core2h_rows
#@   # the function assumes that only single tile pattern exists in the design
#@   # assumes that rows alternate between N & S with no gaps in site_rows.
#@   # bonuscore rows are the same height & orientation as existing core tile
#@   # core2h rows are the same width as existing core tile, and require N-S pair
#@   ###########################################################################
#@ 
#@ 
#@   # get techfile info
#@   set tech_info [P_get_techfile_info]
#@   if { [llength $tech_info] == 0 } {
#@     eval $da_error "\"No MW library open or insufficient disk space\""
#@     return 1
#@   }
#@   # look up info for tiles
#@   set all_tiles {}
#@   set all_tile_names {}
#@   foreach tech_item $tech_info {
#@     if { ! [string equal "Tile" [lindex $tech_item 0]] } {
#@       continue
#@     }
#@     unset -nocomplain tech_tile_name tech_tile_width tech_tile_length
#@     set tech_tile_name [lindex $tech_item 1]
#@     foreach sub_item [lrange $tech_item 2 end] {
#@       if { [string equal -nocase "width" [lindex $sub_item 0]] } {
#@         set tech_tile_width [lindex $sub_item 1]
#@       } elseif { [string equal -nocase "height" [lindex $sub_item 0]] } {
#@         set tech_tile_height [lindex $sub_item 1]
#@       }
#@     }
#@     if { (! [info exists tech_tile_width]) || (! [info exists tech_tile_height]) } {
#@       continue
#@     }
#@     set new_tile [list $tech_tile_name $tech_tile_width $tech_tile_height]
#@     lappend all_tiles $new_tile
#@     lappend all_tile_names $tech_tile_name
#@   }
#@ 
#@ 
#@ 
#@   # ensure that a design is open and has core_area
#@   redirect /dev/null {catch {set core_area [get_core_area]}}
#@   if { (! [info exists core_area]) || ([llength $core_area] == 0) } {
#@     # no design is open or core_area isn't defined
#@     eval $da_error "\"No design open or undefined core_area\""
#@     return 1
#@   }
#@ 
#@ 
#@   # get min resolution (the round about method for icc)
#@   redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
#@   regexp -line {^length.*} $unit_vars length_units
#@   set resolution [expr 1.0 / ([lindex $length_units 2] + 0.0)]
#@ 
#@ 
#@   # check that each tile specified exists
#@   set error 0
#@   set core_step 1.0
#@   set core2h_width 1.0
#@   set core2h_height 1.0
#@   set bonus_width  1.0
#@   set bonuscore_mult 1
#@   if { [info exists flag(-unit_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-unit_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"unit_tile '$flag(-unit_tile)' doesn't exist\""
#@     } else {
#@       set core_tile $flag(-unit_tile)
#@       set core_item [lindex $all_tiles $tile_number]
#@       set tile_width  [lindex $core_item 1]
#@       set tile_height [lindex $core_item 2]
#@       set core_step [expr int(round($tile_width / $resolution))]
#@     }
#@   }
#@   if { [info exists flag(-bonus_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-bonus_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"bonus_tile '$flag(-bonus_tile)' doesn't exist\""
#@     } else {
#@       set bonuscore_tile $flag(-bonus_tile)
#@       set bonus_item [lindex $all_tiles $tile_number]
#@       set bonus_width  [lindex $bonus_item 1]
#@       set bonuscore_step [expr int(round($bonus_width / $resolution))]
#@       set bonuscore_mult [expr int(round($bonuscore_step / $core_step))]
#@     }
#@   }
#@   if { [info exists flag(-unit_2h_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-unit_2h_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' doesn't exist\""
#@     } else {
#@       set core2h_tile $flag(-unit_2h_tile)
#@       set core2h_item [lindex $all_tiles $tile_number]
#@       set core2h_width  [lindex $core2h_item 1]
#@       set core2h_height  [lindex $core2h_item 2]
#@       set core2h_step [expr int(round($core2h_width / $resolution))]
#@       set core2h_mult [expr int(round($core2h_step / $core_step))]
#@       if { (int(round($tile_height/$resolution)) * 2) != int(round($core2h_height/$resolution)) } {
#@         set error 1
#@         eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' is not double the height of the unit_tile\""
#@       }
#@       set tile_height [lindex $core_item 2]
#@     }
#@   }
#@ 
#@ 
#@   # exit if error
#@   if { $error } {
#@     eval $da_error "\"Problem specified tiles don't exist\""
#@     return 1
#@   }
#@ 
#@ 
#@ 
#@   # get information on existing site_rows
#@   # use win_select_objects (rather than get_site_rows)
#@   # -- this is due to an early bug where get_site_rows didn't get unnamed rows
#@   set design_bbox [get_attribute -quiet [get_die_area] bbox]
#@   if { [llength $design_bbox] == 1 } { set design_bbox [lindex $design_bbox 0] }
#@   set design_bbox [join $design_bbox]
#@   change_selection -remove [get_selection]
#@   win_set_select_class {site_row}
#@   win_set_filter -class site -filter {site_row}
#@   win_select_objects -within $design_bbox -slct_targets global -slct_targets_operation clear -intersect
#@   set site_rows [sort_collection [sort_collection [filter_collection [get_selection] "object_class==\"site_row\""] bbox_llx] bbox_lly]
#@   change_selection $site_rows
#@   if { [sizeof_collection $site_rows] == 0 } {
#@     eval $da_warn "\"no site_row in design\""
#@     return 1
#@   }
#@ 
#@   # record existing site_row information
#@   set existing_rows {}
#@   set existing_names {}
#@   set core2h_N_rows {}
#@   set core2h_S_rows {}
#@   set core_sites {}
#@   set bonuscore_sites {}
#@   set core2h_sites {}
#@   unset -nocomplain min_y
#@   foreach_in_collection site_row $site_rows {
#@     set site_space  [get_attribute -quiet $site_row site_space]
#@     set site_count  [get_attribute -quiet $site_row site_count]
#@     set site_type   [get_attribute -quiet $site_row site_type]
#@     if { ! [string equal $core_tile $site_type] } { continue }
#@     set origin      [get_attribute -quiet $site_row origin]
#@     if { [llength $origin] == 1 } { set origin [lindex $origin 0] }
#@     foreach { x y } $origin { break }
#@     if { (! [info exists min_y]) || ($y < $min_y) } {
#@       set min_y $y
#@     }
#@     set orientation [get_attribute -quiet $site_row orientation]
#@     set direction   [get_attribute -quiet $site_row direction]
#@     set name        [get_attribute -quiet $site_row name]
#@     switch -glob $orientation {
#@       *N { set flip_orient "FS" }
#@       *S { set flip_orient "N" }
#@       default { set flip_orient $orientation }
#@     }
#@     set add_row [list $site_space $site_count $site_type $origin $orientation $direction $name $flip_orient]
#@     lappend existing_rows $add_row
#@     lappend existing_names $name
#@ 
#@     # core sites
#@     lappend core_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation $site_count]
#@ 
#@     # bonuscore sites are original core sites with site_count divided by 4
#@     set x_length [expr $site_count * $tile_width]
#@     lappend bonuscore_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation [expr int(floor(($x_length/$bonus_width) + $resolution))]]
#@ 
#@     #
#@     # compute rows for core2h
#@     # use polygon operation, build bbox for each site_row
#@     #   BUT ... stretch N rows up by tile_height, S rows down by tile_height
#@     #   core2h site_rows described by the intersection of N & S polygons
#@     #
#@     switch -glob $orientation {
#@       *N { set yll $y
#@         set yur [expr $y + $tile_height]
#@         set north 1
#@       }
#@       *S { set yll [expr $y - $tile_height]
#@         set yur $y
#@         set north 0
#@       }
#@       default { set yll 0.0
#@         set yur 0.0
#@         set north -1
#@       }
#@     }
#@     set xll $x
#@     set xur [expr $x + ($site_space * $site_count)]
#@     set bbox [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     if { $north == 1 } {
#@       lappend core2h_N_rows $bbox
#@     } elseif { $north == 0 } {
#@       lappend core2h_S_rows $bbox
#@     }
#@   }
#@   if { [llength $core_sites] == 0 } {
#@     eval $da_error "\"No $core_tile site_rows found in design\""
#@     return 1
#@   }
#@   remove_site_row [get_selection]
#@   change_selection -remove [get_selection]
#@ 
#@   # make a list of core2h sites from the intersection of N & S polygons
#@   foreach row2h [compute_polygons -boolean and $core2h_N_rows $core2h_S_rows] {
#@     # get the bounds of each polygon to figure out core2h sites
#@     set xll [lindex [lindex [lsort -real -index 0 -increasing $row2h] 0] 0]
#@     set yll [lindex [lindex [lsort -real -index 1 -increasing $row2h] 0] 1]
#@     set xur [lindex [lindex [lsort -real -index 0 -decreasing $row2h] 0] 0]
#@     if { int(round(($yll - $min_y)/$core2h_height)) % 2 } {
#@       set core_orient "N"
#@     } else {
#@       set core_orient "FS"
#@     }
#@     lappend core2h_sites [list [expr int(round($xll/$resolution))] [expr int(round($yll/$resolution))] $core_orient [expr int(floor((($xur-$xll)/$core2h_width) + $resolution))]]
#@ 
#@   }
#@ 
#@   # create DEF file
#@   write_def -rows_tracks_gcells -output core_[pid].def
#@   set f1 [open core_[pid].def  ]
#@   redirect -variable file_dump {set tmp [read $f1]}
#@   close $f1
#@ 
#@   set f2 [open core_[pid].def   w]
#@   regsub -all "ROW STD_ROW_\[\^\n\]*\n" $tmp "" tmpnew1
#@   regsub -all "DIEAREA " $tmpnew1 "\#DIEAREA" tmpnew2
#@   regsub -all "END DESIGN.*" $tmpnew2 "" tmpnew
#@   puts $f2 "[string trimright $tmpnew]\n"
#@   # add core
#@   # DEF line looks like;
#@   #  ROW STD_ROW_1 core 0 2784 N DO 7080 BY 1 STEP 116 0 ;
#@   if { ! [info exists core_tile] } {
#@     set core_sites {}
#@   }
#@   set i 1
#@   foreach site_row [lsort -index 0 [lsort -index 1 $core_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_$i $core_tile $x $y $orient DO $step BY 1 STEP $core_step 0 ;"
#@     incr i
#@   }
#@   # add bonuscore
#@   # DEF line looks like;
#@   #  ROW STD_ROW_BONUSCORE_1 bonuscore 0 2784 N DO 7080 BY 1 STEP 464 0 ;
#@   if { ! [info exists bonuscore_tile] } {
#@     set bonuscore_sites {}
#@   }
#@   foreach site_row [lsort -index 0 [lsort -index 1 $bonuscore_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_BONUSCORE_$i $bonuscore_tile $x $y $orient DO $step BY 1 STEP $bonuscore_step 0 ;"
#@     incr i
#@   }
#@   # add core2h (if available)
#@   # DEF line looks like;
#@   #  ROW STD_ROW_CORE2H_1 core2h 0 2784 N DO 7080 BY 1 STEP 116 0 ;
#@   if { ! [info exists core2h_tile] } {
#@     set core2h_sites {}
#@   }
#@   foreach site_row [lsort -index 0 [lsort -index 1 $core2h_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_CORE2H_$i $core2h_tile $x $y $orient DO $step BY 1 STEP $core2h_step 0 ;"
#@     incr i
#@   }
#@   close $f2
#@ 
#@   # load def
#@   read_def core_[pid].def
#@   file delete -force "core_[pid].def"
#@ 
#@ 
#@   return 0
#@ 
#@ }
#@ 
#@ define_proc_attributes P_add_bonuscore_core2h_rows     -info "Create site_rows for core2h and bonuscore"     -define_args {
#@       {-unit_tile "name of unit tile" unit_tile string required}
#@       {-bonus_tile "name of bonus tile" bonus_tile string optional}
#@       {-unit_2h_tile "name of 2x height tile" unit_2h_tile string optional}
#@     }
#@ 
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_get_techfile_info
#@ # __description:  dump & read in contents of techfile for current_mw_lib
#@ #                 ignores comment fields
#@ # __proc returns:  a list of lists of technology information
#@ #                  i.e.
#@ #                  {{Technology {name "name-string"} {date "date-string"}
#@ #                               {dielectric 3.45e-5} ...}
#@ #                   {Color 19 {{name 19} {rgbDefined 1} ...}}
#@ #                   {Stipple patternM1 {{width 8} {height 8}
#@ #                                       {pattern {0 0 0 1 0 0 ...}  ...}}
#@ #                   {Tile unit {{width 0.xx} {height x.xx}}}
#@ #                   {Tile core {{width 0.xx} {height x.xx}}}
#@ #                   {Layer poly {{layerNumber #} {maskName poly} {visible 1} ...}}
#@ #                   {ContactCode via1 {{contactCodeNumber #} {cutLayer via1} ...}}
#@ #                   .....}
#@ # __required_args:  none
#@ # __optional_args:
#@ # __end
#@ #-------------------------------------------------------------------
#@ #
#@ proc P_get_techfile_info {} {
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   # set up error outputs
#@   set puts "puts"
#@   set puts_nnl "puts -nonewline"
#@   set info_stack "\n#INFO-STACK==> $func_name"
#@   set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
#@   set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
#@   if { [llength [info commands da_error]] > 0 } { set da_error da_error
#@   } else { set da_error [eval $fmte ERROR] }
#@   if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
#@   } else { set da_warn [eval $fmt WARNING] }
#@   if { [llength [info commands da_info]] > 0 } { set da_info da_info
#@   } else { set da_info [eval $fmt INFO] }
#@ 
#@   redirect /dev/null {catch {set mw_lib [current_mw_lib]}}
#@   if { (! [info exists mw_lib]) || ([llength $mw_lib] == 0) } {
#@     # no library is open
#@     return {}
#@   }
#@   write_mw_lib_files -technology -output tech_[pid].tf [current_mw_lib]
#@ 
#@   set tfh [open tech_[pid].tf r]
#@   set tech_lines {}
#@   set start_comment -1
#@   while { ! [eof $tfh] } {
#@     gets $tfh line
#@     set new_line ""
#@     while { [string length $line] > 0 } {
#@       if { $start_comment >= 0 } {
#@         set stop_comment [string first "*/" $line $start_comment]
#@         if { $stop_comment < 0 } {
#@           set line ""
#@           set start_comment 0
#@           break
#@         } else {
#@           set line [string range $line [expr $stop_comment + 2] end]
#@           set start_comment -1
#@         }
#@       } else {
#@         set start_comment [string first "/*" $line]
#@         if { $start_comment > 0 } {
#@           append new_line [string range $line 0 [expr $start_comment - 1]]
#@           set line [string range $line [expr $start_comment + 2] end]
#@           set start_comment 0
#@         } elseif { $start_comment < 0 } {
#@           append new_line $line
#@           set line ""
#@         }
#@       }
#@       set new_line [string trim $new_line]
#@       if { [string length $new_line] > 0 } {
#@         lappend tech_lines $new_line
#@       }
#@     }
#@   }
#@   close $tfh
#@ 
#@   set tech_info {}
#@   set in_section 0
#@   set line ""
#@   # have a techfile with all comments stripped
#@   foreach read_line $tech_lines {
#@     append line " $read_line"
#@     if { ! $in_section } {
#@       unset -nocomplain field type new_list end
#@       if { [regexp {^\s*(\S+)\s+"(\S+)"\s+\{\s*(\}?)$} $line all field type end] } {
#@         set new_list [list $field $type]
#@       } elseif { [regexp {^\s*(\S+)\s+(\d+)\s+\{\s*(\}?)$} $line all field type end] } {
#@         set new_list [list $field $type]
#@       } elseif { [regexp {^\s*(\S+)\s+\{\s*(\}?)$} $line all field end] } {
#@         set new_list [list $field]
#@       } else {
#@         continue
#@       }
#@       set in_section 1
#@     } else {
#@       if { [regexp {^\s*(\S+)\s*=\s*"([^\"]+)"\s*(\}?)$} $line all item value end] } {
#@         lappend new_list [list $item $value]
#@       } elseif { [regexp {^\s*(\S+)\s*=\s*\(([^\)]+)\)\s*(\}?)$} $line all item value_list end] } {
#@         set value [regsub -all {[\s,]+} [string trim $value_list] { }]
#@         lappend new_list [list $item $value]
#@       } elseif { [regexp {^\s*(\S+)\s*=\s*([^\s\(]+)\s*(\}?)$} $line all item value end] } {
#@         lappend new_list [list $item $value]
#@       } elseif { ! [regexp {^\s*(\})$} $line all end] } {
#@         continue
#@       }
#@     }
#@     if { [info exists end] && [string equal "\}" $end] } {
#@       lappend tech_info $new_list
#@       set in_section 0
#@     }
#@     set line ""
#@ 
#@   }
#@ 
#@   # remove the temporary techfile
#@   file delete -force "tech_[pid].tf"
#@ 
#@   return $tech_info
#@ 
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_set_repeating_custom_tracks
#@ # Input(s)    : -track_settings {list}
#@ # Output(s)   : none
#@ # Help line   : sets custom tracks based on track_settings
#@ #                  list that describes track settings
#@ # Description : set preferred directions, preferred
#@ #               and non-preferred routing tracks.
#@ #               The procedure will set tracks across the
#@ #               entire floorplan and allows a either a
#@ #               single repeating track or set of
#@ #               (non-uniform) repeating tracks.
#@ #               Non-preferred tracks can be explicitly set
#@ #               or if not set then are derived from preferred
#@ #               tracks above & below the current layer.
#@ #               Tracks are built to avoid wires
#@ #               that won't be contained in the floorplan area.
#@ #
#@ #               {list} format for -track_settings:
#@ #                  => per layer list specifying:
#@ #                   layer                string(layer_name)
#@ #                   preferred-direction  string(horizontal or vertical)
#@ #                   preferred-tracks     list(offsets,repeat)
#@ #                   non-preferred-tracks list(offsets,repeat)
#@ #                   {offsets} - (list of) number(s)
#@ #                   {repeat}  - number (step value for tracks)
#@ #
#@ # Example(s)  : Suppose you are running script called "check_hier.tcl"
#@ #               set my_tracks {
#@ #                   { { layer metal1 }
#@ #                          { preferred-direction vertical }
#@ #                          { preferred-tracks { offsets 0 }
#@ #                                             { repeat 0.116 } } }
#@ #                      { { layer metal2 }
#@ #                          { preferred-direction horizontal }
#@ #                          { preferred-tracks { offsets { 0.029 0.145 0.464 0.580
#@ #                                                         0.696 0.812 0.928
#@ #                                                         1.247 1.363 1.479 } }
#@ #                                             { repeat  1.566 } } }
#@ #                      { { layer metal3 }
#@ #                          { preferred-direction vertical }
#@ #                          { preferred-tracks { offsets 0.116 }
#@ #                                             { repeat 0.116 } } }
#@ #                      { { layer metal4 }
#@ #                          { preferred-direction horizontal } }
#@ #                   }
#@ #               P_set_repeating_custom_tracks -track_settings $my_tracks
#@ #
#@ # Notes(s)    :
#@ #      1) arguments are given as lists (lists of lists with keyword directives)
#@ #      2) it is not necessary to specify preferred-direction, values set
#@ #             up in the design are used by default
#@ #      3) offsets should be given from the bottom & left
#@ #      4) tracks are only added if the entire metal width fits in the fub
#@ #      5) non-preferred tracks by default will be derived from the
#@ #           preferred tracks of the layers above & below the current layer
#@ #      6) non-preferred tracks can be forced if needed using the
#@ #           non-preferred-tracks directive
#@ #      7) if two different sets of repeats are required for a particular
#@ #           track setup, then they need to be given as 2 separate layer sets
#@ #           i.e. (this example pushes preferred tracks from
#@ #                         metal2 & metal4 to metal3 non-preferred tracks)
#@ #
#@ #               set my_tracks {
#@ #                      { { layer metal3 }
#@ #                          { non-preferred-tracks { offsets
#@ #                                                    { 0.029 0.145 0.464 0.580
#@ #                                                      0.696 0.812 0.928
#@ #                                                      1.247 1.363 1.479 } }
#@ #                                             { repeat  1.566 } } }
#@ #                      { { layer metal3 }
#@ #                          { non-preferred-tracks { offsets 0.087 }
#@ #                                                 { repeat 0.174 } } }
#@ #                   }
#@ #               P_set_repeating_custom_tracks -track_settings $my_tracks
#@ #
#@ # -----------------------------------------------------------------------------
#@ #
#@ 
#@ 
#@ proc P_set_repeating_custom_tracks {args } {
#@   parse_proc_arguments -args $args flag
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   if { [info exists flag(-track_settings)] } {
#@     if { $flag(-track_settings) == "help" } {
#@       puts "need help"
#@       puts "Usage: $func_name # set custom tracks"
#@       puts "        -track_settings TrackInfoList"
#@       puts "   (TrackInfoList of type list)"
#@       puts "   TrackInfoList format:"
#@       puts "      {"
#@       puts "         { {layer LAYER_1}"
#@       puts "              {preferred-direction HORIZONTAL|VERTICAL}"
#@       puts "              {preferred-tracks"
#@       puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
#@       puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
#@       puts "              }"
#@       puts "              {non-preferred-tracks"
#@       puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
#@       puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
#@       puts "              }"
#@       puts "         }"
#@       puts "         { {layer LAYER_N}"
#@       puts "           {preferred-direction HORIZONTAL|VERTICAL}"
#@       puts "         }"
#@       puts "      }"
#@       puts "   - - - - - - - -"
#@       puts "   (optional) non-preferred-tracks"
#@       puts "        - if not given, then derived from preferred-tracks above/below"
#@       puts ""
#@       return
#@     }
#@     set track_settings $flag(-track_settings)
#@   }
#@ 
#@   # set default offset reference to the lowerLeft unless 'origin' is specified
#@   set reference_origin 0
#@   if { [info exists flag(-offset_reference)] } {
#@     if { [string equal "origin" $flag(-offset_reference)] } {
#@       set reference_origin 1
#@     }
#@   }
#@ 
#@   # record if tracks can land on the boundary
#@   set no_sharing_boundary [info exists flag(-no_tracks_on_boundary)]
#@ 
#@   # All track settings are done HERE with track_settings
#@ 
#@   # get length precision (the round about method for icc)
#@   redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
#@   regexp -line {^length.*} $unit_vars length_units
#@   set lengthPrecision [expr [lindex $length_units 2] + 0.0]
#@   # hard code length precision - not easily available in tcl
#@   # set lengthPrecision 1000.0
#@ 
#@   # base on bounds of the block to set range of wiretracks
#@   set bound_llx [expr [get_attribute [current_design] die_area_llx]                      / $lengthPrecision]
#@   set bound_lly [expr [get_attribute [current_design] die_area_lly]                      / $lengthPrecision]
#@   set bound_urx [expr [get_attribute [current_design] die_area_urx]                      / $lengthPrecision]
#@   set bound_ury [expr [get_attribute [current_design] die_area_ury]                      / $lengthPrecision]
#@ 
#@   # find metal routing layers
#@   set layer_pairs {}
#@   foreach_in_collection layer [get_layers] {
#@     set layer_name [get_attribute $layer name]
#@     if { [string match [get_layer_attribute -layer $layer_name isDefaultLayer] 0] } {
#@       continue
#@     }
#@     if { [string match metal*               [get_layer_attribute -layer $layer_name mask_name]] } {
#@       lappend layer_pairs [list [get_layer_attribute -layer $layer_name mask_name] $layer_name]
#@     }
#@   }
#@   set layer_pairs [lsort -index 0 -dictionary $layer_pairs]
#@   set layers {}
#@   foreach item $layer_pairs {
#@     lappend layers [lindex $item 1]
#@   }
#@   unset layer_pairs
#@ 
#@   # get existing preferred directions
#@   set preferred_dir_list {}
#@   redirect -variable dump_preferred_dir { report_preferred_routing_direction }
#@   set next_match 0
#@   if { [regexp -start $next_match -indices -lineanchor             "Layer Name  \[^\n]*"             $dump_preferred_dir dump_indices] } {
#@     set new_str [string range $dump_preferred_dir [lindex $dump_indices 0]                      [lindex $dump_indices 1]]
#@     set next_match [expr [lindex $dump_indices 1] + 2]
#@     regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_fields
#@     # find fields for layer_name & design
#@     set layer_index [lsearch [string tolower $dump_fields] layer_name]
#@     set design_index [lsearch [string tolower $dump_fields] design]
#@     set num_fields [llength $dump_fields]
#@ 
#@     # now search for fields
#@     while { [regexp -start $next_match -indices -lineanchor                  "\[^\n]*"                  $dump_preferred_dir dump_indices] } {
#@       if { $layer_index < 0 || $design_index < 0 } {
#@         break
#@       }
#@       set new_str [string range $dump_preferred_dir                        [lindex $dump_indices 0]                        [lindex $dump_indices 1]]
#@       set next_match [expr [lindex $dump_indices 1] + 2]
#@       regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_string
#@       if { [llength $dump_string] < $num_fields } {
#@         unset dump_string new_str
#@         break
#@       }
#@       set prefer_layer [lindex $dump_string $layer_index]
#@       set prefer_dir   [string tolower [lindex $dump_string $design_index]]
#@       lappend preferred_dir_list [list $prefer_layer $prefer_dir]
#@       unset prefer_layer prefer_dir dump_string new_str
#@     }
#@     unset layer_index design_index num_fields
#@   }
#@   unset dump_preferred_dir next_match
#@   set preferred_dir_list [lsort -index 0 -dictionary $preferred_dir_list]
#@ 
#@ 
#@   # begin processing track settings for layer
#@   set error 0
#@   set tracks_actually_set {}
#@   set nprfr_adds {}
#@   set dir_updates {}
#@   foreach track_set $track_settings {
#@     unset -nocomplain layer_name preferred_dir         PT NPT unknown_opt comment_field err_type
#@     foreach item $track_set {
#@       if { $error } {
#@         break
#@       }
#@       if { [llength $item] < 2 } {
#@         continue
#@       }
#@       set chk_field [string tolower [lindex $item 0]]
#@       switch -- ${chk_field} {
#@         layer                { if { [info exists layer_name] } {
#@           set err_type layer
#@         } else {
#@           set layer_name [lindex $item 1]
#@         }
#@         }
#@         preferred-direction  { if { [info exists preferred_dir] } {
#@           set err_type preferred-direction
#@         } else {
#@           set preferred_dir [lindex $item 1]
#@         }
#@         }
#@         non-preferred-tracks { if { [info exists NPT] } {
#@           set err_type non-preferred-tracks
#@         } else {
#@           set NPT [lrange $item 1 end]
#@         }
#@         }
#@         preferred-tracks     { if { [info exists PT] } {
#@           set err_type preferred-tracks
#@         } else {
#@           set PT [lrange $item 1 end]
#@         }
#@         }
#@         comment              { set comment_field 1 }
#@         default        { set unknown_opt $item }
#@       }
#@       if { [info exists err_type] } {
#@         puts "ERROR - duplicate option for \"$err_type\" in 'track_settings' for \{ $track_set \}"
#@         set error 1
#@         break
#@       }
#@       if { [info exists comment_field] } {
#@         unset comment_field
#@         continue
#@       }
#@       if { [info exists unknown_opt] } {
#@         break
#@       }
#@     }
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists unknown_opt] } {
#@       puts "WARNING - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $track_set \}"
#@       continue
#@     }
#@     if { ! [info exists layer_name] } {
#@       puts "ERROR - Required 'layer' option missing in 'track_settings' for \{ $track_set \}"
#@       set error 1
#@       break
#@     }
#@     if { [lsearch -exact $layers $layer_name] < 0 } {
#@       puts "ERROR - Unknown 'layer' \"$layer_name\" specified in 'track_settings' for \{ $track_set \}"
#@       puts "      - layer must be one of: $layers"
#@       set error 1
#@       break
#@     }
#@     if { [info exists preferred_dir] } {
#@       switch -- [string tolower ${preferred_dir}] {
#@         vertical    { set new_dir vertical }
#@         horizontal  { set new_dir horizontal }
#@         default     { set unknown_opt $item }
#@       }
#@       if { [info exists unknown_opt] } {
#@         puts "ERROR - bad preferred-direction \"$preferred_dir\" defined for layer \"$layer_name\" "
#@         set error 1
#@         break
#@       }
#@       if { [info exists ${layer_name}(dir)] && (! [string match $new_dir [expr $${layer_name}(dir)]]) } {
#@         puts "ERROR - preferred-direction defined as both horizontal & vertical for layer \"$layer_name\" "
#@         set error 1
#@         break
#@       }
#@       set ${layer_name}(dir) $new_dir
#@     }
#@ 
#@     set track_items {}
#@     if { [info exists PT] } {
#@       lappend track_items [list PT $PT]
#@     }
#@     if { [info exists NPT] } {
#@       lappend track_items [list NPT $NPT]
#@     }
#@     unset -nocomplain comment_field PT_track_offsets PT_track_repeats NPT_track_offsets NPT_track_repeats
#@     foreach N_item $track_items {
#@       set N_dir [string toupper [lindex $N_item 0]]
#@       foreach item [lindex $N_item 1] {
#@         set chk_field [string tolower [lindex $item 0]]
#@         switch -- ${N_dir}_${chk_field} {
#@           NPT_offsets { if { [info exists NPT_track_offsets] } {
#@             set err_type "non-preferred-tracks offsets"
#@           } else {
#@             set NPT_track_offsets [lindex $item 1]
#@           }
#@           }
#@           NPT_repeat  { if { [info exists NPT_track_repeats ] } {
#@             set err_type "non-preferred-tracks repeat"
#@           } else {
#@             set NPT_track_repeats [lindex $item 1]
#@           }
#@           }
#@           NPT_comment { set comment_field 1 }
#@           PT_offsets  { if { [info exists PT_track_offsets] } {
#@             set err_type "preferred-tracks offsets"
#@           } else {
#@             set PT_track_offsets [lindex $item 1]
#@           }
#@           }
#@           PT_repeat   { if { [info exists PT_track_repeats ] } {
#@             set err_type "preferred-tracks repeat"
#@           } else {
#@             set PT_track_repeats [lindex $item 1]
#@           }
#@           }
#@           PT_comment  { set comment_field 1 }
#@           default     { set unknown_opt $item }
#@         }
#@         if { [info exists comment_field] } {
#@           unset comment_field
#@           continue
#@         }
#@         if { [info exists unknown_opt] } {
#@           break
#@         }
#@         if { [info exists err_type] } {
#@           if { ($N_dir == "PT") } {
#@             set type "preferred-tracks"
#@           } else {
#@             set type "non-preferred-tracks"
#@           }
#@           puts "ERROR - duplicate option for \"$err_type\" in $layer_name '${type}' for \{ $item \}"
#@           set error 1
#@           break
#@         }
#@       }
#@       if { [info exists unknown_opt] } {
#@         break
#@       }
#@     }
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists unknown_opt] } {
#@       if { ($N_dir == "PT") } {
#@         set type "preferred-tracks"
#@       } else {
#@         set type "non-preferred-tracks"
#@       }
#@       puts "ERROR - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $layer_name $N_dir \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists PT_track_offsets] } {
#@       foreach t_item $PT_track_offsets {
#@         if { ! [string is double $t_item] } {
#@           set error 1
#@           break
#@         }
#@       }
#@       if { $error } {
#@         puts "ERROR - illegal \"preferred-tracks offsets\". Value must be real on $layer_name for $PT \}"
#@         break
#@       }
#@     }
#@     if { [info exists PT_track_repeats] && ((! [string is double $PT_track_repeats]) || ($PT_track_repeats < (1.0 / $lengthPrecision))) } {
#@       puts "ERROR - illegal \"preferred-tracks repeat\". Value must be positive real on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_offsets] } {
#@       foreach t_item $NPT_track_offsets {
#@         if { ! [string is double $t_item] } {
#@           set error 1
#@           break
#@         }
#@       }
#@       if { $error } {
#@         puts "ERROR - illegal \"non-preferred-tracks offsets\". Value must be real on $layer_name for $NPT \}"
#@         break
#@       }
#@     }
#@     if { [info exists NPT_track_repeats] && ((! [string is double $NPT_track_repeats]) || ($NPT_track_repeats < (1.0 / $lengthPrecision))) } {
#@       puts "ERROR - illegal \"non-preferred-tracks repeat\". Value must be positive real on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@ 
#@     if { [info exists PT_track_offsets] && (! [info exists PT_track_repeats]) } {
#@       puts "ERROR - \"preferred-tracks\" missing \"repeat\" on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists PT_track_repeats] && (! [info exists PT_track_offsets]) } {
#@       puts "ERROR - \"preferred-tracks\" missing \"offsets\" on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_offsets] && (! [info exists NPT_track_repeats]) } {
#@       puts "ERROR - \"non-preferred-tracks\" missing \"repeat\" on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_repeats] && (! [info exists NPT_track_offsets]) } {
#@       puts "ERROR - \"non-preferred-tracks\" missing \"offsets\" on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@ 
#@     if { [info exists PT_track_repeats] } {
#@       if { ! [info exists ${layer_name}(PT)] } {
#@         set ${layer_name}(PT) {}
#@       }
#@       lappend ${layer_name}(PT) [list $PT_track_repeats $PT_track_offsets]
#@     }
#@     if { [info exists NPT_track_repeats] } {
#@       if { ! [info exists ${layer_name}(NPT)] } {
#@         set ${layer_name}(NPT) {}
#@       }
#@       lappend ${layer_name}(NPT) [list $NPT_track_repeats $NPT_track_offsets]
#@     }
#@ 
#@   }
#@ 
#@   foreach layer_name $layers {
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists ${layer_name}(dir)] } {
#@       set preferred_dir [expr $${layer_name}(dir)]
#@     } elseif { ! ([info exists ${layer_name}(PT)] || [info exists ${layer_name}(PT)]) } {
#@       # no tracks or preferred_dir defined for the layer
#@       continue
#@     }
#@     unset -nocomplain act_dir
#@     set dir_index [lsearch -glob $preferred_dir_list "$layer_name *"]
#@     if { $dir_index >= 0 } {
#@       set act_dir [lindex [lindex $preferred_dir_list $dir_index] 1]
#@     }
#@     if { [info exists preferred_dir] } {
#@       # see if preferred_dir needs to be changed
#@       if { [info exists act_dir] } {
#@         if { ! [string match -nocase $act_dir $preferred_dir] } {
#@           # mismatched preferred direction
#@           puts "INFO - Changing $layer_name preferred direction to \"${preferred_dir}\""
#@           unset_preferred_routing_direction -layer $layer_name
#@           set_preferred_routing_direction -layers $layer_name -direction $preferred_dir
#@           set act_dir $preferred_dir
#@           set preferred_dir_list               [lreplace $preferred_dir_list $dir_index $dir_index                    [list $layer_name $preferred_dir]]
#@           lappend dir_updates [list $layer_name $preferred_dir]
#@         }
#@       } else {
#@         puts "ERROR - $layer_name has no preferred direction"
#@         set error 1
#@         continue
#@       }
#@     } else {
#@       if { [info exists act_dir] &&                ( [string match horizontal $act_dir] ||                      [string match vertical $act_dir] ) } {
#@         puts "INFO - $layer_name using $act_dir preferred direction"
#@         set preferred_dir $act_dir
#@       } else {
#@         puts "WARNING - $layer_name has no preferred direction"
#@         continue
#@       }
#@     }
#@   }
#@ 
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { ! [info exists ${layer_name}(PT) ] } {
#@       # no defined preferred tracks to add
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     # set layer_index [lsearch -exact $layers $layer_name]
#@ 
#@     unset -nocomplain tracks_actually_set
#@     set tracks_actually_set {}
#@ 
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 1
#@       set XY Y
#@       set bound_ll $bound_lly
#@       set bound_ur $bound_ury
#@     } else {
#@       set horizontal 0
#@       set XY X
#@       set bound_ll $bound_llx
#@       set bound_ur $bound_urx
#@     }
#@ 
#@     # find start track (based on reference_origin) relative to lower-left
#@     if { $reference_origin } {
#@       # reference for offset is origin
#@       set start_ref 0
#@     } else {
#@       # reference for offset is lower-left
#@       set start_ref $bound_ll
#@     }
#@ 
#@     set PT_list [expr $${layer_name}(PT)]
#@ 
#@     # get default layer width
#@     set width [get_layer_attribute -layer $layer_name defaultWidth]
#@     # if no_sharing_boundary use width, else treat as if width=0
#@     #   (since only the track not the metal must fall within/touching boundary)
#@     if { ! $no_sharing_boundary } {
#@       set width 0
#@     }
#@     set removed_track 0
#@ 
#@     foreach PT $PT_list {
#@       set PT_track_repeats [lindex $PT 0]
#@       set PT_track_offsets [lindex $PT 1]
#@ 
#@ 
#@       # figure out offsets and repeats for actual tracks
#@       set item_list {}
#@       foreach PT_offset $PT_track_offsets  {
#@         # find start track based on start_ref (wire width must fit in bounds)
#@         set offset_adjust [expr $PT_offset                                - ($PT_track_repeats *floor($PT_offset / $PT_track_repeats))]
#@         set PT_start [expr $start_ref + $offset_adjust                           + (($offset_adjust < (0.5 * $width))? $PT_track_repeats : 0)]
#@         set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $PT_start)                                          / $PT_track_repeats)) ]
#@         if { $tcnt > 0 } {
#@           set new_item [list $PT_start $tcnt]
#@           if { [lsearch -exact $item_list $new_item] < 0 } {
#@             lappend item_list $new_item
#@           }
#@         }
#@       }
#@       if { (! $removed_track) && ([llength $item_list] > 0) } {
#@         puts "INFO: Forcing preferred track to defined values on -layer $layer_name"
#@         remove_track -layer $layer_name -dir $XY
#@         set removed_track 1
#@       }
#@       foreach new_item $item_list  {
#@         set PT_start [lindex $new_item 0]
#@         set tcnt [lindex $new_item 1]
#@         set new_track "create_track -layer $layer_name -dir $XY -coord $PT_start                       -space $PT_track_repeats -count $tcnt"
#@         eval $new_track
#@         lappend tracks_actually_set $new_track
#@       }
#@     }
#@     if { [llength $tracks_actually_set] > 0 } {
#@       set ${layer_name}(tracks) $tracks_actually_set
#@     }
#@   }
#@ 
#@   # loop to add defined non-preferred tracks
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { ! [info exists ${layer_name}(NPT)] } {
#@       # no defined non-preferred tracks to add
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     set layer_index [lsearch -exact $layers $layer_name]
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 0
#@       set XY X
#@       set bound_ur $bound_urx
#@     } else {
#@       set horizontal 1
#@       set XY Y
#@       set bound_ur $bound_ury
#@     }
#@ 
#@     set NPT_list [expr $${layer_name}(NPT)]
#@ 
#@     # get default layer width
#@     set width [get_layer_attribute -layer $layer_name defaultWidth]
#@     # if no_sharing_boundary use width, else treat as if width=0
#@     #   (since only the track not the metal must fall within/touching boundary)
#@     if { ! $no_sharing_boundary } {
#@       set width 0
#@     }
#@     set removed_track 0
#@ 
#@     foreach NPT $NPT_list {
#@       set NPT_track_repeats [lindex $NPT 0]
#@       set NPT_track_offsets [lindex $NPT 1]
#@ 
#@       # figure out offsets and repeats for actual tracks
#@       set item_list {}
#@       foreach NPT_offset $NPT_track_offsets  {
#@         # find start track based on start_ref (wire width must fit in bounds)
#@         set offset_adjust [expr $NPT_offset                                - ($NPT_track_repeats                                       * floor($NPT_offset / $NPT_track_repeats))]
#@         set NPT_start [expr $start_ref + $offset_adjust                            + (($offset_adjust < (0.5 * $width))? $NPT_track_repeats : 0)]
#@         set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $NPT_start)                                          / $NPT_track_repeats)) ]
#@         if { $tcnt > 0 } {
#@           set new_item [list $NPT_start $tcnt]
#@           if { [lsearch -exact $item_list $new_item] < 0 } {
#@             lappend item_list $new_item
#@           }
#@         }
#@       }
#@       if { (! $removed_track) && ([llength $item_list] > 0) } {
#@         puts "INFO: Forcing non-preferred track to defined values on -layer $layer_name"
#@         remove_track -layer $layer_name -dir $XY
#@         set removed_track 1
#@       }
#@       foreach new_item $item_list  {
#@         set NPT_start [lindex $new_item 0]
#@         set tcnt [lindex $new_item 1]
#@         set new_track "create_track -layer $layer_name -dir $XY -coord $NPT_start                       -space $NPT_track_repeats -count $tcnt"
#@         eval $new_track
#@       }
#@     }
#@   }
#@ 
#@   # loop to check if default non-preferred tracks are needed
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { [info exists ${layer_name}(NPT)] } {
#@       # already added non-preferred tracks
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     set layer_index [lsearch -exact $layers $layer_name]
#@     if { $layer_index > 0 } {
#@       set lower_layer [lindex $layers [expr $layer_index - 1]]
#@     } else {
#@       set lower_layer ""
#@     }
#@     if { $layer_index < ([llength $layers] - 1) } {
#@       set upper_layer [lindex $layers [expr $layer_index + 1]]
#@     } else {
#@       set upper_layer ""
#@     }
#@ 
#@     if { ! ([info exists ${upper_layer}(tracks)] || [info exists ${lower_layer}(tracks)]) } {
#@       # no preferred tracks defined on adjacent tracks
#@       continue
#@     }
#@ 
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 0
#@       set XY X
#@     } else {
#@       set horizontal 1
#@       set XY Y
#@     }
#@ 
#@     set np_list {}
#@     if { [llength $lower_layer] } {
#@       unset -nocomplain lower_tracks
#@       redirect -variable lower_tracks { report_track -layer $lower_layer -dir $XY }
#@       set next_match 0
#@       while { [regexp -start $next_match -indices                    "$lower_layer \[^\n]*"                    $lower_tracks np_indices] } {
#@         lappend np_list             [lreplace [lrange [string range $lower_tracks                                    [lindex $np_indices 0]                                    [lindex $np_indices 1]]                            0 4] 0 0 $layer_name]
#@         set next_match [expr [lindex $np_indices 1] + 1]
#@       }
#@       unset -nocomplain lower_tracks np_indices next_match
#@     }
#@     if { [llength $upper_layer] } {
#@       unset -nocomplain upper_tracks
#@       redirect -variable upper_tracks { report_track -layer $upper_layer -dir $XY }
#@       set next_match 0
#@       while { [regexp -start $next_match -indices                    "$upper_layer \[^\n]*"                    $upper_tracks np_indices] } {
#@         lappend np_list             [lreplace [lrange [string range $upper_tracks                                    [lindex $np_indices 0]                                    [lindex $np_indices 1]]                            0 4] 0 0 $layer_name]
#@         set next_match [expr [lindex $np_indices 1] + 1]
#@       }
#@       unset -nocomplain upper_tracks np_indices next_match
#@     }
#@     set np_list [lsort -unique $np_list]
#@ 
#@     if { [llength $np_list] > 0 } {
#@       puts "INFO: Resetting non-preferred track to adjacent layer preferred tracks settings on -layer $layer_name"
#@       remove_track -layer $layer_name -dir $XY
#@     }
#@     foreach np_track $np_list {
#@       if { [llength $np_track] < 5 } {
#@         continue
#@       }
#@       set new_track "create_track -layer $layer_name -dir $XY -coord [lindex $np_track 2]                         -space [lindex $np_track 4] -count [lindex $np_track 3]"
#@       eval $new_track
#@     }
#@ 
#@   }
#@ 
#@   if { $error } {
#@     puts "ERROR - $func_name stopped due to errors"
#@   }
#@ 
#@ }
#@ define_proc_attributes P_set_repeating_custom_tracks -info "set custom tracks"     -define_args {{-track_settings "provide list or use '-track_settings help' for TrackInfoList format" TrackInfoList list required }                       {-offset_reference "reference for track offsets {default=lowerLeft}" offset_reference one_of_string { optional value_help {values {lowerLeft origin}}}}                       {-no_tracks_on_boundary "require tracks produce wires fully in the boundary" "" boolean optional} }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_check_boundary_contact
#@ # Description : The procedure to determine if the Core Boundary contacts with any cell
#@ #               which has start point coordinates as cell_llx, cell_lly
#@ #               Used in halo insertion
#@ 
#@ proc P_check_boundary_contact {cell_llx cell_lly} {
#@ 
#@   set bbox [get_attribute [get_core_area] bbox]
#@   set bbox_x1 [lindex [lindex $bbox 0] 0]
#@   set bbox_y1 [lindex [lindex $bbox 0] 1]
#@   set bbox_x2 [lindex [lindex $bbox 1] 0]
#@   set bbox_y2 [lindex [lindex $bbox 1] 1]
#@ 
#@   global diehalo_width
#@   global diehalo_height
#@ 
#@   set flag 0
#@   set prs_flag 0
#@ 
#@   # Checking if the cell that gets placed will be within the die boundary.
#@   # Uncomment line from 78-83 and comment line 85-90 if die-edge halo is considered within Core
#@   #  if {($cell_llx <= [expr $bbox_x1 + 0.54 - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + 1.68 - 0.001]) || ($cell_llx >= [expr $bbox_x2 - 0.54 - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - 1.68 - 0.001] )} {
#@   # set flag 1
#@   #   } else {
#@   #       set flag 0
#@   #   }
#@   #   return $flag
#@ 
#@   if {($cell_llx <= [expr $bbox_x1 + $diehalo_width - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + $diehalo_height - 0.001]) || ($cell_llx >= [expr $bbox_x2 - $diehalo_width - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - $diehalo_height - 0.001] )} {
#@     set flag 1
#@   } else {
#@     set flag 0
#@   }
#@   return $flag
#@ }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_get_abut_chain
#@ # Description : This proc is used to get list of macros which are abutting each other
#@ #               Used in halo insertion
#@ 
#@ proc P_get_abut_chain {abut_master} {
#@   global cellabutlist
#@   set cellabutlist [add_to_collection $cellabutlist $abut_master]
#@   set macro_bbox [list [get_attribute $abut_master boundary]]
#@   set overlapcells [remove_from_collection [get_cells -all -intersect $macro_bbox] $cellabutlist]
#@   foreach_in_collection ovcell $overlapcells {
#@     P_get_abut_chain $ovcell
#@   }
#@   return $cellabutlist
#@ }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_get_abutted_cells
#@ # Description : This proc is used to get macro cells which are abutting
#@ #               Used in halo insertion
#@ 
#@ proc P_get_abutted_cells {input_master} {
#@   set macro_groups ""
#@   set fullabutlist ""
#@   global cellabutlist
#@   foreach_in_collection macrolist $input_master {
#@     if {[sizeof_collection [remove_from_collection $fullabutlist $macrolist -intersect]] == 0} {
#@       set cellabutlist ""
#@       set out_list [P_get_abut_chain $macrolist]
#@       set fullabutlist [add_to_collection $fullabutlist $out_list]
#@       lappend macro_groups [lsort -unique [get_object_name $out_list]]
#@     }
#@   }
#@ 
#@   return $macro_groups
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_get_boundary_polygon
#@ # Description : This proc is used boundary polygon computation for halo insertion
#@ 
#@ proc P_get_boundary_polygon {list_macros} {
#@   set result_polygon [list]
#@   while {[llength $list_macros] > 0} {
#@     set copy_macros $list_macros
#@     for { set i 0 } { $i < [llength $copy_macros] } { incr i } {
#@       if {[llength $result_polygon] > 0 } {
#@         set polygon [compute_polygons -boolean or "$result_polygon" [get_attribute [get_cells -all [lindex $copy_macros $i]] boundary]]
#@         if {[llength $polygon] == 1} {
#@           set result_polygon $polygon
#@           set list_macros [lsearch -inline -all -not -exact $list_macros [lindex $copy_macros $i]]
#@         }
#@       } else {
#@         set first_macro [lindex $copy_macros 0]
#@         set list_macros [lsearch -inline -all -not -exact $list_macros $first_macro]
#@         set result_polygon [get_attribute [get_cells -all $first_macro] boundary]
#@       }
#@     }
#@   }
#@ 
#@   if {[llength $result_polygon] != 1} {
#@     set result_polygon [list $result_polygon];
#@   }
#@ 
#@   return $result_polygon
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_lcount
#@ # Description : This proc is used to get repeated elements from a list
#@ 
#@ proc P_lcount list {
#@   foreach x $list {lappend arr($x) {}}
#@   set res {}
#@   foreach name [array names arr] {
#@     if { [llength $arr($name)] == 2 } {
#@       set res $name
#@     }
#@   }
#@   return $res
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_place_halo
#@ # creates and places a HALO cell at a specific location
#@ # to improve run time, save orientation in list and run at the end
#@ #
#@ proc P_place_halo {cell inst x y orientation} {
#@   global halo_counter
#@   global halo_orient_N halo_orient_FN halo_orient_S halo_orient_FS
#@   create_cell $inst $cell > /dev/null
#@   set_cell_location $inst -coordinates "$x $y" -ignore_fixed
#@   #rotate_objects $inst -to $orientation -ignore_fixed > /dev/null
#@   #this command is slow, so create a list of cell first, then run at once
#@   if {$orientation == "N"} {
#@     lappend halo_orient_N "$inst"
#@   } elseif {$orientation == "FN"} {
#@     lappend halo_orient_FN "$inst"
#@   } elseif {$orientation == "S"} {
#@     lappend halo_orient_S "$inst"
#@   } elseif {$orientation == "FS"} {
#@     lappend halo_orient_FS "$inst"
#@   } else {
#@     P_msg_error "set orientation error"
#@   }
#@   incr halo_counter
#@   #puts "==>INFORMATION: Placed $cell $inst $x $y $orientation"
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_find_direction
#@ # This procedure just finds the direction of the boundary edge
#@ # by looking at the coordinate of start point and end point
#@ # returns "up", "down", "left", "right"
#@ #
#@ proc P_find_direction {start end} {
#@   set startx [lindex $start 0]
#@   set starty [lindex $start 1]
#@   set endx [lindex $end 0]
#@   set endy [lindex $end 1]
#@   if {$startx == $endx && $starty==$endy} {
#@     return "nochange"
#@   } elseif {$startx<$endx && $starty==$endy} {
#@     return "right"
#@   } elseif {$startx==$endx && $starty<$endy} {
#@     return "up"
#@   } elseif {$startx>$endx && $starty==$endy} {
#@     return "left"
#@   } elseif {$startx==$endx && $starty>$endy} {
#@     return "down"
#@   } else {
#@     P_msg_error "Cannot determine direction"
#@   }
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_ret_intersect_list
#@ # Description : This proc returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo 
#@ #               Used during halo insertion around voltage areas
#@ 
#@ proc P_ret_intersect_list {args} {
#@   parse_proc_arguments -args $args inputs
#@   set vboundary $inputs(-input_boundary)
#@   set input_va_name $inputs(-input_va)
#@ 
#@   set check_boundary_list [list ]
#@   set volt_boundary [lsort -unique -dict -increasing $vboundary]
#@ 
#@   set die_boundary [lsort -unique -dict -increasing [get_attribute [get_die_area] boundary]]
#@   lappend check_boundary_list $die_boundary
#@   
#@   set intersect_macros [get_cells -all -intersect $vboundary -quiet -filter "name !~ *halo_va*"]
#@   foreach_in_collection  macro $intersect_macros {
#@     lappend check_boundary_list [lsort -unique -incr -dict [get_attribute $macro boundary]]
#@   }
#@   
#@   set ret_list ""
#@   set volt_count -1
#@ 
#@   foreach volt_point $volt_boundary {
#@     incr volt_count
#@     foreach volt_x_val [lindex $volt_point 0] {
#@       foreach check_bound $check_boundary_list {
#@         set ch_count -1
#@         set x_val ""
#@         foreach check_point $check_bound {
#@           incr ch_count
#@           foreach check_x_val [lindex $check_point 0] {
#@             if {[lsearch $x_val $volt_x_val] > -1} {continue}
#@             if {$check_x_val == $volt_x_val} {
#@               lappend x_val $check_x_val
#@               set check_curr_y_val [lindex $check_point 1]
#@               set check_next_y_val [lindex [lindex $check_bound [expr $ch_count + 1]] 1]
#@               set volt_curr_y_val [lindex $volt_point 1]
#@               set volt_next_y_val [lindex [lindex $volt_boundary [expr $volt_count + 1]] 1]
#@               
#@               if {($check_curr_y_val <= $volt_curr_y_val) && ($check_next_y_val > $volt_curr_y_val)} {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$volt_curr_y_val y2_$check_next_y_val"
#@               } elseif {($check_curr_y_val < $volt_next_y_val) && ($check_next_y_val >= $volt_next_y_val)} {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$volt_next_y_val"
#@               } elseif {($check_curr_y_val > $volt_curr_y_val) && ($check_next_y_val < $volt_next_y_val)}  {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$check_next_y_val"
#@               }
#@             }
#@           }
#@         }
#@       }
#@     }
#@   }
#@ 
#@   return $ret_list
#@ }
#@ 
#@ define_proc_attributes P_ret_intersect_list     -info "Returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo"     -define_args {
#@       {"-input_boundary" "Voltage area boundary" "" list required}
#@       {"-input_va" "Voltage area name" "" string required}
#@     }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_check_exclusion
#@ # Description : This proc returns the returns y1 y2 intersect points of boundary/macro/non-va-halo
#@ #               Used during halo insertion around voltage areas
#@ 
#@ proc P_check_exclusion {args} {
#@   parse_proc_arguments -args $args inputs
#@   set x $inputs(-x)
#@   set y $inputs(-y)
#@   set ret 1
#@ 
#@   foreach in_list $inputs(-list) {
#@     set match_index [lsearch -all $in_list x_$x]
#@     foreach x_index $match_index {
#@       if {$x_index > -1} {
#@         set y1 [lindex [split [lindex $in_list [expr $x_index + 1]] "_"] 1]
#@         set y2 [lindex [split [lindex $in_list [expr $x_index + 2]] "_"] 1]
#@         if {[expr $y >= $y1] && [expr $y < $y2]} {
#@           set ret 0
#@           return $ret
#@         }
#@       }
#@     }
#@   }
#@ 
#@   return $ret
#@ 
#@ }
#@ 
#@ define_proc_attributes P_check_exclusion     -info "Returns y1 y2 intersect points"     -define_args {
#@       {"-list" "input list" "" string required}
#@       {"-x" "x coordinate to check" "" string required}
#@       {"-y" "y coordinate to check" "" string required}
#@     }
#@ 
#@ ####################################################################################################
#@ # Procedure   : P_macro_route_guide_cmd
#@ # Description : This proc is a PG pullback solution.
#@ #               It creates route-guides for all IPs for all specified layers and pulls back the PG when power straps are created.
#@ #               The route guide is removed when the proc is executed again for the next metal layer.
#@ 
#@ proc P_macro_route_guide_cmd {layer} {
#@   global INTEL_MACRO_EXCLUSION_LIST
#@   global INTEL_MACRO_RG_LIST
#@   remove_route_guide macroblkg*
#@ 
#@   foreach_in_collection macro [all_macro_cells] {
#@     set macro_ref_name [get_attribute $macro ref_name]
#@     set macro_index ""
#@     set default_index ""
#@     set exclusion_list -1
#@ 
#@     #Sets up exclusion list for macro references which should not have RGs for any layer
#@     #------------------------------------------------------------------------------------
#@     if {[info exists INTEL_MACRO_EXCLUSION_LIST] && $INTEL_MACRO_EXCLUSION_LIST != ""} {
#@       set exclusion_list [lsearch $INTEL_MACRO_EXCLUSION_LIST $macro_ref_name]
#@     }
#@ 
#@     if {$exclusion_list >= 0} {
#@       P_msg_info "Route Guides not created for macro:$macro_ref_name as it is part of exclusion list..."
#@     } else {
#@ 
#@       #Overrides default bloat values of current layer for specified macros
#@       #---------------------------------------------------------------------------------
#@       if {[info exists INTEL_MACRO_RG_LIST($macro_ref_name)]} {
#@         set macro_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST($macro_ref_name)] $layer]
#@         if {$macro_index != -1} {
#@           set x_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 1]]
#@           set y_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 2]]
#@         }
#@       }
#@ 
#@       #Defaults bloat values for current layer if not overriden for a macro
#@       #-------------------------------------------------------------------------
#@ 
#@       if {![info exists INTEL_MACRO_RG_LIST($macro_ref_name)] || $macro_index == -1} {
#@         if {[info exists INTEL_MACRO_RG_LIST(DEFAULT)]} {
#@           set default_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST(DEFAULT)] $layer]
#@           if {$default_index != -1} {
#@             set x_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 1]]
#@             set y_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 2]]
#@           }
#@         }
#@       }
#@ 
#@       #No route guides will be created for current layer, if bloat values were neither provided in default or override list
#@       #----------------------------------------------------------------------------------------------------------------------
#@ 
#@       if {![info exists INTEL_MACRO_RG_LIST(DEFAULT)] || $default_index == -1} {
#@         puts "==>ERROR: Neither \$INTEL_MACRO_RG_LIST($macro_ref_name) nor \$INTEL_MACRO_RG_LIST(DEFAULT) have been defined for layer $layer. Route Guides will not be created..."
#@         return
#@       }
#@ 
#@       #Check to ensure that both bloats should either be NA or should be a double value.
#@       #----------------------------------------------------------------------------
#@       if {!(($x_bloat eq "NA") && ($y_bloat eq "NA")) && !([string is double $x_bloat] && [string is double $y_bloat])} {
#@         puts "==>ERROR: Bloat values specified incorrectly for $macro_ref_name. Either x_bloat and y_bloat should both be NA (or) a double value. Route Guides will not be created..."
#@         return
#@       }
#@ 
#@ 
#@       #Route Guides will not be created if both x and y bloats equal NA
#@       #-------------------------------------------------------------------
#@       if {($x_bloat eq "NA") && ($y_bloat eq "NA")} {
#@         return
#@       }
#@ 
#@ 
#@       #Route Guides will be created around macros on layers m0-m4 + layers containing macro pins.
#@       #-------------------------------------------------------------------------------------------
#@ 
#@       set macro_name [get_attribute $macro full_name]
#@       set macro_bound [get_attribute $macro boundary]
#@       set rect_box [convert_from_polygon -format rectangle $macro_bound]
#@       set i 0
#@       foreach rect $rect_box {
#@         scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@         set macrobbox_bloat "[expr $b_llx - $x_bloat] [expr $b_lly - $y_bloat] [expr $b_urx + $x_bloat] [expr $b_ury + $y_bloat]"
#@ 
#@         set pin_names [get_pins -all -quiet -filter "layer=~*$layer*" -of_objects $macro ]
#@         if {[sizeof_collection $pin_names] > 0 || [regexp {m[0-5]$} $layer]} {
#@           create_route_guide -no_preroute_layers $layer               -name macroblkg_${macro_name}_${layer}_${i}               -coordinate $macrobbox_bloat
#@           incr i
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ #########################################################################################################
#@ # Procedure   : P_strap_cmd
#@ # Common procedure to create power straps
#@ # step_at: the offset from which the start the first strap
#@ # step: pitch
#@ # pullback: distance to pull the end of strap away from bondary to isolate from neighbor partition
#@ 
#@ proc P_strap_cmd {layer direction net width start_at step pullback} {
#@   global bound_llx bound_lly bound_urx bound_ury
#@   set cmd "create_power_straps -layer $layer -nets $net -width $width                                  -start_at $start_at -step $step                                  -configure step_and_stop                                  -clip_at_top_cell_boundaries                                  -advanced_via_rules                                  -keep_floating_wire_pieces"
#@   if {$direction == "horizontal"} {
#@     set high_ends [expr $bound_urx - $pullback]
#@     set low_ends [expr $bound_llx + $pullback]
#@     set cmd "$cmd -direction horizontal                       -start_high_ends coordinate -start_high_ends_coordinate [expr $bound_urx - $pullback]                       -start_low_ends coordinate -start_low_ends_coordinate [expr $bound_llx + $pullback]                       -stop $bound_ury"
#@   } else {
#@     set high_ends [expr $bound_ury - $pullback]
#@     set low_ends [expr $bound_lly + $pullback]
#@     set cmd "$cmd -direction vertical                       -start_high_ends coordinate -start_high_ends_coordinate $high_ends                       -start_low_ends coordinate -start_low_ends_coordinate $low_ends                       -stop $bound_urx"
#@   }
#@   if {$pullback == 0} {
#@     set cmd "$cmd -extend_low_ends to_boundary_and_generate_pins                       -extend_high_ends to_boundary_and_generate_pins"
#@   }
#@   set cmd [regsub -all {\s+} $cmd " "]; #clean up extra spaces
#@   puts "==>INFORMATION: Running \"$cmd\""
#@   eval $cmd
#@ }
#@ 
#@ #########################################################################################################
#@ # Procedure   : P_check_partition_dimension
#@ # Check if the partition dimension is modular-grid multiple
#@ 
#@ proc P_check_partition_dimension {} {
#@ 
#@   global INTEL_DESIGN_WIDTH INTEL_DESIGN_HEIGHT INTEL_FP_BOUNDARY
#@   global INTEL_FP_INPUT
#@   global INTEL_MD_GRID_X INTEL_MD_GRID_Y
#@ 
#@   if {[info exists INTEL_DESIGN_WIDTH] && $INTEL_DESIGN_WIDTH != "" && [info exists INTEL_DESIGN_HEIGHT] && $INTEL_DESIGN_HEIGHT != ""} {
#@     P_msg_info "Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
#@     if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X) - round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X))]] != 0.0 } {
#@       P_msg_error "Block width is NOT n * $INTEL_MD_GRID_X, please adjust the design width setting INTEL_DESIGN_WIDTH."
#@       P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_X is [expr round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X)]"
#@     }
#@     if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y) - round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@       P_msg_error "Block height is NOT n * $INTEL_MD_GRID_Y, please adjust the design height setting INTEL_DESIGN_HEIGHT."
#@       P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_Y is [expr round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y)]"
#@     }
#@     P_msg_info "Done: Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
#@   } elseif {[info exists INTEL_FP_BOUNDARY] && $INTEL_FP_BOUNDARY != ""} {
#@     P_msg_info "Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
#@     redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $INTEL_FP_BOUNDARY $INTEL_FP_BOUNDARY]}}
#@     if { ! [info exists _bndry] } {
#@       P_msg_error "INTEL_FP_BOUNDARY is not valid.  May require additional set of {} braces"
#@     } elseif { $_bndry == 0 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified is not a valid polygon"
#@     } elseif { [llength $_bndry] == 0 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified has no defined area"
#@     } elseif { [llength $_bndry] != 1 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified is not a single polygon shape"
#@     } else {
#@       set _bndry [lindex $_bndry 0]
#@     }
#@     foreach xy $INTEL_FP_BOUNDARY {
#@       set x [lindex $xy 0]
#@       set y [lindex $xy 1]
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
#@         P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
#@       }
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
#@         P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
#@       }
#@     }
#@     P_msg_info "Done: Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
#@   } elseif { ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "DEF") || ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "FP_TCL") } {
#@     set fp_boundary [get_attribute [get_die_area] boundary]
#@     P_msg_info "Checking if coordinates of the die area are integer multiples of the modular grid."
#@     redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $fp_boundary $fp_boundary]}}
#@     if { ! [info exists _bndry] } {
#@       P_msg_error "The die area is not valid.  May require additional set of {} braces"
#@     } elseif { $_bndry == 0 } {
#@       P_msg_error "The die area specified is not a valid polygon"
#@     } elseif { [llength $_bndry] == 0 } {
#@       P_msg_error "The die area specified has no defined area"
#@     } elseif { [llength $_bndry] != 1 } {
#@       P_msg_error "The die area specified is not a single polygon shape"
#@     } else {
#@       set _bndry [lindex $_bndry 0]
#@     }
#@     foreach xy $fp_boundary {
#@       set x [lindex $xy 0]
#@       set y [lindex $xy 1]
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
#@         P_msg_error "Please adjust the die area."
#@       }
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
#@         P_msg_error "Please adjust the die area."
#@       }
#@     }
#@     P_msg_info "Done: Checking if coordinates of the die area are integer multiples of the modular grid."
#@   } else {
#@     P_msg_error "None of the following is set: INTEL_DESIGN_WIDTH/INTEL_DESIGN_HEIGHT, INTEL_FP_BOUNDARY, INTEL_FP_DEF or INTEL_FP_TCL"
#@   }
#@ }
#@ 
#@ proc P_adv_polygon_size { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon)]) || [info exists inputs(-list)]]
#@ 
#@   # get size argument, see if valid
#@   set size $inputs(size)
#@ 
#@   # allow for separate x,y size
#@   # if only a single value, then x,y default to that value
#@   set xsize [lindex $size 0]
#@   set ysize [lindex $size end]
#@   if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@     error "$func_name: size value \"$size\" is not a float or pair of floats."
#@     unset size xsize ysize
#@   }
#@ 
#@   set no_sizing 0
#@   set single_resize 1
#@   set directional_resize 0
#@   if { $xsize == $ysize } {
#@     set simple_size 1
#@     set size $xsize
#@     if { $xsize == 0 } {
#@       set no_sizing 1
#@     } else {
#@       redirect -variable resize_help {resize_polygon -help}
#@       set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     }
#@   } else {
#@     set simple_size 0
#@     redirect -variable resize_help {resize_polygon -help}
#@     set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     set directional_resize [regexp -- {-size_left} $resize_help]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     error "'${func_name}': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # suppress message MWUI-087 when downsizing removes a polygon
#@   set no_MWUI_087_suppress 0
#@   if { (! $single_resize) && (($xsize < 0) || ($ysize < 0)) } {
#@     redirect -variable suppress_chk_str {print_suppressed_messages}
#@     if { [lsearch -exact [split [regsub -all {[\{\},\s]+} $suppress_chk_str { }]] {MWUI-087}] == -1 } {
#@       set no_MWUI_087_suppress 1
#@       suppress_message {MWUI-087}
#@     }
#@   }
#@ 
#@   # go through sizing scenarios
#@   if { $no_sizing || ([llength $polygon] < 1) } {
#@     # no sizing or no polygon - nothing to do
#@     set final $polygon
#@   } elseif { $simple_size && $single_resize } {
#@     # use simple sizing function
#@     set final {}
#@     foreach shape $polygon {
#@       foreach sized_poly [resize_polygon -size $size $shape] {
#@         # ensure a valid polygon was returned
#@         # - some Synopsys versions return '0' rather than {} if empty
#@         if { [llength $sized_poly] > 3 } {
#@           lappend final $sized_poly
#@         }
#@       }
#@     }
#@   } elseif { $simple_size } {
#@     set final [resize_polygon -size $size $polygon]
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } elseif { $directional_resize } {
#@     if { (($xsize < 0) && ($ysize < 0)) || (($xsize > 0) && ($ysize > 0)) } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize -size_top $ysize -size_bottom $ysize $polygon]
#@     } elseif { $ysize < 0 } {
#@       set pre_final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $xsize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_left $xsize -size_right $xsize $pre_final]
#@       }
#@     } elseif { $xsize < 0 } {
#@       set pre_final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $ysize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_top $ysize -size_bottom $ysize $pre_final]
#@       }
#@     } elseif { $ysize == 0 } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@     } elseif { $xsize == 0 } {
#@       set final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@     } else {
#@       set final $polygon
#@     }
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } else {
#@     # first perform any necessary shrink
#@     if { ($xsize < 0) || ($ysize < 0) } {
#@       # to avoid issues with breaking apart during shrink,
#@       # the shrink is done as an inverse image using a grow
#@       #   expand_bound = (expand BOUND(polygon) by size)
#@       #   shrink_poly = expand_bound NOT
#@       #         (expand (poly_to_rects(expand_bound NOT polygon)) by shrink)
#@       set shrunk_poly {}
#@ 
#@       # expand by 0.1 more than smallest negative value
#@       set ovrsize [expr ($xsize < $ysize) ? (0.1 - $xsize) : (0.1 - $ysize)]
#@       set rect_shrink_factor_x [expr ($xsize<0) ?  abs($xsize) : 0]
#@       set rect_shrink_factor_y [expr ($ysize<0) ?  abs($ysize) : 0]
#@ 
#@       foreach shape $polygon {
#@         # get x extents using a list sort
#@         set x_sort [lsort -index 0 -increasing -real $shape]
#@         set xll [expr [lindex [lindex $x_sort 0] 0] - $ovrsize]
#@         set xur [expr [lindex [lindex $x_sort end] 0] + $ovrsize]
#@ 
#@         # get y extents using a list sort
#@         set y_sort [lsort -index 1 -increasing -real $shape]
#@         set yll [expr [lindex [lindex $y_sort 0] 1] - $ovrsize]
#@         set yur [expr [lindex [lindex $y_sort end] 1] + $ovrsize]
#@ 
#@         set expand_bound [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         set inv_polygon [compute_polygons -boolean not $expand_bound $shape]
#@ 
#@         # create inverse sized polygon
#@         set inv_sized_polygon {}
#@         foreach inv_shape $inv_polygon {
#@           foreach rect [convert_from_polygon -format polygon $inv_shape] {
#@             # get x extents using a list sort
#@             set x_sort [lsort -index 0 -increasing -real $rect]
#@             set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_shrink_factor_x]
#@             set xur [expr [lindex [lindex $x_sort end] 0] + $rect_shrink_factor_x]
#@ 
#@             # get y extents using a list sort
#@             set y_sort [lsort -index 1 -increasing -real $rect]
#@             set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_shrink_factor_y]
#@             set yur [expr [lindex [lindex $y_sort end] 1] + $rect_shrink_factor_y]
#@ 
#@             lappend inv_sized_polygon [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@           }
#@         }
#@ 
#@         # merge inverse sized polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain merge_polygon
#@         redirect /dev/null {
#@           catch {set merge_polygon [compute_polygons -boolean or $inv_sized_polygon [lindex $inv_sized_polygon 0]]}
#@         }
#@         if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set inv_sized_polygon $merge_polygon
#@           unset -nocomplain merge_polygon
#@         } else {
#@           for { set i 0 } { $i < [llength $inv_sized_polygon] } {incr i} {
#@             for { set j [expr $i + 1] } { $j < [llength $inv_sized_polygon] } {incr j} {
#@               set new [compute_polygons -boolean or [lindex $inv_sized_polygon $i] [lindex $inv_sized_polygon $j]]
#@               if { [llength $new] > 1 } {
#@                 continue
#@               }
#@               set inv_sized_polygon [lreplace [lreplace $inv_sized_polygon $i $i [lindex $new 0]] $j $j]
#@               incr i -1
#@               break
#@             }
#@           }
#@         }
#@ 
#@         # re-invert the polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain re_inv_polygon
#@         redirect /dev/null {
#@           catch {set re_inv_polygon [compute_polygons -boolean not [list $expand_bound] $inv_sized_polygon]}
#@         }
#@         if { [info exists re_inv_polygon] && (! [string equal $re_inv_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         } else {
#@           set re_inv_polygon [list $expand_bound]
#@           foreach inv_shape $inv_sized_polygon {
#@             set new_shrink {}
#@             foreach re_shape $re_inv_polygon {
#@               foreach poly_not [compute_polygons -boolean not $re_shape $inv_shape] {
#@                 lappend new_shrink $poly_not
#@               }
#@             }
#@             set re_inv_polygon $new_shrink
#@           }
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         }
#@       }
#@     } else {
#@       set shrunk_poly $polygon
#@     }
#@ 
#@     # then perform any necessary grow
#@     set final {}
#@     if { ($xsize > 0) || ($ysize > 0) } {
#@       # the grow is a directional grow on the rectangles of the polygon
#@       set rect_grow_factor_x [expr ($xsize>0) ?  $xsize : 0]
#@       set rect_grow_factor_y [expr ($ysize>0) ?  $ysize : 0]
#@ 
#@       foreach shape $shrunk_poly {
#@         foreach rect [convert_from_polygon -format polygon $shape] {
#@           # get x extents using a list sort
#@           set x_sort [lsort -index 0 -increasing -real $rect]
#@           set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_grow_factor_x]
#@           set xur [expr [lindex [lindex $x_sort end] 0] + $rect_grow_factor_x]
#@ 
#@           # get y extents using a list sort
#@           set y_sort [lsort -index 1 -increasing -real $rect]
#@           set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_grow_factor_y]
#@           set yur [expr [lindex [lindex $y_sort end] 1] + $rect_grow_factor_y]
#@ 
#@           lappend final [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         }
#@       }
#@     } else {
#@       set final $shrunk_poly
#@     }
#@   }
#@ 
#@   if { $no_MWUI_087_suppress } {
#@     set no_MWUI_087_suppress 0
#@     unsuppress_message {MWUI-087}
#@   }
#@ 
#@   # merge final polygons
#@   if { (! $no_sizing) && $single_resize } {
#@     # first see if compute_polygons works for lists of polygons
#@     unset -nocomplain merge_polygon
#@     redirect /dev/null {
#@       catch {set merge_polygon [compute_polygons -boolean or $final [lindex $final 0]]}
#@     }
#@     if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@       # compute_polygons took the list of polygons
#@       set final $merge_polygon
#@       unset -nocomplain merge_polygon
#@     } else {
#@       # compute_polygons didn't take the list of polygons
#@       for { set i 0 } { $i < [llength $final] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $final] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $final $i] [lindex $final $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set final [lreplace [lreplace $final $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # return result or assign to polygon_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon) $final
#@     return {}
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_adv_polygon_size     -info "grow/shrink polygon"     -define_args {
#@       {polygon "polygon" polygon string required}
#@       {"size" "size {+grow / -shrink} float or list {x y} of float" "" string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ 
#@ 
#@ 
#@ proc P_adv_polygon_check { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set poly_args {}
#@   set poly_cnt 1
#@ 
#@   if { [string equal $option "identical"] } {
#@     if { [info exists inputs(other_polygon)] } {
#@       incr poly_cnt
#@     }
#@   } elseif { [string equal $option "polygon"] } {
#@     if { [info exists inputs(other_polygon)] &&  [string equal -nocase "$inputs(other_polygon)" "-list"]} {
#@       set option "return_expression"
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   # store as list for each polygon { name_or_NULL is_simple_polygon
#@   #                                  is_polygon is_rect_array
#@   #                                  is_compressed_set complex_polygon_list }
#@   #    where name_or_NULL = name of defined polygon set if valid, else {}
#@   #          is_simple_polygon    = 1 if a simple polygon, else 0
#@   #          is_polygon           = 1 if a polygon, else 0
#@   #          is_rect_array        = 1 if paired coordinates for rect, else 0
#@   #          is_compressed_set    = 1 if a compressed polygon set, else 0
#@   #          complex_polygon_list = polygon value as a complex polygon list
#@   set polygon_info {}
#@   for { set i 1 } { $i <= $poly_cnt } { incr i } {
#@     if { $i == 1 } {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(polygon)
#@       set item $inputs(polygon)
#@     } else {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(other_polygon)
#@       set item $inputs(other_polygon)
#@     }
#@     # check if the polygon is defined in a polygon set
#@     if { [info exists $source_polygon] } {
#@       set polygon_set [expr $$source_polygon]
#@       lappend polygon_info [list $item 0 1 0 0 $polygon_set]
#@       continue
#@     }
#@ 
#@     # check to see if the cell is either a simple/complex polygon or rectArray
#@     #    or a compressed polygon set
#@ 
#@     # First ensure that coordinates if paired are at consistent level
#@     # - first ensure that a double coordinate value is in the expected levels
#@     # - max levels to first double = 3
#@     # -    complex_polygon = { simple_polygon_1 ... simple_polygon_n }
#@     # -    simple_polygon  = { list_of_coordinates }
#@     # -    coordinate      = { x y }
#@     if { ! [string is double -strict [lindex [lindex [lindex $item 0] 0] 0]] } {
#@       # may be that this is an empty list
#@       if { [llength $item] == 0 } {
#@         lappend polygon_info [list {} 1 1 1 1 {}]
#@       } else {
#@         lappend polygon_info [list {} 0 0 0 0 {}]
#@       }
#@       continue
#@     }
#@ 
#@     # while the length of list is one, strip the nesting level
#@     while { [llength $item] == 1 } {
#@       set item [lindex $item 0]
#@     }
#@ 
#@     # - find up one level from the first double coordinate x or y value
#@     # - ensure that the level is always consistent
#@     set paired 1
#@     if { [string is double -strict [lindex $item 0]] } {
#@       # only a single level - this can only be a rectArray or compressedSet
#@       set is_simple_polygon 0
#@       set is_rectArray 1
#@       set is_compressedSet 1
#@       set is_polygon 0
#@       # all items can only be double floats and must be paired set of coords
#@       # this means the length must be a multiple of 4
#@       if { ([llength $item] % 4) == 0 } {
#@         # run a quick check to see if all numbers are double
#@         if { [catch { lsort -real $item } catch_result] != 0 } {
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         set paired 0
#@       }
#@     } else {
#@       if { [string is double -strict [lindex [lindex $item 0] 0]] } {
#@         # this can only be a list of coordinate pairs
#@         # which can be either a compressedSet, rectArray, or simple polygon
#@         set is_simple_polygon 1
#@         set is_compressedSet 1
#@         set is_polygon 1
#@         # for rectArray, must have an even number of points
#@         set is_rectArray [expr ([llength $item] % 2) == 0]
#@ 
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         if { ([lsearch -glob $item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         } elseif { [llength $item] > 4 } {
#@           # for this one case see if same start+end and common x or y
#@           # in this case then an empty set (must be at least 5 pairs)
#@           foreach {x1 y1} [lindex $item 0] { break }
#@           foreach {x2 y2} [lindex $item end] { break }
#@           if { ($x1 == $x2) && ($y1 == $y2) } {
#@             if { [llength [lsort -real -unique -index 0 $item]] eq 1 } {
#@               # fixed x, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             } elseif { [llength [lsort -real -unique -index 1 $item]] eq 1 } {
#@               # fixed y, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             }
#@           }
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         # with the levels involved this can only be a complex polygon
#@         set is_simple_polygon 0
#@         set is_compressedSet 0
#@         set is_polygon 1
#@         set is_rectArray 0
#@         # check that all coordinates are paired sets of real/double
#@         # discard trivial shapes of <3 coordinates
#@         set polygon {}
#@         foreach shape $item {
#@           if { [llength $shape] < 3 } {
#@             # ignore trivial shapes
#@             continue
#@           }
#@           lappend polygon $shape
#@         }
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of joined item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         set joined_item [join $item]
#@         if { ([lsearch -glob $joined_item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $joined_item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $joined_item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         unset -nocomplain joined_item
#@       }
#@ 
#@     }
#@     if { ! $paired } {
#@       # bad pairing of coordinates found, this is a bad polygon
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@       continue
#@     }
#@ 
#@ 
#@     # step through the actual shapes and check to see if a valid polygon
#@     set rectArray {}
#@     if { $is_rectArray } {
#@       foreach {xl yl xu yu} [join [join [join $polygon]]] {
#@         if { ($xl<$xu) && ($yl<$yu) } {
#@           lappend rectArray [list [list $xl $yl] [list $xl $yu] [list $xu $yu] [list $xu $yl] [list $xl $yl]]
#@         } else {
#@           set is_rectArray 0
#@           break
#@         }
#@       }
#@     }
#@ 
#@     if { $is_compressedSet } {
#@       set compressedSet {}
#@       set partialSet {}
#@       # can only be a length of 1
#@       set joined_polygon [join [join [join $polygon]]]
#@       set shifted_polygon [join [list [lrange $joined_polygon 2 end] 0 0]]
#@       unset -nocomplain x0 y0
#@       foreach {x1 y1} $joined_polygon {x2 y2} $shifted_polygon {
#@         lappend partialSet [list $x1 $y1]
#@         if { [info exists x0] } {
#@           if { ($x0==$x1) && ($y0==$y1) } {
#@             # shape valid if both x & y have more than one value (there is size to the shape)
#@             if { ([llength [lsort -unique -real -index 0 $partialSet]] > 1) && ([llength [lsort -unique -real -index 1 $partialSet]] > 1) } {
#@               lappend compressedSet $partialSet
#@             }
#@             set partialSet {}
#@             unset -nocomplain x0 y0
#@             continue
#@           }
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         } else {
#@           if { ($x1==$x2) && ($y1==$y2) } {
#@             continue
#@           }
#@           if { ($x1==$x2) || ($y1==$y2) } {
#@             set x0 $x1
#@             set y0 $y1
#@           } else {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@       }
#@       if { [info exists x0] } {
#@         # didn't complete the final polygon shape
#@         set is_simple_polygon 0
#@         set is_polygon 0
#@         set is_compressedSet 0
#@       }
#@     } elseif { $is_polygon } {
#@       set new_polygon {}
#@       foreach shape $polygon {
#@         # check that first/last coordinate match
#@         foreach {x0 y0} [join [lindex $shape 0]] { break }
#@         foreach {xend yend} [join [lindex $shape end]] { break }
#@         if { ($x0!= $xend) || ($y0 != $yend) } {
#@           set is_simple_polygon 0
#@           set is_polygon 0
#@           break
#@         }
#@         set joined_shape [join [join $shape]]
#@         set joined_shape1 [lrange $joined_shape 0 end-2]
#@         set joined_shape2 [lrange $joined_shape 2 end]
#@         foreach {x1 y1} $joined_shape1 {x2 y2} $joined_shape2 {
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@         if { ! $is_polygon } {
#@           break
#@         }
#@         # shape is valid if both x & y have more than one value (there is size to the shape)
#@         if { ([llength [lsort -unique -real -index 0 $shape]] > 1) && ([llength [lsort -unique -real -index 1 $shape]] > 1) } {
#@           lappend new_polygon $shape
#@         }
#@       }
#@       set polygon $new_polygon
#@     }
#@ 
#@     if { $is_rectArray } {
#@       lappend polygon_info [list {} 0 0 1 0 $rectArray]
#@     } elseif { $is_polygon && (! $is_compressedSet) } {
#@       lappend polygon_info [list {} $is_simple_polygon 1 0 0 $polygon]
#@     } elseif { $is_compressedSet } {
#@       set is_simple_polygon [expr [llength $compressedSet] < 2]
#@       lappend polygon_info [list {} $is_simple_polygon $is_simple_polygon 0 [expr ! $is_simple_polygon] $compressedSet]
#@     } else {
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@     }
#@   }
#@ 
#@   set is_polygon [expr [lindex [lindex $polygon_info 0] 2] ||                       [lindex [lindex $polygon_info 0] 3] ||                       [lindex [lindex $polygon_info 0] 4] ||                       ([llength [lindex [lindex $polygon_info 0] 0]] > 0)]
#@   switch -exact -- $option {
#@     simple      {
#@       set is_simple           [expr [lindex [lindex $polygon_info 0] 1]  && ([llength [lindex                                                                        [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_simple
#@     }
#@     complex     {
#@       set is_complex           [expr (! [lindex [lindex $polygon_info 0] 1]) && ([llength [lindex                                                                           [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_complex
#@     }
#@     defined_set {
#@       return [expr [llength [lindex [lindex $polygon_info 0] 0]] > 0]
#@     }
#@     rectArray   {
#@       return [expr [lindex [lindex $polygon_info 0] 3] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     compressed  {
#@       return [expr [lindex [lindex $polygon_info 0] 4] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     polygon     {
#@       return $is_polygon
#@     }
#@     default     {
#@       if { ! $is_polygon } {
#@         error "'${func_name} $option': polygon \"$inputs(polygon)\" is not a valid polygon."
#@         return
#@       }
#@       set is_polygon [expr                           [lindex [lindex $polygon_info end] 2] || [lindex [lindex $polygon_info end] 3] ||                           [lindex [lindex $polygon_info end] 4] || ([llength [lindex [lindex $polygon_info end] 0]] > 0)]
#@       if { (! $is_polygon) && [string equal $option "identical"] && ([llength $polygon_info] > 1) } {
#@         error "'${func_name} $option': other_polygon \"$inputs(other_polygon)\" is not a valid polygon."
#@         return
#@       }
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (if so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_help]
#@ 
#@   # simplify polygon structure
#@   set check_empty [string equal $option "empty"]
#@   if { [llength [lindex [lindex $polygon_info 0] 0]] == 0 } {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@ 
#@     # merge polygon
#@     # (see if compute_polygons works for lists of polygons - avail in icc)
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $polygon [lindex $polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set polygon {}
#@       } else {
#@         set polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $polygon $i] [lindex $polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set polygon [lreplace [lreplace $polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@   }
#@ 
#@   if { $check_empty } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $polygon] < 1]
#@   }
#@ 
#@   if { [string equal $option "return_expression"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $polygon
#@   }
#@ 
#@ 
#@   # determine if the polygon is now only a single rectangle
#@   if { [string equal $option "rectangle"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr ([llength $polygon]==1) && ([llength [lindex $polygon 0]]==5)]
#@   }
#@ 
#@   # ONLY CHECK remaining is "identical"
#@ 
#@   # simplify other_polygon structure for performing "identical" check
#@   if { [llength [lindex [lindex $polygon_info end] 0]] == 0 } {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@ 
#@     # merge other_polygon
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $other_polygon [lindex $other_polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set other_polygon {}
#@       } else {
#@         set other_polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $other_polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $other_polygon $i] [lindex $other_polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set other_polygon [lreplace [lreplace $other_polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@   }
#@ 
#@   # simple check is if one empty, then they both must be empty
#@   if { ([llength $polygon] == 0) && ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 1
#@   } elseif { ([llength $polygon] == 0) || ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 0
#@   }
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   if { ! $simple_polygons } {
#@     # compute_polygons takes a list of polygons
#@     unset -nocomplain xor_polygon
#@     redirect /dev/null {
#@       catch {set xor_polygon [compute_polygons -boolean xor $polygon $other_polygon]}
#@     }
#@     if { $xor_polygon == "0" } {
#@       set xor_polygon {}
#@     }
#@ 
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $xor_polygon] == 0]
#@   }
#@ 
#@   # otherwise to be identical,
#@   # each piece of polygon must have a corresponding piece of other_polygon
#@   foreach shape $polygon {
#@     set poly_and {}
#@     set poly_xor $polygon
#@     for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@       set other_shape [lindex $other_polygon $i]
#@       set poly_and [compute_polygons -boolean and $shape $other_shape]
#@       if { [llength $poly_and] != 0 } {
#@         set poly_xor [compute_polygons -boolean xor $shape $other_shape]
#@         break
#@       }
#@     }
#@     if { [llength $poly_xor] != 0 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return 0
#@     }
#@     set other_polygon [lreplace $other_polygon $i $i]
#@   }
#@ 
#@   # polygon is identical if no remaining portions of other_polygon to match
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return [expr [llength $other_polygon] == 0]
#@ 
#@ }
#@ 
#@ define_proc_attributes P_adv_polygon_check     -info "check condition 'option' on polygon"     -define_args {
#@       {option "check option" option one_of_string { required value_help {values { simple complex defined_set rectArray compressed polygon empty rectangle identical }}}}
#@       {polygon "polygon" polygon string required}
#@       {other_polygon "second polygon -> only used for identical check" other_polygon string optional}}
#@ #}}}
#@ 
#@ 
#@ 
#@ proc P_adv_polygon_logic { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set operation $inputs(operation)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set copy_set   [string equal $operation "copy"]
#@   set or_set     [string equal $operation "or"]
#@   set and_set    [string equal $operation "and"]
#@   set not_set    [string equal $operation "not"]
#@   set xor_set    [string equal $operation "xor"]
#@   set select_set [string equal $operation "select"]
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon_a)])]
#@   if { $copy_set && $return_expression } {
#@     error "'$func_name copy': polygon \"$inputs(polygon_a)\" is not a defined_set."
#@   } else {
#@     set return_expression [expr $return_expression || [info exists inputs(-list)]]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_a) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_a)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_a)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_a)"
#@     }
#@     error "'${func_name} $operation': polygon_a \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_b) -list} other_polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_b)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_b)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_b)"
#@     }
#@     error "'${func_name} $operation': polygon_b \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # return if copy
#@   if { $copy_set } {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $other_polygon
#@     return {}
#@   }
#@ 
#@   # do simple cases where either polygon is empty
#@   unset -nocomplain final_polygon
#@   if { [llength $polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon {}
#@     } elseif { $xor_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   } elseif { [llength $other_polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon $polygon
#@     } elseif { $xor_set } {
#@       set final_polygon $polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   }
#@   if { [info exists final_polygon] } {
#@     if { $return_expression } {
#@       return $final_polygon
#@     } else {
#@       set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@       return {}
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_polygons_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_polygons_help]
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   # can do all operations except select which requires 2 steps
#@   unset -nocomplain final_polygon
#@   if { $select_set } { set op "and" } else { set op $operation }
#@   unset -nocomplain or_polygon
#@ 
#@   if { ! $simple_polygons } {
#@     redirect /dev/null {
#@       catch {set final_polygon [compute_polygons -boolean $op $polygon $other_polygon]}
#@     }
#@     if { (! [info exists final_polygon]) || [string equal $final_polygon "0"] } {
#@       # compute_polygons didn't take the list of polygons
#@       set final_polygon {}
#@     } elseif { $select_set } {
#@       if { [llength $final_polygon] < [llength $other_polygon] } {
#@         set other_polygon $final_polygon
#@       }
#@       unset -nocomplain final_polygon
#@     }
#@   }
#@ 
#@   # perform OR operation if needed ("or" & "xor")
#@   set or_polygon {}
#@   if { [info exists final_polygon] } {
#@     set or_polygon $final_polygon
#@   } elseif { $or_set || $xor_set } {
#@     set or_polygon [concat $polygon $other_polygon]
#@     # merge or_polygon
#@     for { set i 0 } { $i < [llength $or_polygon] } {incr i} {
#@       for { set j [expr $i + 1] } { $j < [llength $or_polygon] } {incr j} {
#@         set new [compute_polygons -boolean or [lindex $or_polygon $i] [lindex $or_polygon $j]]
#@         if { [llength $new] > 1 } {
#@           continue
#@         }
#@         set or_polygon [lreplace [lreplace $or_polygon $i $i [lindex $new 0]] $j $j]
#@         incr i -1
#@         break
#@       }
#@     }
#@   }
#@ 
#@   # perform AND operation if needed ("and" "not" "xor" "select")
#@   set and_polygon {}
#@   set select_polygon {}
#@   if { [info exists final_polygon] } {
#@     set and_polygon $final_polygon
#@   } elseif { $select_set && (! $simple_polygons) } {
#@     if { [llength $other_polygon] != 0 } {
#@       # evaluating select in subsets of from 20-50 tend to give best runtimes
#@       set incr_value 30
#@       for { set i 0 } { $i < [llength $polygon] } { incr i $incr_value } {
#@         set sub_range [lrange $polygon $i [expr $i + $incr_value]]
#@         set sub_range_and [compute_polygons -boolean and $sub_range $other_polygon]
#@         if { ($sub_range_and == "0") || ([llength $sub_range_and] == 0) } {
#@           # no intersection, skip this subset of polygons
#@           continue
#@         } elseif { [llength $sub_range] == 1 } {
#@           lappend select_polygon [lindex $sub_range 0]
#@           continue
#@         } elseif { [llength $sub_range_and] > [llength $other_polygon] } {
#@           # try to minimize the number of shapes being worked with
#@           set sub_range_and $other_polygon
#@         }
#@         foreach shape $sub_range {
#@           set shape_and [compute_polygons -boolean and $shape $sub_range_and]
#@           if { ($shape_and != "0") && ([llength $shape_and] != 0) } {
#@             lappend select_polygon $shape
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $and_set || $not_set || $xor_set || $select_set } {
#@     foreach shape $polygon {
#@       set poly_and {}
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         set other_shape [lindex $other_polygon $i]
#@         set poly_and [compute_polygons -boolean and $shape $other_shape]
#@         if { [llength $poly_and] != 0 } {
#@           if { $select_set } {
#@             lappend select_polygon $shape
#@             break
#@           } else {
#@             foreach and_item $poly_and {
#@               lappend and_polygon $and_item
#@             }
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $or_set } {
#@     set and_polygon $or_polygon
#@   }
#@ 
#@   # perform NOT operation if needed ("not" "xor")
#@   if { (! [info exists final_polygon]) && ($not_set || $xor_set) } {
#@     if { $not_set } {
#@       set final_polygon $polygon
#@       set not_polygon   $other_polygon
#@     } else {
#@       set final_polygon $or_polygon
#@       set not_polygon   $and_polygon
#@     }
#@     foreach other_shape $not_polygon {
#@       set new_final_polygon {}
#@       foreach shape $final_polygon {
#@         foreach not_poly [compute_polygons -boolean not $shape $other_shape] {
#@           lappend new_final_polygon $not_poly
#@         }
#@       }
#@       set final_polygon $new_final_polygon
#@     }
#@   } elseif { $or_set } {
#@     set final_polygon $or_polygon
#@   } elseif { $select_set } {
#@     set final_polygon $select_polygon
#@   } elseif { $and_set } {
#@     set final_polygon $and_polygon
#@   } elseif { ! [info exists final_polygon] } {
#@     set final_polygon {}
#@   }
#@ 
#@   # return polygon or set value in defined_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final_polygon
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@     return {}
#@   }
#@ 
#@ }
#@ 
#@ 
#@ define_proc_attributes P_adv_polygon_logic     -info "perform logic 'operation' between polygons"     -define_args {
#@       {operation "logic operation" operation one_of_string { required value_help {values { copy or and not xor select }}}}
#@       {polygon_a "polygon_a" polygon_a string required}
#@       {polygon_b "polygon_b" polygon_b string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ # Proc: P_create_diffcheck_grid
#@ # Description: Draws diffcheck grid over design that will show up as DRC violations
#@ # if the diffusion layer is misaligned in any areas. The diffcheck is removed over macros/DICs
#@ proc P_create_diffcheck_grid {layer start width step stop {hard_macro_refs ""}} {
#@ 
#@   set _bndry [get_attribute -quiet [get_die_area] boundary]
#@   set layer $layer
#@   remove_user_shape  [get_user_shapes -quiet -filter layer_name==$layer]
#@ 
#@   set rect_box [convert_from_polygon  -format rectangle $_bndry]
#@   foreach rect $rect_box {
#@     scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@     set y [expr $start + $b_lly]
#@     while { $y < [expr $b_ury - $stop]} {
#@       create_user_shape -layer $layer  -datatype 24 -bbox [list $b_llx $y $b_urx [expr $y + $width]]
#@       set y [expr $y + $step + $width]
#@     }
#@   }
#@ 
#@   # Remove user shapes over HIP/DIC
#@   set hard_macro_cells ""
#@   if {$hard_macro_refs == "" } {
#@     set hard_macro_cells  [all_macro_cells]
#@   } else {
#@     foreach cell $hard_macro_refs {
#@       set hard_macro_cells [add_to_collection $hard_macro_cells [get_cells -quiet -hierarchical -all -filter ref_name==$cell]]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $hard_macro_cells]>0} {
#@     cut_objects  -by $hard_macro_cells [get_user_shapes -quiet -filter layer_name==$layer]
#@   }
#@ 
#@ }
#@ define_proc_attributes P_create_diffcheck_grid     -info "Creates diffcheck grid over design"     -define_args {                        {layer "diffcheck grid layer name" layer string required}                        {start "Offset to start grid relative to boundary" start string required}                        {width "Path to overlay cell gds file" width string required}                        {step "Pitch between shapes" step string required}                        {stop "Offset to stop grid relative to boundary" stop string required}                        {hard_macro_refs "Macro reference names. If blank, then grid removed over all_macro_cells" hard_macro_refs list required}                      }
#@ 
#@ # Proc: P_create_polycheck_grid
#@ # Description: Draws polycheck grid over design that will show up as DRC violations
#@ # if the poly layer is misaligned in any areas. The polycheck is removed over macros/DICs
#@ 
#@ proc P_create_polycheck_grid { layer start width step stop {hard_macro_refs ""}} {
#@ 
#@   set _bndry [get_attribute -quiet [get_die_area] boundary]
#@   set layer $layer
#@   remove_user_shape  [get_user_shapes -quiet -filter layer_name==$layer]
#@ 
#@   set rect_box [convert_from_polygon  -format rectangle $_bndry]
#@   foreach rect $rect_box {
#@     scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@     set x [expr $start + $b_llx]
#@     while { $x < [expr $b_urx - $stop]} {
#@       create_user_shape -layer $layer -bbox [list $x $b_lly [expr $x + $width] $b_ury]
#@       set x [expr $x + $step + $width]
#@     }
#@   }
#@ 
#@   # Remove user shapes over HIP/DIC
#@   set hard_macro_cells ""
#@   if {$hard_macro_refs == "" } {
#@     set hard_macro_cells  [all_macro_cells]
#@   } else {
#@     foreach cell $hard_macro_refs {
#@       set hard_macro_cells [add_to_collection $hard_macro_cells [get_cells -quiet -hierarchical -all -filter ref_name==$cell]]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $hard_macro_cells]>0} {
#@     cut_objects -by $hard_macro_cells [get_user_shapes -quiet -filter layer_name==$layer]
#@   }
#@ 
#@ }
#@ define_proc_attributes P_create_polycheck_grid     -info "Creates polycheck grid over design"     -define_args {                        {layer "Polycheck layer name" layer string required}                        {start "Offset to start grid relative to boundary" start string required}                        {width "Path to overlay cell gds file" width string required}                        {step "Pitch between shapes" step string required}                        {stop "Offset to stop grid relative to boundary" stop string required}                        {hard_macro_refs "Macro reference names. If blank, then grid removed over all_macro_cells" hard_macro_refs list required}                      }
#@ 
#@ proc P_placement_blockage_move_or_unmove { {mode report_usage} } {
#@   ###  move placement blockage out of bounds Or back  ###
#@   if {$mode=="report_usage"} {
#@     puts "  usage1 ->  set blockage_bbox_pairs \[P_placement_blockage_move_or_unmove move\]; ## to move blockage out of bounds ##";
#@     puts "  usage2 ->  P_placement_blockage_move_or_unmove \$blockage_bbox_pairs;           ## to restore blockage ##";
#@     return;
#@   }
#@   ###  mode=move - moves blockage and returns blockage_bbox_pairs variable | mode=$blockage_bbox_pairs - restores blockage  ###
#@   set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
#@   if {"$mode"=="move"} {
#@     set boundary [get_attribute -quiet [get_core_area] boundary]
#@     set boundary_llx [lindex [lindex [lsort -index 0 -real -increasing $boundary] 0] 0]
#@     set boundary_lly [lindex [lindex [lsort -index 1 -real -increasing $boundary] 0] 1]
#@     set hard_pb_llx [expr $boundary_llx - .01]; set hard_pb_lly [expr $boundary_lly - .01]
#@     set hard_placement_box [list [list $hard_pb_llx  $hard_pb_lly]  [list $boundary_llx $boundary_lly]]
#@     set blockage_bbox_pairs {}
#@     foreach_in_collection blkg_obj [remove_from_collection [get_placement_blockages -quiet] [get_placement_blockages -quiet halo_adjacent_placement_blk_*]] {
#@       lappend blockage_bbox_pairs  [list $blkg_obj [get_attribute -quiet $blkg_obj bbox]]
#@       set_attribute -quiet $blkg_obj bbox $hard_placement_box
#@     }
#@     return $blockage_bbox_pairs;
#@   } else {
#@     foreach blkg_pair $mode {
#@       foreach {blkg_obj blkg_bbox} $blkg_pair { break }
#@       set_attribute -quiet $blkg_obj bbox $blkg_bbox
#@     }
#@   }
#@   set_object_snap_type -enabled $oldSnapState; set flag 1;
#@ }
#@ 
#@ ##########################################################################
#@ # Procedure   : P_insert_pre_place_cells_blockage
#@ #
#@ # Description : To insert the placement blockage at the intended pre-place cells
#@ #               locations if option -as_blockage useage.
#@ #               Otherwise, To insert the placement blockage everywhere except
#@ #               pre-place cells locations
#@ #
#@ # Inputs      :
#@ #
#@ # Returns     :
#@ #
#@ # Note        :
#@ #
#@ ##########################################################################
#@ proc P_insert_pre_place_cells_blockage {args} {
#@ 
#@   global INTEL_STDCELL_BONUS_GATEARRAY_TILE INTEL_STDCELL_TILE INTEL_TAP_CELL
#@   parse_proc_arguments -args $args flag
#@   set x_start $flag(-x_start)
#@   set y_start $flag(-y_start)
#@   set x_increment $flag(-x_increment)
#@   set y_increment $flag(-y_increment)
#@   set width_prplace_cell $flag(-w_preplace_cell)
#@   set height_prplace_cell $flag(-h_preplace_cell)
#@ 
#@   if { [info exists flag(-x_trim)] } {
#@     set x_trim $flag(-x_trim)
#@   } else {
#@     set x_trim 0
#@   }
#@   if { [info exists flag(-y_trim)] } {
#@     set y_trim $flag(-y_trim)
#@   } else {
#@     set y_trim 0
#@   }
#@   if { [info exists flag(-as_blockage)] } {
#@     set as_blockage 1
#@   } else {
#@     set as_blockage 0
#@   }
#@   if { [info exists flag(-ignore_hard_blockage)] } {
#@     set ignore_hard_blockage 1
#@   } else {
#@     set ignore_hard_blockage 0
#@   }
#@   if { [info exists flag(-no_flip)] } {
#@     set no_flip 1
#@   } else {
#@     set no_flip 0
#@   }
#@ 
#@   if { [info exists flag(-stagger)] } {
#@     set stagger 1
#@   } else {
#@     set stagger 0
#@   }
#@ 
#@   ### Derive tile widths
#@   set sample_site [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_TILE"]] 0]
#@   set stdcell_tile_height [expr [get_attribute [get_site_row $sample_site] bbox_ury] - [get_attribute [get_site_row $sample_site] bbox_lly]]
#@   set stdcell_tile_width [get_attribute [get_site_rows $sample_site] site_space]
#@   if { [info exists INTEL_STDCELL_BONUS_GATEARRAY_TILE] } {
#@     set stdcell_bonus_tile_width [get_attribute [get_site_rows [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_BONUS_GATEARRAY_TILE"]] 0]] site_space]
#@   }
#@ 
#@   if { [info exists flag(-tile)] } {
#@     if { [regexp "bonuscore" $flag(-tile) ] } {
#@       set tile_width $stdcell_bonus_tile_width
#@     } else {
#@       set tile_width $stdcell_tile_width
#@     }
#@   } else {
#@     set tile_width $stdcell_tile_width
#@   }
#@ 
#@   if { [info exists flag(-ignore_tap_cell)] } {
#@     set ignore_tap_cell 1
#@   } else {
#@     set ignore_tap_cell 0
#@   }
#@ 
#@   ###Find the first ROW rotation
#@   scan [get_attribute [get_core_areas] bbox] "{%f %f} {%f %f}" core_llx core_lly core_urx core_ury
#@   set my_site_rows [get_site_rows -quiet -filter "bbox_lly == $core_lly && bbox_ury == [expr $core_lly + $stdcell_tile_height]       && site_type ==  $INTEL_STDCELL_TILE"]
#@   if {$my_site_rows ne ""} {
#@     set first_cell_orientation [lindex [get_attribute [get_site_rows [lindex $my_site_rows 0]] orientation] 0]
#@   } else {
#@     set first_cell_orientation "N"
#@   }
#@ 
#@   set step_y [expr (floor ( [expr $y_increment / ( 2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@   set half_step_y  [expr $step_y / 2.0]
#@   if { $no_flip == 1 } {
#@     # Need to find the VSS row
#@     if { $first_cell_orientation == "N"} {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@     }  else {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
#@     }
#@   } else {
#@     if { $first_cell_orientation == "N"} {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
#@     }  else {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@     }
#@   }
#@ 
#@   set step_x [expr (floor ( [expr $x_increment / $tile_width] )) *  $tile_width]
#@   set half_step_x  [expr $step_x / 2.0]
#@   set xstart [expr (floor ( [expr ($x_start) / $tile_width] )) *  $tile_width + $core_llx]
#@ 
#@   remove_placement_blockage _tmp_pre_place_placement_blk_*
#@   set_object_snap_type -enabled 0
#@ 
#@   unset -nocomplain boundary
#@   set boundary [get_attribute -quiet [get_die_area] boundary]
#@   # to cover paranoid case of extra braces, remove a set if only 1 point
#@   if { [llength $boundary] == 1 } { set boundary [lindex $boundary 0] }
#@ 
#@   unset -nocomplain all_locations_newpolygon
#@   unset -nocomplain all_blk_newpolygon
#@   set all_locations_newpolygon $boundary
#@ 
#@   ### Find the original placement blockage
#@   set original_placement_blks [get_placement_blockages -type hard ]
#@ 
#@   ### Find the Voltage area rings
#@   unset -nocomplain _va_boundary_polys
#@   unset -nocomplain _tmp_use_polys _tmp_use_polys2
#@   set _va_boundary_polys ""
#@   foreach_in_collection _va [get_voltage_areas] {
#@     set _tmp_use_polys [get_attribute [get_voltage_areas $_va] points]
#@     set _va_boundary_polys [P_adv_polygon_logic or $_va_boundary_polys                                 [P_adv_polygon_logic not $_tmp_use_polys [P_adv_polygon_size $_tmp_use_polys "-$stdcell_tile_height -$stdcell_tile_height"]]]
#@   }
#@   set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_va_boundary_polys]
#@ 
#@   ### Find all is_fixed cells
#@   set _tmp_use_polys {}
#@   if { $ignore_tap_cell ==1 } {
#@     foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true && ref_name!=$INTEL_TAP_CELL"]                                  [all_macro_cells]] {
#@                                    lappend _tmp_use_polys [get_attribute $c boundary]
#@                                  }
#@   } else {
#@     foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true"]                                  [all_macro_cells]] {
#@                                    lappend _tmp_use_polys [get_attribute $c boundary]
#@                                  }
#@   }
#@   ### To prevent pre_place cells too close to EBB (might cause density violation)
#@   set _tmp_use_polys2 {}
#@   foreach_in_collection c [all_macro_cells] {
#@     foreach poly_shape [P_adv_polygon_size [get_attribute $c boundary] "[expr 3 * $stdcell_tile_width] 0.0"] {
#@       lappend _tmp_use_polys2 $poly_shape
#@     }
#@   }
#@   if { ![P_adv_polygon_check empty $_tmp_use_polys2]} {
#@     set _tmp_use_polys [P_adv_polygon_logic or $_tmp_use_polys $_tmp_use_polys2]
#@   }
#@   set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]
#@ 
#@   ### Find all existing placement blockages
#@   set _tmp_use_polys {}
#@   if { $ignore_hard_blockage != 1 } {
#@     foreach_in_collection blk $original_placement_blks {
#@       if { [llength [convert_to_polygon [get_placement_blockage $blk]]] >= 5 } {
#@         lappend _tmp_use_polys [convert_to_polygon [get_placement_blockage $blk]]
#@       } elseif { [llength [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]] >= 5 } {
#@         lappend _tmp_use_polys [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]
#@       }
#@     }
#@     set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]
#@   }
#@ 
#@   set switch 0
#@   set i 0
#@   set _tmp_use_polys {}
#@   unset -nocomplain _tmp_area_array
#@   for {set y $ystart } {$y < $core_ury } {set y [expr $y+$step_y]} {
#@     if { $stagger == 1 } {
#@       if { $switch == 1 } {
#@         set newxstart [expr $xstart + $half_step_x]
#@         set switch 0
#@       } else {
#@         set newxstart $xstart
#@         set switch 1
#@       }
#@     } else {
#@       set newxstart $xstart
#@     }
#@ 
#@     set core_urx_2 [expr $core_urx - $x_trim]
#@     for {set x $newxstart } {$x < $core_urx_2 } {set x [expr $x+$step_x]} {
#@       set x2 [expr $x + $half_step_x]
#@       if { $half_step_y < $height_prplace_cell } {
#@         set y2 [expr $y + $height_prplace_cell]
#@       } else {
#@         set y2 [expr $y + $half_step_y]
#@       }
#@       if {$y2 > [expr $core_ury - $y_trim] } { set y2  $core_ury }
#@       lappend _tmp_use_polys "{$x $y} {$x $y2} {$x2 $y2} {$x2 $y} {$x $y}"
#@       set _tmp_area_array($i) "{{$x $y} {$x2 $y2}}"
#@       incr i
#@     }
#@   }
#@   set all_blk_newpolygon [P_adv_polygon_logic and $all_locations_newpolygon $_tmp_use_polys]
#@ 
#@   unset -nocomplain _tmp_use_polys _tmp_use_polys2 my_pgon all_blk_newpolygon_final
#@   set all_blk_newpolygon_final {}
#@   foreach _tmp_use_polys $all_blk_newpolygon  {
#@     unset -nocomplain newbox
#@     scan [P_adv_polygon_get bbox $_tmp_use_polys] "{%f %f} {%f %f}" _llx _lly _urx _ury
#@     for {set y $_lly } {$y < $_ury } {set y [expr $y+$stdcell_tile_height]} {
#@       if { $no_flip == 1 } {
#@         if { $first_cell_orientation == "N"} {
#@           set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
#@         }  else {
#@           set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
#@         }
#@       } else {
#@         if { $first_cell_orientation == "N"} {
#@           set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
#@         }  else {
#@           set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
#@         }
#@       }
#@       for {set x $_llx } {$x < $_urx } {set x [expr $x+$tile_width]} {
#@         set snap_x [expr ( ceil ( $x / $tile_width)) * $tile_width + $core_llx]
#@         set x2 [expr $snap_x + $width_prplace_cell]
#@         set y2 [expr $snap_y + $height_prplace_cell]
#@         set _tmp_use_polys2 "{$snap_x $snap_y} {$snap_x $y2} {$x2 $y2} {$x2 $snap_y} {$snap_x $snap_y}"
#@         set my_pgon [P_adv_polygon_logic and $_tmp_use_polys $_tmp_use_polys2]
#@         set area_diff [expr [P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)]
#@         if { [expr (abs ([P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)))] < 0.001 } {
#@           set all_blk_newpolygon_final [P_adv_polygon_logic or $all_blk_newpolygon_final $my_pgon]
#@           set x $_urx
#@           set y $_ury
#@         }
#@       }
#@     }
#@   }
#@ 
#@   remove_placement_blockage _tmp_pre_place_placement_blk_*
#@   set count 0
#@   if { $as_blockage != 1 } {
#@     set all_blk_newpolygon_final [P_adv_polygon_logic not $boundary $all_blk_newpolygon_final]
#@     foreach my_pgon $all_blk_newpolygon_final {
#@       foreach box [convert_from_polygon -format rectangle $my_pgon] {
#@         create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
#@         incr count
#@       }
#@     }
#@   } else {
#@     foreach my_pgon $all_blk_newpolygon_final {
#@       foreach box [convert_from_polygon -format rectangle $my_pgon] {
#@         create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
#@         incr count
#@       }
#@     }
#@   }
#@ 
#@   set rm_placement_blk_list ""
#@   foreach i [array names _tmp_area_array] {
#@     if {([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet]] > 1) ||              ([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet]]  > 1) } {
#@       set _tmp_placement_blk_list [lsort -unique [get_object_name [add_to_collection                                                                        [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet ]                                                                        [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet ]]]]
#@       set _tmp_placement_blk_list_bb [lsort -command P_compare [get_attribute  [get_placement_blockages $_tmp_placement_blk_list -quiet ] bbox]]
#@       foreach box [lrange $_tmp_placement_blk_list_bb 1 [expr [llength $_tmp_placement_blk_list] - 1 ]] {
#@         lappend rm_placement_blk_list [get_object_name [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $box]]
#@       }
#@     }
#@   }
#@   foreach blk $rm_placement_blk_list {
#@     remove_placement_blockage $blk
#@   }
#@ 
#@   set_object_snap_type -enabled 1
#@ }
#@ 
#@ define_proc_attributes P_insert_pre_place_cells_blockage     -info "insert the placement blockages at pre_place cells location or reverse locations"     -define_args {
#@       {-x_start "Left point of region which cell be pre-placed" x_start float required}
#@       {-y_start "Bottom point of region which cell be pre-placed" y_start float required}
#@       {-x_increment "X direction increment distance" x_increment float required}
#@       {-y_increment "Y direction increment distance" y_increment float required}
#@       {-x_trim "X direction distance away from core boundary" x_trim float optional}
#@       {-y_trim "Y direction  distance away from core boundary" y_trim float optional}
#@       {-w_preplace_cell "Width of the pre-placed cell" w_preplace_cell float required}
#@       {-h_preplace_cell "Height of the pre-placed cell" h_preplace_cell float required}
#@       {-as_blockage "Create placement blockage at Pre-place cells locations or reverse locations" "" boolean optional}
#@       {-ignore_hard_blockage "Ignore the existing hard placement blockage" "" boolean optional}
#@       {-no_flip "The rotation of pre-place cells as N" "" boolean optional}
#@       {-stagger "Preplace cells in the stagger pattern" "" boolean optional}
#@       {-tile "The tile name for the pre_place_cells" tile string optional}
#@       {-ignore_tap_cell "Ignore the existing tap cells" "" boolean optional}
#@     }
#@ 
#@ ###############################################################################
#@ # Procedure   : P_compare
#@ # Description :
#@ 
#@ proc P_compare {a b} {
#@   set a0 [lindex [lindex $a 0] 0]
#@   set b0 [lindex [lindex $b 0] 0]
#@   if {$a0 < $b0} {
#@     return -1
#@   } elseif {$a0 > $b0} {
#@     return 1
#@   }
#@   set a1 [lindex [lindex $a 0] 1]
#@   set b1 [lindex [lindex $b 0] 1]
#@   if {$a1 < $b1 } {
#@     return -1
#@   } elseif {$a1  > $b1} {
#@     return 1
#@   }
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_adv_polygon_get #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_adv_polygon_get
#@ # __description:  get 'option' from polygon
#@ #                 polygon can be polygon_set, simple polygon, complex polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result --- (dependent on option: float or (list of) rectangle
#@ #                       area       = return area of the polygon
#@ #                       bound      = return bounding rectangle of the polygon
#@ #                       rectangles = return list of rectangles of the polygon
#@ # __required_args:  option (one of): area bbox bound rectangles
#@ #                   polygon:         polygon_set, simple or complex polygon
#@ # __optional_args:  -size
#@ #                   if size, then post size the rectangles
#@ #                   (i.e. using 'size' can create overlaps or gaps)
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc P_adv_polygon_get { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # check size argument to see if valid
#@   if { [info exists inputs(-size)] } {
#@     set size $inputs(-size)
#@     # allow for separate x,y size
#@     # if only a single value, then x,y default to that value
#@     set xsize [lindex $size 0]
#@     set ysize [lindex $size end]
#@     if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@       error "$func_name: size value \"$size\" is not a float or pair of floats."
#@       unset size xsize ysize
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     error "'${func_name} $option': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # perform area calculation if "area" option, return result
#@   if { [string equal $option "area"] } {
#@     set area 0.0
#@ 
#@     # see if polygon lists are accepted or only simple polygons
#@     redirect -variable get_polygon_area_help {get_polygon_area -help}
#@     set simple_polygons [regexp -- {points list of } $get_polygon_area_help]
#@ 
#@     if { $simple_polygons } {
#@       foreach poly_segment $polygon {
#@         set area [expr $area + [get_polygon_area $poly_segment]]
#@       }
#@     } elseif { [llength $polygon] > 0 } {
#@       set area [expr $area + [get_polygon_area $polygon]]
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $area
#@   }
#@ 
#@   # perform bound check if "bound" option, return resulting rectangle
#@   if { [string equal $option "bbox"] || [string equal $option "bound"] } {
#@     # see if polygon is empty
#@     if { [llength $polygon] < 1 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return {}
#@     }
#@ 
#@     set joined_polygon [join $polygon]
#@ 
#@     # get x extents using a list sort
#@     set x_sort [lsort -index 0 -increasing -real $joined_polygon]
#@     set xll [lindex [lindex $x_sort 0] 0]
#@     set xur [lindex [lindex $x_sort end] 0]
#@ 
#@     # get y extents using a list sort
#@     set y_sort [lsort -index 1 -increasing -real $joined_polygon]
#@     set yll [lindex [lindex $y_sort 0] 1]
#@     set yur [lindex [lindex $y_sort end] 1]
#@ 
#@     # optionally size the box
#@     if { [info exists xsize] && [info exists ysize] } {
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@         return {}
#@       }
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     if { [string equal $option "bbox"] } {
#@       return [list [list $xll $yll] [list $xur $yur]]
#@     } else {
#@       return [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@   }
#@ 
#@   ### only option left is "rectangles"
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable convert_from_polygon_help {convert_from_polygon -help}
#@   set simple_polygons [regexp -- {points list of } $convert_from_polygon_help]
#@ 
#@   # create list of rectangles
#@   if { $simple_polygons } {
#@     set rectangles {}
#@     foreach poly_segment $polygon {
#@       foreach rect [convert_from_polygon -format polygon $poly_segment] {
#@         lappend rectangles $rect
#@       }
#@     }
#@   } else {
#@     if { [llength $polygon] == 0 } {
#@       set rectangles {}
#@     } else {
#@       set rectangles [convert_from_polygon -format polygon $polygon]
#@     }
#@     if { $rectangles == "0" } {
#@       set rectangles {}
#@     }
#@   }
#@ 
#@   # optionally size the box
#@   if { [info exists xsize] && [info exists ysize] } {
#@     set sized_rects {}
#@     foreach rect $rectangles {
#@       set x_sort [lsort -index 0 -increasing -real $rect]
#@       set xll [lindex [lindex $x_sort 0] 0]
#@       set xur [lindex [lindex $x_sort end] 0]
#@       set y_sort [lsort -index 1 -increasing -real $rect]
#@       set yll [lindex [lindex $y_sort 0] 1]
#@       set yur [lindex [lindex $y_sort end] 1]
#@ 
#@       # apply sizing
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         continue
#@       }
#@       lappend  sized_rects [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@     set rectangles $sized_rects
#@   }
#@ 
#@   # return list of rectangles
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return $rectangles
#@ 
#@ }
#@ define_proc_attributes P_adv_polygon_get     -info "get 'option' information from polygon"     -define_args {
#@       {option "get option" option one_of_string { required value_help {values { area bbox bound rectangles }}}}
#@       {polygon "polygon" polygon string required}
#@       {"-size" "size (+grow / -shrink)" "" string optional}}
#@ #}}}
#@ 
#@ 
#@ ##########################
#@ # Place-UPF Procedures
#@ ##########################
#@ 
#@ proc P_parse_pwrgrid_params {args} {
#@   parse_proc_arguments -args $args inputs
#@ 
#@   set attribute $inputs(-attribute)
#@   set layer $inputs(-layer)
#@   set param_list $inputs(-params)
#@ 
#@   set layer_index [lsearch [regexp -inline -all -- {\S+} $param_list] $layer]
#@   set width_val [lindex $param_list [expr $layer_index + 1]]
#@   set pitch_val [lindex $param_list [expr $layer_index + 2]]
#@   set offset_val [lindex $param_list [expr $layer_index + 3]]
#@ 
#@   if {$attribute == "offset"} {
#@     return $offset_val
#@   } elseif {$attribute == "pitch"} {
#@     return $pitch_val
#@   } elseif {$attribute == "width"} {
#@     return $width_val
#@   }
#@ }
#@ 
#@ define_proc_attributes P_parse_pwrgrid_params     -info "Parses powergrid parameters to determine offset and pitch values of various layers"     -define_args {
#@       {"-layer"  "Layer for which offset/pitch value is required" "" string required}
#@       {"-params" "INTEL_ parameter variable that contains layer, pitch and offset values" "" list required}
#@       {"-attribute" "Specify the attribute to be fetched" "" one_of_string {required value_help {values {offset pitch width}}}}
#@     }
#@ 
#@ proc P_ret_aon_net {args} {
#@   parse_proc_arguments -args $args inputs
#@ 
#@   set pwr_domain $inputs(-pwr_domain)
#@   redirect -variable rpt_pd {report_power_domain $pwr_domain}
#@ 
#@   set switch_line [regexp -inline -lineanchor -linestop {^Switch:.*} $rpt_pd]
#@   set switch_aon_vcc [lindex [regexp -inline -all {\S+} $switch_line] 2]
#@ 
#@   set primary_line [regexp -inline -lineanchor -linestop {^Primary:.*} $rpt_pd]
#@   set primary_aon_vcc [lindex [regexp -inline -all {\S+} $primary_line] 1]
#@ 
#@ 
#@   if {$switch_aon_vcc != ""} {
#@     return $switch_aon_vcc
#@   } elseif {$primary_aon_vcc != ""} {
#@     return $primary_aon_vcc
#@   } else {
#@     P_msg_error "P_ret_aon_net: Parsing report_power_domain failed. Aborting..."
#@     return
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_ret_aon_net     -info "Returns the always on power net for the provided power domain"     -define_args {
#@       {"-pwr_domain" "Domain for which the always on power net should be returned" "" string required}
#@     }
#@ 
#@ proc P_check_sec_pg_overlap {args} {
#@   parse_proc_arguments -args $args inputs
#@   set aon_net $inputs(-aon_net)
#@   set origin_x $inputs(-origin_x)
#@   set origin_y $inputs(-origin_y)
#@   set length $inputs(-length)
#@   set layer $inputs(-layer)
#@   set width $inputs(-width)
#@ 
#@   set vcc_base [get_attribute [get_nets $aon_net -all] base_name]
#@   set direction [get_attribute [get_layer $layer] preferred_direction]
#@ 
#@   if {$direction == "horizontal"} {
#@     set shape_bbox "{$origin_x $origin_y} {[expr $origin_x + $length] [expr $origin_y + $width]}"
#@   } else {
#@     set shape_bbox "{$origin_x $origin_y} {[expr $origin_x + $width] [expr $origin_y + $length]}"
#@   }
#@   set overlap [get_net_shapes -intersect $shape_bbox -filter "layer == $layer && owner_net != $vcc_base" -quiet]
#@   if {[sizeof_collection $overlap] == 0} {
#@     set overlap [get_vias -intersect $shape_bbox -filter "layer =~ *$layer* && owner_net != $vcc_base" -quiet]
#@   }
#@   if {[sizeof_collection $overlap] == 0} {
#@     set overlap [get_route_guides -intersect $shape_bbox -filter "no_signal_layers == $layer || no_preroute_layers == $layer" -quiet]
#@   }
#@ 
#@   if {[sizeof_collection $overlap] > 0} {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ define_proc_attributes  P_check_sec_pg_overlap     -info "Checks to see if sec pg staples overlap with one another"     -define_args {
#@       {"-layer"  "Staple layer" "" string required}
#@       {"-aon_net"  "AON net name" "" string required}
#@       {"-origin_x"  "Staple shape llx" "" string required}
#@       {"-origin_y"  "Staple shape lly" "" string required}
#@       {"-length"  "Staple length" "" string required}
#@       {"-width"  "Staple width" "" string required}
#@     }
#@ 
#@ ##############################
#@ # CTS-UPF Procedures
#@ ##############################
#@ 
#@ ##########################################################################################################
#@ # Procedure   : P_query_voltage_pgnet
#@ # Description : This proc is to find out the primary pg net for each voltage area for stdcell PG hookup
#@ 
#@ proc P_query_voltage_pgnet {} {
#@   global INTEL_VA_PWR INTEL_AON_PWR
#@   global INTEL_VA_GND
#@ 
#@   # determine if power domains are used in the design
#@   redirect /dev/null {set domains [get_power_domains -hierarchical ] }
#@   # get list of voltage_areas
#@   set va_list {}
#@   foreach_in_collection va [get_voltage_areas] {
#@     set va_name [get_attribute -quiet $va name]
#@     lappend va_list $va_name
#@   }
#@   unset -nocomplain  INTEL_VA_PWR INTEL_VA_GND INTEL_AON_PWR
#@ 
#@   # determine power & ground nets based on whether domains are present
#@   if { ([info exists domains]) && ([sizeof_collection $domains] > 0) } {
#@     # power domains exist
#@     # determine power & ground supplies for each voltage_area
#@ 
#@     # check power domains for corresponding voltage_area (then pwr/gnd nets)
#@     foreach_in_collection domain $domains {
#@       set domain_name [collection_to_list $domain -no_braces -name_only]
#@       redirect -variable rpt_pd  {report_power_domain $domain}
#@       set va_line [regexp -inline -lineanchor -linestop {^Voltage Area Information:\s+(\S+)} $rpt_pd]
#@ 
#@       if { ! [llength $va_line] } {
#@         continue
#@       } elseif { [string equal "N/A" [lindex $va_line 1]] } {
#@         continue
#@       } else {
#@         set voltage_area [lindex $va_line 1]
#@       }
#@ 
#@       # ensure the voltage_area is defined
#@       if { [lsearch -exact $va_list $voltage_area] < 0 } { continue }
#@ 
#@       # get supply info
#@       set primary_line [regexp -inline -lineanchor -linestop {^Primary:\s+(\S+)(\s+\([^\)]*\))?\s*(\S+)} $rpt_pd]
#@       if { [llength $primary_line] >= 4 } {
#@         set INTEL_VA_PWR($voltage_area) [lindex $primary_line 1]
#@         set INTEL_VA_GND($voltage_area) [lindex $primary_line 3]
#@       }
#@       # get AON supply info (if switched)
#@       set switch_line [join [regexp -inline -lineanchor -linestop {^Switch:.*} $rpt_pd]]
#@       if { [llength $switch_line] >= 4 } {
#@         set INTEL_AON_PWR($voltage_area) [lindex $switch_line 2]
#@       } else {
#@         set INTEL_AON_PWR($voltage_area) $INTEL_VA_PWR($voltage_area)
#@       }
#@     }
#@   }
#@ }
#@ 
#@ #######################
#@ # Route Procedures
#@ #######################
#@ 
#@ proc P_bonus_array_blockage {oddeven mode} {
#@   ###  add bonus array placement blockage - decap or spacer cell  ###
#@   ## oddeven - even_blockage | odd_blockage | remove_blockage ## mode - decap | spacer | spacer_vcnv0
#@   set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
#@   set die_area [get_attribute -quiet [get_die_area] bbox];
#@   regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} $die_area match dllx dlly durx dury; set blkgname "spcrblkg_";
#@   if {[get_placement_blockages -quiet -filter "name=~${blkgname}_*"] != ""} {
#@     remove_placement_blockage -name ${blkgname}_*;  ## always remove previous blockage or get name collision ##
#@   }
#@   if {$oddeven=="odd_blockage" || $oddeven=="even_blockage"} {
#@     set offx 0.28
#@     if {$mode=="decap"} {
#@       set step 4.48
#@       set gap 0
#@       if {$oddeven=="odd_blockage"} {
#@         set startx [expr 0 + $offx + $step + $gap]
#@       } else {
#@         set startx [expr 0 + $offx]
#@       }
#@       while {$startx<$durx} {
#@         create_placement_blockage -bbox "$startx $dlly [expr $startx+$step+$gap] $dury" -name ${blkgname}_${cnt}
#@         set startx [expr $startx+2*$step+2*$gap];
#@         incr cnt
#@       }
#@     }
#@ 
#@     regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} [get_attribute [index_collection  [get_site_rows -filter "site_type==$::INTEL_STDCELL_TILE"] 0] bbox] match llx lly urx ury
#@     set row_height [expr $ury-$lly]
#@     if {$oddeven=="even_blockage"} {
#@       set starty 0
#@     } else {
#@       set starty [expr 2*$row_height]
#@     }
#@     while {$starty<$dury} {
#@       create_placement_blockage -bbox "$dllx $starty $durx [expr $starty+2*$row_height]" -name ${blkgname}_${cnt}
#@       set starty [expr $starty+4*$row_height];
#@       incr cnt
#@     }
#@ 
#@   }
#@   set_object_snap_type -enabled $oldSnapState; set flag 1;
#@ }
#@ 
#@ #######################
#@ # Focal opt Procedures
#@ #######################
#@ 
#@ proc P_fix_min_cap args {
#@   global synopsys_program_name
#@   set DEBUG 0
#@   # Get arguments passed to this proc
#@   parse_proc_arguments -args $args results
#@ 
#@   # Default values
#@   set report_timing_cmd "report_timing -slack_lesser_than 0"
#@   set _iterations 10
#@   set _threshold -100
#@   set _reports [list mincap]
#@   upvar report_timing_cmd _report_timing_cmd
#@ 
#@   # Create variables from arguments with this format: $_<argument name>
#@   foreach _argname [array names results] {
#@     regsub -- {-} $_argname {_} _varname
#@     set $_varname $results($_argname)
#@   }
#@ 
#@   # Initialize argument variables
#@   set iteration_cnt 0
#@   if {[info exists _report_timing] && $_report_timing == 1} {
#@     lappend _reports [list timing]
#@   }
#@   if {[info exists _fix_dont_touch] && $_fix_dont_touch == 1} {
#@     set _fix_dont_touch "true"
#@   } else {
#@     set _fix_dont_touch "false"
#@   }
#@   if {[info exists _fix_cts_fixed] && $_fix_cts_fixed == 1} {
#@     set _fix_cts_fixed "true"
#@   } else {
#@     set _fix_cts_fixed "false"
#@   }
#@   if {[info exists _fix_is_fixed] && $_fix_is_fixed == 1} {
#@     set _fix_is_fixed "true"
#@   } else {
#@     set _fix_is_fixed "false"
#@   }
#@ 
#@   # Issue warning if user is in pt_shell
#@   if {$synopsys_program_name == "pt_shell"} {
#@     P_msg_warn "User is in pt_shell: Clock cells, fixed cells, and cells not explicitly marked as dont_touch will be modified"
#@   }
#@ 
#@   # Begin iterations for min cap fixing
#@   P_msg_info "Beignning min cap fixing"
#@   while {$iteration_cnt < $_iterations} {
#@     incr iteration_cnt
#@     P_msg_info "Begin iteration $iteration_cnt"
#@     P_msg_info "Printing reports..."
#@     foreach report $_reports {
#@       if {$report == "mincap"} {
#@         report_constraint -all_violators -min_capacitance
#@       }
#@       if {$report == "timing"} {
#@         eval $_report_timing_cmd
#@       }
#@     }
#@ 
#@     # Writing out violations
#@     P_msg_info "Getting violations..."
#@     redirect -file ./temp_mincap_rpt.txt {report_constraint -all_violators -min_capacitance -nosplit}
#@     set noviol 0
#@     # Grep violations from report
#@     set rc [catch {eval exec "grep VIOLATED ./temp_mincap_rpt.txt > ./temp_mincap.txt"} output]
#@     if {$rc == 0} {
#@       P_msg_info "Successfully grepped violations"
#@       sh rm ./temp_mincap_rpt.txt
#@     } else {
#@       if {[lindex $::errorCode 0] eq "CHILDSTATUS"} {
#@         if {[lindex $::errorCode 2] == 1} {
#@           P_msg_info "No violations found"
#@           # show output with "child process exited abnormally message
#@           P_msg_info "Exit status: $output"
#@           # Stop fixing violations
#@           set noviol 1
#@           sh rm ./temp_mincap_rpt.txt
#@           sh rm ./temp_mincap.txt
#@         } else {
#@           P_msg_error "grep error: $output"
#@         }
#@       } else {
#@         P_msg_error "error calling grep: $output"
#@       }
#@     }
#@ 
#@     if {$noviol == 1} {
#@       set vcnt 0
#@       set nofixcnt 0
#@       # No violations found in the file - can skip
#@       break
#@     }
#@ 
#@     # Parse violations
#@     P_msg_info "Parsing violations..."
#@     set fd [open "./temp_mincap.txt" "r"]
#@     # Violation Count
#@     set nofixcnt 0
#@     set vcnt 0
#@     while {[gets $fd line] > -1} {
#@       # Get Data
#@       set sline ""
#@       foreach item [split $line] {
#@         if {$item ne ""} { lappend sline $item }
#@       }
#@ 
#@       # In ICC _name is a net, in PT _name is a pin
#@       set _name [lindex $sline 0]
#@       set _is_port [sizeof_collection [get_ports $_name -quiet]]
#@       if {$_is_port} {
#@         P_msg_info "Skipping net $_name because its driver is a port"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       set _net_name $_name
#@       if {$synopsys_program_name == "pt_shell"} {
#@         set _net_name [get_object_name [get_nets -of_objects [get_pins $_name]]]
#@         set _driver [get_cells -of_objects [get_pins $_name]]
#@       } elseif {$synopsys_program_name == "icc_shell"} {
#@         set _driver [get_cells -of_objects [get_pins -of_objects [get_nets $_name] -filter "pin_direction==out" -leaf]]
#@       }
#@ 
#@       set _net_dont_touch [get_attribute [get_net $_net_name] is_dont_touch -quiet]
#@       set _is_macro [get_attribute $_driver is_macro -quiet]
#@       set _cell_dont_touch [get_attribute $_driver is_dont_touch -quiet]
#@       set _cell_cts_fixed "false"
#@       if {$_fix_cts_fixed == "false" && [get_attribute $_driver cts_fixed -quiet] == "true"} {
#@         set _cell_cts_fixed "true"
#@       }
#@       set _cell_is_fixed "false"
#@       if {$_fix_is_fixed == "false" && [get_attribute $_driver is_fixed -quiet] == "true"} {
#@         set _cell_is_fixed "true"
#@       }
#@ 
#@       if {$DEBUG} {
#@         puts "**DEBUG-MSG**> net: $_net_name"
#@         puts "**DEBUG-MSG**> driver: [get_object_name $_driver]"
#@       }
#@ 
#@       # NO FIX CONDITIONS
#@       # Driver is a macro
#@       if {$_is_macro == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is a macro ([get_object_name $_driver])"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver has cts_fixed==true attribute
#@       if {$_cell_cts_fixed == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is cts_fixed"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver has is_fixed==true attribute
#@       if {$_cell_is_fixed == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is fixed"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver is dont_touch
#@       if {$_fix_dont_touch == "false"} {
#@         if {$_net_dont_touch == "true"} {
#@           P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is dont_touch"
#@           incr nofixcnt
#@           continue
#@         } elseif {$_cell_dont_touch == "true"} {
#@           P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because driver [get_object_name $_driver] is dont_touch"
#@           incr nofixcnt
#@           continue
#@         }
#@       }
#@       # Output net is a dangling net
#@       if {[sizeof_collection [all_connected [get_nets $_net_name] -leaf]] <= 1} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is a dangling net.  Consider waiving this violation"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       # Get slack
#@       if {$_net_dont_touch == "true"} {
#@         set slack_column 4
#@       } else {
#@         set slack_column 3
#@       }
#@       set _slack [lindex $sline $slack_column]
#@ 
#@       # Don't fix if slack is greater than threshold
#@       if {[expr $_slack < $_threshold]} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its slack ($_slack) is greater than the threshold ($_threshold)"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       set ref_name [get_attribute $_driver ref_name]
#@       set base [string replace $ref_name 9 [string length $ref_name]]
#@       if {$synopsys_program_name == "icc_shell"} { set _attr "name" } else { set _attr "base_name" }
#@       set libcells [get_attribute [get_lib_cells */$base*] $_attr]
#@       set libcells [lsort -dictionary -unique $libcells]
#@       # Find cells and downsize
#@       set prev ""
#@       for {set j 0} {[expr $j < [llength $libcells]]} {incr j} {
#@         set mylibcell [lindex $libcells $j]
#@         if {$mylibcell == $ref_name} {
#@           if {$prev == ""} {
#@             P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is already minimum size."
#@             incr nofixcnt
#@           } else {
#@             P_msg_info "Swapping cell [get_object_name $_driver] from $ref_name to $prev"
#@             size_cell $_driver $prev
#@             incr vcnt
#@           }
#@           continue
#@         } else {
#@           set prev $mylibcell
#@         }
#@       }
#@     }
#@     sh rm ./temp_mincap.txt
#@     P_msg_info "Iteration $iteration_cnt complete"
#@     if {$vcnt == 0} {
#@       break
#@     }
#@   }
#@   report_constraint -all_violators -min_capacitance
#@   P_msg_info "Min Cap Fixing complete after $iteration_cnt iterations"
#@   P_msg_info "$vcnt fixable violations remain"
#@   P_msg_info "$nofixcnt non-fixable violations remain"
#@ }
#@ 
#@ #-----------------------------------#
#@ #--- Proc Attributes & Arguments ---#
#@ #-----------------------------------#
#@ define_proc_attributes P_fix_min_cap -info "Fixes mincap violations by down-sizing cells"     -define_args {                        {-iterations "Max number of downsizing iterations" iterations int optional}                        {-threshold  "Slack threshold - violations worse than this  will not be fixed" threshold float optional}                        {-report_timing "Prints timing report before each iteration" "" boolean optional}                        {-fix_dont_touch "Fix dont_touch nets & instances" "" boolean optional}                        {-fix_cts_fixed "Fix cts_fixed cells (Mainly flops)" "" boolean optional}                        {-fix_is_fixed "Fix fixed-placement cells" "" boolean optional}                      }
#@ 
#@ #####################
#@ # STA Procedures
#@ #####################
#@ 
#@ #######################################################################
#@ # Usage: P_report_xtalk_deltas
#@ #
#@ # This procedure reports xtalk delta delays
#@ #######################################################################
#@ suppress_message UIAT-4
#@ 
#@ proc P_report_xtalk_deltas {args} {
#@   global sh_dev_null
#@ 
#@   set results(nets) {}
#@   set results(-sort) {}
#@   set results(-verbose) 0
#@   parse_proc_arguments -args $args results
#@ 
#@   if {$results(nets) == ""} {
#@     set results(nets) [get_nets -hierarchical *]
#@   }
#@ 
#@   set sort_type $results(-sort)
#@ 
#@   set nets [get_nets $results(nets)]
#@   define_user_attribute -type float -class net dtrans_min_attr
#@   define_user_attribute -type float -class net dtrans_max_attr
#@   define_user_attribute -type float -class net delta_min_attr
#@   define_user_attribute -type float -class net delta_max_attr
#@   define_user_attribute -type float -class net abs_dtrans_attr
#@   define_user_attribute -type float -class net abs_delta_attr
#@ 
#@   echo ""
#@   echo ""
#@   set header [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"                   "Net Name" "Abs Dtrans" "Min Dtrans" "Max Dtrans" "Abs Delta" "Min Delta" "Max Delta"]
#@   echo $header
#@   echo [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"             "----------" "----------" "----------" "----------" "----------" "----------" "----------"]
#@ 
#@   foreach_in_collection this_net $nets {
#@     set net_loads {}
#@     set net_drivers {}
#@     set this_net_name [get_attribute -quiet $this_net full_name]
#@     set connections [all_connected [get_nets $this_net_name]]
#@     foreach_in_collection this_connection $connections {
#@       if {[get_attribute -quiet $this_connection object_class] == "port"} {
#@         if {[get_attribute -quiet [get_ports $this_connection] direction] == "in"} {
#@           set net_drivers [add_to_collection $net_drivers [get_ports $this_connection]]
#@         }
#@         if {[get_attribute -quiet [get_ports $this_connection] direction] == "out"} {
#@           set net_loads [add_to_collection $net_loads [get_ports $this_connection]]
#@         }
#@       }
#@       if {[get_attribute -quiet $this_connection object_class] == "pin"} {
#@         if {[get_attribute -quiet [get_pins $this_connection] direction] == "in"} {
#@           set net_loads [add_to_collection $net_loads [get_pins $this_connection]]
#@         }
#@         if {[get_attribute -quiet [get_pins $this_connection] direction] == "out"} {
#@           set net_drivers [add_to_collection $net_drivers [get_pins $this_connection]]
#@         }
#@       }
#@     }
#@ 
#@     set dtrans_min 0.00000
#@     set dtrans_max 0.00000
#@     set delta_min 0.00000
#@     set delta_max 0.00000
#@     set report ""
#@     foreach_in_collection this_load $net_loads {
#@       if {[get_attribute -quiet $this_load object_class] == "pin"} {
#@         if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]} {
#@           set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]
#@         }
#@         if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]} {
#@           set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]
#@         }
#@         if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]} {
#@           set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]
#@         }
#@         if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]} {
#@           set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]
#@         }
#@       }
#@       foreach_in_collection this_net_driver $net_drivers {
#@         set arcs [get_timing_arcs -from $this_net_driver -to $this_load]
#@         foreach_in_collection arc $arcs {
#@           if {$delta_min > [get_attribute -quiet $arc                                 annotated_delay_delta_min_rise]} {
#@             set delta_min [get_attribute -quiet $arc                                annotated_delay_delta_min_rise]
#@           }
#@           if {$delta_min > [get_attribute -quiet $arc                                 annotated_delay_delta_min_fall]} {
#@             set delta_min [get_attribute -quiet $arc                                annotated_delay_delta_min_fall]
#@           }
#@           if {$delta_max < [get_attribute -quiet $arc                                 annotated_delay_delta_max_rise]} {
#@             set delta_max [get_attribute -quiet $arc                                annotated_delay_delta_max_rise]
#@           }
#@           if {$delta_max < [get_attribute -quiet $arc                                 annotated_delay_delta_max_fall]} {
#@             set delta_max [get_attribute -quiet $arc                                annotated_delay_delta_max_fall]
#@           }
#@         }
#@       }
#@       if {$dtrans_min != ""} {
#@         set dtrans_min_nosign [expr abs($dtrans_min)]
#@       }
#@       if {$delta_min != ""} {
#@         set delta_min_nosign [expr abs($delta_min)]
#@       }
#@       set abs_dtrans $dtrans_max
#@       set abs_delta $delta_max
#@       if {$dtrans_min_nosign > $dtrans_max} {
#@         set abs_dtrans $dtrans_min_nosign
#@       }
#@       if {$delta_min_nosign > $delta_max} {
#@         set abs_delta $delta_min_nosign
#@       }
#@     }
#@ 
#@     if {$dtrans_min == 0.00000 && $dtrans_max == 0.00000 && $delta_min == 0.00000 &&             $delta_max == 0.00000 && !$results(-verbose)} {
#@       set_user_attribute -quiet -class net $this_net_name dtrans_min_attr 9999
#@       continue
#@     }
#@     set_user_attribute -quiet -class net $this_net_name dtrans_min_attr $dtrans_min
#@     set_user_attribute -quiet -class net $this_net_name dtrans_max_attr $dtrans_max
#@     set_user_attribute -quiet -class net $this_net_name delta_min_attr $delta_min
#@     set_user_attribute -quiet -class net $this_net_name delta_max_attr $delta_max
#@     set_user_attribute -quiet -class net $this_net_name abs_dtrans_attr $abs_dtrans
#@     set_user_attribute -quiet -class net $this_net_name abs_delta_attr $abs_delta
#@   }
#@ 
#@   set temp [filter_collection $nets "dtrans_min_attr != 9999" ]
#@   set no_crosstalk true
#@   if {[sizeof_collection $temp] != 0} {
#@     set temp_sort $temp
#@     if {$sort_type == "dtrans"} {
#@       set temp_sort [sort_collection -descending $temp {abs_dtrans_attr}]
#@     }
#@     if {$sort_type == "delta"} {
#@       set temp_sort [sort_collection -descending $temp {abs_delta_attr}]
#@     }
#@ 
#@     foreach_in_collection this_net_to_report $temp_sort {
#@       set dtrans_min [get_attribute -quiet $this_net_to_report dtrans_min_attr]
#@       set dtrans_max [get_attribute -quiet $this_net_to_report dtrans_max_attr]
#@       set delta_min  [get_attribute -quiet $this_net_to_report delta_min_attr]
#@       set delta_max  [get_attribute -quiet $this_net_to_report delta_max_attr]
#@       set abs_dtrans [get_attribute -quiet $this_net_to_report abs_dtrans_attr]
#@       set abs_delta  [get_attribute -quiet $this_net_to_report abs_delta_attr]
#@       set this_net_to_report_name [get_attribute -quiet $this_net_to_report full_name]
#@       set output [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"                       "$this_net_to_report_name" $abs_dtrans $dtrans_min $dtrans_max $abs_delta $delta_min $delta_max ]
#@       echo "$output"
#@     }
#@     set no_crosstalk false
#@   }
#@   if {$no_crosstalk == "true"} {
#@     echo "No crosstalk effects in this analysis."
#@   }
#@   echo "Analysis of [sizeof_collection $nets] net(s) complete."
#@ }
#@ 
#@ 
#@ define_proc_attributes P_report_xtalk_deltas     -info "reports delta delay and delta transition information for nets"     -define_args     {
#@       {-sort "dtrans to sort by absolute value of dtrans or delta to sort by absolute value of delta" "dtrans/delta" one_of_string {value_help {values {dtrans delta}} optional}}
#@       {-verbose "show all selected nets" "" boolean optional}
#@       {nets "nets to check" "nets" string optional}
#@     }
#@ 
#@ #######################################################################
#@ # Usage: P_restore_dmsa_session
#@ #
#@ # This procedure creates dmsa scenarios from a directory of saved sessions
#@ #######################################################################
#@ 
#@ proc P_restore_dmsa_session {args} {
#@   parse_proc_arguments -args $args results
#@ 
#@   if {[set dirs [glob -nocomplain -type f $results(dir_name)/*/*/lib_map]]
#@       eq {}} {
#@     echo "Error: no save_session directories found."
#@     return 0
#@   }
#@ 
#@   foreach dir $dirs {
#@     set dir [file dirname $dir]
#@     set name [file tail $dir]
#@     regsub "\/$name" $dir "" scenario
#@     regsub "..\/" $scenario "" scenario
#@     echo "Defining scenario ${scenario}."
#@ 
#@     create_scenario -name $scenario -image $dir
#@   }
#@ }
#@ 
#@ define_proc_attributes P_restore_dmsa_session     -info "Restores PrimeTime sessions in DMSA"     -define_args     {
#@       {dir_name "Dir name to restore from" "dir_name" string required}
#@     }
#@ 
#@ #######################################################################
#@ # Usage: P_report_qor
#@ #
#@ # This procedure to emulate DC's report_qor in PT
#@ #######################################################################
#@ 
#@ proc P_report_qor {args} {
#@ 
#@   global sh_product_version
#@   global sh_dev_null
#@   global report_default_significant_digits
#@   global synopsys_program_name
#@   global pt_shell_mode
#@ 
#@   set results(-help) "no help"
#@   set results(-significant_digits) "none"
#@   set results(-only_violated) "false"
#@   set results(-summary) "false"
#@ 
#@   parse_proc_arguments -args $args results
#@ 
#@   if {$results(-help)==""} {
#@     help -verbose report_qor
#@     return 1
#@   }
#@ 
#@   if {$results(-significant_digits)=="none"} {
#@     set significant_digits $report_default_significant_digits
#@   } else {
#@     if {$results(-significant_digits) < 0 || $results(-significant_digits) > 13} {
#@       echo "Error: value '$results(-significant_digits)' not in range (0 to 13). (CMD-019)"
#@       return 0
#@     } else {
#@       set significant_digits $results(-significant_digits)
#@     }
#@   }
#@ 
#@   proc P_count_levels {path} {
#@     set levels 0
#@     set endpoint [get_object_name [get_attribute -quiet $path endpoint]]
#@     foreach_in_collection point [get_attribute -quiet $path points] {
#@       set object [get_attribute -quiet $point object]
#@       if {[get_attribute -quiet $object object_class] == "pin"} {
#@         if {[get_attribute -quiet $object pin_direction] == "in"} {
#@           if {[get_attribute -quiet $object is_port] == "false"} {
#@             if {[get_attribute -quiet $object full_name] != $endpoint} {
#@               incr levels
#@             }
#@           }
#@         }
#@       }
#@     }
#@     return $levels
#@   }
#@ 
#@   proc P_display_path_group {levels arrival slack cost count significant_digits scenario} {
#@     echo "  ---------------------------------------------"
#@     echo [format "  Levels of Logic:%29d$scenario" $levels]
#@     echo [format "  Critical Path Length:%24.${significant_digits}f$scenario" $arrival]
#@     if {[regexp {[^a-zA-Z]} $slack full]} {
#@       echo [format "  Critical Path Slack:%25.${significant_digits}f$scenario" $slack]
#@     } else {
#@       echo [format "  Critical Path Slack:            unconstrained$scenario"]
#@     }
#@     echo [format "  Total Negative Slack:%24.${significant_digits}f" $cost]
#@     echo [format "  No. of Violating Paths:%22d" $count]
#@     echo "  ---------------------------------------------"
#@   }
#@ 
#@   proc P_display_cell_count_and_drcs {hier_cells_count nonhier_cells_count area hier_pins_count nonhier_pins_count cost count drc_list significant_digits scenario} {
#@     upvar $cost cost_local
#@     upvar $count count_local
#@     echo "\n\n  Cell Count"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Hierarchical Cell Count:%21d$scenario" $hier_cells_count]
#@     echo [format "  Hierarchical Port Count:%21d$scenario" $hier_pins_count]
#@     echo [format "  Leaf Cell Count:%29d$scenario" $nonhier_cells_count]
#@     echo "  ---------------------------------------------"
#@     echo "\n\n  Area"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Design Area:%33.6f$scenario" $area]
#@     if {[info exists cost_local(max_area)]} {
#@       echo [format "  Area Cost:%35.6f" $cost_local(max_area)]
#@     }
#@     echo "  ---------------------------------------------"
#@     echo "\n\n  Design Rule Violations"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Total No. of Pins in Design:%17d$scenario" $nonhier_pins_count]
#@     foreach i $drc_list {
#@       if {$count_local($i) != 0} {
#@         set len [expr 38 - [string length $i]]
#@         echo [format "  $i Count:%${len}d" $count_local($i)]
#@       }
#@     }
#@     set total_cost 0
#@     foreach i $drc_list {
#@       if {$cost_local($i) != 0} {
#@         set len [expr 39 - [string length $i]]
#@         set total_cost [expr $total_cost + $cost_local($i)]
#@         echo [format "  $i Cost:%${len}.${significant_digits}f" $cost_local($i)]
#@       }
#@     }
#@     echo [format "  Total DRC Cost:%30.${significant_digits}f" $total_cost]
#@     echo "  ---------------------------------------------\n"
#@   }
#@ 
#@   if {$synopsys_program_name != "pt_shell"} {
#@     echo "Error: This script only functions properly in PrimeTime."
#@     return 0
#@   }
#@ 
#@   set constraint_text ""
#@   set drc_list ""
#@   set group_list ""
#@ 
#@   if {$pt_shell_mode == "primetime" || $pt_shell_mode == "primetime_slave"} {
#@ 
#@     set cost(unconstrained) 0
#@     set count(unconstrained) 0
#@ 
#@     redirect $sh_dev_null {catch {set design [current_design]}}
#@ 
#@     if { $design == "" } {
#@       echo "Error: Current design is not defined. (DES-001)"
#@       return 0
#@     }
#@ 
#@     echo "\n****************************************"
#@     echo "Report : qor"
#@     echo "Design : [get_object_name $design]"
#@     echo "Version: $sh_product_version"
#@     echo "Date   : [date]"
#@     echo "****************************************\n"
#@ 
#@     redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}
#@ 
#@     foreach line [split $constraint_text "\n"] {
#@       switch -regexp $line {
#@         {^.* +([-\.0-9]+) +\(VIOLATED} {
#@           regexp {^.* +([-\.0-9]+) +\(VIOLATED} $line full slack
#@           set cost($group) [expr $cost($group) + $slack]
#@           incr count($group)
#@           continue
#@         }
#@         { *max_delay/setup.*'(.*)'} {
#@           regexp { *max_delay/setup.*'(.*)'} $line full group
#@           set cost($group) 0
#@           set count($group) 0
#@           continue
#@         }
#@         { *min_delay/hold.*'(.*)'} {
#@           regexp { *min_delay/hold.*'(.*)'} $line full group
#@           set group ${group}_min
#@           set cost($group) 0
#@           set count($group) 0
#@           continue
#@         }
#@         {^ *([a-zA-Z_]+) *$} {
#@           regexp {^ *([a-zA-Z_]+) *$} $line full group
#@           if {$group == "recovery" } {
#@             set group async_default
#@           }
#@           if {$group == "removal"} {
#@             set group async_default_min
#@           }
#@           if ![info exists cost($group)] {
#@             set cost($group) 0
#@             set count($group) 0
#@             if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
#@               lappend drc_list $group
#@             }
#@           }
#@           continue
#@         }
#@       }
#@     }
#@ 
#@     set WNS 0.0; set TNS 0.0; set NVP 0;
#@     set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;
#@ 
#@     foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group]] path_group] {
#@       set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost($path_group)]} {
#@         set cost($path_group) 0
#@         set count($path_group) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@ 
#@       if {$slack < $WNS} { set WNS $slack }
#@       set TNS [expr $TNS + $cost(${path_group})]
#@       set NVP [expr $NVP + $count(${path_group})]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits ""
#@     }
#@ 
#@     echo ""
#@ 
#@     foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group] -delay_type min] path_group] {
#@       redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost(${path_group}_min)]} {
#@         set cost(${path_group}_min) 0
#@         set count(${path_group}_min) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@ 
#@       if {$slack < $WNS_min} { set WNS_min $slack }
#@       set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
#@       set NVP_min [expr $NVP_min + $count(${path_group}_min)]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits ""
#@     }
#@ 
#@ 
#@     if {$results(-summary)} {
#@       puts "  Summary"
#@       puts "  ---------------------------------------------"
#@       puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
#@       puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
#@       puts "  ---------------------------------------------"
#@     }
#@ 
#@     set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"]
#@     set nonhier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == false"]
#@ 
#@     P_display_cell_count_and_drcs [sizeof_collection $hier_cells]         [sizeof_collection $nonhier_cells]         [get_attribute -quiet $design area]         [sizeof_collection [get_pins -quiet -of_objects $hier_cells]]         [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]]         cost         count         $drc_list         $significant_digits         ""
#@ 
#@   } elseif {$pt_shell_mode == "primetime_master"} {
#@ 
#@     global multi_scenario_message_verbosity_level
#@ 
#@     set old_verbosity_level $multi_scenario_message_verbosity_level
#@     set multi_scenario_message_verbosity_level low
#@ 
#@     if [info exists constraint_text] {
#@       unset constraint_text
#@     }
#@ 
#@     if {$sh_product_version=="Z-2007.06"||$sh_product_version=="Z-2007.06-SP1"||$sh_product_version=="Z-2007.06-SP2"||$sh_product_version=="Z-2007.06-SP2-1"} {
#@       echo "Error: Aborting script execution! Due to a DMSA bug in Z-2007.06 versions prior to Z-2007.06-SP3 (STAR 9000188708),"
#@       echo "       this script will produce inconsistent and incorrect results. The bug is fixed in Z-2007.06-SP3 PrimeTime."
#@       echo "       To use this script in DMSA mode, please use Z-2007.06-SP3 or later PrimeTime instead."
#@       return 0
#@     }
#@ 
#@     echo "\n****************************************"
#@     echo "Report : qor"
#@     echo "Design : multi-scenario design"
#@     echo "Version: $sh_product_version"
#@     echo "Date   : [date]"
#@     echo "****************************************\n"
#@ 
#@     get_distributed_variables -pre_commands         {redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}}         constraint_text
#@ 
#@     set max_paths [get_timing_paths -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]
#@     set min_paths [get_timing_paths -delay_type min -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]
#@ 
#@     set old_scenario_list [current_scenario]
#@ 
#@     foreach_in_collection scenario $old_scenario_list {
#@       set first_scenario_name [get_object_name $scenario]
#@       break
#@     }
#@ 
#@     current_scenario $first_scenario_name
#@ 
#@     get_distributed_variables -pre_commands         {set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"];              set nonhier_cells [get_cells -quiet -hieriarchical * -filter "is_hierarchical == false"];              set hier_cells_count [sizeof_collection $hier_cells];              set hier_pins_count [sizeof_collection [get_pins -quiet -of_objects $hier_cells]];              set nonhier_cells_count [sizeof_collection $nonhier_cells];              set nonhier_pins_count [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]];              set area [get_attribute -quiet [current_design] area];            } "hier_cells_count nonhier_cells_count hier_pins_count nonhier_pins_count area"
#@ 
#@     current_scenario $old_scenario_list
#@ 
#@     set multi_scenario_message_verbosity_level $old_verbosity_level
#@     set group ""
#@     foreach scenario [array names constraint_text] {
#@       foreach line [split $constraint_text($scenario) "\n"] {
#@         switch -regexp $line {
#@           {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} {
#@             regexp {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} $line full object slack
#@             set object [string trimright $object]
#@             if ![info exists slack_${group}($object)] {
#@               set slack_${group}($object) $slack
#@             } else {
#@               if [expr $slack < [set slack_${group}($object)]] {
#@                 set slack_${group}($object) $slack
#@               }
#@               continue
#@             }
#@           }
#@           { *max_delay/setup.*'(.*)'} {
#@             regexp { *max_delay/setup.*'(.*)'} $line full group
#@             if ![info exists slack_$group] {
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@               lappend group_list $group
#@             }
#@             continue
#@           }
#@           { *min_delay/hold.*'(.*)'} {
#@             regexp { *min_delay/hold.*'(.*)'} $line full group
#@             set group ${group}_min
#@             if ![info exists slack_$group] {
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@               lappend group_list $group
#@             }
#@             continue
#@           }
#@           {^ *([a-zA-Z_]+) *$} {
#@             regexp {^ *([a-zA-Z_]+) *$} $line full group
#@             if {$group == "recovery"} {
#@               set group async_default
#@               if ![info exists slack_async_default] {
#@                 lappend group_list async_default
#@               }
#@             }
#@             if {$group == "removal"} {
#@               set group async_default_min
#@               if ![info exists slack_async_default_min] {
#@                 lappend group_list async_default_min
#@               }
#@             }
#@             if ![info exists slack_$group] {
#@               if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
#@                 lappend drc_list $group
#@               }
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@             }
#@             continue
#@           }
#@         }
#@       }
#@     }
#@ 
#@     foreach group "$group_list $drc_list" {
#@       foreach object [array names slack_$group] {
#@         set cost($group) [expr $cost($group) + [set slack_${group}($object)]]
#@         incr count($group)
#@       }
#@     }
#@ 
#@     set WNS 0.0; set TNS 0.0; set NVP 0;
#@     set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;
#@ 
#@     foreach_in_collection path [sort_collection $max_paths path_group] {
#@       set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost($path_group)]} {
#@         set cost($path_group) 0
#@         set count($path_group) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@       set scenario_name [get_attribute $path scenario_name]
#@ 
#@       if {$slack < $WNS} { set WNS $slack }
#@       set TNS [expr $TNS + $cost(${path_group})]
#@       set NVP [expr $NVP + $count(${path_group})]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits " ($scenario_name)"
#@     }
#@ 
#@     echo ""
#@ 
#@     foreach_in_collection path [sort_collection $min_paths path_group] {
#@       redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost(${path_group}_min)]} {
#@         set cost(${path_group}_min) 0
#@         set count(${path_group}_min) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@       set scenario_name [get_attribute $path scenario_name]
#@ 
#@       if {$slack < $WNS_min} { set WNS_min $slack }
#@       set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
#@       set NVP_min [expr $NVP_min + $count(${path_group}_min)]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits " ($scenario_name)"
#@     }
#@ 
#@     if {$results(-summary)} {
#@       puts "  Summary"
#@       puts "  ---------------------------------------------"
#@       puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
#@       puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
#@       puts "  ---------------------------------------------"
#@     }
#@ 
#@     P_display_cell_count_and_drcs $hier_cells_count($first_scenario_name)         $nonhier_cells_count($first_scenario_name)         $area($first_scenario_name)         $hier_pins_count($first_scenario_name)         $nonhier_pins_count($first_scenario_name)         cost         count         $drc_list         $significant_digits         " ($first_scenario_name)"
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_report_qor     -info "Report QoR"     -define_args {                      {-physical "For compatibility with DC/ICC report_qor; ignored in PrimeTime" "" boolean optional}
#@       {-significant_digits "Precision level of report (range from 0 to 13)" "<digits>" int optional}
#@       {-only_violated "Show only violating path groups" "" boolean optional}
#@       {-summary "QoR Summary report" "" boolean optional}
#@     }
#@ 
#@ ###################################
#@ # Reports and Outputs Procedures
#@ ###################################
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_create_xyv_icc
#@ # Description : This proc is used to create top level block's XYV file for RV LTE analysis
#@ #               The xyv file contains rotation, flipping and coordinates information of top
#@ #               level block and all instances within top level block
#@ 
#@ proc P_create_xyv_icc {args } {
#@ 
#@   set topcell_name [get_attribute [current_design] name]
#@   if { $topcell_name == ""} {
#@     error "P_create_xyv_icc -ERROR- current design name for top level block is not defined\n"
#@   }
#@ 
#@   parse_proc_arguments -args $args flag
#@ 
#@   if {![info exists flag(-step)]} {
#@     error "P_create_xyv_icc -ERROR- Required APR step is not defined\n"
#@   } else {
#@     set step $flag(-step)
#@     set outputfile "outputs/${topcell_name}.${step}.xyv"}
#@   set fp [open $outputfile w]
#@ 
#@   global mw_attr_value_extra_braces
#@   set existing_value_of_extra_braces_var $mw_attr_value_extra_braces
#@   set mw_attr_value_extra_braces false
#@ 
#@   #############################################
#@   #xyv for top level block
#@   #############################################
#@ 
#@   set top_xy_coords ""
#@   set top_boundary [get_attribute [get_die_area] boundary]
#@   for {set tcount 0} {$tcount < [expr [llength $top_boundary] - 1]} {incr tcount} {
#@     set top_firstval [lindex $top_boundary $tcount]
#@     set top_xmin [lindex $top_firstval 0]
#@     set top_ymin [lindex $top_firstval 1]
#@     set top_xmin_nm [expr int($top_xmin*1000)]
#@     set top_ymin_nm [expr int($top_ymin*1000)]
#@     append top_xy_coords " $top_xmin_nm $top_ymin_nm"
#@   }
#@   puts $fp "$topcell_name $topcell_name 0 0 0 0 $top_xy_coords"
#@ 
#@   #############################################
#@   #xyv for all instances within top level block
#@   #############################################
#@ 
#@   foreach_in_collection cell [get_fp_cells -all] {
#@     set inst_name [get_attribute $cell full_name]
#@     set cell_name [get_attribute $cell ref_name]
#@     set inst_origin_x [lindex [get_attribute $cell origin] 0]
#@     set inst_origin_y [lindex [get_attribute $cell origin] 1]
#@     set orientation [get_attribute $cell orientation]
#@     if { $orientation eq "N"} {
#@       set inst_orient "0 0"
#@     } elseif {$orientation eq "FS"} {
#@       set inst_orient "1 0"
#@     } elseif {$orientation eq "FN"} {
#@       set inst_orient "2 0"
#@     } elseif {$orientation eq "S" } {
#@       set inst_orient "0 2"
#@     } else {
#@       puts "P_create_xyv_icc -ERROR- Invalid orientation is found for instance: $inst_name cell: $cell_name"
#@     }
#@     set inst_xy_coords ""
#@     set inst_boundary [get_attribute $cell boundary]
#@     for {set icount 0} {$icount < [expr [llength $inst_boundary] - 1]} {incr icount} {
#@       set inst_firstval [lindex $inst_boundary $icount]
#@       set inst_xmin [lindex $inst_firstval 0]
#@       set inst_ymin [lindex $inst_firstval 1]
#@       set inst_xmin_nm [expr int($inst_xmin*1000)]
#@       set inst_ymin_nm [expr int($inst_ymin*1000)]
#@       append inst_xy_coords " $inst_xmin_nm $inst_ymin_nm"
#@     }
#@     puts $fp "${topcell_name}/$inst_name $cell_name $inst_origin_x $inst_origin_y $inst_orient $inst_xy_coords"
#@   }
#@ 
#@   close $fp
#@ 
#@   set mw_attr_value_extra_braces $existing_value_of_extra_braces_var
#@ 
#@ }
#@ 
#@ define_proc_attributes P_create_xyv_icc      -info "Used to create top level block's XYV file for RV LTE analysis from ICC database"     -define_args {
#@       {-step "APR Step for which XYV file is created" string string required}
#@     }
#@ 
#@ #########################################################
#@ # Procedure: P_report_related_supply_net
#@ # Description: Report related supply nets for given ports.
#@ 
#@ proc P_report_related_supply_net { ports } {
#@   echo "\n****************************************"
#@   echo "Report : related_supply_net"
#@   echo "Design : [current_design_name]"
#@   echo "Version: $::sh_product_version"
#@   echo "Date   : [sh date]"
#@   echo "****************************************\n"
#@   array set miss_num {
#@     power  0
#@     ground 0
#@   }
#@   foreach_in_collection port [sort_collection -dictionary $ports full_name] {
#@     array unset rsn
#@     redirect $::sh_dev_null {
#@       set rsn(power) [get_related_supply_net $port]
#@       set rsn(ground) [get_related_supply_net -ground $port]
#@     }
#@     foreach net_type {power ground} {
#@       if { [sizeof_collection $rsn($net_type)] == 0 } {
#@         incr miss_num($net_type)
#@       }
#@     }
#@     echo "Port [get_object_name $port] ([get_attribute $port direction]) : power = [get_object_name $rsn(power)] , ground = [get_object_name $rsn(ground)]"
#@   }
#@   if { $miss_num(power) > 0 || $miss_num(ground) > 0 } {
#@     echo "\nERROR: $miss_num(power) of [sizeof_collection $ports] ports missing related power net & $miss_num(ground) of [sizeof_collection $ports] ports missing related ground net!\n"
#@     return 0
#@   } else {
#@     echo {}
#@     return 1
#@   }
#@ }
#@ 
#@ #########################################################
#@ # Procedure: P_reports
#@ # Description:  Writes out report files for SYN, APR, PV
#@ 
#@ proc P_reports {step} {
#@   set _start [clock seconds]
#@   global INTEL_DESIGN_NAME INTEL_UPF INTEL_REPORTS
#@   global INTEL_INSERT_SCAN INTEL_HARD_MACRO_NAME
#@   global INTEL_SLACK_LIMIT INTEL_MAX_PATHS INTEL_NWORST
#@   global synopsys_program_name
#@ 
#@   if {[info exists INTEL_MAX_PATHS($step)]} {
#@     set tmax_paths $INTEL_MAX_PATHS($step)
#@   } else {
#@     set tmax_paths 1000
#@   }
#@   if {[info exists INTEL_SLACK_LIMIT($step)]} {
#@     set tslack_limit $INTEL_SLACK_LIMIT($step)
#@   } else {
#@     set tslack_limit 9999
#@   }
#@   if {[info exists INTEL_NWORST($step)]} {
#@     set tnworst $INTEL_NWORST($step)
#@   } else {
#@     set tnworst 1
#@   }
#@ 
#@   set reports_path ./reports
#@   set report_timing_options "report_timing -nosplit -capacitance -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
#@   set check_timing_options "check_timing"
#@ 
#@ 
#@   set rpt_cmd ""
#@   if {$synopsys_program_name == "pt_shell"} {
#@     set report_timing_options "report_timing -nosplit -capacitance -crosstalk_delta -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
#@     set check_timing_options "check_timing -verbose"
#@   }
#@ 
#@   set act_scenarios ""
#@   if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
#@      set act_scenarios [all_active_scenarios]
#@   } 
#@ 
#@   if {[info exists INTEL_REPORTS($step)]} {
#@     foreach report $INTEL_REPORTS($step) {
#@       #         puts "==>INFORMATION: Generating $report report..."
#@       switch -exact -- $report {
#@         area {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set hard_macro_area 0.0
#@           set hard_macro_count 0
#@           if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@             foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@               foreach_in_collection inst_col [get_cells -hierarchical -filter ref_name==$hard_macro_name] {
#@                 set area [get_attribute $inst_col area]
#@                 set hard_macro_area [expr $hard_macro_area + $area]
#@                 incr hard_macro_count
#@               }
#@             }
#@           }
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
#@             report_area
#@             echo "HARD MACRO COUNT= $hard_macro_count"
#@             echo "HARD MACRO AREA = $hard_macro_area sq. microns"
#@             report_reference -hierarchy -nosplit
#@           }
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         qor {
#@           puts "==>INFORMATION: Generating $report report..."
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_report_qor}\n}\n"
#@           } else {
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_qor}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             if { $act_scenarios != "" } {
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt {report_qor -summary}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt reports/${INTEL_DESIGN_NAME}.${report}.summary.rpt
#@             }
#@           }
#@         }
#@         power {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_power -verbose -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               }
#@             } else {
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit }
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         congestion {
#@           if {[shell_is_in_topographical_mode] || [regexp {^icc} $synopsys_program_name]} {
#@             # reports estimated routing related congestion after topo mode synthesis.
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_congestion}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported in this mode."
#@           }
#@         }
#@         multi_vth {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         aocvm {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         high_fanout {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_net_fanout -high_fanout}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         logic_levels {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_get_logic_levels}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         max_delay {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.delay.rpt {report_constraint -all_violators -max_delay -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.delay.rpt reports/${INTEL_DESIGN_NAME}.delay.rpt
#@             }
#@           }
#@         }
#@         max_cap {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.cap.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.cap.rpt reports/${INTEL_DESIGN_NAME}.cap.rpt
#@             }
#@           }
#@         }
#@         max_tran {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt {report_constraint -all_violators -max_transition -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.tran.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tran.rpt reports/${INTEL_DESIGN_NAME}.tran.rpt
#@             }
#@           }
#@         }
#@         all_violators {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_constraint -all_violators -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         create_qor_snapshot {
#@           P_msg_info "Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "create_qor_snapshot -name $step -show_all -clock_tree"}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         timing_setup {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type max}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type max -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type max"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         timing_hold {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type min}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type min -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type min"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         timing_setup_zeroRC {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  set_zero_interconnect_delay_mode true\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay min}\n set_zero_interconnect_delay_mode false\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 set_zero_interconnect_delay_mode true
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@                 set_zero_interconnect_delay_mode false
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               set_zero_interconnect_delay_mode true
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               set_zero_interconnect_delay_mode false
#@             }
#@           }
#@         }
#@         timing_setup_groups {
#@           puts "==>INFORMATION: Generating $report report..."
#@           foreach_in_collection group [get_path_groups] {
#@             set group_name [get_object_name ${group}]
#@             regsub -all {\*} $group_name "" group_rpt_name
#@             regsub -all {\/} $group_rpt_name "-" group_rpt_name
#@             if {[regexp {^pt} $synopsys_program_name]} {
#@               set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {$report_timing_options -group $group_name}}\n"
#@             } else {
#@               if { $act_scenarios != "" } {
#@                 foreach scenario [all_active_scenarios] {
#@                   redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name -scenarios $scenario"}
#@                   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
#@                 }
#@               } else {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_setup_${group_rpt_name}.rpt
#@               }
#@             }
#@           }
#@         }
#@         timing_hold_groups {
#@           puts "==>INFORMATION: Generating $report report..."
#@           foreach_in_collection group [get_path_groups] {
#@             set group_name [get_object_name ${group}]
#@             regsub -all {\*} $group_name "" group_rpt_name
#@             regsub -all {\/} $group_rpt_name "-" group_rpt_name
#@             if {[regexp {^pt} $synopsys_program_name]} {
#@               set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {$report_timing_options -delay_type min -group $group_name}}\n"
#@             } else {
#@               if { $act_scenarios != "" } {
#@                 foreach scenario [all_active_scenarios] {
#@                   redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name -scenarios $scenario"}
#@                   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
#@                 }
#@               } else {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_hold_${group_rpt_name}.rpt
#@               }
#@             }
#@           }
#@         }
#@         timing_loops {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {$report_timing_options -loops}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {eval "$report_timing_options -loops"}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt reports/${INTEL_DESIGN_NAME}.max.timingloops.rpt
#@           }
#@         }
#@         timing_histogram {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -range_maximum 0}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_histogram.rpt {report_timing_histogram -bin_range 25 -scenarios $scenario}
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -bin_range 25}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt reports/${INTEL_DESIGN_NAME}.timing_histogram.rpt
#@             }
#@           }
#@         }
#@         clock {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock -skew -attributes -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         physical {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_design -physical}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         clock_tree {
#@           if { $act_scenarios != "" } {
#@             foreach scenario [all_active_scenarios] {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_tree -scenarios $scenario}
#@               redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup -scenarios $scenario}
#@               redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup -scenario $scenario }
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@             }
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_tree }
#@             redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup }
#@             redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup  }
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         clock_gating {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_gating -ungated -style}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_timing {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$check_timing_options}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval $check_timing_options}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         min_pulse_width {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_min_pulse_width -all_violators -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         check_zrt_routability {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_zrt_routability -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         drc {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_drc -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
#@           sh ln -fs ${INTEL_DESIGN_NAME}_${step}_${report}.err reports/${INTEL_DESIGN_NAME}_${report}.err
#@         }
#@         lvs {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_lvs -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err -max_error 200 -check_short_locator -check_open_locator}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_design {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_design}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         error_info {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}\n}\n"
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt  
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         saif {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_saif -hier -missing -annotated_flag -type gate}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_mv_design {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_mv_design -verbose}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         upf {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
#@               eval report_power_domain [get_power_domains -quiet -hierarchical *]
#@               eval report_supply_port [get_supply_ports -quiet -hierarchical *]
#@               eval report_supply_net -include_exception [get_supply_nets -quiet -hierarchical *]
#@               eval report_power_switch -verbose [get_power_switches -quiet -hierarchical *]
#@               # Somehow, ICC report_isolation_cell needs associate_mv_cells -isolation_cells.
#@               report_isolation_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               # Somehow, ICC report_level_shifter needs domain names instead of domain objects.
#@               if { $::synopsys_program_name == {icc_shell} } {
#@                 report_level_shifter -verbose -domain [get_object_name [get_power_domains -quiet -hierarchical *]]
#@               } else {
#@                 report_level_shifter -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               }
#@               report_retention_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               P_report_related_supply_net [get_ports *]
#@             }
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         check_legality {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_legality -verbose}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         threshold_voltage_group {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         vars {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {\n    echo \"##### Environment Variables #####\"\n     printenv\n   echo \" \"\n   echo \"##### Flow Related Variables #####\"\n    printvar\n}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {
#@               echo "##### Environment Variables #####"
#@               printenv
#@               echo " "
#@               echo "##### Flow Related Variables #####"
#@               printvar
#@             }
#@             ################
#@             # dump file paths of libraries and technology data.
#@             #   resulting file can be run through sha1sum for audit purposes.
#@             # libraries
#@             set libs [get_libs *]
#@             foreach_in_collection lib $libs {
#@               set file [get_attribute $lib extended_name]
#@               set l [split $file ":"]
#@               lappend names [lindex $l 0]
#@             }
#@             set names [lsort -unique $names]
#@             set f [open "$reports_path/${INTEL_DESIGN_NAME}.${step}.files" "w"]
#@             foreach n $names {
#@               puts $f $n
#@             }
#@             if {[regexp {icc} $synopsys_program_name] || ([regexp {dc} $synopsys_program_name] && [shell_is_in_topographical_mode])} {
#@               # tlu files
#@               redirect -variable tlu_files {report_tlu_plus_files}
#@               foreach line [split $tlu_files "\n"] {
#@                 regsub -all {\s+} $line {} line
#@                 if {[regexp {file:} $line]} {
#@                   puts $f [lindex [split $line ":"] 1]
#@                 }
#@               }
#@               # techfile - ??
#@             }
#@             close $f
#@           }
#@         }
#@         flow_vars {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {\n   echo \"#### INTEL_* flow varaibles #####\"\n   printvar INTEL_*\n}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {
#@               echo "#### INTEL_* flow varaibles #####"
#@               printvar INTEL_*
#@             }
#@           }
#@         }
#@         dft_drc {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {dft_drc -coverage_estimate}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         dft_signal {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_dft_signal}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         scanpath {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_scan_path}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         parasitic_not_annotated_check {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n   redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {report_annotated_parasitics -internal_nets -boundary_nets -list_not_annotated}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {
#@               report_annotated_parasitics                   -internal_nets                   -boundary_nets                   -list_not_annotated                 }
#@           }
#@         }
#@         pin_margin   {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_margin.pv.rpt
#@           redirect $output_file {echo [format "%-50s %-7s %-7s %-7s %-7s %-4s %-15s" #pin_name max_rise max_fall min_rise min_fall direction cell ]}
#@           redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection pin [get_pins -hierarchical * -filter "is_hierarchical == false && is_clock_pin == false"] {
#@             set temp [format "%-50s %7.2f %7.2f %7.2f %7.2f %-4s %-15s" [get_attribute -quiet -class pin $pin full_name]                           [get_attribute -quiet -class pin $pin max_rise_slack]                           [get_attribute -quiet -class pin $pin max_fall_slack]                           [get_attribute -quiet -class pin $pin min_rise_slack]                           [get_attribute -quiet -class pin $pin min_fall_slack]                           [get_attribute -quiet -class pin $pin direction]                           [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]
#@ 
#@             redirect -append $output_file { echo $temp}
#@           }
#@         }
#@         pin_attribute {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_pin_attribute.pv.rpt
#@           redirect $output_file {echo [format "%60s %14s" #RISE_TRAN FALL_TRAN]}
#@           redirect -append $output_file {echo [format "%-50s %-6s %-6s %-6s %-6s %-4s %-15s" #pin_name max  min  max  min  arr_window  cell]}
#@           redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection pin [get_pins -hierarchical * ] {
#@             set temp [format "%-50s %5.2f %5.2f %5.2f %5.2f %-50s %-15s" [get_attribute -quiet -class pin $pin full_name]                           [get_attribute -quiet -class pin $pin actual_rise_transition_max]                           [get_attribute -quiet -class pin $pin actual_rise_transition_min]                           [get_attribute -quiet -class pin $pin actual_fall_transition_max]                           [get_attribute -quiet -class pin $pin actual_fall_transition_min]                           [get_attribute -quiet -class pin $pin arrival_window]                           [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]
#@             redirect -append $output_file { echo $temp }
#@           }
#@         }
#@         net_attribute {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_net_attribute.pv.rpt
#@           redirect output_file {echo [format "%40s " #CAPACITANCE_MAX# ]}
#@           redirect -append $output_file {echo [format "%-20s %-7s %-7s %-7s %-7s %-4s %-15s" #net wire pin Total R_max lth_H  lth_V]}
#@           redirect -append $output_file {echo "#------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection hn [get_nets -hierarchical * ] {
#@             set tmp_val [get_attribute -quiet -class net $hn x_coordinate_max]
#@             if {[info exists tmp_val] && $tmp_val == ""} {
#@               set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-5s %-5s" [get_attribute -quiet -class net $hn full_name]                             [get_attribute -quiet -class net $hn wire_capacitance_max]                             [get_attribute -quiet -class net $hn pin_capacitance_max]                             [get_attribute -quiet -class net $hn total_capacitance_max]                             [get_attribute -quiet -class net $hn net_resistance_max]                             --- ---]
#@             } else {
#@               set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-9.2s %-9.2s" [get_attribute -quiet -class net $hn full_name]                             [get_attribute -quiet -class net $hn wire_capacitance_max]                             [get_attribute -quiet -class net $hn pin_capacitance_max]                             [get_attribute -quiet -class net $hn total_capacitance_max]                             [get_attribute -quiet -class net $hn net_resistance_max]                             [expr {[get_attribute -quiet -class net $hn x_coordinate_max] - [get_attribute -quiet -class net $hn x_coordinate_min]}]                             [expr {[get_attribute -quiet -class net $hn y_coordinate_max] - [get_attribute -quiet -class net $hn y_coordinate_min]}]]
#@             }
#@             redirect -append $output_file { echo $temp }
#@           }
#@         }
#@         noise_all_vio {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators -slack_type height -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators                                                                                    -verbose                                                                                    -slack_type height                                                                                    -nosplit }
#@           }
#@         }
#@         noise_below {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below                                                                                  -verbose                                                                                  -slack_type height                                                                                  -nworst 10000                                                                                  -nosplit }
#@           }
#@         }
#@         noise_above {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above                                                                                  -verbose                                                                                  -slack_type height                                                                                  -nworst 10000                                                                                  -nosplit }
#@           }
#@         }
#@         check_noise {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity} -beyond_rail -verbose}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity}                                                                                  -verbose }
#@           }
#@         }
#@         max_analysis_coverage {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage -status_details untested -check_type \"setup recovery clock_gating_setup out_setup\" -exclude_untested \"user_disabled false_paths constant_disabled\" -sort_by name -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage                                                                                            -status_details untested                                                                                            -check_type "setup recovery clock_gating_setup out_setup"                                                                                            -exclude_untested "user_disabled false_paths"                                                                                            -sort_by name                                                                                            -nosplit }
#@           }
#@         }
#@         switching_activity {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.switching_activity.rpt {report_switching_activity}\n}\n"
#@           }
#@         }
#@ 
#@         hier_switching_activity {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"  redirect $reports_path/${INTEL_DESIGN_NAME}.hier.switching_activity.rpt { report_switching_activity -hierarchy}\n}\n"
#@           }
#@         }
#@         missing_power_tables {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.no_power_table.rpt {check_power -verbose  -override_defaults missing_table }\n}\n"
#@           }
#@         }
#@         default {
#@           puts "==>WARNING: The defined report \"$report\" is not configured at $step in the default flow."
#@         }
#@       }
#@     }
#@   } else {
#@     puts "==>WARNING: No reports are defined at $step step in the default flow."
#@   }
#@ 
#@   if {[regexp {^pt} $synopsys_program_name]} {
#@     set rpt_cmd "parallel_execute -commands_only {\n $rpt_cmd }"
#@     echo $rpt_cmd
#@     eval $rpt_cmd
#@   }
#@   set _end [clock seconds]
#@   P_msg_info "Runtime for reports: [expr ($_end - $_start)/60.0] minutes"
#@ 
#@ }
#@ 
#@ ### procedure get_logic_levels takes in the output of "get_timing_path"
#@ proc P_get_logic_levels {args} {
#@   parse_proc_arguments -args $args results
#@   if {[info exists results(-paths)] && $results(-paths) != ""} {
#@     set paths $results(-paths)
#@   } elseif {[info exists results(-gtp_options)] && $results(-gtp_options) != ""} {
#@     set paths [eval get_timing_paths $results(-gtp_options)]
#@   } else {
#@     set paths [get_timing_paths -max_paths 25]
#@   }
#@   puts "\nPrining logic levels per start/end point\n"
#@   puts "Startpoint, Endpoint, # of logic cells, slack"
#@   puts "============================================="
#@   foreach_in_collection path $paths {
#@     set slack [get_attribute $path slack]
#@     set startpoint [get_object_name [get_attribute $path startpoint]]
#@     set endpoint [get_object_name [get_attribute $path endpoint]]
#@     set points [get_attribute $path points]
#@     set cells {}
#@     foreach_in_collection point $points {
#@       set obj [get_attribute $point object]
#@       set obj_class [get_attribute $obj object_class]
#@       set dir [get_attribute $obj direction]
#@       if {$dir == "in" && $obj_class == "pin" } {
#@         set cells [add_to_collection $cells [get_cells -of_objects $obj -filter "@is_combinational == true"]]
#@       }
#@     }
#@     puts "$startpoint, $endpoint, [sizeof_collection $cells], $slack"
#@   }
#@ }
#@ 
#@ define_proc_attributes P_get_logic_levels     -info "Prints logic levels in a start/end point pair"     -define_args {
#@       {-paths "output of get_timing_paths command" timing_paths string optional}
#@       {-gtp_options "options to be used by get_timing_paths command" get_timing_path_options string optional}
#@     }
#@ 
#@ ## procedure to create PG terminals on the entire strap of top metal layer to ensure correct FRAM creation
#@ proc P_create_pg_terminals {} {
#@   global INTEL_MAX_PG_LAYER
#@   global INTEL_TERM_LENGTH
#@ 
#@   set pports [get_ports -all -filter "port_type=~*Power* || port_type=~*Ground*"]
#@ 
#@   # Remove existing terminals
#@   set top_layer [string map {m ""} $INTEL_MAX_PG_LAYER]
#@   set filter_exp "layer!=tm1 && layer!=c4b"
#@   for {set i [expr $top_layer + 1]} {[expr $i <= 12]} {incr i} {
#@     set filter_exp "$filter_exp && layer!=m${i}"
#@   }
#@   remove_terminal [get_terminals -of_objects $pports -filter "$filter_exp"]
#@ 
#@   # Create new terminals
#@   set all_pg_nets [get_net_shapes -of_objects [get_nets -all -of_objects $pports] -filter "route_type==pg_strap"]
#@   set top_layer_nets [filter_collection $all_pg_nets "layer==$INTEL_MAX_PG_LAYER"]
#@   set other_nets [remove_from_collection $all_pg_nets $top_layer_nets]
#@ 
#@   # Terminals half DR in size
#@   foreach {metal stub} $INTEL_TERM_LENGTH {
#@     set stub_size($metal) [expr $stub / 2]
#@   }
#@ 
#@   # Get vertical/horizontal edges
#@   set boundary [get_attribute [get_die_area] boundary]
#@   set vert_edges ""
#@   set horz_edges ""
#@   set first 1
#@   foreach point $boundary {
#@     if {$first} {
#@       set first 0
#@     } else {
#@       #  puts "point:$point, prev:$prev"
#@       if {[lindex $point 0] == [lindex $prev 0]} {
#@         # X didn't change, vertical edge
#@         lappend vert_edges [format "%.3f" [lindex $point 0]]
#@       } else {
#@         lappend horz_edges [format "%.3f" [lindex $point 1]]
#@       }
#@     }
#@     set prev $point
#@   }
#@ 
#@   set first_layer 5
#@   for {set i 5} {[expr $i < [string map {m ""} $INTEL_MAX_PG_LAYER]]} {incr i} {
#@     # Create terminal stubs
#@     set layer "m${i}"
#@     P_msg_info "Creating terminals on layer $layer"
#@     foreach_in_collection net_shape [filter_collection $other_nets "layer==$layer"] {
#@       scan [get_attribute $net_shape bbox] "{%f %f} {%f %f}" llx lly urx ury
#@       if {[get_attribute [get_layer $layer] preferred_direction] == "horizontal"} {
#@         # L/R sides
#@         if {[lsearch $vert_edges [format "%.3f" $llx]] > -1} {
#@           set bbox1 [list $llx $lly [expr $llx + $stub_size($layer)] $ury]
#@           create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@         if {[lsearch $vert_edges [format "%.3f" $urx]] > -1} {
#@           set bbox2 [list [expr $urx - $stub_size($layer)] $lly $urx $ury]
#@           create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@       } else {
#@         # T/B sides
#@         if {[lsearch $horz_edges [format "%.3f" $lly]] > -1} {
#@           set bbox1 [list $llx $lly $urx [expr $lly + $stub_size($layer)]]
#@           create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@         if {[lsearch $horz_edges [format "%.3f" $ury]] > -1} {
#@           set bbox2 [list $llx [expr $ury - $stub_size($layer)] $urx $ury]
#@           create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@       }
#@       #      create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@       #      create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@     }
#@   }
#@ 
#@   # Terminals of top metal layers
#@   P_msg_info "Creating terminals on layer $INTEL_MAX_PG_LAYER"
#@   foreach_in_collection net_shape $top_layer_nets {
#@     create_terminal -bbox [get_attribute $net_shape bbox] -layer $INTEL_MAX_PG_LAYER -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@   }
#@ 
#@   proc P_poly2bbox {polygon} {
#@     return [join [list [lindex $polygon 0] [lindex $polygon 2]] " "]
#@   }
#@ 
#@   foreach_in_collection pin_shape [get_pin_shapes -of_objects [get_pins -all -of_objects [all_macro_cells ] -filter "pin_type=~*Power* || pin_type=~*Ground*" -quiet] -filter "layer==$INTEL_MAX_PG_LAYER" -quiet] {
#@     set port [get_ports -all -of_objects [get_nets -all [get_attribute [get_pins -all -of_objects $pin_shape -quiet] net_name -quiet] -quiet] -quiet]
#@     if {[sizeof_collection $port] > 0} {
#@       set points [get_attribute $pin_shape points]
#@       set plength [llength $points]
#@       if {[expr $plength % 5] == 0} {
#@         for {set pi 0} {[expr $pi < $plength]} {set pi [expr $pi + 5]} {
#@           set ppoints [lrange $points $pi [expr $pi + 4]]
#@           create_terminal -bbox [P_poly2bbox $ppoints] -layer $INTEL_MAX_PG_LAYER -port $port -no_snap
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ proc P_outputs_linkname {} {
#@   global synopsys_program_name
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
#@     set ::output_linkname syn
#@   } else {
#@     set ::output_linkname apr
#@   }
#@ }
#@ 
#@ proc P_outputs_verilog {step} {
#@   global INTEL_DESIGN_NAME
#@   global synopsys_program_name
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.vg
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
#@     write_file -format verilog -hierarchy -output $output_file
#@   } else {
#@     write_verilog -diode_ports -no_physical_only_cells -no_core_filler_cells -no_tap_cells -unconnected_ports $output_file
#@   }
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.vg outputs/${INTEL_DESIGN_NAME}.${output_linkname}.vg
#@ }
#@ 
#@ proc P_outputs_verilog_pg {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}_lvs.vg
#@   write_verilog -pg -diode_ports -unconnected_ports -output_net_name_for_tie $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}_lvs.vg outputs/${INTEL_DESIGN_NAME}.${output_linkname}_lvs.vg
#@ }
#@ 
#@ proc P_outputs_upf {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.upf
#@   save_upf $output_file
#@   P_msg_info "Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.upf outputs/${INTEL_DESIGN_NAME}.${output_linkname}.upf
#@ }
#@ 
#@ 
#@ proc P_outputs_spef {step} {
#@   global synopsys_program_name
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   if {($synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell")  && [shell_is_in_topographical_mode]} {
#@     write_parasitics -format distributed -output ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     if {[file exists ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz]} {
#@       sh rm ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz
#@     }
#@     sh gzip ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.gz
#@   } elseif {$synopsys_program_name != "dc_shell"} {
#@     global INTEL_DESIGN_NAME
#@     extract_rc -coupling_cap
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     write_parasitics -format SPEF -compress -output $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}.max.gz ${output_file}.min.gz"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.max.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.max.gz
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.min.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.min.gz
#@   }
#@ }
#@ 
#@ proc P_outputs_def {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   global synopsys_program_name
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
#@   if {($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode]) || $synopsys_program_name == "de_shell" } {
#@     write_def -output $output_file -placed
#@ 		sh ln -fs ${INTEL_DESIGN_NAME}.${step}.def outputs/${INTEL_DESIGN_NAME}.${output_linkname}.def
#@     puts "==>INFORMATION: Output file: ${INTEL_DESIGN_NAME}.${step}.def"
#@   } elseif {$synopsys_program_name == "icc_shell" } {
#@     write_def -compressed -output $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}.gz"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.def.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.def.gz
#@   }
#@ }
#@ 
#@ proc P_outputs_techlef {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tech.lef
#@   set libpath  [file dirname [ get_attribute [current_mw_lib] path]]
#@   set libname [get_attribute [current_mw_lib] name]
#@   set f_out [open write_lef.tcl "w"]
#@   puts $f_out "write_lef -output_version 5.5 -lib_name $libpath/$libname -ignore_tech_signal_em -ignore_tech_antenna_rule -ignore_cell_geom $output_file"
#@   puts $f_out "exit"
#@   close $f_out
#@   if {[catch {sh which Milkyway} id] } {
#@     puts "==>WARNING: Milkyway tool not set, techlef cannot be generated"
#@   } else {
#@     exec Milkyway -nullDisplay -nogui -tcl -file ./write_lef.tcl -logd logs/mw -cmdd logs/mw >& /dev/null
#@   } 
#@   sh rm ./write_lef.tcl
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tech.lef outputs/${INTEL_DESIGN_NAME}.${output_linkname}.tech.lef
#@ }
#@ 
#@ proc P_syn_output_def {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_SCRIPTS_SEARCH_PATH
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
#@   set file1 icc_dp.tcl
#@   if {[catch {sh which icc_shell} id] } {
#@     puts "ICC is not set , def file cannot be geneartaed"
#@   } else {
#@     set iccpath [sh which icc_shell]
#@     set_icc_dp_options -icc_executable $iccpath
#@     foreach search_dir $INTEL_SCRIPTS_SEARCH_PATH {
#@       if {[file exists [ file join $search_dir $file1]] } {
#@         set file_icc_dp [file join $search_dir $file1]
#@       }
#@     }
#@     start_icc_dp -f $file_icc_dp
#@     if { [file exists icc_dp_error] } {
#@       puts "WARNING: cannot write def file due to error in icc_dp"
#@     }
#@   }
#@ }
#@ 
#@ proc P_outputs_fp {step} {
#@   global INTEL_DESIGN_NAME
#@ 
#@   ### All floorplan contents
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tcl
#@   write_floorplan -all $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@ 
#@   ### Hard macro placements only
#@   if {[sizeof_collection [all_macro_cells]] != 0} {
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.macro_placement.tcl
#@     write_floorplan -placement { hard_macro }  -no_placement_blockage -no_bound         -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary         $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}"
#@   }
#@ 
#@   ### IO placements only
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.io_placement.tcl
#@   write_floorplan -placement { terminal }  -no_placement_blockage -no_bound       -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary       $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@ }
#@ 
#@ proc P_outputs_sdc {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   global synopsys_program_name
#@ 
#@   P_outputs_linkname
#@ 
#@   set act_scenarios ""
#@   if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
#@     set act_scenarios [all_active_scenarios]
#@   }
#@   if { $act_scenarios == ""} {
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.sdc.orig
#@     write_sdc -nosplit $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}"
#@     if { [file exists $output_file ] } {
#@       set org_sdc [ open $output_file ]
#@       set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.sdc w]
#@       while { [ gets $org_sdc line ] != -1 } {
#@         if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
#@           set new_line [concat #$line]
#@           puts $mod_sdc "$new_line"
#@         } else {
#@           puts $mod_sdc "$line"
#@         }
#@       }
#@       close $org_sdc
#@       close $mod_sdc
#@     }
#@     puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.sdc"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.sdc
#@ 
#@   } else {
#@     foreach scenario [all_active_scenarios] {
#@       set output_file outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc.orig
#@       write_sdc -nosplit $output_file
#@       puts "==>INFORMATION: Output file: ${output_file}"
#@ 
#@       #Modify SDC for PV usage
#@       if { [file exists $output_file ] } {
#@         set org_sdc [ open $output_file ]
#@         set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc w]
#@         while { [ gets $org_sdc line ] != -1 } {
#@           if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
#@             set new_line [concat #$line]
#@             puts $mod_sdc "$new_line"
#@           } else {
#@             puts $mod_sdc "$line"
#@           }
#@         }
#@         close $org_sdc
#@         close $mod_sdc
#@       }
#@       puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc"
#@       sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.${scenario}.sdc
#@     }
#@   }
#@ }
#@ 
#@ 
#@ proc P_outputs_saif {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_SAIF
#@   global synopsys_program_name
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell" } {
#@     saif_map -end
#@     saif_map -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap
#@     if {[info exists INTEL_SAIF] && $INTEL_SAIF == 1} {
#@       saif_map -type ptpx -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap.ptpx
#@ 
#@     }
#@     set_vsdc -off
#@   }
#@ }
#@ 
#@ proc P_outputs_scandef {step} {
#@   global INTEL_INSERT_SCAN
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   if {[info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN == 1} {
#@     puts "==>INFORMATION: writing a scandef since INTEL_INSERT_SCAN is set to $INTEL_INSERT_SCAN"
#@     write_scan_def -output ./outputs/${INTEL_DESIGN_NAME}.${step}.scandef
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.scandef outputs/${INTEL_DESIGN_NAME}.${output_linkname}.scandef
#@   }
#@ }
#@ 
#@ 
#@ proc P_outputs_oas {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@   P_outputs_linkname
#@   set_write_stream_options -reset
#@   set_write_stream_options       -map_fill_data       -output_first_same_name_cell       -skip_global_route_contact       -contact_prefix X       -child_depth 1000       -output_filling fill       -output_outdated_fill       -output_pin {text geometry}       -keep_data_type       -map_layer $INTEL_GDS_OUT_LAYER_MAP       -output_instance_name_as_property 112       -max_name_length 128       -output_net text
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
#@   write_stream -cells $INTEL_DESIGN_NAME -format oasis $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.oas outputs/${INTEL_DESIGN_NAME}.${output_linkname}.oas
#@ }
#@ 
#@ 
#@ #proc P_outputs_oas {step} {
#@ #   global INTEL_DESIGN_NAME
#@ #   global fdk_asic_flows_dir
#@ #
#@ #   if {$step == "fill"} {
#@ #      set output_file outputs/${INTEL_DESIGN_NAME}.apr.oas
#@ #      set gds_file outputs/${INTEL_DESIGN_NAME}.apr.gds.gz
#@ #      echo "Need GDS file to create OAS. Creating GDS..."
#@ #      P_outputs_gds apr
#@ #   } else {
#@ #      set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
#@ #      set gds_file outputs/${INTEL_DESIGN_NAME}.${step}.gds.gz
#@ #      echo "Need GDS file to create OAS. Creating GDS..."
#@ #      P_outputs_gds $step
#@ #   }
#@ #
#@ #   puts "==>INFORMATION: Generating OAS database using Calibre"
#@ #   set gds2oas_script $fdk_asic_flows_dir/apr/layout_merge_calibre.tcl
#@ #   set status [catch {sh calibredrv -64 $gds2oas_script convert $gds_file $output_file oas} msg]
#@ #   echo "$msg";
#@ #   puts "==>INFORMATION: Generated OAS database"
#@ #}
#@ 
#@ 
#@ proc P_outputs_gds {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@   P_outputs_linkname
#@   set_write_stream_options -reset
#@   set_write_stream_options       -map_fill_data       -child_depth 1000       -output_filling fill       -output_outdated_fill       -output_pin {text geometry}       -keep_data_type       -map_layer $INTEL_GDS_OUT_LAYER_MAP       -output_instance_name_as_property 112       -max_name_length 128       -output_net text       -compressed
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.gds.gz
#@   write_stream -cells $INTEL_DESIGN_NAME -format gds $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.gds.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.gds.gz
#@ }
#@ 
#@ proc P_outputs_fram {step} {
#@   global INTEL_MAX_PG_LAYER
#@   global INTEL_DESIGN_NAME
#@ 
#@   P_create_pg_terminals; #Creates PG terminals on the entire strap of top metal layer
#@ 
#@ 
#@   # Create macro fram work around give by SNPS:
#@   # 1. Create_macro_fram with default setting, so you will get the top metal layer blockages. Write out the top level blockages to a file.
#@   # 2. Create_macro_fram with no top layer blockage setting, so you can get all the VIAN-1 extracted. And then read the files contain the top level blockages to the FRAM and save the FRAM, by doing this, you get both VIAN-1 vias and the top level blockages in your FRAM view.
#@ 
#@ 
#@   # Open temp file to right fram info
#@   set fp [open "scripts/.fram.tcl" w+]
#@   set my_mw_cel [get_object_name [current_mw_cel]]
#@ 
#@ 
#@   if {$INTEL_MAX_PG_LAYER=="m12"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m14 -1.0 m15 -1.0} -extract_via_on_layer V12 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m12] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m12 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V12 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   }  elseif {$INTEL_MAX_PG_LAYER=="m11"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V11 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m11] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m11 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V11 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m10"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V10 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m10] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m10 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V10 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m9"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V9 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m9] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m9 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V9 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m8"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V8 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m8] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m8 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V8 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m7"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V7 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m7] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m7 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V7 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m6"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V6 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m6] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m6 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V6 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m5"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V5 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m5] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m5 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V5 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m4"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V4 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m4] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m4 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V4 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m3"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V3 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m3] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m3 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m4 -1.0 m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V3 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } else {
#@     P_msg_error "FRAM view is not properly created."
#@   }
#@ }
#@ 
#@ proc P_outputs_lteloc {step} {
#@   global INTEL_DESIGN_NAME
#@ 
#@   set output_file ./outputs/${INTEL_DESIGN_NAME}.${step}.xyv
#@   P_create_xyv_icc -step $step
#@   P_msg_info "Output file: ${output_file}"
#@ }
#@ 
#@ proc P_outputs {step} {
#@   global INTEL_DESIGN_NAME INTEL_UPF INTEL_SPG INTEL_INSERT_SCAN INTEL_SCAN_REPLACE_FLOPS
#@   global INTEL_OUTPUTS
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@ 
#@   if {[info exists INTEL_OUTPUTS($step)]} {
#@     set step_name $step
#@     foreach v $INTEL_OUTPUTS($step) {
#@       #         puts "==>INFORMATION: Writing an output $v"
#@       switch -exact -- $v {
#@         verilog {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_verilog $step_name
#@         }
#@         verilog_pg {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_verilog_pg $step_name
#@         }
#@         upf {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating output $v because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating output $v because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating an output $v"
#@             P_outputs_upf $step_name
#@           }
#@         }
#@         spef {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_spef $step_name
#@         }
#@         def {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_def $step_name
#@         }
#@         techlef {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_techlef $step_name
#@         }
#@         syn_def {
#@           if  { [shell_is_in_topographical_mode] && $INTEL_SPG == 1 } {
#@             puts "==>INFORMATION: Generating an output $v"
#@             P_syn_output_def $step_name
#@           } else {
#@             P_msg_warn "Skip generating def file as spg option is turned off"
#@           }
#@         }
#@         fp {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_fp $step_name
#@         }
#@         sdc {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_sdc $step_name
#@         }
#@         saif {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_saif $step_name
#@         }
#@         scandef {
#@           if {$INTEL_SCAN_REPLACE_FLOPS==1 && $INTEL_INSERT_SCAN==1} {
#@             puts "==>INFORMATION: Generating an output $v"
#@             P_outputs_scandef $step_name
#@           } else {
#@             puts "==>INFORMATION : either INTEL_INSERT_SCAN or INTEL_SCAN_REPLACE_FLOPS are turned off , No scnadef will be generated"
#@           }
#@         }
#@         oas {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_oas $step_name
#@         }
#@         gds {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_gds $step_name
#@         }
#@         lteloc {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_lteloc $step_name
#@         }
#@         fram {
#@           P_msg_info "Generating an output $v"
#@           P_outputs_fram $step_name
#@         }
#@ 
#@         default {
#@           puts "==>WARNING: The defined output is not configured at $step in the default flow"
#@         }
#@       }
#@     }
#@   } else {
#@     puts "==>WARNING: No outputs are defined at $step step in the default flow"
#@   }
#@ }
#@ 
#@ ##############################################################################
#@ ## Define procedure: P_check_place_overlap
#@ ## This proc checks for overlapped cells
#@ ## Usage: P_check_place_overlap
#@ ##############################################################################
#@ proc P_check_place_overlap {} {
#@   P_msg_info " Checking for cell overlap "
#@   set legalize_support_phys_only_cell true
#@   redirect -file ./temp_check_legality_v0.txt {check_legality -verbose}
#@   #takes care the CTS spacer cells
#@   sh grep -v "cts_fill" ./temp_check_legality_v0.txt 1> ./temp_check_legality.txt
#@ 
#@   #check if no cells overlap ( count the number of lines in the ./temp_overlap.txt )
#@   set fd [open "./temp_check_legality.txt" "r"]
#@   set count 0;
#@   set pattern "overlaps with cell"
#@   while {[gets $fd line] > -1 } {
#@     set isMatch [string match *$pattern* $line]
#@     if { $isMatch != 0 } {
#@       incr count 1
#@     }
#@   }
#@   close $fd
#@ 
#@   echo $count
#@ 
#@ 
#@   if { $count == 0 } {
#@     P_msg_info " There is no overlapped cells "
#@   } else {
#@     #there is some overlap cells, now post process that cells
#@     sh grep "overlaps with cell" ./temp_check_legality.txt 1> ./temp_overlap.txt
#@     #create awk script for log file post processing
#@     set fd [open "./temp_post_process.awk" "w"]
#@     puts $fd "{ if (NF == 9 || NF == 8)"
#@     puts $fd "   print \$3;"
#@     puts $fd " else if (NF == 10) "
#@     puts $fd "   print \$5;"
#@     puts $fd "}"
#@     close $fd
#@     #run awk script
#@     sh awk -f ./temp_post_process.awk ./temp_overlap.txt  > ./temp_overlap_cell.txt
#@     #post-process the overlapped cells
#@     set list_overlap {}
#@     set fd [open "./temp_overlap_cell.txt" "r"]
#@     while {[gets $fd line] > -1} {
#@       lappend list_overlap $line
#@     }
#@     close $fd
#@     #print cell_type and cell name of overlapped cells
#@     foreach cell_overlap $list_overlap {
#@       set cell_name [get_attribute $cell_overlap full_name]
#@       set cell_type [get_attribute $cell_overlap ref_name]
#@       P_msg_error "Overlap Cell in place: $cell_type : $cell_name"
#@     }
#@     #remove all temporary files
#@     sh rm ./temp_check_legality_v0.txt
#@     sh rm ./temp_check_legality.txt
#@     sh rm ./temp_overlap.txt
#@     sh rm ./temp_overlap_cell.txt
#@     sh rm ./temp_post_process.awk
#@   }
#@   P_msg_info " Done: Checking for cell overlap "
#@ }
#@ 
#@ ##################################################################
#@ # Procedure   : P_check_cells
#@ # Description : This proc checks if specified cells are used in the list of instances.
#@ #               when given a list of reference cell names and a list of instances,
#@ #               if the instance cell matches any cell in the reference cell list,
#@ #               it flags it as a warning or error depending on the flag.
#@ # Usage: P_check_cells <ref_list> <inst_list> <msg> <flag>
#@ # Example: P_check_cells $ref_list $inst_list $msg $flag
#@ # $ref_list : list of cells to check
#@ # $inst_list : collection of instance to check
#@ # $msg: message prefix
#@ # $flag: indicates to print as warning or error (P_msg_warn or P_msg_err)
#@ ###################################################################
#@ 
#@ proc P_check_cells {ref_list inst_list msg flag} {
#@   P_msg_info "Checking cells in the design..."
#@   #collection of instances to check
#@   set coll_of_insts $inst_list
#@   #flag message depending on the flag value: Error or Warning
#@   if { $flag == "err" } {
#@     set flag_local "P_msg_error"
#@   } elseif { $flag == "warn" } {
#@     set flag_local "P_msg_warn"
#@   } else {
#@     set flag_local "P_msg_info"
#@   }
#@   set dont_use_list [list]
#@ 
#@   foreach cell $ref_list {
#@     if {$cell ne ""} {
#@       set pattern "(ref_name=~[join $cell {) || (ref_name =~} ])"
#@       lappend dont_use_list $pattern
#@     }
#@   }
#@   set dont_use_expr [join $dont_use_list || ]
#@   set ic_cntr  0
#@   foreach_in_collection c [get_cells $inst_list -filter "is_hierarchical==false && $dont_use_expr"  -quiet] {
#@     set c_name [get_attribute $c full_name]
#@     $flag_local "$c_name is a $msg [get_attribute $c ref_name]"
#@     incr ic_cntr
#@   }
#@ 
#@   if {!$ic_cntr} {
#@     P_msg_info "No dont_use cells found in your design"
#@   } else {
#@     $flag_local "$ic_cntr dont_use cells found in your design"
#@   }
#@ 
#@   P_msg_info "Done: Checking cells in the design..."
#@ }
#@ 
#@ define_proc_attributes P_check_cells     -info "Procedure to check if ref cells are used in the list of instances"
#@ 
#@ 
#@ ###########################################################################################
#@ # check if there are any shorts or opens or floating on power/ground nets
#@ # The script parse the verify_lvs reports
#@ # if there are any shorts/opens/floatings on PG, this script will issue an error message
#@ # if user see error message, user may look more detail on the verify_lvs reports
#@ 
#@ ###########################################################################################
#@ 
#@ proc P_check_power_ground_nets {} {
#@   P_msg_info "Check if there are any shorts or opens on power/ground nets"
#@ 
#@   #set DEBUG 1
#@   set DEBUG 0
#@   global INTEL_MW_POWER_NET INTEL_MW_GROUND_NET
#@ 
#@   set icc_pg_nets "$INTEL_MW_POWER_NET $INTEL_MW_GROUND_NET"
#@   redirect -file ./temp_verify_lvs_pg.txt {verify_lvs  -nets $icc_pg_nets }
#@ 
#@   set fd [open "./temp_verify_lvs_pg.txt" "r"]
#@   set err_count 0; set war_count 0;
#@   set pattern1 "Total Floating Nets are 1"
#@   set pattern2 "Total Floating Nets are 2"
#@   set pattern3 "Total SHORT Nets are 1"
#@   set pattern4 "Total SHORT Nets are 2"
#@   set pattern5 "Total OPEN Nets are 1"
#@   set pattern6 "Total OPEN Nets are 2"
#@ 
#@   while {[gets $fd line] > -1} {
#@     set isMatch1 [string match *$pattern1* $line]
#@     set isMatch2 [string match *$pattern2* $line]
#@     set isMatch3 [string match *$pattern3* $line]
#@     set isMatch4 [string match *$pattern4* $line]
#@     set isMatch5 [string match *$pattern5* $line]
#@     set isMatch6 [string match *$pattern5* $line]
#@     set errMatch [expr $isMatch3 || $isMatch4 || $isMatch5 || $isMatch6]
#@     set warMatch [expr $isMatch1 || $isMatch2]
#@     if { $errMatch != 0 } {
#@       incr err_count 1;
#@     }
#@     if { $warMatch != 0 } {
#@       incr war_count 1;
#@     }
#@   }
#@   close $fd
#@ 
#@   if {$DEBUG} {puts $err_count}
#@ 
#@   if { $err_count > 0 } {
#@     P_msg_error " Power/Ground net has short/open\n                Please review the verify_lvs reports for more information"
#@   }
#@   if { $war_count > 0 } {
#@     P_msg_warn " Power/Ground net has floating\n                Please review the verify_lvs reports for more information"
#@   }
#@ 
#@   #unset temporary variables
#@   unset -nocomplain pattern1 pattern2 pattern3 pattern4 pattern5 pattern6 isMatch1 isMatch2 isMatch4 isMatch5 isMatch6 anyMatch count icc_pg_nets fd
#@   #remove all temporary files
#@   sh rm ./temp_verify_lvs_pg.txt
#@   P_msg_info "Done: Check if there are any shorts or opens on power/ground nets"
#@ 
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## End Of File
#@ ## -----------------------------------------------------------------------------
#@ 
#@ puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/common/procs.tcl

#@ 
#@ # To setup all blocks, global variables used in the flow.
#@ P_source_if_exists project_setup.tcl -require
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/project_setup.tcl

#@ ##############################################################################
#@ 
#@ ####################################
#@ # Flow Vars
#@ ####################################
#@ 
#@ # Synthesis flow vars
#@ # To add an extra step to the flow update the *_STEPS var to add the new step
#@ # Also define *_SUBSTEPS(<new step>) to include the tcl files that need to be sourced during that step
#@ 
#@ set INTEL_SYN_STEPS {read_design read_constraints compile insert_dft inc_compile}
#@ 
#@ set INTEL_SYN_SUBSTEPS(read_design)           { read_design }
#@ set INTEL_SYN_SUBSTEPS(read_constraints)      { read_constraints read_phys_constraints create_scenarios }
#@ set INTEL_SYN_SUBSTEPS(compile)               { compile_prep create_path_group compile }
#@ set INTEL_SYN_SUBSTEPS(insert_dft)            { insert_dft }
#@ set INTEL_SYN_SUBSTEPS(inc_compile)           { compile_prep inc_compile change_names }
#@ 
#@ # APR Flow vars
#@ 
#@ set INTEL_APR_STEPS {import_design floorplan place post_place cts route post_route adr fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(import_design)      { dont_use import_design read_constraints create_scenarios create_path_group derive_pg}
#@ 
#@ set INTEL_APR_SUBSTEPS(floorplan)          { dont_use tool_constraints init_floorplan set_wiretracks macro_placement halo_d04 derive_pg create_power_straps interface_metals isolated_pin_extension io_placement add_tap_cells insert_antenna_diodes_on_input pre_place_fiducial_d04 pre_place_bonus_fib_d04 create_check_grid check_floorplan derive_pg }
#@ 
#@ set INTEL_APR_SUBSTEPS(place)              { dont_use tool_constraints cmax_interpolate set_ideal_clock_network cell_spacing_d04 layer_promotion place_opt  check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(post_place)         { dont_use tool_constraints cmax_interpolate psynopt insert_spare_kit check_place derive_pg change_names}
#@ 
#@ set INTEL_APR_SUBSTEPS(cts)                { dont_use tool_constraints cmax_interpolate cts_ndr_rules cts_options create_route_guides remove_ideal_clock_network cts add_pg_hookup route_options_drc redundant_via_insertion clock_route create_clock_shield remove_pg_hookup freeze_clock_nets update_clocks check_cts derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(route)              { dont_use tool_constraints cmax_interpolate route_options route_options_drc report_pre_route route_trackassign add_pg_hookup initial_detailroute incr_create_clock_shield verify_zrt_route derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(post_route) { dont_use tool_constraints cmax_interpolate route_options  route_options_drc antenna_rules remove_pg_hookup incr_route_opt insert_antenna_diodes_on_input tie_high incr_eco_detail_route opportunistic_local_fiducial_place incr_create_clock_shield add_filler_cells_d04 derive_pg add_pg_hookup incr_detailroute verify_zrt_route derive_pg check_route change_names }
#@ 
#@ #set INTEL_APR_SUBSTEPS(focal_opt)          { dont_use tool_constraints cmax_interpolate route_options route_options_drc remove_pg_hookup focal_opt incr_create_clock_shield inc_add_filler_cells_d04 add_pg_hookup focal_opt_cleanup derive_pg check_route change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(adr)                { dont_use tool_constraints route_options route_options_drc adr derive_pg}
#@ 
#@ set INTEL_APR_SUBSTEPS(fill)               { dont_use check_fill_view metal_via_fill create_port_layer }
#@ 
#@ # TO run UPF flow uncomment the APR_STEPS line below
#@ #set INTEL_APR_STEPS {import_design upf_floorplan upf_place upf_post_place cts route upf_post_route adr fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_floorplan)      { dont_use tool_constraints init_floorplan set_wiretracks macro_placement halo_d04 halo_power_voltage_island derive_pg create_power_switch connect_power_switch derive_pg create_ls_bounds create_power_plan compile_power_plan connect_sec_pg_power_switch interface_metals isolated_pin_extension io_placement add_tap_cells insert_antenna_diodes_on_input pre_place_fiducial_d04 pre_place_bonus_fib_d04 create_check_grid check_floorplan derive_pg }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_place)              { dont_use tool_constraints cmax_interpolate set_ideal_clock_network upf_sec_pg_hookup magnet_placement cell_spacing_d04 layer_promotion place_opt  check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_post_place)          { dont_use tool_constraints cmax_interpolate psynopt insert_spare_kit upf_sec_pg_hookup route_upf_ao_pg check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_post_route)          { dont_use tool_constraints cmax_interpolate route_options route_options_drc antenna_rules remove_pg_hookup incr_route_opt insert_antenna_diodes_on_input tie_high incr_eco_detail_route opportunistic_local_fiducial_place add_filler_cells_d04 derive_pg upf_sec_pg_hookup route_upf_ao_pg add_pg_hookup incr_detailroute verify_zrt_route derive_pg check_route change_names }
#@ 
#@ # To Run ECO flow uncomment the INTEL_APR_STEPS line below
#@ #set INTEL_APR_STEPS {eco fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(eco)                { dont_use tool_constraints cmax_interpolate route_options route_options_drc eco_remove_filler remove_pg_hookup eco derive_pg eco_legalize_placement add_filler_cells_d04 route_eco add_pg_hookup incr_detailroute verify_zrt_route change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(metal_only_eco)     { dont_use tool_constraints cmax_interpolate route_options route_options_drc metal_only_eco verify_zrt_route change_names }
#@ 
#@ ####################################
#@ #Path Settings
#@ ####################################
#@ 
#@ set fdk_lib                     d04
#@ set fdk_stdcells_sp_dir         $env(INTEL_STDCELLS)
#@ set fdk_stdcells_misc_dir       $env(INTEL_STDCELLS_MISC)
#@ set fdk_asic_flows_dir          $env(INTEL_ASIC)/asicflows/synopsys
#@ set fdk_icv_fill_dir            $env(INTEL_PDK)/fill/icv
#@ set fdk_icv_adr_dir             $env(INTEL_PDK)/runsets/adr
#@ set fdk_star_ext_tech_dir       $env(INTEL_PDK)/extraction/starrc/cmdfiles
#@ set fdk_icc_ext_tech_dir        $env(INTEL_PDK)/extraction/icc/techfiles
#@ set fdk_icc_tech_dir            $env(INTEL_PDK)/apr/icc/
#@ 
#@ ######################################
#@ #Library Variables
#@ ######################################
#@ 
#@ # Variable used to set operating condition. Valid values are bc_wc, on_chip_variation.
#@ set INTEL_ANALYSIS_TYPE             "bc_wc"
#@ 
#@ # Max and Min operating condition used during set_operating_condition setting
#@ set INTEL_MAX_OPCON           slow_1.00
#@ if {$synopsys_program_name == "icc_shell" } {
#@   set INTEL_MIN_OPCON       fast_1.00
#@ } elseif {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell" } {
#@   set INTEL_MIN_OPCON       slow_1.00
#@ }
#@ 
#@ # Include the names of all memories, io's etc to be used in the block. An example is given below
#@ # set INTEL_HARD_MACRO_NAME         [list c69p0rgf1r1w4t128x34 c69p0ssa2048x52cm4]
#@ 
#@ 
#@ #######################################
#@ #Tech File Variables
#@ #######################################
#@ 
#@ set INTEL_GDS_OUT_LAYER_MAP       $fdk_icc_tech_dir/1273Milkyway2GdsLayerMap
#@ set INTEL_MW_TECH_FILE            $fdk_icc_tech_dir/${fdk_lib}/p1273.tf
#@ set INTEL_MAX_TLUPLUS_FILE        $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.tluplus
#@ set INTEL_MIN_TLUPLUS_FILE        $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.tluplus
#@ set INTEL_TLUPLUS_MAP_FILE        $fdk_star_ext_tech_dir/asic.starrc.map
#@ set INTEL_MAX_TLUPLUS_EMUL_FILE   $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.mfill.tluplus
#@ set INTEL_MIN_TLUPLUS_EMUL_FILE   $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.mfill.tluplus
#@ 
#@ ########################################
#@ #Design Variables:
#@ ########################################
#@ 
#@ ############SYN, APR and PV#############
#@ ########################################
#@ 
#@ # Top level block name for Physical Design
#@ set INTEL_DESIGN_NAME   ""
#@ 
#@ # Modular grid x and y
#@ set INTEL_MD_GRID_X                 1.680
#@ set INTEL_MD_GRID_Y                 1.596
#@ 
#@ # Max and min routing layers. These variables are used by set_ignored_layers icc command and various other tcl scripts.
#@ set INTEL_MAX_ROUTING_LAYER                  "m8"
#@ set INTEL_MIN_ROUTING_LAYER                  "m0"
#@ set INTEL_RC_IGNORE_LAYERS                   "m0 tm1"
#@ # Override the min routing layer contraint during placement only. Used in tool_constraints.tcl.
#@ # This has proven to improve post route QOR by reducing RC in placement.
#@ set INTEL_MIN_ROUTING_LAYER_OVERRIDE(place)           "m2"
#@ set INTEL_MIN_ROUTING_LAYER_OVERRIDE(post_place)      "m2"
#@ 
#@ # MW Power net Name
#@ set INTEL_MW_POWER_NET    vcc
#@ set INTEL_MW_GROUND_NET   vss
#@ 
#@ # Variable to enable the usage of SDC file. If set to 1, read ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc. If set to 0, read ./inputs/constraints/clocks.tcl and ./inputs/constraints/constraints.tcl
#@ set INTEL_SDC_FILE      0
#@ 
#@ 
#@ # Variable to use scan flops or not (if 1, compile -scan otherwise -scan is not used). If var set to 1 then, Synthesis will run compile -scan and compiled netlist will have scan flops.
#@ set INTEL_SCAN_REPLACE_FLOPS 1
#@ 
#@ #Variable to insert scan chain, if set to 1, DC will insert scan chain and  write out ./outputs/${INTEL_DESIGN_NAME}.scandef. APR will read in ./inputs/${INTEL_DESIGN_NAME}.scandef and run place_opt -optimize_dft
#@ set INTEL_INSERT_SCAN   0
#@ 
#@ # If set to 1, enables UPF flow for synthesis and APR.
#@ set INTEL_UPF     0
#@ 
#@ # Set RTL & post-synthesis UPF version, either 1.0 or 2.0.
#@ set INTEL_UPF_VERSION   1.0
#@ 
#@ # Set the list of nets incase of UPF design
#@ set INTEL_UPF_POWER_NETS {vss vcc}
#@ 
#@ # If set to 1, synthesis and APR flow will read ./inputs/constraints/${INTEL_DESIGN_NAME}.saif and optimizes dynamic power.
#@ set INTEL_SAIF      0
#@ 
#@ # Variable used to define the hierarchical instance (top/instA) for which switching activity is annotated. If not defined then top level design name will be assumed
#@ set INTEL_SAIF_INSTANCE   ""
#@ 
#@ # SPECIFY DEFAULT SWITCHING ACTIVITY for VECTOR-FREE power analysis and dynamic power optimization.
#@ # Use these variables to set switching activity for dynamic power optimization if not using SAIF.
#@ # Annotate a suitable default Toggle Rate value and Static Probability, for example, 0.2 to all the starting points.
#@ set INTEL_POWER_TR 0.2
#@ set INTEL_POWER_SP 0.3
#@ 
#@ ############SYN Specific################
#@ ########################################
#@ 
#@ # If set to 1 then DC will read the .def file for floorplan from ./inputs/floorplan/${INTEL_DESIGN_NAME}.def
#@ set INTEL_TOPO_DEF      0
#@ 
#@ # Variable to set insert_clock_gating (if 1 then insert_clock_gating and compile_ultra -clock_gate is used)
#@ set INTEL_INSERT_CLOCKGATES         1
#@ 
#@ # Set to 1, to invoke synopsys physical guidance to generate ddc/mwdb for seed placement to APR. DEF file must be provided and INTEL_TOPO_DEF set to 1.
#@ set INTEL_SPG                       0
#@ 
#@ # Set to 1, to enable congestion optimization
#@ set INTEL_CONGESTION_OPTIMIZE       0
#@ 
#@ # If set to 1 then ICC will read .ddc file from ./inputs/${INTEL_DESIGN_NAME}.syn.ddc
#@ set INTEL_DDC                       0
#@ 
#@ ###########APR Specific #################
#@ #####################################################################
#@ 
#@ #Input file name variables - Provide full paths to file names. Examples provided below.
#@ #Note - if variable not set, default path and filename (as shown in example below) will be assumed.
#@ 
#@ # set INTEL_INPUT_NETLIST ./inputs/<INTEL_DESIGN_NAME>.syn.vg
#@ # set INTEL_INPUT_SCANDEF ./inputs/<INTEL_DESIGN_NAME>.syn.scandef
#@ # set INTEL_INPUT_DEF ./inputs/floorplan/<INTEL_DESIGN_NAME>.floorplan.def
#@ # set INTEL_INPUT_UPF ./inputs/upf/<INTEL_DESIGN_NAME>.syn.upf
#@ # set INTEL_INPUT_SDC ./inputs/constraints/<INTEL_DESIGN_NAME>.sdc
#@ 
#@ ########## Main Command Variables ###################################
#@ # The following variables set the options to main APR commands like place_opt, psynopt, etc
#@ 
#@ # place_opt.tcl may append additional switches "-power", "-layer_optimization", "-optimize_dft" or "-spg" conditionally based on other INTEL_* conrol vars.
#@ set INTEL_PLACE_CMD "place_opt -congestion -effort medium"
#@ 
#@ # used in psynopt.tcl
#@ set INTEL_POST_PLACE_CMD "psynopt -area_recovery -power -congestion"
#@ 
#@ # used in cts.tcl
#@ set INTEL_CLK_OPT_CMD "clock_opt -only_cts -no_clock_route -power"
#@ set INTEL_POST_CTS_OPT_CMD "psynopt -only_hold_time"
#@ 
#@ # route_trackassign.tcl may append "-power" switch conditionally based on other INTEL_* conrol vars.
#@ set INTEL_ROUTE_TRACK_ASSIGN_CMD "route_opt -stage track -effort medium -xtalk_reduction"
#@ 
#@ # used in initial_detailroute.tcl
#@ set INTEL_INITIAL_DETAIL_ROUTE_CMD "route_opt  -initial_route_only -stage detail"
#@ 
#@ # used in incr_route_opt.tcl
#@ set INTEL_INCR_ROUTE_OPT_CMD "route_opt -incremental -xtalk_reduction -power"
#@ 
#@ # used in incr_eco_detail_route.tcl
#@ set INTEL_INCR_ECO_DETAIL_ROUTE_CMD "route_zrt_eco -open_net_driven true -reroute modified_nets_first_then_others; route_zrt_detail -incremental true"
#@ 
#@ # used in incr_detailroute.tcl
#@ set INTEL_INCR_DETAIL_ROUTE_OPT_CMD "route_zrt_detail -incremental true -max_number_iterations 45"
#@ 
#@ # if additional focal_opt fixing needs to be done please update variable and add necessary focal_opt commands
#@ #set INTEL_FOCAL_OPT_CMD "focal_opt -power; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_power"
#@ # for example if drc fixing needs to be done apart from power, variable can be udpated as below
#@ # set INTEL_FOCAL_OPT_CMD "focal_opt -drc_pins all; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_drc; focal_opt -power; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_power"
#@ 
#@ # Set this according to focal_opt being done, if just -power is used, incr route may not be needed. If using other modes you will need to do incr routing.  
#@ # used in focal_opt_cleanup.tcl
#@ #set INTEL_POST_FOCAL_OPT_ROUTE_CMD "verify_zrt_route"
#@ # Example showing incr routing done for non -power focal_opt modes.
#@ # set INTEL_POST_FOCAL_OPT_ROUTE_CMD "verify_zrt_route;route_zrt_detail -incremental true"
#@ 
#@ # Set to 1 to enable dynamic power optimization in ICC
#@ set INTEL_DYNAMIC_POWER 0
#@ 
#@ #############PG Hookup##################
#@ 
#@ ## Boundary net info file are used by the tcl/binary based pg hookup flow. Not needed by runset based flow.
#@ set INTEL_PWR_HOOKUP_ATTRIB [list $fdk_stdcells_sp_dir/utilities/d04_p1273.4_c.0_all_boundary_net_info.txt                                  $fdk_stdcells_misc_dir/utilities/d04_misc_p1273.4_c.0_all_boundary_net_info.txt]
#@ 
#@ ## Runset based needed variables.
#@ set INTEL_PWR_HOOKUP_GRID_COUNT              4
#@ set INTEL_PWR_HOOKUP_LAYERS                  "vcn tcn gcn m0 v0 m1 v1"
#@ set INTEL_PWR_HOOKUP_DH_BONUS_CELLS_LIST     {c04bfy??????? d04bfy???????}
#@ set INTEL_PWR_HOOKUP_CELLS_LIST              {*c04?????[^grx]???? *d04?????[^grx]????}
#@ set INTEL_PWR_HOOKUP_CELLS_LIST_XN           {*d04?????x????}
#@ set INTEL_PWR_HOOKUP_REMOVAL_COMPATIBILITY   1
#@ 
#@ set INTEL_PROCESS_NAME p1273
#@ set INTEL_STDCELL_TILE_HEIGHT 0.399
#@ set INTEL_FLIP_FIRST_ROW 0
#@ set INTEL_XN_LIBRARY 0
#@ 
#@ # The following variables are also used, but defined in other parts of project_setup.tcl, by the runset based pg hookup.
#@ # INTEL_UPF, INTEL_MW_POWER_NET, INTEL_MW_GROUND_NET, INTEL_STDCELL_TILE, INTEL_DFM_RELEASE_DIR
#@ 
#@ 
#@ #############Floorplan##################
#@ 
#@ set INTEL_FP_INPUT                 "" ; # DEF(import fp def)|FP_TCL(import fp tcl)|""
#@ set INTEL_DESIGN_WIDTH             "";  #must be set by user for each design
#@ set INTEL_DESIGN_HEIGHT            "";  #must be set by user for each design
#@ 
#@ # Example
#@ # set INTEL_FP_BOUNDARY             "{{0.000 0.000} {2138.112 0.000} {2138.112 1804.032} {409.248 1804.032} {409.248 651.456} {0.000 651.456} {0.000 0.000}}";
#@ 
#@ set INTEL_METAL_LAYERS {m2 m3 m4 m5 m6 m7 m8 m9}
#@ set INTEL_MAX_PG_LAYER "m9"
#@ 
#@ set INTEL_STDCELL_TILE                   "core"
#@ set INTEL_STDCELL_BONUS_GATEARRAY_TILE   "bonuscore"
#@ set INTEL_STDCELL_CORE2H_TILE            "core2h"
#@ 
#@ # List of halo cells to be used during halo insertion
#@ set INTEL_halo_b_horiz         "fdk73d84_asic_halo_hhb"
#@ set INTEL_halo_c_horiz         "fdk73d84_asic_halo_hhc"
#@ set INTEL_halo_b_corner        "fdk73d84_asic_halo_hcb"
#@ set INTEL_halo_c_corner        "fdk73d84_asic_halo_hcc"
#@ set INTEL_halo_b_inside_corner "fdk73d84_asic_halo_hib"
#@ set INTEL_halo_c_inside_corner "fdk73d84_asic_halo_hic"
#@ set INTEL_halo_side            "fdk73d84_asic_halo_hvn"
#@ set INTEL_halo_power_cell      "fdk73d84_asic_halo_hvniso"
#@ 
#@ # Tap cell to be used during tap cell insertion
#@ set INTEL_TAP_CELL                       "${fdk_lib}tap02ldz05"
#@ 
#@ # Sets the terminal length for each metal layer for use in P_create_pg_terminals procedure during FRAM generation.
#@ set INTEL_TERM_LENGTH "m1 0.070 m2 0.084 m3 0.084 m4 0.084 m5 0.084 m6 0.160 m7 0.204 m8 0.274 m9 0.540"
#@ 
#@ #Create route guides over specified macros
#@ #------------------------------------------
#@ #1. Route Guides will be created only on layers m0-m4 and layers containing macro pins.
#@ #2. Route guides should be provided in the format <layer_name> <x_bloat_val> <y_bloat_val>
#@ #3. Both x and y bloat values should be provided. Either both x and y bloat should be NA (or) both x and y bloat should be a double value.
#@ #4. If both x_bloat_val and y_bloat_val equal 0, RGs will be created the exact size of the macro
#@ #5. If both x_bloat_val and y_bloat_val equal NA, RGs will not be created for that layer
#@ #6. Use INTEL_MACRO_RG_LIST(DEFAULT) to specify the default bloat values to use for all macros
#@ #7. Use INTEL_MACRO_RG_LIST(<macro_ref_name>) to override the default bloat values for the specified <macro_ref_name>
#@ #8. Use INTEL_MACRO_EXCLUSION_LIST to specify macros which should be completely excluded from creating RGs.
#@ 
#@ #Note: (E2E Spacing) - (MinSpacing value of layer in techfile) = (Bloat Value of route guide outside macro boundary)
#@ #FYI: Pre-calculated Bloat values for all layers based on M*_41 (E2E spacing) and MinSpacing value in Techfile.
#@ #set INTEL_MACRO_RG_LIST(DEFAULT)  "m2  0.032  0      m3  0  0.032  \   
#@ #                                   m4  0.032  0      m5  0  0.032  #                                   m6  0.040  0      m7  0  0.034  #                                   m8  0.014  0      m9  NA NA"
#@ 
#@ set INTEL_MACRO_RG_LIST(DEFAULT) "m2  0.032 0      m3  0  0.032     m4  0.032 0                                   m5  0     0.032  m6  NA NA        m7  NA    NA                                   m8  NA    NA     m9  NA NA"
#@ 
#@ #The example below shows how to override default RG values for macro reference (iromu1r0w6144d16w1spu0p) for layers m4 and m5.
#@ #set INTEL_MACRO_RG_LIST(iromu1r0w6144d16w1spu0p) "m4 0.10 -0.10 m5 -0.210 -0.210"
#@ 
#@ #The example below shows how to completely exclude some macro references.
#@ #set INTEL_MACRO_EXCLUSION_LIST [list iromu1r0w6144d16w1spu0p iromu1r0w6144d16w1spu1p]
#@ 
#@ # Enable bonus gate array cel pre-placement
#@ set INTEL_INSERT_BONUS_GATE_ARRAY 1
#@ 
#@ # Set pre-placement bonus array cell
#@ set INTEL_PREPLACE_BONUSGATEARRAY_CELL "${fdk_lib}bar00nnz64"
#@ 
#@ #Update the list of ports where you don't need diode insertion
#@ set INTEL_NO_INPUT_DIODE_PORTS ""
#@ 
#@ ############### LOCAL FIDUCIALS ##########################
#@ # 2x fiducial cells are placed spaced apart in staggered  fashion, the follwing variables control the fiducial cell being placed.
#@ set INTEL_LOCAL_FIDUCIAL_PREPLACE_CELL "d04qfd02ndz00"
#@ 
#@ # These cells are placed opportunistically post-route
#@ set INTEL_LOCAL_FIDUCIAL_POSTROUTE_CELLS "d04qfd02nnz00 d04qfd01ndz00"
#@ 
#@ 
#@ ################# UPF Specific variables ############################
#@ 
#@ ####################################################################################
#@ # Sets up the UPF flow specific variables
#@ # These are only block independent vars. You may need to setup block specific vars
#@ # Example of a block specfic block_setup.tcl is provided with the DHM testcase.
#@ ####################################################################################
#@ 
#@ ###################################
#@ # Generic variables
#@ ###################################
#@ 
#@ # Select the UPF power plan to use if $INTEL_UPF == 1.
#@ set INTEL_POWER_PLAN mesh_upf_1aosv
#@ 
#@ # Sets default values for Power Switch. All the values provided below are the default values. User can override these variables locally in block_setup.tcl on a per domainn basis.
#@ 
#@ # Defines the power switch lib cell to use. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_POWER_SWITCH(default) d04pws00ld8b0
#@ 
#@ # Sets the x and y pitch of Power switch used for create_power_switch_array command. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_PS_X_PITCH(default) 13.44
#@ set INTEL_PS_Y_PITCH(default) 9.576
#@ 
#@ # Set the connect configuration for Power switch enables. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_PS_CONNECT_CONFIG(default) "daisy"
#@ set INTEL_PS_CONNECT_CORNER(default) "lower_left"
#@ 
#@ # The following variables(INTEL_PS_ALIGN_METAL_*) are used by the flow to calculate lower_left offset of power switches w.r.to the voltage area.
#@ # The values provided below are offset values of AON Power straps for the layer specified.
#@ # These values are used to align the Power Switch cells under m7 and m6.
#@ # Users are not needed to change these values unless the Power Strap offsets/pitch is updated (or) users want to align the power swtich cells differently and not under m6/m7 AON straps
#@ 
#@ # The offset value provides the offset values for AON power straps in the same order as the INTEL_UPF_POWER_NETS. The value also changes for singe supply vs dual supply grids. The variable is indexed accordingly
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_2aosv,m7) {0.896 1.344 2.464}
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_1aosv,m7) {0.896 2.464}
#@ 
#@ # The pitch value provides the pitch of AON power straps for which the offset is provided above.
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_2aosv,m7) 6.72
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_1aosv,m7) 6.72
#@ 
#@ # Values for m6 AON straps
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_2aosv,m6) {0.336 0.672 2.520}
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_1aosv,m6) {0.336 1.932}
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_2aosv,m6) 3.192
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_1aosv,m6) 3.192
#@ 
#@ # Values for power switch offset for top/right boundary. The left/bottom offset is calculated by flow based on INTEL_PS_ALIGN_METAL_* values provided above.
#@ # For a non-zero value, the insertion region for power switches is shrinked from the voltage area boundary by the offset value provided below.
#@ set INTEL_PS_RIGHT_OFFSET 0
#@ set INTEL_PS_TOP_OFFSET 0
#@ 
#@ # Users can create Level shifter bounds and assign level shifters cells to these bounds.
#@ # All Always-on straps are distributed over these bounds to enable seconday PG hookup for Level shifter cells.
#@ # Users need to set the variables following the constraints provided.
#@ 
#@ # NOTE: Side margins for VA bands start from lower left-most side of voltage area of $power_domain in clockwise order, and must be 0 or positive numbers on grids of horizontal placement width for vertical sides and double-row height for horizontal sides.
#@ # NOTE: Number of margins must match the sides of voltage area of $power_domain.
#@ # NOTE: VA band width should be at least widths of vertical halo cell + widest isolation or level-shifter cells used.
#@ # NOTE: VA band height should be at least 2 rows as the lwevel shifter cells are double height cells.
#@ 
#@ # NOTE: INTEL_LS_BOUND_CELLS($power_domain,<inner/outer>) must match cells of level shifter with parent/self location of $power_domain specified in UPF.
#@ 
#@ #set INTEL_LS_BOUND(pd_sleep1,inner) "0 0 $band_width 0"
#@ #set INTEL_LS_BOUND_CELLS(pd_sleep1,inner) u_dhm_unit_1/u_dhm_bypass/u_dhm_sleep_logic/*_UPF_LS
#@ 
#@ # Set name of templates to use from template file
#@ # The template name values provided below are for the default templates provided with the kit. Users are expected to update this list only if they change template names/add additional templates.
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,top) {common common_second_swap}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,always_on) {always_on_swap always_on always_on_second always_on_third}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,primary) {primary primary_second primary_third}
#@ 
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,top) {common common_second_swap}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,always_on) {always_on always_on_second_vss}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,primary) {primary primary_second primary_second_swap primary_second_power}
#@ 
#@ 
#@ ###############################################
#@ # Variables used for Secondary PG hookup
#@ ###############################################
#@ 
#@ #Note - Use 1aosv if $INTEL_POWER_PLAN is set to mesh_upf_1aosv. Use 2aosv if $INTEL_POWER_PLAN is set to mesh_upf_2aosv.
#@ #none implies default params applied across the entire design. Specify <va_name> to override params for a specific voltage area.
#@ 
#@ # INTEL_PWRGRID_PARAMS_PRIMARY(1aosv/2aosv, <va_name>/none) "<layer> <width> <pitch> <offset>"
#@ 
#@ set INTEL_PWRGRID_PARAMS_PRIMARY(1aosv,none)  "m4b 0.076 6.384 5.090                                                m4a 0.076 6.384 2.890                                                m4  0.084 6.384 0.798                                                m3  0.084 1.680 1.288"
#@ 
#@ set INTEL_PWRGRID_PARAMS_PRIMARY(2aosv,none)   "m4b 0.084 9.576 7.182                                                 m4a 0.084 9.576 3.990                                                 m4  0.084 9.576 0.798                                                 m3  0.084 1.680 1.288"
#@ 
#@ # INTEL_PWRGRID_PARAMS_PRIMARY(1aosv/2aosv, <index>, <va_name>/none) "<layer> <width> <pitch> <offset>"
#@ # index implies index value of the AON net in INTEL_UPF_POWER_NETS.
#@ # Eg. INTEL_UPF_POWER_NETS is [list vss vcc vccL]. To specify params for vcc AON, use index 1. To specify params for vccL AON, use index 2.
#@ 
#@ set INTEL_PWRGRID_PARAMS_AON(1aosv,1,none)    "m4b 0.076 6.384 6.082                                                m4a 0.084 6.384 3.990                                                m4  0.076 6.384 1.898                                                m3  0.084 1.680 1000000.0"
#@ set INTEL_PWRGRID_PARAMS_AON(2aosv,1,none)     "m4b 0.076 9.576 8.282                                                 m4a 0.076 9.576 5.090                                                 m4  0.076 9.576 1.898                                                 m3  0.084 1.680 1000000.0"
#@ set INTEL_PWRGRID_PARAMS_AON(2aosv,2,none)     "m4b 0.076 9.576 9.274                                                 m4a 0.076 9.576 6.082                                                 m4  0.076 9.576 2.890                                                 m3  0.084 1.680 1000000.0"
#@ 
#@ ################################################
#@ # Variables used for Frequency based Max-Cap LUT
#@ ################################################
#@ #Location of Max-Cap LUT CSV file
#@ set INTEL_CMAX_LUT $env(INTEL_STDCELLS)/erc/stdcell73_3x1r6u1_d04_rv_allfreq.csv
#@ 
#@ #Clock period to use if min clock period could not be determined
#@ set INTEL_CMAX_DEFAULT_PERIOD 1500.00
#@ 
#@ #############Placement##################
#@ 
#@ set INTEL_CRITICAL_RANGE           "2000";
#@ set INTEL_AREA_CRITICAL_RANGE      "not_set";
#@ set INTEL_POWER_CRITICAL_RANGE     "not_set";
#@ set INTEL_TIE_HIGH_CELL            "${fdk_lib}tih00wnz00"
#@ set INTEL_TIE_LOW_CELL             "${fdk_lib}til00wnz00"
#@ 
#@ set INTEL_INSERT_SPARE_KITS        "0"
#@ set INTEL_SPARE_CELLS              "${fdk_lib}nan02ln0b5 ${fdk_lib}nan02ln0c0 ${fdk_lib}nan02ln0d0 ${fdk_lib}non02ln0b5 ${fdk_lib}non02ln0c0 ${fdk_lib}non02ln0c5 ${fdk_lib}inn00ln0a5 ${fdk_lib}inn00ln0b5"
#@ set INTEL_DIST_BTW_SPARE_KITS      "30";
#@ 
#@ ## Set to 1 to enable Layer Promotion
#@ set INTEL_LAYER_PROMOTION           0
#@ 
#@ # Set to "magnet" for magnet placement, "port" for placing cells close to ports and "" to let place_opt place the iso cells.
#@ set INTEL_ISOCELL_PLACER            ""
#@ 
#@ ################CTS#####################
#@ 
#@ set INTEL_CTS_NETS                          ""
#@ set INTEL_CTS_MAX_ROUTING_LAYER(DEFAULT)    "m8"
#@ set INTEL_CTS_MIN_ROUTING_LAYER(DEFAULT)    "m6"
#@ set INTEL_CTS_LEAF_MIN_LAYER                "m6"
#@ set INTEL_CTS_LEAF_MAX_LAYER                "m7"
#@ set INTEL_ENABLE_CLOCK_SPACING              "1" ; #Enables/disables clock cell spacing for IR/EM
#@ set INTEL_CTS_MAX_FANOUT                    "24"
#@ set INTEL_CTS_ADVANCED_DRC_FIXING           "true"
#@ 
#@ ######################################
#@ # CTS NDR SETUP
#@ ######################################
#@ set INTEL_ENABLE_CLOCK_NDR "1"
#@ set INTEL_CTS_NDR_RULE(DEFAULT) "ndr_defaultW_3T_noSh_Lth"
#@ 
#@ ########################################################################
#@ # NDR definitions for each clock in the design
#@ #   Note - If INTEL_ENABLE_CLOCK_NDR is set to '0', then default routing
#@ #          rules are used for clocks
#@ ########################################################################
#@ #set INTEL_CTS_NDR_RULE(clk) "2xSpacing"
#@ #set INTEL_CTS_MAX_ROUTING_LAYER(clk) "m8"
#@ #set INTEL_CTS_MIN_ROUTING_LAYER(clk) "m7"
#@ 
#@ set INTEL_CTS_CELLS_DEFAULT "${fdk_lib}gbf00nd0* ${fdk_lib}gin00nd*"
#@ set INTEL_CTS_CELLS_SIZE "${fdk_lib}gbf00nd0* ${fdk_lib}gin00nd* ${fdk_lib}cgc01nd* ${fdk_lib}cgc03nd*                           ${fdk_lib}cgc00nd* ${fdk_lib}cgc02nd* ${fdk_lib}cgm22nd*                           ${fdk_lib}gan10nd* ${fdk_lib}gan20nd*                           ${fdk_lib}gan30nd* ${fdk_lib}gan40nd*                           ${fdk_lib}gmx22nd* ${fdk_lib}gna00nd*                           ${fdk_lib}gna02nd* ${fdk_lib}gno00nd*                           ${fdk_lib}gno02nd* ${fdk_lib}gor00nd*"
#@ set INTEL_CTS_CELLS_DELAY_INSERT "${fdk_lib}gbf10nd* ${fdk_lib}gbf20nd* ${fdk_lib}gbf30nd* ${fdk_lib}gin20nd*"
#@ set INTEL_CTS_CELL_BOUNDARY "${fdk_lib}gbf00nd0h0"
#@ 
#@ ##############Routing###################
#@ 
#@ set INTEL_ZROUTE_FIX_ANTENNA       1
#@ set INTEL_ZROUTE_VIA_DBL           "1"     ;# Redundant via insertion
#@ set INTEL_ANTENNA_DIODE            "${fdk_lib}gnc01lnz00"
#@ set INTEL_DELAY_CELL_LIST          "${fdk_lib}bfn11wn* ${fdk_lib}bfn12wn* ${fdk_lib}bfn13wn*"
#@ 
#@ #############Filler cells###############
#@ 
#@ set INTEL_BONUS_GATEARRAY_CELLS    "${fdk_lib}bar00nnz64 ${fdk_lib}bar00nnz32 ${fdk_lib}bar01nnz16 ${fdk_lib}bar01nnz08 ${fdk_lib}bar01nnz04"
#@ set INTEL_STDCELL_FILLER_CELLS     "${fdk_lib}spc00nnz03 ${fdk_lib}spc00nnz02 ${fdk_lib}spc00nnz01"
#@ set INTEL_DECAP_CELLS              "${fdk_lib}dcp00wnz08 ${fdk_lib}dcp00wnz04"
#@ set INTEL_2X_DECAP_CELLS           "${fdk_lib}dcp00wdz64"
#@ 
#@ # Set this switch to pick type of fillers, valid options are default & decap. Please refer add_filler_cells.tcl for more details
#@ set INTEL_STDCELL_FILLER_MODE decap
#@ 
#@ ############Metal/via fill##############
#@ 
#@ set INTEL_DFM_RELEASE_DIR   $fdk_icv_fill_dir
#@ set INTEL_DFM_UIN_DIR       $INTEL_DFM_RELEASE_DIR/uin/${fdk_lib}
#@ set INTEL_DFM_WRITE_MW_OUTPUT true
#@ set INTEL_DFM_ZONE_VIA_FILL true
#@ set INTEL_DFM_MAX_FILL_LAYER "m9"
#@ 
#@ ################ ADR ###################
#@ 
#@ set INTEL_ADR_RELEASEPATH $fdk_icv_adr_dir
#@ set INTEL_ADR_RUNSET_FILE "$INTEL_ADR_RELEASEPATH/adr.rs"
#@ # Sets pointer to configuration file that defines DRCs to target
#@ set INTEL_ADR_CONFIG_FILE "$INTEL_ADR_RELEASEPATH/adr.cfg"
#@ set INTEL_ADR_USER_DEF_OPT "-I . -I [pwd]/adr_work/adr_control/ -I $INTEL_ADR_RELEASEPATH/ -I $INTEL_DFM_UIN_DIR/"
#@ # Specifies the number of ADR iterations
#@ set INTEL_ADR_LOOPS 5
#@ 
#@ ############# ECO Flow Specific Variables #######
#@ # NOTE: In Normal Operation INTEL_ECO_TYPE is set 0; In ECO mode INTEL_ECO_TYPE can be set to 1, 2 or 3 based on the type of ECO that you are performing
#@ # When INTEL_ECO_TYPE set to 1, ECO is based on a TCL script where all your ECO's are defined.
#@ # When INTEL_ECO_TYPE set to 2, ECO is based on a verilog netlist. It is a unfreeze approach.  A verilog netlist w/ minor deltas is used.
#@ # For freeze silicon verilog approach, refer to place_freeze_silicon command in ICC for more details.
#@ set INTEL_ECO_TYPE 0
#@ #set INTEL_ECO_TCL inputs/eco1.tcl
#@ #set INTEL_ECO_NETLIST dhm.eco2.vg
#@ 
#@ ############# MCMM Flow Specific Variables ################
#@ # Comments on MCMM Flow:
#@ # The prerequisite for running the MCMM flow is:
#@ #   1) The library.tcl is updated to include PVTs referenced here by set_operating_conditions. Macros PVT must match the PVT of the stdcell libraries for the tools to link to them correctly.
#@ #   2) The variable below be set for each scenario created.
#@ #
#@ # All MCMM related setup is now done through create_scenarios.tcl. If something custom is required, please copy the file over locally an modify as needed.
#@ 
#@ # When using MCMM (set INTEL_MCMM 1), it is set to 0 by default
#@ # Also need to set all the MCMM variables below (example provided below)
#@ set INTEL_MCMM 0
#@ 
#@ ### Specify the name of each scenario.
#@ ### By default, all scenarios are active.
#@ ##set INTEL_MCMM_SCENARIOS         "max_corner_1 max_corner_2 min_corner_1"
#@ ##
#@ ### Specify the active scenarios by step. (OPTIONAL)
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(place)      "max_corner_1"
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(post_place) "max_corner_1 max_corner_2"
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(cts)        "max_corner_1 min_corner_1"
#@ ##
#@ ### Specify the default 'current_scenario'
#@ ##set INTEL_MCMM_SCENARIO_DEFAULT  "max_corner_1"
#@ ##
#@ ### Foreach scenario, define the operating condition for that scenario.
#@ ##set INTEL_MCMM_OPCON(max_corner_1) "set_operating_conditions -analysis_type on_chip_variation -max slow_1.00 -max_library d04_nn_p1273_6x1r2_psss_0.75v_125c_ccst"
#@ ##set INTEL_MCMM_OPCON(max_corner_2) "set_operating_conditions -analysis_type on_chip_variation -max slow_1.00 -max_library d04_nn_p1273_6x1r2_psss_0.98v_125c_ccst"
#@ ##set INTEL_MCMM_OPCON(min_corner_2) "set_operating_conditions -analysis_type on_chip_variation -max fast_1.00 -max_library d04_nn_p1273_6x1r2_pfff_0.98v_-40c_ccst"
#@ ##
#@ ### Foreach scenario, define the min and max tlu+ file
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(max_corner_1) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(max_corner_2) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(min_corner_1) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(max_corner_1) $INTEL_MIN_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(max_corner_2) $INTEL_MIN_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(min_corner_1) $INTEL_MIN_TLUPLUS_FILE
#@ ##
#@ ### Foreach scenario, define the min and max emulated tlu+ file (OPTIONAL)
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(max_corner_1) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(max_corner_2) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(min_corner_1) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(max_corner_1) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(max_corner_2) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(min_corner_1) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ 
#@ ### For scenario options, please provide just true or false for setup, hold, leakage_power, and cts_mode.
#@ ### The values for cts_corner can be max, min, min_max or none.
#@ ### Please refer to the set_scenario_options man page for further information.
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(max_corner_1)   "set_scenario_options -setup true  -hold true  -leakage_power true  -cts_mode true -cts_corner max"
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(max_corner_2)   "set_scenario_options -setup true  -hold true  -leakage_power true  -cts_mode true -cts_corner max"
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(min_corner_2)   "set_scenario_options -setup false -hold true  -leakage_power false -cts_mode false"
#@ 
#@ # The MCMM flow will either read all SDC files or all tcl files (but not both) for each scenario.
#@ # This is controlled via the $INTEL_SDC_FILE
#@ #        if {$INTEL_SDC_FILE == 1} {foreach $INTEL_MCMM_CONS_SDC($scenario) { read_sdc $sdc }}
#@ #   elseif ($INTEL_SDC_FILE == 0} {foreach $INTEL_MCMM_CONS_TCL($scenario) { source $tcl }}
#@ set INTEL_SDC_FILE 0
#@ ##set INTEL_MCMM_CONS_SDC(max_corner_1) "./inputs/constraints/max_corner_1.clocks.sdc ./inputs/constraints/max_corner_1.io.sdc"
#@ ##set INTEL_MCMM_CONS_SDC(max_corner_2) "./inputs/constraints/max_corner_2.clocks.sdc ./inputs/constraints/max_corner_2.io.sdc"
#@ ##set INTEL_MCMM_CONS_SDC(min_corner_1) "./inputs/constraints/min_corner_1.clocks.sdc ./inputs/constraints/min_corner_1.io.sdc"
#@ ### OR
#@ ##set INTEL_MCMM_CONS_TCL(max_corner_1) "./inputs/constraints/max_corner_1.clocks.tcl ./inputs/constraints/max_corner_1.io.tcl"
#@ ##set INTEL_MCMM_CONS_TCL(max_corner_2) "./inputs/constraints/max_corner_2.clocks.tcl ./inputs/constraints/max_corner_2.io.tcl"
#@ ##set INTEL_MCMM_CONS_TCL(min_corner_2) "./inputs/constraints/min_corner_1.clocks.tcl ./inputs/constraints/min_corner_1.io.tcl"
#@ 
#@ # In the case where two scenarios are defined to have similar PVT, the tool can have difficulty distinguishing which library to associate for that scenario.
#@ # For this case, there is an optional setting INTEL_MCMM_LINK_LIBRARY_SUBSET which will use the tool command link_library_subset to specify which libraries should be used for the given scenario.
#@ #set INTEL_MCMM_LINK_LIBRARY_SUBSET(max_corner_1) [list d04_ln_p1273_6x1r2_psss_0.75v_-40c_nldm.ldb]
#@ #set INTEL_MCMM_LINK_LIBRARY_SUBSET(max_corner_2) [list d04_ln_p1273_6x1r2_pfff_0.75v_-40c_nldm.ldb]
#@ 
#@ ###########STA Specific##################
#@ ########################################
#@ 
#@ ###########Setup Variables##############
#@ 
#@ if {[regexp {^pt_shell} $synopsys_program_name]} {
#@   # Variable used to set operating condition. Valid values are bc_wc, on_chip_variation.
#@   set INTEL_ANALYSIS_TYPE             "on_chip_variation"
#@ }
#@ 
#@ # Include List of all lib pair (max corner used for link lib during PV). The min lib will be used for setting the set_min_library which will provide the min lib corresponding to all max lib.
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(max)   "${fdk_lib}_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_nn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_ln_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_wn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_yn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(min)   "${fdk_lib}_nn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_nn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_ln_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_ln_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_wn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_wn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_yn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_yn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(power) "${fdk_lib}_nn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_nn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_ln_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_ln_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_wn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_wn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_yn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_yn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_nn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_ln_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_wn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_yn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(noise) "${fdk_lib}_nn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_nn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_ln_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_ln_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_wn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_wn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_yn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_yn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm"
#@ 
#@ # Specify the valid run_type and stage. User can configure custom run type and stages in the following vars.
#@ set INTEL_RUN_TYPES                  [list max min noise power]
#@ set INTEL_RUN_STAGES                 [list prelayout prects postlayout]
#@ 
#@ # Set the extraction file (SPEF) for the design.
#@ 
#@ set INTEL_SPEF_FILE(max)           ""
#@ set INTEL_SPEF_FILE(min)     ""
#@ set INTEL_SPEF_FILE(noise)     ""
#@ set INTEL_SPEF_FILE(power)     ""
#@ 
#@ # Set the SDC File for the design.
#@ set INTEL_PV_SDC(max)                   ""
#@ set INTEL_PV_SDC(min)                   ""
#@ set INTEL_PV_SDC(power)                 ""
#@ set INTEL_PV_SDC(noise)                 ""
#@ 
#@ # Set the Max-Min Operating conditions for the design.
#@ set INTEL_PV_MAX_OPCON(max)             "slow_1.00"
#@ set INTEL_PV_MAX_OPCON(min)             "fast_1.00"
#@ set INTEL_PV_MAX_OPCON(power)           "typical_1.00"
#@ set INTEL_PV_MAX_OPCON(noise)           "fast_1.00"
#@ 
#@ set INTEL_PV_MIN_OPCON(max)             "slow_1.00"
#@ set INTEL_PV_MIN_OPCON(min)             "fast_1.00"
#@ set INTEL_PV_MIN_OPCON(power)           "typical_1.00"
#@ set INTEL_PV_MIN_OPCON(noise)           "fast_1.00"
#@ 
#@ # Configure the number of cores on the local machine to use during the run.
#@ set_host_options -max_cores 4
#@ 
#@ # Variable used to setup AOCVM based runs.
#@ set INTEL_ENABLE_AOCVM     0
#@ 
#@ # Variables used to define early and late AOCVM tables. Populate the list with entire path of the table.
#@ set INTEL_AOCVM_TABLE(max)   [list ]
#@ set INTEL_AOCVM_TABLE(min)   [list ]
#@ 
#@ 
#@ 
#@ # Variable used to enable ILM generation for design.
#@ set INTEL_GENERATE_ILM               0
#@ 
#@ # Variable used to set absolute and percentage comparison limit for ILM model validation.
#@ set INTEL_ILM_ABS_TOL                200
#@ set INTEL_ILM_PER_TOL                5
#@ 
#@ #Variable to invoke PV Fast Analysis
#@ set INTEL_PV_FAST_ANALYSIS           0
#@ 
#@ ###########DMSA Variables (Variables not yet in use!!)##############
#@ 
#@ # Define DMSA corners: <mode> <run-type> <slew> <voltage> <temperature>
#@ # Syntax: <func|scan_shift|scan_capture> <max|min|power|noise> <psss|tttt|pfff> <lib voltage as in library name> <lib temp as in library name>
#@ set INTEL_DMSA_VARS               "func max psss 0.9v 125.00c                                scan_shift max psss 0.9v 125.00c                                scan_capture max psss 0.9v 125.00c                                func min pfff 1.025v 0.00c                                scan_shift min pfff 1.025v 0.00c                                scan_capture min pfff 1.025v 0.00c                                func power pfff 1.025v 0.00c                                func power psss 1.025v 105.00c"
#@ 
#@ # Specify all Vt variants present in netlist
#@ set INTEL_DMSA_VT                  [list ln nn wn]
#@ 
#@ # Scenarios to analyze currently. Can contain wildcard characters"
#@ set INTEL_DMSA_CURRENT_SCENARIOS   ""
#@ 
#@ # SPEF files for all corners. Create similar variables for extra temperatures than provided above.
#@ set INTEL_DMSA_SPEF(0.00)          ""
#@ set INTEL_DMSA_SPEF(125.00)        ""
#@ 
#@ # Clocks for all runs
#@ set INTEL_DMSA_CLOCKS              ""
#@ 
#@ # Constraint file for all run types
#@ set INTEL_DMSA_CONSTRAINTS(max)    ""
#@ set INTEL_DMSA_CONSTRAINTS(min)    ""
#@ set INTEL_DMSA_CONSTRAINTS(power)  ""
#@ set INTEL_DMSA_CONSTRAINTS(noise)  ""
#@ 
#@ # SDC files for all run types
#@ set INTEL_DMSA_SDC(max)           ""
#@ set INTEL_DMSA_SDC(min)           ""
#@ set INTEL_DMSA_SDC(power)         ""
#@ set INTEL_DMSA_SDC(noise)         ""
#@ 
#@ ############Power variables#############
#@ 
#@ # Variable is used to enable VCD/SAIF file read for PTPX Power Calculation ./inputs/${INTEL_DESIGN_NAME}.vcd/.fsdb/.saif. Specify the full path of the activity file name.
#@ set INTEL_ACTIVITY_FILE    ""
#@ 
#@ # Specifies a path prefix that is to be stripped from all the object names read from the VCD file. This option is applied to strip the testbench/instance path from the VCD file.
#@ set INTEL_STRIP_PATH         ""
#@ 
#@ # Variables used to specify the map file while using VCD from RTL. Give full path of the file. Map file will make sure that RTL names in the VCD match with those in the gate-level netlist.
#@ set INTEL_RTL_VCD_MAP_FILE     ""
#@ 
#@ # Variable used to set average or peak power_analysis type. Valid values are avg, peak.
#@ set INTEL_POWER_ANALYSIS     "avg"
#@ 
#@ ########################################
#@ #Outputs and Reports Variables
#@ ########################################
#@ 
#@ #############Synthesis##################
#@ ########################################
#@ 
#@ # Setting the reports var. All the reports listed are in common/scripts/procs_reference.tcl
#@ set INTEL_REPORTS(inc_compile) "qor area clock clock_gating max_delay max_cap                                 max_tran all_violators saif power check_timing                                 check_design high_fanout timing_setup timing_setup_groups                                 timing_loops congestion dft_drc dft_signal scanpath vars check_mv_design"
#@ 
#@ # Variable used to control report_timing parameters
#@ foreach step $INTEL_SYN_STEPS {
#@   set INTEL_MAX_PATHS($step)   1000
#@   set INTEL_SLACK_LIMIT($step) 9999
#@   set INTEL_NWORST($step)      1
#@ }
#@ 
#@ set INTEL_OUTPUTS(compile)     "verilog upf"
#@ set INTEL_OUTPUTS(insert_dft)  "verilog upf"
#@ if { $::sh_product_version < {I-2013.12} } {
#@   set INTEL_OUTPUTS(inc_compile) "verilog upf sdc saif spef scandef syn_def"
#@ } else {
#@   set INTEL_OUTPUTS(inc_compile) "verilog upf sdc saif spef scandef def"
#@ }
#@ 
#@ ################ APR ################################################
#@ #####################################################################
#@ 
#@ # Available report types:
#@ # NOTE: check_mv_design & upf will only be reported if $INTEL_UPF == 1.
#@ # Design checks:   check_design check_mv_design check_timing check_legality check_zrt_routability
#@ # Design reports:  area threshold_voltage_group high_fanout physical
#@ # UPF reports:     upf
#@ # Timing reports:  qor all_violators timing_setup timing_hold timing_setup_zeroRC timing_setup_groups timing_loops
#@ # Clock reports:   clock_tree clock_gating
#@ # Power reports:   saif power
#@ # Route reports:   verify_zrt_route lvs
#@ # Other reports:   logic_levels vars
#@ 
#@ set INTEL_REPORTS(import_design)    "timing_setup_zeroRC flow_vars"
#@ 
#@ set INTEL_REPORTS(floorplan)        ""
#@ set INTEL_REPORTS(upf_floorplan)    "$INTEL_REPORTS(floorplan) check_mv_design upf"
#@ 
#@ set INTEL_REPORTS(place)            "qor physical"
#@ set INTEL_REPORTS(upf_place)        $INTEL_REPORTS(place)
#@ set INTEL_REPORTS(post_place)       $INTEL_REPORTS(place)
#@ set INTEL_REPORTS(upf_post_place)   "$INTEL_REPORTS(post_place) check_mv_design upf"
#@ 
#@ set INTEL_REPORTS(cts)              "clock_tree qor physical"
#@ 
#@ set INTEL_REPORTS(route)            "all_violators timing_setup timing_hold qor power                                      threshold_voltage_group logic_levels vars physical lvs"
#@ set INTEL_REPORTS(post_route)       $INTEL_REPORTS(route)
#@ set INTEL_REPORTS(upf_post_route)   "$INTEL_REPORTS(post_route) check_mv_design upf"
#@ 
#@ #set INTEL_REPORTS(focal_opt)         $INTEL_REPORTS(post_route)
#@ set INTEL_REPORTS(fill)             "$INTEL_REPORTS(post_route) timing_setup_groups"
#@ 
#@ foreach step $INTEL_APR_STEPS {
#@   set INTEL_MAX_PATHS($step)   1000
#@   set INTEL_SLACK_LIMIT($step) 9999
#@   set INTEL_NWORST($step)      1
#@ }
#@ 
#@ # Available output types: verilog verilog_pg spef def fp sdc oas gds
#@ # NOTE: check_mv_design & upf will only be reported if $INTEL_UPF == 1.
#@ 
#@ set INTEL_OUTPUTS(import_design)   ""
#@ set INTEL_OUTPUTS(floorplan)       ""
#@ set INTEL_OUTPUTS(upf_floorplan)   $INTEL_OUTPUTS(floorplan)
#@ set INTEL_OUTPUTS(place)           ""
#@ set INTEL_OUTPUTS(upf_place)       $INTEL_OUTPUTS(place)
#@ set INTEL_OUTPUTS(post_place)      $INTEL_OUTPUTS(place)
#@ set INTEL_OUTPUTS(upf_post_place)  $INTEL_OUTPUTS(post_place)
#@ set INTEL_OUTPUTS(cts)             ""
#@ set INTEL_OUTPUTS(route)           "verilog_pg oas"
#@ set INTEL_OUTPUTS(post_route)      $INTEL_OUTPUTS(route)
#@ set INTEL_OUTPUTS(upf_post_route)  $INTEL_OUTPUTS(post_route)
#@ #set INTEL_OUTPUTS(focal_opt)       $INTEL_OUTPUTS(route)
#@ set INTEL_OUTPUTS(adr)             "$INTEL_OUTPUTS(route) def"
#@ set INTEL_OUTPUTS(fill)            "verilog verilog_pg upf sdc def spef oas lteloc techlef"
#@ set INTEL_OUTPUTS(eco)             "verilog verilog_pg upf sdc def spef oas"
#@ 
#@ ################PV######################
#@ 
#@ # Variable used to set generate reports for different runs
#@ 
#@ set INTEL_REPORTS(max)             [list timing_setup all_violators clock check_timing timing_setup_groups pin_margin net_attribute pin_attribute parasitic_not_annotated_check vars max_cap max_tran max_delay error_info aocvm qor min_pulse_width]
#@ set INTEL_REPORTS(min)             [list timing_hold  all_violators clock check_timing timing_hold_groups  pin_margin net_attribute pin_attribute parasitic_not_annotated_check vars error_info aocvm qor min_pulse_width]
#@ set INTEL_REPORTS(noise)           [list noise_all_vio noise_below noise_above check_noise parasitic_not_annotated_check max_analysis_coverage vars error_info qor]
#@ set INTEL_REPORTS(power)           [list power switching_activity missing_power_tables parasitic_not_annotated_check vars error_info qor]
#@ 
#@ # Variable used to control report_timing parameters
#@ set INTEL_MAX_PATHS(max)            1000
#@ set INTEL_SLACK_LIMIT(max)          9999
#@ set INTEL_NWORST(max)               1
#@ 
#@ set INTEL_MAX_PATHS(min)            1000
#@ set INTEL_SLACK_LIMIT(min)          9999
#@ set INTEL_NWORST(min)               1
#@ 
#@ set INTEL_MAX_PATHS(power)            1000
#@ set INTEL_SLACK_LIMIT(power)          9999
#@ set INTEL_NWORST(power)               1
#@ 
#@ set INTEL_MAX_PATHS(noise)            1000
#@ set INTEL_SLACK_LIMIT(noise)          9999
#@ set INTEL_NWORST(noise)               1
#@ 
#@ # ERC checks variables and reporting
#@ # Variable to enable ERC checks
#@ set INTEL_PT_ERC_CHECK_ENABLE 0
#@ 
#@ 
#@ 
#@ 
#@ ################PV-DMSA (Variables not yet in use!!)######################
#@ 
#@ set INTEL_REPORTS(dmsa)              [list timing_setup timing_hold all_violators vars max_cap max_tran max_delay max_analysis_coverage clock_summary]
#@ set INTEL_MAX_PATHS(dmsa)            1000
#@ set INTEL_SLACK_LIMIT(dmsa)          9999
#@ set INTEL_NWORST(dmsa)               1
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/project_setup.tcl

#@ 
#@ # To set block level variable used in the flow
#@ P_source_if_exists -inclusive block_setup.tcl
#@ # -- Starting source ./scripts/block_setup.tcl

#@ set INTEL_DESIGN_NAME 		"fdkex"
#@ 
#@ set INTEL_PT_ERC_CHECK_ENABLE	1
#@ 
#@ ###  Appended values of INTEL_SDC_FILE and INTEL_PV_SDC(<run_type>) by Regr System
#@ 
#@ set INTEL_SDC_FILE 1
#@ 
#@ set INTEL_PV_SDC(max) fdkex.apr.sdc
#@ 
#@ set INTEL_PV_SDC(min) fdkex.apr.sdc
#@ 
#@ set INTEL_PV_SDC(power) fdkex.apr.sdc
#@ 
#@ set INTEL_PV_SDC(noise) fdkex.apr.sdc
#@ 
#@ ### Appended values of INTEL_SPEF_FILE(max) by Regr System
#@ set INTEL_SPEF_FILE(max) fdkex_mw.spef.tttt_-10.gz
#@ 
#@ ### Appended values of INTEL_SPEF_FILE(min) by Regr System
#@ set INTEL_SPEF_FILE(min) fdkex_mw.spef.tttt_-40.gz
#@ 
#@ ### Appended values of INTEL_SPEF_FILE(power) by Regr System
#@ set INTEL_SPEF_FILE(power) fdkex_mw.spef.tttt_90.gz
#@ 
#@ ### Appended values of INTEL_SPEF_FILE(noise) by Regr System
#@ set INTEL_SPEF_FILE(noise) fdkex_mw.spef.tttt_110.gz
#@ # -- End source ./scripts/block_setup.tcl

#@ 
#@ # To setup the directories for various runs.
#@ P_source_if_exists pt_run_setup.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/pt_run_setup.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ 
#@ #Checking for Run-Types and Run Stages
#@ #---------------------------------------
#@ 
#@ if {[info exists INTEL_RUN_TYPES] && $INTEL_RUN_TYPES != ""} {
#@   if {![info exists run_type] || [lsearch -exact $INTEL_RUN_TYPES $run_type] < 0} {
#@     puts "==>FATAL: Either run_type variable does not exist (or) $run_type is a not a valid value in INTEL_RUN_TYPES. Choose a run_type from $INTEL_RUN_TYPES. Exiting ..."
#@     exit
#@   } else {
#@     puts "==>INFORMATION: Creating reports, snapshot and logs directory for $run_type"
#@     sh mkdir -p ./runs/${run_type}/logs ./runs/${run_type}/reports ./runs/${run_type}/snapshot
#@   }
#@ 
#@ } else {
#@   puts "==>FATAL: INTEL_RUN_TYPES variable is not defined (or) set to \"\". Please update INTEL_RUN_TYPES variable in block_setup.tcl"
#@   exit
#@ }
#@ 
#@ if {[info exists INTEL_RUN_STAGES] && $INTEL_RUN_STAGES != ""} {
#@   if {![info exists stage] || [lsearch -exact $INTEL_RUN_STAGES $stage] < 0} {
#@     puts "==>FATAL: Either stage variable does not exist (or) $stage is a not a valid value in INTEL_RUN_STAGES. Choose a stage from $INTEL_RUN_STAGES. Exiting ..."
#@     exit
#@   }
#@ 
#@ } else {
#@   puts "==>FATAL: INTEL_RUN_STAGES variable is not defined (or) set to \"\". Please update INTEL_RUN_STAGES variable in block_setup.tcl"
#@   exit
#@ }
#@ 
#@ #Setting up design
#@ #------------------
#@ 
#@ if {![info exists INTEL_DESIGN_NAME] || $INTEL_DESIGN_NAME == ""} {
#@   puts "==>FATAL: Either INTEL_DESIGN_NAME variable is not defined (or) set to \"\". Please update INTEL_DESIGN_NAME variable in block_setup.tcl. Exiting..."
#@   exit
#@ } else {
#@   puts "==>INFORMATION: Setting up for design: $INTEL_DESIGN_NAME"
#@ }
#@ 
#@ if {[file exists inputs/${INTEL_DESIGN_NAME}.vg]} {
#@   sh cp -rfL inputs/${INTEL_DESIGN_NAME}.vg ./runs/${run_type}/snapshot
#@ } else {
#@   puts "==>FATAL: ${INTEL_DESIGN_NAME}.vg does not reside in inputs directory. Exiting..."
#@ }
#@ 
#@ if {$stage == "prects" || $stage == "postlayout"} {
#@   if {![info exists INTEL_SPEF_FILE($run_type)] || $INTEL_SPEF_FILE($run_type) == ""} {
#@     puts "==>FATAL: Either INTEL_SPEF_FILE(${run_type}) variable is not defined (or) set to \"\". Please update INTEL_SPEF_FILE(${run_type}) variable in block_setup.tcl. Exiting..."
#@     exit
#@   } else {
#@     sh cp -rfL inputs/$INTEL_SPEF_FILE($run_type) ./runs/${run_type}/snapshot
#@   }
#@ }
#@ 
#@ if {$stage == "prelayout"} {
#@   if [file exists ./inputs/${INTEL_DESIGN_NAME}.wlm] {
#@     sh cp -rfL inputs/${INTEL_DESIGN_NAME}.wlm ./runs/${run_type}/snapshot
#@   }
#@ }
#@ 
#@ if {[info exists INTEL_SDC_FILE] && $INTEL_SDC_FILE} {
#@   if {![info exists INTEL_PV_SDC($run_type)] || $INTEL_PV_SDC($run_type) == ""} {
#@     puts "==>FATAL: Either INTEL_PV_SDC(${run_type}) variable is not defined (or) set to \"\". Please update INTEL_PV_SDC(${run_type}) variable in block_setup.tcl. Exiting..."
#@     exit
#@   } else {
#@     sh cp -rfL inputs/$INTEL_PV_SDC($run_type) ./runs/${run_type}/snapshot
#@   }
#@ } else {
#@   if {[file exists inputs/${INTEL_DESIGN_NAME}.clocks.tcl] && [file exists inputs/${INTEL_DESIGN_NAME}.constraints.tcl]} {
#@     sh cp -rfL inputs/${INTEL_DESIGN_NAME}.clocks.tcl ./runs/${run_type}/snapshot
#@     sh cp -rfL inputs/${INTEL_DESIGN_NAME}.constraints.tcl ./runs/${run_type}/snapshot
#@   } else {
#@     puts "==>FATAL: Either ${INTEL_DESIGN_NAME}.clocks.tcl (or) ${INTEL_DESIGN_NAME}.constraints.tcl does not exist in the inputs directory. Exiting..."
#@     exit
#@   }
#@ }
#@ 
#@ if {[regexp {(^power)(.*)} $run_type]} {
#@   if {[file exists $INTEL_ACTIVITY_FILE]} {
#@     sh cp -rfL $INTEL_ACTIVITY_FILE ./runs/${run_type}/snapshot
#@   }
#@   if {[file exists $INTEL_RTL_VCD_MAP_FILE]} {
#@     sh cp -rfL $INTEL_RTL_VCD_MAP_FILE ./runs/${run_type}/snapshot
#@   }
#@ }
#@ 
#@ #Checking for collaterals in Full Chip Timing
#@ #------------------------------------------------
#@ 
#@ if {[info exists INTEL_HIER] && $INTEL_HIER != ""} {
#@   foreach {hier module inst desg_type} $INTEL_HIER {
#@     if {($desg_type == "netlist")} {
#@       if {[file exists inputs/${module}.vg]} {
#@         sh cp -rfL ./inputs/${module}.vg  ./runs/${run_type}/snapshot/
#@       } else {
#@         puts "==>FATAL: ${module}.vg file does not exist in inputs directory. Exiting..."
#@         exit
#@       }
#@       if {[regexp {((^noise)|(^max)|(^power))(.*)} $run_type] && [file exists inputs/${module}.hot.spef.gz]} {
#@         sh cp -rfL ./inputs/${module}.hot.spef.gz ./runs/${run_type}/snapshot/
#@       } elseif {[regexp {(^min)(.*)} $run_type] && [file exists inputs/${module}.cold.spef.gz]} {
#@         sh cp -rfL ./inputs/${module}.cold.spef.gz ./runs/${run_type}/snapshot/
#@       } else {
#@         puts "==>FATAL: SPEF File ${module}.hot.spef.gz for max/power/noise runtypes (or) ${module}.cold.spef.gz for min runtype does not exist in ./inputs directory. Exiting..."
#@         exit
#@       }
#@     } elseif {($desg_type == "ilm")} {
#@       if {[file exists inputs/${module}.ilm.vg]} {
#@         sh cp -rfL ./inputs/${module}.ilm.vg ./runs/${run_type}/snapshot/
#@       } else {
#@         puts "==>FATAL: ${module}ilm.vg file does not exist in inputs directory. Exiting..."
#@         exit
#@       }
#@       if {[file exists inputs/${module}.ilm.spef.gz]} {
#@         sh cp -rfL ./inputs/${module}.ilm.spef.gz ./runs/${run_type}/snapshot/
#@       } else {
#@         puts "==>FATAL: ${module}ilm.spef.gz file does not exist in inputs directory. Exiting..."
#@         exit
#@       }
#@     } elseif {($desg_type == "lib")} {
#@       if {[file exists ./inputs/${module}.etm.lib]} {
#@         sh cp -rfL ./inputs/${module}.etm.lib ./runs/${run_type}/snapshot/
#@       } elseif {[file exists ./inputs/${module}.etm.db]} {
#@         sh cp -rfL ./inputs/${module}.etm.db ./runs/${run_type}/snapshot/
#@       } else {
#@         puts "==>FATAL: Neither ${module}.etm.lib nor ${module}.etm.db file exists for ${module} in inputs directory. Exiting..."
#@         exit
#@       }
#@     } else {
#@       puts "==>FATAL: $desg_type is not a valid value. Choose either netlist (or) ilm (or) lib. Exiting..."
#@     }
#@   }
#@ }
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/pt_run_setup.tcl

#@ 
#@ # To setup default PT variables to be used in the flow.
#@ P_source_if_exists pt_var_setup.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/pt_var_setup.tcl

#@ ##############################################################################
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ ####################################
#@ # Common Setup Variables
#@ ####################################
#@ 
#@ set cache_read  {} ;#
#@ set cache_write {} ;#
#@ set allow_newer_db_files true ;#
#@ set write_compressed_db_files  true ;#
#@ set_app_var sh_source_uses_search_path true ;#
#@ 
#@ 
#@ #############################################################################################
#@ #Required Variables
#@ #These variables need to be defined first, because some variables will trigger update_timing
#@ #This will help in runtime improvement
#@ #############################################################################################
#@ 
#@ #sh_continue_on_error tells PT to continue when there is an error.
#@ #sh_script_stop_severity and sh_source_emits_line_numbers can be used to stop and report line number
#@ set_app_var sh_continue_on_error true
#@ 
#@ #sh_source_uses_search_path tells PT to use the search paths to find the appropriate files
#@ set_app_var sh_source_uses_search_path true
#@ 
#@ #svr_keep_unconnected_nets to preserve unconnected nets in PT will prevent errors during linking.
#@ set_app_var svr_keep_unconnected_nets "true"
#@ 
#@ #case_analysis_sequential_propagation is used to propagate the case. Only use if the constraints has case.
#@ #set_app_var case_analysis_sequential_propagation "always"
#@ 
#@ #timing_report_unconstrained_paths is used to report unconstrained paths.
#@ #set_app_var timing_report_unconstrained_paths true
#@ 
#@ #timing_remove_clock_reconvergence_pessimism will incur additional runtime. Set to true for final layout.
#@ set_app_var timing_remove_clock_reconvergence_pessimism true
#@ 
#@ ##This variable will preserve slack info on pins
#@ set_app_var timing_save_pin_arrival_and_slack true
#@ 
#@ set_app_var read_parasitics_load_locations true
#@ 
#@ ##To remove the print statement of all new vars at the end of flow
#@ set_app_var sh_new_variable_message false
#@ 
#@ if {[info exists INTEL_PV_FAST_ANALYSIS] && $INTEL_PV_FAST_ANALYSIS == 1} {
#@   set_program_options -enable_fast_analysis
#@ }
#@ 
#@ ## Disable command and argument abbreviation.
#@ #set_app_var sh_command_abbrev_mode none
#@ #set_app_var sh_command_abbrev_options false
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/pt_var_setup.tcl

#@ 
#@ # To setup library files for the design.
#@ P_source_if_exists library.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/library.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ######################################
#@ 
#@ ###########################################
#@ # Variables for CCST Timing Model
#@ ###########################################
#@ 
#@ # NOTE : Set the variables for NLDM Timing Model as per requirement.
#@ 
#@ set_app_var rc_driver_model_mode advanced
#@ set_app_var rc_receiver_model_mode advanced
#@ set lib_cell_using_delay_from_ccs true
#@ set lib_pin_using_cap_from_ccs true
#@ 
#@ ###########################################################################
#@ # Description: This file sets up libraries for the entire design
#@ ###########################################################################
#@ 
#@ # NOTE: This is a reference of what could be done. You can use hard paths here.
#@ 
#@ set tmp_search_path [list                          $env(INTEL_STDCELLS_MISC)/lib/ln                          $env(INTEL_STDCELLS_MISC)/lib/nn                          $env(INTEL_STDCELLS_MISC)/lib/wn                          $env(INTEL_STDCELLS_MISC)/lib/yn                          $env(INTEL_STDCELLS)/lib/ln                          $env(INTEL_STDCELLS)/lib/nn                          $env(INTEL_STDCELLS)/lib/wn                          $env(INTEL_STDCELLS)/lib/yn                          $env(INTEL_STDCELLS)/ccs/ln                          $env(INTEL_STDCELLS)/ccs/wn                          $env(INTEL_STDCELLS)/ccs/nn                          $env(INTEL_STDCELLS)/ccs/yn
#@ 
#@                     ]
#@ set_app_var search_path [concat $search_path [lsort -unique $tmp_search_path]]
#@ 
#@ puts "==>INFORMATION: search_path is set to $search_path"
#@ 
#@ set_app_var link_library [list * ]
#@ 
#@ if {[info exists INTEL_PV_MAX_MIN_LIB_PAIR($run_type)] && $INTEL_PV_MAX_MIN_LIB_PAIR($run_type) != ""} {
#@   set tmp_lib_pair $INTEL_PV_MAX_MIN_LIB_PAIR($run_type)
#@ } else {
#@   puts "==>FATAL: INTEL_PV_MAX_MIN_LIB_PAIR is not set... Exiting..."
#@ }
#@ 
#@ foreach {max_library min_library} $tmp_lib_pair {
#@   if {[which ${max_library}.ldb] != ""} {
#@     lappend link_library ${max_library}.ldb
#@   } elseif {[which ${max_library}.db] != ""} {
#@     lappend link_library ${max_library}.db
#@   } else {
#@     puts "==> WARNING: Neither db nor ldb file was found"
#@   }
#@ }
#@ 
#@ 
#@ puts "==>INFORMATION: link_library is set to $link_library"
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/library.tcl

#@ 
#@ # To import the design.
#@ P_source_if_exists design_setup.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/design_setup.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ cd ./runs/${run_type}/
#@ 
#@ #############
#@ #Read Design
#@ #############
#@ 
#@ read_verilog ./snapshot/${INTEL_DESIGN_NAME}.vg
#@ 
#@ if {[info exists INTEL_HIER] && $INTEL_HIER != ""} {
#@   set uniq_mod ""
#@   foreach {hier module inst desg_type} $INTEL_HIER {
#@     if {$hier !=0 } {
#@       if {[lsearch -exact $uniq_mod $module] < 0} {
#@         lappend uniq_mod $module
#@         if {($desg_type == "netlist")} {
#@           if {[file exists ./snapshot/${module}.vg]} {
#@             read_verilog ./snapshot/${module}.vg
#@           } else {
#@             puts "==>FATAL: Netlist ${module}.vg does not exist in ./snapshot/ directory for $module.Exiting..."
#@             exit
#@           }
#@         } elseif {($desg_type == "ilm")} {
#@           if {[file exists ./snapshot/${module}.ilm.vg]} {
#@             read_verilog ./snapshot/${module}.ilm.vg
#@           } else {
#@             puts "==>FATAL: ILM Netlist ${module}.ilm.vg does not exist in ./snapshot directory for $module. Exiting..."
#@             exit
#@           }
#@         } elseif {($desg_type == "lib")} {
#@           lappend search_path "./snapshot"
#@           if {[file exists ./snapshot/${module}.etm.lib]} {
#@             puts "==>INFORMATION: Reading ./snapshot/${module}.etm.lib file..."
#@             read_lib ./snapshot/${module}.etm.lib
#@             set_app_var link_path "$link_path ${module}.etm.lib"
#@           } elseif {[file exists ./snapshot/${module}.etm.db]} {
#@             puts "==>INFORMATION: Reading ./snapshot/${module}.etm.db file..."
#@             set_app_var link_path "$link_path ${module}.etm.db"
#@           } else {
#@             puts "==>FATAL: Neither ${module}.etm.lib, nor ${module}.etm.db file exists for ${module} in ./snapshot directory. Exiting"
#@             exit
#@           }
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ current_design ${INTEL_DESIGN_NAME}
#@ 
#@ # Link the design. The option -remove_sub_designs can be used to free up memory and helps runtime.
#@ redirect -tee ./reports/${INTEL_DESIGN_NAME}.link.rpt {link_design -verbose -keep_sub_designs ${INTEL_DESIGN_NAME}}
#@ 
#@ 
#@ 
#@ ######################
#@ #Setting Min library
#@ ######################
#@ 
#@ #Starting G-2012.06 Primetime requires min library to be set after design is linked.
#@ foreach {max_library min_library} $INTEL_PV_MAX_MIN_LIB_PAIR($run_type) {
#@   if {[which ${max_library}.ldb] != ""} {
#@     if {![string compare $max_library $min_library]} {
#@       set_min_library ${max_library}.ldb -none
#@     } else {
#@       set_min_library ${max_library}.ldb -min_version ${min_library}.ldb
#@     }
#@   } elseif {[which ${max_library}.db] != ""} {
#@     if {![string compare $max_library $min_library]} {
#@       set_min_library ${max_library}.db -none
#@     } else {
#@       set_min_library ${max_library}.db -min_version ${min_library}.db
#@     }
#@   }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ #####################
#@ #Operating Condition
#@ #####################
#@ 
#@ #Analysis_type can be bc_wc or on_chip_variation
#@ #Using OCV for max slew for data lauching and min slew for data capturing
#@ 
#@ set cmd "set_operating_conditions -analysis_type $INTEL_ANALYSIS_TYPE"
#@ 
#@ if {[info exists INTEL_PV_MIN_OPCON($run_type)]} {set cmd [concat $cmd "-min $INTEL_PV_MIN_OPCON($run_type)"]}
#@ if {[info exists INTEL_PV_MAX_OPCON($run_type)]} {set cmd [concat $cmd "-max $INTEL_PV_MAX_OPCON($run_type)"]}
#@ 
#@ if  {![eval $cmd] } {
#@   puts "==>FATAL: Setting Operating Conditions failed. Exiting..."
#@   exit
#@ } else {
#@   puts "==>INFORMATION: Setting default Operating Conditions\n$cmd "
#@ }
#@ 
#@ 
#@ ########################
#@ # Design Constraints
#@ ########################
#@ 
#@ if {[info exists INTEL_SDC_FILE] && $INTEL_SDC_FILE==1} {
#@   read_sdc ./snapshot/$INTEL_PV_SDC($run_type)
#@ } else {
#@ 
#@   #CLOCKS
#@   #-------
#@ 
#@   if {[file exists  ./snapshot/${INTEL_DESIGN_NAME}.clocks.tcl]} {
#@     puts "==>INFORMATION: Sourcing ${INTEL_DESIGN_NAME}.clocks.tcl file"
#@     source -echo -verbose ./snapshot/${INTEL_DESIGN_NAME}.clocks.tcl
#@   } else {
#@     puts "==>FATAL: ${INTEL_DESIGN_NAME}.clocks.tcl file does not exist in ./snapshot/ dir. Exiting..."
#@     exit
#@   }
#@ 
#@   #IO, Loading Constraints, Timing Exception File
#@   #------------------------------------------------
#@ 
#@   if {[file exists  ./snapshot/${INTEL_DESIGN_NAME}.constraints.tcl]} {
#@     puts "==>INFORMATION: Sourcing the design constraints file"
#@     source -echo -verbose ./snapshot/${INTEL_DESIGN_NAME}.constraints.tcl
#@   } else {
#@     puts "==>FATAL: ${INTEL_DESIGN_NAME}.constraints.tcl file does not exist in ./snapshot/ dir. Exiting..."
#@     exit
#@   }
#@ }
#@ 
#@ #####################
#@ # Read parasitics/WLM
#@ #####################
#@ 
#@ if {[info exists INTEL_HIER] && $INTEL_HIER != ""} {
#@   foreach {hier module inst desg_type} $INTEL_HIER {
#@     if {($hier !=0)} {
#@       if {($desg_type == "netlist")} {
#@         if {[regexp {((^noise)|(^max)|(^power))(.*)} $run_type]} {
#@           set spef_file [glob -nocomplain ./snapshot/${module}.hot.spef.gz]
#@           set para_cmd "read_parasitics -increment -format spef -path $inst $spef_file"
#@         } elseif {[regexp {((^min))(.*)} $run_type]} {
#@           set spef_file [glob -nocomplain ./snapshot/${module}.cold.spef.gz]
#@           set para_cmd "read_parasitics -increment -format spef -path $inst $spef_file"
#@         } elseif {($desg_type == "ilm")} {
#@           set spef_file   [glob -nocomplain ./snapshot/${module}.ilm.spef.gz]
#@           set para_cmd "read_parasitics -increment -format spef -path $inst $spef_file"
#@         } elseif {($desg_type == "lib")} {
#@           set para_cmd ""
#@         }
#@         if {![file exists $spef_file]} {
#@           puts "==>FATAL: SPEF file $spef_file does not exists for $module in ./snapshot/ dir. Exiting..."
#@           exit
#@         }
#@         if {[info exists si] && $si == "on"} {
#@           set para_cmd "$para_cmd -keep_capacitive_coupling"
#@         }
#@         if {($desg_type == "netlist") || ($desg_type == "ilm")} {
#@           puts "==>INFORMATION: $para_cmd"
#@           eval $para_cmd
#@         } elseif {($desg_type == "lib")} {
#@           puts "==>INFORMATION: SPEF file not required since .lib (ETM) is used for ${module}"
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ 
#@ if {$stage == "prects" || $stage == "postlayout"} {
#@   if {[file exists ./snapshot/$INTEL_SPEF_FILE($run_type)]} {
#@     set spef_file [glob -nocomplain ./snapshot/$INTEL_SPEF_FILE($run_type)]
#@     if {[info exists si] && $si == "on"} {
#@       read_parasitics -increment -format spef $spef_file -keep_capacitive_coupling
#@     } else {
#@       read_parasitics -increment -format spef $spef_file
#@     }
#@   } else {
#@     puts "==>FATAL: SPEF file $spef_file was not found in ./snapshot dir. Exiting..."
#@     exit
#@   }
#@ 
#@ } elseif { $stage == "prelayout" } {
#@   if {[file exists ./snapshot/$INTEL_DESIGN_NAME.wlm]} {
#@     puts "==>INFORMATION: Using Custom Wireload Model"
#@     source ./snapshot/${INTEL_DESIGN_NAME}.wlm
#@   } else {
#@     puts "==>INFORMATION: No parasitics have been annotated"
#@   }
#@ }
#@ 
#@ #PROPAGATING CLOCKS
#@ #-----------------
#@ if {[info exists stage] && $stage == "postlayout"} {
#@   redirect /dev/null { set masterclks [ all_clocks ] }
#@   if { $masterclks != {} } {
#@     redirect /dev/null { set_propagated_clock $masterclks }
#@   }
#@   redirect /dev/null { set masterclks [ get_generated_clocks "*" ] }
#@   if { $masterclks != {} } {
#@     redirect /dev/null { set_propagated_clock $masterclks }
#@   }
#@ }
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/design_setup.tcl

#@ 
#@ # To setup don't use list
#@ P_source_if_exists dont_use.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ 
#@ # To setup path groups
#@ P_source_if_exists create_path_group.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_path_group.tcl

#@ ##############################################################################
#@ 
#@ ###################################
#@ # List of procs used in this script
#@ # None
#@ ###############################
#@ 
#@ #------------------------
#@ #Create Paths groups
#@ #-----------------------
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1 && $synopsys_program_name != "pt_shell"} {
#@   set_active_scenarios [all_scenarios]
#@   foreach scenario $INTEL_MCMM_SCENARIOS {
#@     current_scenario $scenario
#@     puts "==> For scenario $scenario..."
#@ 
#@     set nonclockports [all_inputs]
#@     foreach_in_collection ck [all_clocks] {
#@       redirect /dev/null { set nonclockports [remove_from_collection $nonclockports [ get_ports [ get_object_name $ck ]]] }
#@     }
#@     redirect  /dev/null {group_path -name INPUTS -from $nonclockports}
#@ 
#@     group_path -name OUTPUTS -to [all_outputs]
#@     group_path -name COMB -from [all_inputs] -to [all_outputs]
#@ 
#@     if {[sizeof_collection [all_registers]] !=0} {
#@       group_path -name REG2REG -from [all_registers -clock_pins] -to [all_registers -data_pins]
#@     }
#@ 
#@     if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@       set hard_macro_cells ""
#@       set mc_pin  ""
#@       foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@         set hard_macro_cells [get_attribute  [get_cells -hierarchical -quiet -filter ref_name==$hard_macro_name] full_name]
#@         foreach hard_macro_cell $hard_macro_cells {
#@           set mc_pin [add_to_collection $mc_pin [get_pins -quiet ${hard_macro_cell}/* ]]
#@         }
#@       }
#@       group_path -name MACRO -from $mc_pin -to  [all_registers -data_pins]
#@       group_path -name MACRO -from  [all_registers -clock_pins]  -to $mc_pin
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ 
#@ } else {
#@ 
#@   set nonclockports [all_inputs]
#@   foreach_in_collection ck [all_clocks] {
#@     redirect /dev/null { set nonclockports [remove_from_collection $nonclockports [ get_ports [ get_object_name $ck ]]] }
#@   }
#@   redirect  /dev/null {group_path -name INPUTS -from $nonclockports}
#@ 
#@   group_path -name OUTPUTS -to [all_outputs]
#@   group_path -name COMB -from [all_inputs] -to [all_outputs]
#@ 
#@   if {[sizeof_collection [all_registers]] !=0} {
#@     group_path -name REG2REG -from [all_registers -clock_pins] -to [all_registers -data_pins]
#@   }
#@ 
#@   if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@     set hard_macro_cells ""
#@     set mc_pin  ""
#@     foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@       set hard_macro_cells [get_attribute  [get_cells -hierarchical -quiet -filter ref_name==$hard_macro_name] full_name]
#@       foreach hard_macro_cell $hard_macro_cells {
#@         set mc_pin [add_to_collection $mc_pin [get_pins -quiet ${hard_macro_cell}/* ]]
#@       }
#@     }
#@     group_path -name MACRO -from $mc_pin -to  [all_registers -data_pins]
#@     group_path -name MACRO -from  [all_registers -clock_pins]  -to $mc_pin
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_path_group.tcl

#@ 
#@ # To setup crosstalk settings for SI/Noise runs
#@ P_source_if_exists xtalk_settings.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/xtalk_settings.tcl

#@ ##############################################################################
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ if {[info exists si] && $si eq "on" || [regexp {((^noise))(.*)} $run_type]} {
#@ 
#@   set_app_var si_ignore_input_port_clock_arrival true
#@ 
#@   #       si_enable_analysis
#@   #              Enables or disables PrimeTime-SI, which provides crosstalk analysis.
#@ 
#@   set_app_var si_enable_analysis true
#@ 
#@   #       si_analysis_logical_correlation_mode
#@   #              Enables  or  disables logical correlation analysis during Prime-
#@   #              Time-SI delay or noise calculation.
#@ 
#@   set_app_var si_analysis_logical_correlation_mode true
#@ 
#@   #       si_ccs_aggressor_alignment_mode
#@   #              Specifies  aggressor  alignment mode used in the CCS-based gate-
#@   #              level simulation engine.
#@   #
#@ 
#@   set_app_var si_ccs_aggressor_alignment_mode lookahead
#@ 
#@ 
#@   #       si_filter_accum_aggr_noise_peak_ratio
#@   #              Specifies the threshold for the accumulated voltage bumps intro-
#@   #              duced by aggressors at a victim  node,  divided  by  Vcc,  below
#@   #              which  aggressor nets can be filtered out during electrical fil-
#@   #              tering.
#@ 
#@   set_app_var si_filter_accum_aggr_noise_peak_ratio 0.03
#@ 
#@   #       si_filter_per_aggr_noise_peak_ratio
#@   #              Specifies  the  threshold  for the voltage bump introduced by an
#@   #              aggressor at a victim node, divided  by  Vcc,  below  which  the
#@   #              aggressor net can be filtered out during electrical filtering.
#@ 
#@   set_app_var si_filter_per_aggr_noise_peak_ratio 0.01
#@ 
#@   #       si_ilm_keep_si_user_excluded_aggressors
#@ 
#@   set_app_var si_ilm_keep_si_user_excluded_aggressors false
#@ 
#@   #       si_noise_composite_aggr_mode
#@   #              Specifies the composite aggressor mode for noise analysis.
#@   #              3/13/09 - Synopsys recommends disabling composite aggressor for noise analysis
#@   #              (revert to the default setting) because with composite aggressor enabled,
#@   #              the tool will use the less accurate detailed noise analysis engine
#@   #              instead of the advanced CCS engine.
#@ 
#@   set_app_var si_noise_composite_aggr_mode disabled
#@ 
#@   #       si_noise_effort_threshold_beyond_rails
#@   #              Specifies  the threshold for the noise bump height introduced by
#@   #              an aggressor at a quiet victim  node  beyond  power  and  ground
#@   #              rails,  divided  by  Vcc,  above which the aggressor net will be
#@   #              analyzed by detailed noise calculation engine.
#@ 
#@   #set_app_var si_noise_effort_threshold_beyond_rails 0.2
#@ 
#@   #       si_noise_effort_threshold_within_rails
#@   #              Specifies  the threshold for the noise bump height introduced by
#@   #              an aggressor at a quiet victim  node  within  power  and  ground
#@   #              rails,  divided  by  Vcc,  above which the aggressor net will be
#@   #              analyzed by detailed noise calculation engine.
#@ 
#@   #set_app_var si_noise_effort_threshold_within_rails 0.2
#@ 
#@   #       si_noise_endpoint_height_threshold_ratio
#@   #              Specifies  a value that defines the threshold where noise propa-
#@   #              gation stops.  The ratio is between 0.0 and 1.0 of VDD.
#@ 
#@   set_app_var si_noise_endpoint_height_threshold_ratio 0.5
#@ 
#@   #       si_noise_limit_propagation_ratio
#@   #              This variable limits the amount of propagated noise if the noise
#@   #              height passes the failure point.
#@ 
#@   #set_app_var si_noise_limit_propagation_ratio 0.75
#@ 
#@   #       si_noise_slack_skip_disabled_arcs
#@   #              Controls  whether to skip disabled timing arcs for noise slack
#@   #              calculation.
#@ 
#@   set_app_var si_noise_slack_skip_disabled_arcs false
#@ 
#@   #       si_noise_total_effort_threshold_beyond_rails
#@   #              Specifies  the  threshold for the summation of noise bump height
#@   #              introduced by all aggressor at a quiet victim node beyond  power
#@   #              and ground rails, divided by Vcc, above which all aggressor nets
#@   #              will be analyzed by detailed noise calculation engine.
#@ 
#@   #set_app_var si_noise_total_effort_threshold_beyond_rails 10
#@ 
#@   #       si_noise_total_effort_threshold_within_rails
#@   #              Specifies  the  threshold for the summation of noise bump height
#@   #              introduced by all aggressor at a quiet victim node within  power
#@   #              and ground rails, divided by Vcc, above which all aggressor nets
#@   #              will be analyzed by detailed noise calculation engine.
#@ 
#@   #set_app_var si_noise_total_effort_threshold_within_rails 10
#@ 
#@   #       si_noise_update_status_level
#@   #              Controls  the  number  of progress messages displayed during the
#@   #              update of noise analysis.
#@ 
#@   set_app_var si_noise_update_status_level high
#@ 
#@   #       si_use_driving_cell_derate_for_delta_delay
#@   #              Allows crosstalk delta delay for one net to be derated using the
#@   #              relevant derate factor for the cell driving that net.
#@ 
#@   set_app_var si_use_driving_cell_derate_for_delta_delay false
#@ 
#@   #       si_xtalk_composite_aggr_mode
#@   #              Specifies the composite aggressor mode for crosstalk delay.
#@ 
#@   set_app_var si_xtalk_composite_aggr_mode statistical
#@ 
#@   #       si_xtalk_composite_aggr_noise_peak_ratio
#@   #              Used  to  control  the  composite  aggressor selection for xtalk
#@   #              analysis.
#@ 
#@   #set_app_var si_xtalk_composite_aggr_noise_peak_ratio 0.01
#@ 
#@   #       si_xtalk_composite_aggr_quantile_high_pct
#@   #              Used to control the composite aggressor creation for statistical
#@   #              analysis.
#@ 
#@   #set_app_var si_xtalk_composite_aggr_quantile_high_pct 99.73
#@ 
#@   #       si_xtalk_delay_analysis_mode
#@   #              Specifies the arrival window alignment mode for crosstalk delay.
#@ 
#@   #set_app_var si_xtalk_delay_analysis_mode all_paths
#@ 
#@   #       si_xtalk_double_switching_mode
#@   #              Controls  the double switching detection during the PrimeTime-SI
#@   #              timing analysis.
#@ 
#@   #set_app_var si_xtalk_double_switching_mode disabled
#@ 
#@   #       si_xtalk_exit_on_coupled_reevaluated_nets_pct
#@   #              Specifies a maximum percentage of nets selected for reevaluation
#@   #              relative to the total number of coupled nets, below which Prime-
#@   #              Time-SI exits the analysis loop.
#@ 
#@   #set_app_var si_xtalk_exit_on_coupled_reevaluated_nets_pct 0
#@ 
#@   #       si_xtalk_exit_on_max_delta_delay
#@   #              Specifies  the  upper  bound  of a window of delta delay values,
#@   #              within which PrimeTime-SI exits the analysis loop.
#@ 
#@   #set_app_var si_xtalk_exit_on_max_delta_delay 0
#@ 
#@   #       si_xtalk_exit_on_max_iteration_count
#@   #              Specifies  a  maximum  number  of incremental timing iterations,
#@   #              after which PrimeTime-SI exits the analysis loop.
#@ 
#@   set_app_var si_xtalk_exit_on_max_iteration_count 3
#@ 
#@ 
#@   #       si_xtalk_exit_on_min_delta_delay
#@   #              Specifies  the  lower  bound  of a window of delta delay values,
#@   #              within which PrimeTime-SI exits the analysis loop.
#@ 
#@   #set_app_var si_xtalk_exit_on_min_delta_delay 0
#@ 
#@   #       si_xtalk_exit_on_number_of_reevaluated_nets
#@   #              Specifies  a  maximum  number of nets selected for reevaluation,
#@   #              below which PrimeTime-SI exits the analysis loop.
#@ 
#@   #set_app_var si_xtalk_exit_on_number_of_reevaluated_nets 0
#@ 
#@   #       si_xtalk_exit_on_reevaluated_nets_pct
#@   #              Specifies a maximum percentage of nets selected for reevaluation
#@   #              relative to the total number of nets, below  which  PrimeTime-SI
#@   #              exits the analysis loop.
#@ 
#@   #set_app_var si_xtalk_exit_on_reevaluated_nets_pct 0
#@ 
#@ 
#@   #       si_xtalk_reselect_critical_path
#@   #              Determines  whether  or not PrimeTime-SI reselects critical path
#@   #              nets for subsequent delay calculations.
#@ 
#@   set si_xtalk_reselect_critical_path false
#@ 
#@   #       si_xtalk_reselect_delta_and_slack
#@   #              Reselect  nets  that satisfy both delta delay and slack reselec-
#@   #              tion criteria.
#@ 
#@   #set_app_var si_xtalk_reselect_delta_and_slack false
#@ 
#@   #       timing_si_exclude_delta_slew_for_transition_constraint
#@   #              Specifies  delta  slew  to  be excluded from maximum and minimum
#@   #              transition constraint checks.
#@ 
#@   #set_app_var timing_si_exclude_delta_slew_for_transition_constraint false
#@ 
#@   #  set_noise_parameters -enable_propagation
#@   #   Specifies  whether to allow noise propagation or not. Propagated
#@   #       noise on a victim net is caused by noise at an input of the cell
#@   #       that is driving the victim net. PrimeTime SI can calculate popa-
#@   #       gated noise at a cell output, given the propagation characteris-
#@   #       tics of the cell, the noise bump at the cell input, and the load
#@   #       on the cell output.
#@   #
#@ 
#@   set_noise_parameters -enable_propagation
#@ 
#@   #  si_noise_ccs_report_propagation true
#@   # Adds propagated noise info (on the receiver output) to the noise report
#@   #
#@ 
#@   set_app_var si_noise_ccs_report_propagation true
#@ 
#@   #  To set infinite timing windows on all port nets (excluding clocks). This is the most conservative approach for blocks
#@   #  because it decouples your block level SI analysis from the arrival windows of the inputs into the block
#@ 
#@   set ports [remove_from_collection [all_inputs] [get_attribute -quiet [all_clocks]  sources]]
#@ 
#@   set fanout_nets [get_nets -top_net_of_hierarchical_group -segments -of [all_fanout -flat -from $ports]]
#@   set_si_delay_analysis -ignore_arrival $fanout_nets
#@   puts "==>INFORMATION: Set infinite_window analysis on [sizeof_collection $fanout_nets] boundary nets."
#@ 
#@ } else {
#@   puts "==>INFORMATION: Current run is not a noise run (or) si was not turned on. Crosstalk settings were not applied"
#@ }
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/xtalk_settings.tcl

#@ 
#@ # To setup noise glitch settings for Noise runs
#@ P_source_if_exists noise_glitch_settings.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/noise_glitch_settings.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ if {[info exists run_type] && [regexp {((^noise))(.*)} $run_type]} {
#@ 
#@   # NOTE:  These input noise, macro noise, and noise margin settings are project specific.  Please modify as needed per project and per design block
#@ 
#@   # Input port noise
#@   #------------------
#@ 
#@   puts "==>INFORMATION: Setting input_noise values to the specified input ports"
#@ 
#@   set_input_noise -width 0.160 -height 0.21 -above -low [get_ports * -filter {direction==in}]
#@   set_input_noise -width 0.160 -height 0.21 -below -high [get_ports * -filter {direction==in}]
#@   set_input_noise -width 0.160 -height 0.21 -above -high [get_ports * -filter {direction==in}]
#@   set_input_noise -width 0.160 -height 0.21 -below -low [get_ports * -filter {direction==in}]
#@ 
#@   # Macro pin noise
#@   #-----------------
#@ 
#@   puts "==>INFORMATION: Setting input_noise and noise margin values to the input and output pins of the specified macros"
#@ 
#@   set macros_tuned 0
#@   set bumps_added 0
#@   set dcmarg_added 0
#@   set clkdcmarg_added 0
#@ 
#@   set dcnoisemacros {}
#@   set macro {i2*}
#@   set dcmarg 0.500
#@   set outbwidth 0.160
#@   set outbheight 0.280
#@   set ssres 0.800
#@   set clkdcmarg 0.17
#@ 
#@   if {$clkdcmarg eq ""} {
#@     set clkdcmarg $dcmarg
#@   }
#@ 
#@   set macro_insts [get_cells -quiet -hierarchical -filter "ref_name =~ $macro"]
#@   if {[sizeof_collection $macro_insts] > 0} {
#@     if {[info exists dcnoisemacros]} {
#@       add_to_collection $dcnoisemacros $macro_insts
#@     } else {
#@       set dcnoisemacros $macro_insts
#@     }
#@   }
#@ 
#@   foreach_in_collection lib [get_libs -quiet "$macro"] {
#@     set lib_input_data_pins [sort_collection [get_lib_pins -quiet -of_object [get_lib_cells "[get_object_name $lib]/*"] -filter "(pin_direction == in || pin_direction == inout) && clock == false"] full_name]
#@     set lib_input_clock_pins [sort_collection [get_lib_pins -quiet -of_object [get_lib_cells "[get_object_name $lib]/*"] -filter "(pin_direction == in || pin_direction == inout) && clock == true"] full_name]
#@     set lib_output_pins [sort_collection [get_lib_pins -quiet -of_object [get_lib_cells "[get_object_name $lib]/*"] -filter "pin_direction == out || pin_direction == inout"] full_name]
#@     if {[sizeof_collection $lib_input_data_pins] > 0} {
#@       set_noise_margin -above -low $dcmarg $lib_input_data_pins
#@       set_noise_margin -below -high $dcmarg $lib_input_data_pins
#@       incr dcmarg_added [sizeof_collection $lib_input_data_pins]
#@     }
#@     if {[sizeof_collection $lib_input_clock_pins] > 0} {
#@       set_noise_margin -above -low $clkdcmarg $lib_input_clock_pins
#@       set_noise_margin -below -high $clkdcmarg $lib_input_clock_pins
#@       incr clkdcmarg_added [sizeof_collection $lib_input_clock_pins]
#@     }
#@     set_steady_state_resistance -above -low $ssres $lib_output_pins
#@     set_steady_state_resistance -above -high $ssres $lib_output_pins
#@     set_steady_state_resistance -below -high $ssres $lib_output_pins
#@     set_steady_state_resistance -below -low $ssres $lib_output_pins
#@     incr macros_tuned
#@   }
#@ 
#@   puts "==>INFORMATION: Set_macro_noise: Set steady state resistance for $macros_tuned macros."
#@   puts "==>INFORMATION: Set dc noise margins on $dcmarg_added macro data pins and $clkdcmarg_added macro clock pins."
#@ 
#@   foreach_in_collection macroinst [get_cells -quiet -hierarchical -filter "ref_name =~ $macro"] {
#@     foreach_in_collection macropin [get_pins -quiet -of_objects $macroinst -filter "direction == out || direction == inout"] {
#@       set_input_noise -width $outbwidth -height $outbheight $macropin -above -low
#@       set_input_noise -width $outbwidth -height $outbheight $macropin -below -high
#@       incr bumps_added
#@     }
#@   }
#@   puts "==>INFORMATION: Added output noise bumps on $bumps_added macro instance pins."
#@ 
#@   # Output port noise margin
#@   #--------------------------
#@ 
#@   puts "==>INFORMATION: Setting noise margins to the specified output ports"
#@ 
#@   set_noise_margin -above -low 0.210 [get_ports -filter {direction==out}]
#@   set_noise_margin -below -high 0.210 [get_ports -filter {direction==out}]
#@   set_noise_margin -above -high 0.210 [get_ports -filter {direction==out}]
#@   set_noise_margin -below -low 0.210 [get_ports -filter {direction==out}]
#@ 
#@   # If using infinite timing windows, only one iteration is needed
#@   set_app_var si_xtalk_exit_on_max_iteration_count 1
#@ 
#@   # Set to use infinite timing windows for glitch
#@   set_noise_parameters -ignore_arrival -include_beyond_rails
#@ 
#@ } else {
#@   puts "==>INFORMATION: Current run is not of noise run_type. Static Noise Settings were not applied."
#@ }
#@ 
#@ 
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/noise_glitch_settings.tcl

#@ 
#@ # To setup power analysis for Power runs
#@ P_source_if_exists power_analysis.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/power_analysis.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ if {[info exists run_type] && [regexp {((^power))(.*)} $run_type]} {
#@ 
#@   # Defining Power Settings:
#@   #----------------------------
#@ 
#@   set_app_var power_enable_analysis true
#@ 
#@   if {[info exists INTEL_POWER_ANALYSIS] && $INTEL_POWER_ANALYSIS == "peak"} {
#@     set_app_var power_analysis_mode time_based
#@   } else {
#@     set_app_var power_analysis_mode averaged
#@   }
#@ 
#@   # SPECIFY DEFAULT SWITCHING ACTIVITY for VECTOR-FREE power analysis
#@   #Annotate a suitable default toggle rate value, for example, 0.2 to all the starting points.
#@   #Recommended to provide a pessimistic value for power compared to the gate-level VCD
#@ 
#@   set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@   set_app_var power_default_static_probability $INTEL_POWER_SP
#@ 
#@   #Annotate reset signal by applying a constant value of 0.
#@   #Recommended for special signals like reset and scan enable for default toggle rates should not be applied.
#@ 
#@   #set_case_analysis 0 [get_port *RESET*]
#@ 
#@   #Annotate toggle rates based on the related clocks using the -clocks option to register outputs.
#@   #You should do this because propagation through sequential elements can result in loss of activity.
#@ 
#@   #set_switching_activity -type registers -toggle_count <value> -clocks {all_clocks}
#@ 
#@   #Annotate clock-gating cells with a factor that is a multiple of the toggle rate of the related clock.
#@   #When the -clocks is specified, the -clock_derate option is used as an alternative to the -toggle_count option.
#@   #This guarantees that the clock-gating output is toggling at the expected rate.
#@ 
#@   #set_switching_activity -clocks clk2 -clock_derate <value> -type clock_gating_cells
#@ 
#@   # Performing Power Analysis:
#@   #----------------------------
#@ 
#@   #CALCULATING FOR AVERAGE POWER
#@   #-----------------------------
#@   if {[info exists INTEL_POWER_ANALYSIS] && $INTEL_POWER_ANALYSIS == "avg"} {
#@     if {[string match *\.vcd* $INTEL_ACTIVITY_FILE ] || [string match *\.fsdb* $INTEL_ACTIVITY_FILE ]} {
#@       puts "==>INFORMATION: VCD file is used for AVERAGE Power Calculation"
#@       set cmd "read_vcd $INTEL_ACTIVITY_FILE"
#@     } elseif {[string match *\.saif* $INTEL_ACTIVITY_FILE ]} {
#@       puts "==>INFORMATION: SAIF file is used for AVERAGE Power Calculation"
#@       set cmd "read_saif $INTEL_ACTIVITY_FILE"
#@     } else {
#@       puts "==>INFORMATION: Vector-Free AVERAGE Power Calculation is performed using default factors"
#@     }
#@ 
#@     if {[info exists INTEL_STRIP_PATH] && $INTEL_STRIP_PATH !=""} {
#@       set cmd "$cmd -strip_path $INTEL_STRIP_PATH"
#@     }
#@ 
#@     if {[info exists INTEL_RTL_VCD_MAP_FILE] && $INTEL_RTL_VCD_MAP_FILE !=""} {
#@       source $INTEL_RTL_VCD_MAP_FILE
#@       set cmd "$cmd -rtl"
#@     }
#@ 
#@     puts "==>INFORMATION: Evaluating AVERAGE Power Calculation using\n$cmd"
#@     eval $cmd
#@     redirect -tee ${INTEL_DESIGN_NAME}.switching_activity.rpt {report_switching_activity -list_not_annotated}
#@ 
#@   } elseif {[info exists INTEL_POWER_ANALYSIS] && $INTEL_POWER_ANALYSIS == "peak"} {
#@ 
#@     #CALCULATING FOR PEAK POWER
#@     #-----------------------------
#@ 
#@     if {[string match *\.vcd* $INTEL_ACTIVITY_FILE ]} {
#@       puts "==>INFORMATION: VCD file is used for PEAK Power Calculation"
#@       set cmd "read_vcd $INTEL_ACTIVITY_FILE"
#@     } else {
#@       puts "==>FATAL: Could not find VCD file for PEAK Power Calculation. Exiting..."
#@       exit
#@     }
#@ 
#@     if {[info exists INTEL_STRIP_PATH] && $INTEL_STRIP_PATH != ""} {
#@       set cmd "$cmd -strip_path $INTEL_STRIP_PATH"
#@     }
#@ 
#@     if {[info exists INTEL_RTL_VCD_MAP_FILE] && $INTEL_RTL_VCD_MAP_FILE !=""} {
#@       source $INTEL_RTL_VCD_MAP_FILE
#@       set cmd "$cmd -rtl"
#@     }
#@ 
#@     puts "==>INFORMATION: Evaluating PEAK Power Calculation using\n$cmd"
#@     eval $cmd
#@     redirect -tee ${INTEL_DESIGN_NAME}.switching_activity.rpt {report_switching_activity -list_not_annotated}
#@     set_power_analysis_options -waveform_format out -waveform_output vcd
#@   }
#@ } else {
#@   puts "==>INFORMATION: Current run is not a power run. Power Analysis did not take place."
#@ }
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/power_analysis.tcl

#@ 
#@ # To setup AOCVM settings
#@ P_source_if_exists aocvm_setting.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/aocvm_setting.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ if {[info exists INTEL_ENABLE_AOCVM] && $INTEL_ENABLE_AOCVM} {
#@ 
#@   #  Maximum timing derate values to be applied (this will clip AOCVM values).
#@   set_timing_derate -clock -cell_delay -late 1.2
#@   set_timing_derate -data -cell_delay -late 1.00
#@   set_timing_derate -clock -cell_delay -early 0.8
#@   set_timing_derate -data -cell_delay -early 0.8
#@ 
#@   #Enabling AOCVM Analysis
#@   set_app_var timing_aocvm_enable_analysis true
#@   set_app_var timing_aocvm_analysis_mode ""
#@ 
#@   # To perform only AOCVM-PBA during path based analysis (if path based analysis is enabled through the report_timing -pba_mode switch)
#@ 
#@   #set_app_var pba_aocvm_only_mode true
#@ 
#@   ###################
#@   #Read AOCVM tables
#@   ####################
#@ 
#@   if {[info exists INTEL_PV_MAX_MIN_LIB_PAIR($run_type)] && $INTEL_PV_MAX_MIN_LIB_PAIR($run_type) != ""} {
#@     set tmp_lib_pair $INTEL_PV_MAX_MIN_LIB_PAIR($run_type)
#@   } else {
#@     puts "==>FATAL: INTEL_PV_MAX_MIN_LIB_PAIR is not set. Exiting..."
#@     exit
#@   }
#@ 
#@   if {[info exists INTEL_AOCVM_TABLE($run_type)] && $INTEL_AOCVM_TABLE($run_type) != "" } {
#@     foreach aocvm_table $INTEL_AOCVM_TABLE($run_type) {
#@       if {[file exists $aocvm_table]} {
#@         puts "==>INFORMATION: Reading AOCVM table $aocvm_table"
#@         read_aocvm $aocvm_table
#@       } else {
#@         puts "==>FATAL: $aocvm_table does not exists. Exiting..."
#@       }
#@     }
#@   } else {
#@     puts "==>FATAL: Variable \$INTEL_AOCVM_TABLE($run_type) is not set in block_setup.tcl. Exiting ..."
#@     exit
#@   }
#@ 
#@ } else {
#@   puts "==>INFORMATION: INTEL_ENABLE_AOCVM does not exist (or) has been set to 0. AOCVM analysis did not take place"
#@ }
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/aocvm_setting.tcl

#@ 
#@ # Hook to setup OCV and aging derates and RC scaling factors
#@ # Note: Please obtain this file from your Intel Representative.
#@ P_source_if_exists  TIMING_OPTIONS.tcl
#@ 
#@ # To update timing/noise/power and generate reports for the design.
#@ P_source_if_exists update_n_reports.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/update_n_reports.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # 1. P_reports
#@ # 2. P_report_xtalk_deltas
#@ ##########################
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ ############################
#@ #Update timing/noise/power
#@ ############################
#@ 
#@ if {[info exists run_type] && [regexp {(^noise)(.*)} $run_type]} {
#@   puts "==>INFORMATION: Performing update_noise..."
#@   redirect -tee ./logs/update_noise.log {update_noise -full}
#@ } elseif {[info exists run_type] && [regexp {(^power)(.*)} $run_type]} {
#@   puts "==>INFORMATION: Performing update_power..."
#@   redirect -tee ./logs/check_power.log  {check_power}
#@   redirect -tee ./logs/update_power.log {update_power}
#@ } else {
#@   puts "==>INFORMATION: Performing update_timing..."
#@   redirect -tee ./logs/check_power.log  {check_power}
#@   redirect -tee ./logs/update_timing.log {update_timing -full}
#@ }
#@ 
#@ 
#@ ################
#@ # Save Session
#@ ################
#@ 
#@ current_design $INTEL_DESIGN_NAME
#@ save_session [format "%s.%s.Session" $INTEL_DESIGN_NAME $run_type]
#@ 
#@ ############
#@ #PV Reports
#@ ############
#@ 
#@ # Calling report generation procedure P_reports from procs.tcl.
#@ # This procedure makes use of INTEL_REPORTS($run_type) defined in block_setup.tcl to determine the reports to be generated.
#@ 
#@ P_reports $run_type
#@ 
#@ # Calling P_report_xtalk_deltas procedure from procs.tcl to generate Xtalk Delta report if SI is on.
#@ if {[info exists si] && $si == "on" && [regexp {((^max)|(^min))(.*)} $run_type]} {
#@   puts "==>INFORMATION: Generating xtalk delta report..."
#@   P_report_xtalk_deltas -sort delta > ./reports/${INTEL_DESIGN_NAME}.xtalk_delta.rpt
#@ } else {
#@   puts "==>INFORMATION: Xtalk delta report is not supported, since si is off."
#@ }
#@ 
#@ set end_time [clock seconds]
#@ set elapsed_time [expr ($end_time - $start_time) / 60.0 / 60.0]
#@ echo "Runtime of Entire Timing Run = $elapsed_time hrs" > ./reports/$INTEL_DESIGN_NAME.run_time.rpt
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/update_n_reports.tcl

#@ 
#@ # To perform electrical rule checks
#@ if {[info exists INTEL_PT_ERC_CHECK_ENABLE] && $INTEL_PT_ERC_CHECK_ENABLE} {
#@   puts "==>INFORMATION: Setting the files for PT-ERC checks"
#@   # the config file provided in this kit is an example only. Please see
#@   #   your Intel Custom Foundry representative for the correct file for your
#@   #   project.
#@   P_source_if_exists erc_config.tcl
#@   P_source_if_exists run_erc.tcl
#@ }
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/erc_config.tcl

#@ ##############################################################################
#@ 
#@ #################################################################################################################
#@ # Setting up variables
#@ 
#@ # Defines the library cell and file prefix to use in ERC.
#@ set library_type "d04"
#@ set libcell_regexp "^$library_type"
#@ 
#@ #################################################################################################################
#@ #Clock Related Check Variables
#@ 
#@ # These combinational clock cells have disabled timing arcs to infer setup and hold checks. These disabled arcs
#@ #   will block timing paths through these cells if used on a data path, thus they cannot be used on the
#@ #   data path.
#@ set clock_cells_not_allowed_on_datapath { d04gan00wd0*                                               d04gan10wd0*                                               d04gan20wd0*                                               d04gan30wd0*                                               d04gan40wd0*                                               d04gmx22wd0*                                               d04gna00wd0*                                               d04gno00wd0*                                               d04gor00wd0* }
#@ set clock_library_cells { d04gan00* d04gan10* d04gbf* d04gin* d04gan20* d04gan30* d04gan40* d04gmx22* d04gna00* d04gor00* d04cgc00* d04cgc01*}
#@ 
#@ 
#@ #################################################################################################################
#@ #Data Cell Related Check Variables
#@ 
#@ # Define a list of wildcarded cells (* or ?, no regexp) that are not allowed in the design netlist.
#@ #
#@ set illegal_cell_list {d04cgc00*}
#@ 
#@ # Define the analog macro/block pins. Nets of these pins will be checked to make sure no digital logic cells are
#@ #  connected to them.
#@ set analog_macro_list {}
#@ set analog_pins {}
#@ 
#@ #################################################################################################################
#@ # The ERC flow (run_erc.tcl) can be configured to run all checks either serially or in 2 parallel threads.
#@ #
#@ # Parallel:
#@ #   set erc_parallel 1
#@ #   The two variables (erc_rule_list_(1|2) below allow for custom grouping of rules into those 2 threads
#@ #   to provide best runtime improvment.
#@ #
#@ # Serially:
#@ #   set erc_parallel 0
#@ #   This mode still uses the erc_rule_list_(1|2) variables, but concatenates them together in numerical order
#@ #   and runs the rules serially.
#@ #
#@ # The erc_rule_final is meant as a single check to be run at the end for all rules because that rule
#@ #   will modify the timing database. Currently used only for the min_period check since it disables AOCVM,
#@ #   changes clock_uncertainties and re-runs update timing.
#@ 
#@ # the following 4 variables need to be defined for the run_erc.tcl to function correctly.
#@ set erc_parallel 0
#@ set erc_rule_list_1 {}
#@ set erc_rule_list_2 {}
#@ set erc_rule_final {}
#@ 
#@ lappend erc_rule_list_1 "dangling_cell_input \$all_cell_input_pins"
#@ lappend erc_rule_list_1 "clock_cell_on_data_path \$all_cells \$clock_cells_not_allowed_on_datapath"
#@ lappend erc_rule_list_1 "clock_tree_different_vt_cells \$all_clocks"
#@ lappend erc_rule_list_1 "illegal_cell \$all_cells \$illegal_cell_list"
#@ lappend erc_rule_list_1 "bare_passgate_combinational \$all_cells"
#@ lappend erc_rule_list_1 "bare_passgate_sequential \$all_cells"
#@ lappend erc_rule_list_2 "data_cell_on_clock_path"
#@ lappend erc_rule_list_2 "output_pin_connected_to_power_ground"
#@ lappend erc_rule_list_2 "digital_cell_on_analog_net \$analog_pins \$analog_macro_list"
#@ lappend erc_rule_list_1 "multiple_cell_shorted_outputs \$all_nets"
#@ 
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/erc_config.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/run_erc.tcl

#@ ##############################################################################
#@ 
#@ ###################################################################################
#@ # Setup procs and variables needed for this ERC flow
#@ #
#@ #  There is a configuration script that defines the rules and settings for this
#@ #  ERC flow to work. An example script has been provided in the kit:
#@ #
#@ #    source $env(INTEL_ASIC)/asicflows/synopsys/pv/scripts/erc_config.tcl
#@ #
#@ #  However, this config script is not signoff quality. Please see your
#@ #    Intel Custom Foundry representative to obtain the right script for your project
#@ #    to use for signoff ERC checks.
#@ #
#@ set start_time [clock seconds]
#@ puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ source $env(INTEL_ASIC)/asicflows/synopsys/sta/erc_procs.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/erc_procs.tcl

#@ ##############################################################################
#@ 
#@ 
#@ #############################################################################################
#@ # P_get_driver_of_pin
#@ #   gets the libray cell/pin that drives the given pin
#@ #
#@ #  Inputs:
#@ #    pin:  instance pin of design
#@ #    idriver: pointer to store driver pin in
#@ #
#@ #  Returns:
#@ #    string: "cell/pin"
#@ #
#@ proc P_get_driver_of_pin {pin idriver} {
#@   upvar $idriver driver
#@   set driver [filter_collection [all_fanin -to $pin -flat -levels 1] "(object_class ==port && direction ==in) || (object_class == pin && direction ==out)" ]
#@   regsub {^[a-zA-Z0-9\._]*\/} [get_object_name [get_lib_pins -of $driver]] {} driver
#@   return $driver
#@ }
#@ 
#@ 
#@ #############################################################################################
#@ # P_max_min_margin
#@ #   fetches the worst case max and min timing slack of a pin
#@ #
#@ #  Inputs:
#@ #    ipin:  instance pin on data path
#@ #    max_mg: pointer to store worst case max slack of pin
#@ #    min_mg: pointer to store worst case min slack of pin
#@ #
#@ #  Returns:
#@ #    nothing
#@ #
#@ proc P_max_min_margin { ipin max_mg min_mg } {
#@   upvar $max_mg max_margin
#@   upvar $min_mg min_margin
#@   set pin_coll ""
#@   set pin_coll [add_to_collection $pin_coll [get_pins -quiet $ipin]]
#@   set pin_coll [add_to_collection $pin_coll [get_ports -quiet $ipin]]
#@   foreach_in_collection item $pin_coll {
#@     set r_sk_max [get_attribute [get_pins -quiet $item] max_rise_slack]
#@     set f_sk_max [get_attribute [get_pins -quiet $item] max_fall_slack]
#@     set r_sk_min [get_attribute [get_pins -quiet $item] min_rise_slack]
#@     set f_sk_min [get_attribute [get_pins -quiet $item] min_fall_slack]
#@     if {[get_ports -quiet $item] ne ""  } {
#@       set r_sk_max [get_attribute [get_ports -quiet $item] max_rise_slack]
#@       set f_sk_max [get_attribute [get_ports -quiet $item] max_fall_slack]
#@       set r_sk_min [get_attribute [get_ports -quiet $item] min_rise_slack]
#@       set f_sk_min [get_attribute [get_ports -quiet $item] min_fall_slack]
#@     }
#@   }
#@   if {($r_sk_max ne "INFINITY") && ($f_sk_max ne "INFINITY") && ($r_sk_max ne "") && ($f_sk_max ne "")} {
#@     set max_margin [expr ( $r_sk_max <  $f_sk_max) ? $r_sk_max : $f_sk_max ]
#@   } else {
#@     set max_margin "n/a"
#@   }
#@   if {($r_sk_min ne "INFINITY") && ($f_sk_min ne "INFINITY") && ($r_sk_min ne "") && ($f_sk_min ne "")} {
#@     set min_margin [expr ( $r_sk_min <  $f_sk_min) ? $r_sk_min : $f_sk_min ]
#@   } else {
#@     set min_margin "n/a"
#@   }
#@ }
#@ 
#@ #############################################################################################
#@ # P_get_list_largest
#@ #   retuns the largest item in a list of numbers/floats/real
#@ #
#@ #  Inputs:
#@ #    num_list: list of numbers in any order
#@ #
#@ #  Returns:
#@ #    largest number in the list as a string
#@ #
#@ proc P_get_list_largest {num_list} {
#@   return [lindex [lsort -increasing -real $num_list] 0]
#@ }
#@ 
#@ #############################################################################################
#@ # P_clk_max_min_margin
#@ #   fetches the worst case max and min timing slack of a clock pin
#@ #
#@ #  Inputs:
#@ #    ipin:  instance pin on clock path
#@ #    max_mg: pointer to store worst case max slack of pin
#@ #    min_mg: pointer to store worst case min slack of pin
#@ #
#@ #  Returns:
#@ #    nothing
#@ #
#@ proc P_clk_max_min_margin {ipin max_mg min_mg } {
#@   upvar $max_mg max_margin
#@   upvar $min_mg min_margin
#@   global debug_pin
#@   set debug_pin $ipin
#@   set max_margin "n/a"
#@   set min_margin "n/a"
#@   set all_launch_flops [get_pins -quiet -of  [get_cells -quiet -of [all_fanout -endpoints_only -flat -from [get_pins $ipin]]] -filter "direction == out"]
#@   if ![sizeof_collection $all_launch_flops] {
#@     return
#@   }
#@   set all_launch_flops_max [filter_collection $all_launch_flops "(max_rise_slack!=INFINITY) && (max_fall_slack!=INFINITY)"]
#@   set all_launch_flops_min [filter_collection $all_launch_flops "(min_rise_slack!=INFINITY) && (min_fall_slack!=INFINITY)"]
#@   if [sizeof_collection $all_launch_flops_max] {
#@     set r_sk_max_list [get_attribute  -quiet $all_launch_flops_max  max_rise_slack]
#@     set f_sk_max_list [get_attribute  -quiet $all_launch_flops_max  max_fall_slack]
#@     set r_sk_max  [P_get_list_largest $r_sk_max_list]
#@     set f_sk_max  [P_get_list_largest $f_sk_max_list]
#@     if {[llength $r_sk_max] != 0 && [llength $f_sk_max] !=0 } {
#@       set max_margin [expr ($r_sk_max < $f_sk_max ) ? $r_sk_max : $f_sk_max]
#@     }
#@   }
#@   if [sizeof_collection $all_launch_flops_min] {
#@     set r_sk_min_list [get_attribute  -quiet $all_launch_flops_min  min_rise_slack]
#@     set f_sk_min_list [get_attribute  -quiet $all_launch_flops_min  min_fall_slack]
#@     set r_sk_min  [P_get_list_largest $r_sk_min_list]
#@     set f_sk_min  [P_get_list_largest $f_sk_min_list]
#@     if {[llength $r_sk_min] != 0 && [llength $f_sk_min] !=0 } {
#@       set min_margin [expr ($r_sk_min < $f_sk_min ) ? $r_sk_min : $f_sk_min]
#@     }
#@   }
#@ }
#@ 
#@ 
#@ #############################################################################################
#@ # P_get_clock_name
#@ #   returns a list of clocks that are related to given instance pin
#@ #
#@ #  Inputs:
#@ #    ipin:   instance pin (clock or data)
#@ #
#@ #  Returns:
#@ #    list of strings that are the clock names relate to the provide pin
#@ #
#@ proc P_get_clock_name {ipin clk_nm} {
#@   set clk_d [list]
#@   if { [get_attribute [get_cells -of [get_pins  $ipin]] is_clock_network_cell] == true} {
#@     set return_clk [get_attribute $ipin clocks -quiet]
#@     if {$return_clk == ""} {
#@       set return_clk [get_attribute $ipin power_base_clock -quiet]
#@     }
#@     set clkn [get_clocks -quiet $return_clk]
#@     foreach_in_collection ck $clkn {
#@       set name [get_object_name $ck]
#@       lappend clk_d  $name
#@     }
#@   } else {
#@     set return_clk [get_attribute $ipin power_base_clock -quiet]
#@     if {$return_clk == ""} {
#@       set return_clk [get_attribute [all_fanin -to $ipin -startpoints_only -flat] clocks -quiet]
#@     }
#@     set clkn [get_clocks -quiet $return_clk]
#@     foreach_in_collection ck $clkn {
#@       set name [get_object_name $ck]
#@       lappend clk_d  $name
#@       set clk_d [lsort -unique $clk_d]
#@     }
#@   }
#@   return $clk_d
#@ }
#@ 
#@ 
#@ ###################################################################################
#@ # P_get_slack
#@ #  get timing slack through a given pin
#@ #
#@ #  Inputs:
#@ #    pin:  instance pin
#@ #    type: delay type: max|min
#@ #
#@ #  Returns:
#@ #    float of slack through given pin
#@ #
#@ proc P_get_slack {pin {type "max"}} {
#@   set paths [get_timing_paths -delay_type $type -through $pin]
#@   if {[sizeof_coll $paths] > 0} {
#@     set slack [get_attribute [index_collection $paths 0] slack]
#@   } else {
#@     set slack "na"
#@   }
#@   return $slack
#@ }
#@ 
#@ 
#@ 
#@ ###################################################################################
#@ # P_erc_combine_summary_files
#@ #  Combines all the summary files in a parallel execute ERC run
#@ #
#@ #  Inputs:
#@ #    none
#@ #
#@ #  Returns:
#@ #    none
#@ #
#@ proc P_erc_combine_summary_files {} {
#@   foreach fn [glob ./reports/*.tmp.sum] {
#@     set f [open $fn "r"]
#@     gets $f line
#@     lappend all_sum_txt $line
#@     close $f
#@     file delete $fn
#@   }
#@   foreach t $all_sum_txt {
#@     echo $t >> ./reports/erc_checks.sum
#@   }
#@ }
#@ 
#@ 
#@ 
#@ ###################################################################################
#@ # P_erc_get_pin_tran
#@ #  Gets a pin slew/transition time, including any si annotated slew/tran delay.
#@ #
#@ #  Inputs:
#@ #    single item collection of pin to operate on
#@ #
#@ #  Returns:
#@ #    float of pin transition
#@ #
#@ proc P_erc_get_pin_tran {pin} {
#@   set ac_maxrise [get_attribute $pin actual_rise_transition_max]
#@   set ac_maxfall [get_attribute $pin actual_fall_transition_max]
#@   set del_maxrise [get_attribute $pin annotated_rise_transition_delta_max]
#@   set del_maxfall [get_attribute $pin annotated_fall_transition_delta_max]
#@   set maxrise [expr $ac_maxrise + $del_maxrise]
#@   set maxfall [expr $ac_maxfall + $del_maxfall]
#@   set pin_trans [expr $maxrise > $maxfall ? $maxrise : $maxfall]
#@   return $pin_trans
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/erc_procs.tcl

#@ source $env(INTEL_ASIC)/asicflows/synopsys/sta/erc_rules.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/erc_rules.tcl

#@ 
#@ ##############################################################################################
#@ # Usage: dangling_cell_input
#@ #
#@ # This procedure will report all the dangling inputs in your design
#@ ##############################################################################################
#@ proc dangling_cell_input {all_input_pins} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "#floating input pin,"
#@   foreach_in_collection pin  $all_input_pins {
#@     set pins [get_attr [get_nets -of_objects $pin -quiet -top]  number_of_leaf_drivers] 
#@       if {$pins =="" ||   $pins == 0 } {
#@       set p_name [get_attribute $pin full_name]
#@       puts $f $p_name
#@       incr vio_cnt
#@     }
#@   }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ##############################################################################################
#@ # Usage: clock_cell_on_data_path
#@ #
#@ # This procedure will report if specified clock cells are used on data paths
#@ ##############################################################################################
#@ proc clock_cell_on_data_path {all_cells clock_cells_not_allowed_on_datapath} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"] 
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "#cell instance"
#@   set clk_cell_expr "ref_name =~ [lindex $clock_cells_not_allowed_on_datapath 0]"
#@   foreach cell [lrange $clock_cells_not_allowed_on_datapath 1 end] {
#@     append clk_cell_expr " || ref_name =~ $cell"
#@   }
#@   
#@     foreach_in_collection clock_cell [filter_collection $all_cells "$clk_cell_expr"] {
#@       if {[get_attribute $clock_cell is_clock_network_cell] == "false"} {
#@         puts $f "[get_object_name $clock_cell], [get_attribute $clock_cell ref_name]"
#@         incr vio_cnt
#@       }
#@     }
#@   
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ##############################################################################################
#@ # Usage: data_cell_on_clock_path
#@ #
#@ # This procedure will report if any data path cells were used in clock network paths
#@ ##############################################################################################
#@ proc data_cell_on_clock_path {} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "#cell instance, cell reference, clock name"
#@     foreach_in_collection clock_cell [get_clock_network_objects -type cell -include_clock_gating_network] {
#@       set lib_cell [get_lib_cells -of_objects $clock_cell -quiet -filter "undefined(clock_cell) && (number_of_pins > 1)" ]
#@       if { $lib_cell != "" } {
#@         set cell_name [get_object_name  $clock_cell]
#@         set ref_name [get_attribute $clock_cell ref_name]
#@         set clk_name  [get_attribute -quiet [get_pins -of  $clock_cell -filter "direction==out"] clocks]
#@         if { [sizeof_collection $clk_name] == 0 } {
#@           set clock_name "unknown"
#@         } else {
#@           set clock_name [get_object_name $clk_name]
#@         }
#@         puts $f "$cell_name, $ref_name,  $clock_name"
#@         incr vio_cnt
#@       }
#@     }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   unsuppress_message ATTR-3
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ##############################################################################################
#@ # Usage: illegal_cell
#@ #
#@ # This procedure will report all the Illegal cells found in the design; 
#@ ##############################################################################################
#@ proc illegal_cell {all_cells illegal_cell_list} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "# cell instance, cell reference"
#@   set illegal_cell_expr "ref_name =~ [lindex $illegal_cell_list 0]"
#@   foreach cell [lrange $illegal_cell_list 1 end] {
#@     append illegal_cell_expr " || ref_name =~ $cell"
#@   }
#@   foreach_in_collection c [filter_collection $all_cells "$illegal_cell_expr"] {
#@     set c_name [get_attribute $c full_name]
#@     puts $f "$c_name, [get_attribute $c ref_name]"
#@     incr vio_cnt
#@   }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ##############################################################################################
#@ # Usage: digital_cell_on_analog_net
#@ #
#@ # This procedure will report digital cells on analog nets
#@ ##############################################################################################
#@ proc digital_cell_on_analog_net {analog_pins analog_macro_list} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "#analog pin, direction, cell instance name, cell reference name"
#@   if {[llength $analog_macro_list]} {
#@     set not_spec_macro [join $analog_macro_list {) && (ref_name !~} ]
#@     set std_cell_filter "(ref_name !~ $not_spec_macro )" 
#@   } 
#@   foreach_in_collection a_pin $analog_pins {
#@     set a_net [get_nets -quiet -of_objects $a_pin ]
#@     if { $a_net == "" } { continue }
#@     set ebb_pins [remove_from_collection [get_pins -quiet -leaf -of_objects $a_net -filter "(direction == out || direction == inout)"] $a_pin]
#@     if [info exists std_cell_filter] {
#@       set drivers [get_cells -quiet -of_objects $ebb_pins -filter "$std_cell_filter"]
#@     } else {
#@       set drivers [get_cells -quiet -of_objects $ebb_pins]
#@     }
#@     foreach_in_collection connected_cell $drivers {
#@       set pin_dir [get_attribute $a_pin direction]
#@       puts $f "[get_object_name $a_pin], $pin_dir, [get_object_name $connected_cell], [get_attribute $connected_cell ref_name]"
#@       incr vio_cnt
#@     }
#@   }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ##############################################################################################
#@ # Usage: multiple_cell_shorted_outputs
#@ #
#@ # This procedure will report all the shorted outputs or shorted nets 
#@ ##############################################################################################
#@ proc multiple_cell_shorted_outputs {all_nets} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "#net, output pins"
#@   foreach_in_collection n $all_nets {
#@     set d_names [get_pins -quiet -leaf -of_objects $n -filter "direction == out"]
#@     append_to_collection d_names [get_ports -quiet -of_objects $n -filter "direction == in" ]
#@     set d_num  [sizeof_collection $d_names]
#@     if {$d_num > 1} {
#@       set msg "[get_object_name $n],"
#@       foreach_in_collection d_name $d_names {
#@         set msg [concat $msg "[get_object_name $d_name], "]
#@       }
#@       puts $f $msg
#@ 	    incr vio_cnt
#@     }
#@   }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ 
#@ ##############################################################################################
#@ # Usage: output_pin_connected_to_power_ground
#@ #
#@ # This procedure will report all pins or input ports which drives the supply
#@ #############################################################################################
#@ proc output_pin_connected_to_power_ground {} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "#output pin, power/gnd net"
#@   set pinlist [get_pins -hierarchical *Logic1* -quiet -filter "is_hierarchical == false" ]
#@   append_to_collection pinlist [get_pins -hierarchical *Logic0* -quiet -filter "is_hierarchical == false" ]
#@   set supply_nets [get_nets -of_objects $pinlist -quiet ]
#@   foreach_in_collection net $supply_nets {
#@     set connected [all_connected $net -leaf]
#@     if {$connected == ""} { continue }
#@     set n_name [get_attribute $net full_name]
#@     set out_pins_tied_supply [filter_collection $connected "direction == out && full_name !~ *Logic0* && full_name !~ *Logic1* && undefined(constant_value) " ]
#@     foreach_in_collection pin_to_supply $out_pins_tied_supply {
#@ 	    set p_name [get_attribute $pin_to_supply full_name]
#@ 	    puts $f "$p_name, $n_name"
#@ 	    incr vio_cnt
#@     }
#@   }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ##############################################################################################
#@ # Usage: clock_tree_different_vt_cells
#@ #
#@ # This procedure will report violations if clock tree is not made up of the same type of VT cell
#@ ##############################################################################################
#@ proc clock_tree_different_vt_cells {all_clocks} {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"] 
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   puts $f "#clock name, nn count, ln count, wn count, command to find violating cells"
#@   set processed_items ""
#@   foreach_in_collection clock $all_clocks {
#@     set wn_cells ""
#@     set nn_cells ""
#@     set ln_cells ""
#@     set wn 0
#@     set ln 0
#@     set nn 0
#@     set wn_exp "ref_name =~ .*w\[nd\].*"
#@     set ln_exp "ref_name =~ .*l\[nd\].*"
#@     set nn_exp "ref_name =~ .*n\[nd\].*"
#@     set clk_name [get_object_name $clock]
#@     set clk_port [get_attribute $clock sources -quiet]
#@     if {[lsearch $processed_items $clk_port] >= 0} {continue} 
#@     lappend processed_items $clk_port
#@     set clock_cells [get_cells -of_objects  [all_fanout -from $clk_port -flat -trace_arcs all] -filter "is_sequential != true && is_black_box != true" -quiet]
#@     set clock_wn [filter $clock_cells -regexp $wn_exp]  
#@     set clock_ln [filter $clock_cells -regexp $ln_exp]  
#@     set clock_nn [filter $clock_cells -regexp $nn_exp]  
#@     set num_clock_wn [sizeof_coll $clock_wn]
#@     set num_clock_ln [sizeof_coll $clock_ln]
#@     set num_clock_nn [sizeof_coll $clock_nn]
#@     set cell_list ""
#@     lappend cell_list "w\\\[nd\\\] $num_clock_wn"
#@     lappend cell_list "l\\\[nd\\\] $num_clock_ln"
#@     lappend cell_list "n\\\[nd\\\] $num_clock_nn"
#@     set cell_list [lsort -integer -index 1 -decreasing $cell_list]
#@     set secondary_vt_cnt [lindex [lindex $cell_list 1] 1]
#@     set tertiary_vt_cnt [lindex [lindex $cell_list 2] 1]
#@     if {$secondary_vt_cnt > 0 || $tertiary_vt_cnt > 0} {
#@       set outp "$clk_name, $num_clock_nn, $num_clock_ln, $num_clock_wn, " 
#@       lappend outp "filter_collection \[get_cells -of_objects \[all_fanout -from [get_object_name $clk_port] -flat -trace_arcs all\]\] -regexp \"ref_name =~ .*[lindex [lindex $cell_list 1] 0].*\"; "
#@       lappend outp "filter_collection \[get_cells -of_objects \[all_fanout -from [get_object_name $clk_port] -flat -trace_arcs all\]\] -regexp \"ref_name =~ .*[lindex [lindex $cell_list 2] 0].*\""
#@       puts $f $outp
#@       incr vio_cnt
#@     }
#@   }  
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ############################################################################################
#@ #Usage: bare_passgate_combinational 
#@ #
#@ # This procedure will report all the bare passgate sequential cells in the design
#@ ##############################################################################################
#@ proc bare_passgate_combinational {all_cells} { 
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   set bare_passgate_combinational ""
#@ 	set passgate_cell_list [list]
#@ 	set passgate_cell_expr ""
#@   puts $f "#instance, library cell"
#@   foreach_in_collection lib_pin [get_lib_pins */*/* -filter "bare_passgate_pin == true" -quiet ] {
#@     set libpin_name [split [get_object_name $lib_pin] \/]
#@     set cellname [lindex $libpin_name 1]
#@     lappend passgate_cell_list $cellname
#@   }
#@   if {[info exists passgate_cell_list] && $passgate_cell_list != ""} {
#@   set passgate_cell_list [lsort -unique $passgate_cell_list] 
#@   set passgate_cell_expr "(ref_name =~ [lindex $passgate_cell_list 0]"
#@   foreach cell  [lrange $passgate_cell_list 1 end] {
#@     append passgate_cell_expr " || ref_name =~ $cell"
#@   }
#@   append passgate_cell_expr ") && is_sequential != true" 
#@   set bare_passgate_combinational [filter_collection $all_cells $passgate_cell_expr ]
#@   foreach_in_collection cell $bare_passgate_combinational {
#@     puts $f "[get_object_name $cell], [get_attribute [get_cells $cell] ref_name]" 
#@     incr vio_cnt 
#@   }
#@   } else {
#@   puts "INFORMATION : NO bare pass gate cell in the library"
#@   }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ############################################################################################
#@ #Usage: bare_passgate_sequential 
#@ #
#@ # This procedure will report all the bare passgate sequential cells in the design
#@ ##############################################################################################
#@ proc bare_passgate_sequential {all_cells} { 
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"]
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   set bare_passgate_sequential ""
#@   set passgate_cell_expr ""
#@ 	set passgate_cell_list [list]
#@   puts $f "#instance, library cell"
#@   foreach_in_collection lib_pin [get_lib_pins */*/* -filter "bare_passgate_pin == true" -quiet] {
#@     set libpin_name [split [get_object_name $lib_pin] \/]
#@     set cellname [lindex $libpin_name 1]
#@     lappend passgate_cell_list $cellname
#@   }
#@   if {[info exists passgate_cell_list] && $passgate_cell_list != ""} {
#@   set passgate_cell_list [lsort -unique $passgate_cell_list]	 
#@   set passgate_cell_expr "(ref_name =~ [lindex $passgate_cell_list 0]"
#@   foreach cell  [lrange $passgate_cell_list 1 end] {
#@     append passgate_cell_expr " || ref_name =~ $cell"
#@   }
#@   append passgate_cell_expr ") && is_sequential == true" 
#@   set bare_passgate_sequential [filter_collection $all_cells $passgate_cell_expr ]
#@   foreach_in_collection cell $bare_passgate_sequential {
#@     puts $f "[get_object_name $cell], [get_attribute [get_cells $cell] ref_name]" 
#@     incr vio_cnt 
#@   }
#@   } else {
#@   puts "INFORMATION: No bare passgate cell in the library"
#@   }
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ 
#@ ##########################################################################################
#@ # Usage: max_capacitance_violation
#@ #
#@ # This procedure will report Max Cap violations
#@ ##############################################################################################
#@ proc max_capacitance_violation {all_output_pins all_clocks cmax_csv_files libcell_regexp {em_run 0} } {
#@   set name [lindex [info level 0] 0]
#@   regsub {::} $name {} name
#@   set output_file "./reports/$name.rpt"
#@   set f [open $output_file "w"] 
#@   set vio_cnt 0
#@   set start_time [clock seconds]
#@   #####################################################
#@   # read in data from CSV files
#@   foreach csv_file $cmax_csv_files { 
#@     set csvf [open $csv_file "r"]    
#@     # get the first line with the frequencies on it
#@     set fields [split [gets $csvf ] ","]
#@     # make a list of available freqiencies
#@     set n_of_freq [expr [llength $fields] - 1]
#@     set frequencies [lrange $fields 1 $n_of_freq]    
#@     # now read in cap data into array.
#@     while {[gets $csvf line] >=0} {
#@       set fields [split $line ","]
#@       set cell_pin [lindex $fields 0]
#@       set max_caps [lrange $fields 1 $n_of_freq]
#@       set csv_freqs($cell_pin) $frequencies
#@       set num_of_freq($cell_pin) $n_of_freq
#@       set max_cap_lut($cell_pin) $max_caps
#@     }
#@     close $csvf
#@   }
#@   set port_violations 0
#@   set invld_list_blk_f_higher ""
#@   array set invld_not_found ""
#@   array set clock_lut {}
#@   ###############################################################
#@   # build up design clock data
#@   foreach_in_collection clk $all_clocks {
#@     set period [get_attribute $clk period]
#@     set clock_lut($period) [get_object_name $clk]
#@   }
#@   ###############################################################
#@   # header for output file
#@   puts $f "#cell/pin, reference pin, required cap, actual cap, vio amount, setup timing slack, clock name, clock freq, is clock pin, is port"
#@   set slack_list [list]
#@   set clock_violations 0
#@   ###############################################################
#@   # get all max_cap violations in the design, 
#@   #  Query if a vio cell is in a clock network or not. If so, we
#@   #  get the clocks through the cell differently than data cells
#@   foreach_in_collection pin $all_output_pins {
#@     set pin_name [get_object_name $pin]
#@     set cell [get_cells -of_objects $pin]
#@     set cell_name [get_object_name $cell]
#@     set ref_name [get_attribute $cell ref_name]
#@     set is_macro_cell 0
#@     if {! [regexp $libcell_regexp $ref_name]} { set is_macro_cell 1 }
#@     if {[get_attribute $cell is_clock_network_cell] == "true"} {
#@       set is_clock_pin 1
#@     } else {
#@       set is_clock_pin 0
#@     }
#@     set lib_pin_name $ref_name/[lindex [split $pin_name "/"] end]
#@     # check that the lib cell from the csv file exists if it doesnt, record it for later and skip to next design cell
#@     if {!$is_macro_cell && ![info exists max_cap_lut($lib_pin_name)]} {
#@       if {[lsearch [array names invld_not_found] $lib_pin_name] < 0} {
#@         set invld_not_found($lib_pin_name) 1
#@       }
#@       continue
#@     }
#@     set net [get_nets -of_objects $pin -quiet]
#@     # check if pin is not connected and skip processing if it is
#@     if ![sizeof_collection $net] { continue }
#@     # get loads. Find largest one for using in max_cap check
#@     #  em corner must use total cap. All other corners use ceff
#@     # get max_cap attribute on design pin
#@     set max_cap_limit [get_attribute $pin max_capacitance -quiet]
#@     if {$max_cap_limit == ""} { 
#@       set max_cap_limit 999999999
#@     }
#@     if {!$em_run && !$is_macro_cell} {
#@       # If we are not in em_run corner and not a macro, set the cmax limit to 
#@       #   the TT limit, which is the 1st entry in the CSV freq table. 
#@       set max_cap_limit [lindex $max_cap_lut($lib_pin_name) 0]
#@       # now get effective cap
#@       set pin_load [get_attribute $pin effective_capacitance_max -quiet]
#@       # if effective cap is not found, fall back to total cap
#@       if {$pin_load eq ""} {
#@         set ccs_cap_rise [get_attribute $net total_ccs_capacitance_max_rise]
#@         set ccs_cap_fall [get_attribute $net total_ccs_capacitance_max_fall]
#@         set ccs_cap [expr $ccs_cap_rise >= $ccs_cap_fall ? $ccs_cap_rise : $ccs_cap_fall]
#@         set total_cap [get_attribute $net total_capacitance_max -quiet]
#@         set pin_load [expr $total_cap > $ccs_cap ? $total_cap : $ccs_cap]	
#@       } 
#@  } elseif {$em_run && !$is_macro_cell} { 
#@       # If we are in the em_run and we are not a macro_cell, we can look to the csv table that matches the frequecy or larger
#@       set pin_freq 0
#@       ###################################################
#@       # find fastest clock through the given pin
#@       if {$is_clock_pin} {
#@         set pin_clocks [get_clocks -quiet [get_attribute $pin clocks -quiet]]
#@         if {$pin_clocks == ""} {
#@           set pin_clocks [get_clocks -quiet [get_attribute $pin power_base_clock -quiet]]
#@         }
#@       } else {
#@         set pin_clocks [get_clocks -quiet [get_attribute $pin power_base_clock -quiet]]
#@         if {[sizeof_collection $pin_clocks] <= 0} {
#@           #set pin_clocks [get_attribute [all_fanin -to $pin -startpoints_only -flat] clocks -quiet]
#@           regsub -all {[\{\}]} [get_attribute -quiet [get_pins  $pin] arrival_window] " " clock_list
#@           set pin_clocks [get_clocks -quiet $clock_list]
#@         }
#@       }
#@       # if no clocks found through instance pin, nothing to check, move on.  
#@       if {[sizeof_collection $pin_clocks] <= 0 } {continue} 
#@       # now find and calculate clock frequency
#@         set min_clock_period  [lindex [lsort -real -unique [get_attribute $pin_clocks period -quiet]] 0]
#@         set pin_freq [format "%0.2f" [expr 1000 /  $min_clock_period ]]
#@         set clock_name $clock_lut($min_clock_period)
#@       set freq_val_found 0      
#@       set lut_max_cap_limit 0
#@       # is the pin clock faster than our fastest freq in the CSV table? record it if it is and go to next pin
#@       if { $pin_freq > [lindex $csv_freqs($lib_pin_name) end]} {
#@         lappend invld_list_blk_f_higher "$pin_name $lib_pin_name $clock_name $pin_freq"
#@         continue
#@       }
#@       # search through all frequencies this lib_pin is characterized @ looking for an match or larger frequency
#@       #  the result of this loop will contain either a allowed cap for the exact frequency match, or
#@       #  a allowed cap for a frequency higher than the pin frequency.
#@       # If the frequency found is smaller than the smallest freq in the CSV table, use the CSV entry. 
#@       #  Else if the frequency does not match a CSV frequency exactly and scaling is turned on, compute it. 
#@       #  otherwise just take the CSV value. 
#@       # Also if no pin_freq was found, don't scale it and use the CSV value
#@       if {$pin_freq < [lindex $csv_freqs($lib_pin_name) 0]} {
#@         set max_cap_limit [lindex $max_cap_lut($lib_pin_name) 0]
#@       } else {
#@       	# search through all frequencies this lib_pin is characterized @ looking for an match or larger frequency
#@       	#  the result of this loop will contain either a allowed cap for the exact frequency match, or
#@       	#  a allowed cap for a frequency higher than the pin frequency.
#@         set index 0
#@         foreach fval $csv_freqs($lib_pin_name) {
#@           if { $pin_freq <= $fval } {
#@             set freq_val_found  $fval
#@             set lut_max_cap_limit [lindex $max_cap_lut($lib_pin_name) $index]
#@             break
#@           }
#@           incr index
#@         }
#@           set max_cap_limit $lut_max_cap_limit
#@        } 
#@       
#@       set ccs_cap_rise [get_attribute $net total_ccs_capacitance_max_rise]
#@       set ccs_cap_fall [get_attribute $net total_ccs_capacitance_max_fall]
#@       #set ccs_cap [expr $ccs_cap_rise >= $ccs_cap_fall ? $ccs_cap_rise : $ccs_cap_fall]
#@       set total_cap [get_attribute $net total_capacitance_max -quiet]
#@       #set pin_load [expr $total_cap > $ccs_cap ? $total_cap : $ccs_cap]	 
#@       set pin_load [lindex [lsort -real "$total_cap $ccs_cap_rise $ccs_cap_fall"] end]
#@     } else {
#@       # pin is a macro pin, so just check original limit against total cap. 
#@       set ccs_cap_rise [get_attribute $net total_ccs_capacitance_max_rise]
#@       set ccs_cap_fall [get_attribute $net total_ccs_capacitance_max_fall]
#@       set ccs_cap [expr $ccs_cap_rise >= $ccs_cap_fall ? $ccs_cap_rise : $ccs_cap_fall]
#@       set total_cap [get_attribute $net total_capacitance_max -quiet]
#@       set pin_load [expr $total_cap > $ccs_cap ? $total_cap : $ccs_cap]	
#@     }
#@  # now check pin load aginst our allowed pin cap. 
#@     set cap_slack [expr $max_cap_limit - $pin_load]
#@     if {$cap_slack < 0} {
#@       set rise_slack [get_attribute $pin max_rise_slack]
#@       set fall_slack [get_attribute $pin max_fall_slack]
#@       if { ($rise_slack ne "INFINITY") && ($fall_slack ne "INFINITY") && ($rise_slack ne "") && ($fall_slack ne "") } {
#@         set timing_slack [expr $rise_slack < $fall_slack ? $rise_slack : $fall_slack]
#@       } else {
#@         set timing_slack 9999999999
#@       }
#@       #lappend slack_list "$pin_name $lib_pin_name $max_cap_limit $pin_load $slack $clock_name $pin_freq $timing_slack $is_clock_pin"
#@       if {! [info exists clock_name] } { set clock_name "--"; set pin_freq "0.00" }
#@       lappend slack_list "$pin_name $lib_pin_name $max_cap_limit $pin_load $cap_slack $timing_slack $clock_name $pin_freq $is_clock_pin 0"
#@       incr vio_cnt
#@     }
#@   }
#@   # Reporting Max cap violations on I/O ports
#@   #--------------------------------------------
#@   set port_list [get_ports -quiet -filter "defined(max_capacitance) && direction == in"]
#@   foreach_in_collection port $port_list {
#@     set outnets [get_nets [all_connected $port]]
#@     if ![sizeof_collection $outnets] { continue }
#@     set cellcapvalrise [get_attribute $outnets total_ccs_capacitance_max_rise]
#@     set cellcapvalfall [get_attribute $outnets  total_ccs_capacitance_max_fall]
#@     set ccs_cap [expr $cellcapvalrise >= $cellcapvalfall ? $cellcapvalrise : $cellcapvalfall]
#@     set tot_cap [get_attribute $outnets total_capacitance_max -quiet]
#@     set cellcapval [expr $tot_cap > $ccs_cap ? $tot_cap : $ccs_cap]
#@     set cellcaplimit [get_attribute $port max_capacitance -quiet]
#@     set cap_slack [expr $cellcaplimit - $cellcapval]
#@     if {$cap_slack < 0} {
#@       set portname [get_object_name $port]
#@       lappend slack_list "$portname -- $cellcaplimit $cellcapval $cap_slack -- -- -- 0 1"
#@       incr vio_cnt
#@     }
#@   }
#@   ######################################################################
#@   # print the violations if there were any. Sorted by cap slack
#@   foreach i [lsort -increasing -real -index 4 $slack_list] {
#@     puts $f [join $i ","]
#@     }
#@   # dump any cells who's clock is faster than CSV data. 
#@   if {[llength $invld_list_blk_f_higher] > 0} {
#@     puts $f "###### These design cells have a frequency higher than what CSV data contains. ######" 
#@     foreach cell $invld_list_blk_f_higher {
#@       puts $f $cell 
#@   }
#@   }
#@   # dump any lib cells that are missing from CSV data. 
#@   set missing_lib_cell_cnt [llength [array names invld_not_found]]
#@   if {$missing_lib_cell_cnt > 0} {
#@     puts $f "###### These library cells were not found in the CSV data at all. ######"
#@     foreach cell [array names invld_not_found] {
#@       puts $f $cell
#@     }
#@   }
#@   # finish up
#@   close $f
#@   set elapsed_time [expr { ([clock seconds] - $start_time) / 3600.0} ]
#@   set sum [format "%-40s %8d %6.1f" $name $vio_cnt $elapsed_time]
#@   echo $sum > ./reports/$name.tmp.sum
#@   if {$vio_cnt <= 0} { file delete $output_file } else { exec gzip -f $output_file }
#@   return $vio_cnt
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/erc_rules.tcl

#@ source $env(INTEL_ASIC)/asicflows/synopsys/sta/erc_setup.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/erc_setup.tcl

#@ ##############################################################################
#@ 
#@ ###################################################################################
#@ # Create directories in case they do not exist
#@ # The snapshot directory will contain temporary files created by the ERC flow
#@ if { ![file isdirectory snapshot] } { file mkdir snapshot }
#@ if { ![file isdirectory reports] }  { file mkdir reports }
#@ 
#@ ###################################################################################
#@ # Setup commonly used collections for the all the rules to use.
#@ puts "#INFO-MSG==> Setting up ERC collections and user attributes."
#@ set all_clocks           [get_clocks -filter "defined(sources)" *]
#@ set all_ports            [get_ports *]
#@ set all_nets             [get_nets -hier -top_net_of_hierarchical_group *]
#@ set all_output_ports     [filter_collection $all_ports "port_direction==out"]
#@ set all_input_ports      [filter_collection $all_ports "port_direction==in"]
#@ set all_cell_pins        [get_pins -hier * -filter "is_hierarchical == false"]
#@ set all_cell_output_pins [filter_collection $all_cell_pins "direction == out"]
#@ set all_cell_input_pins  [filter_collection $all_cell_pins "direction == in"]
#@ set all_cells            [get_cells -hier * -filter "is_hierarchical == false"]
#@ 
#@ ###################################################################################
#@ # Apply special/user library cell attributes for rule usage
#@ puts "#INFO-MSG==> Setting up special library cell attributes "
#@ suppress_message ATTR-3
#@ 
#@ # BPG attributes
#@ if {[regexp {bare_passgate} $erc_rule_list_1] || [regexp {bare_passgate} $erc_rule_list_2] || [regexp {bare_passgate} $erc_rule_final] } {
#@   set cmd1 "sh perl $env(INTEL_ASIC)/asicflows/synopsys/sta/list_bare_passgate_pins.pl -library $library_type -stdcells $env(INTEL_STDCELLS)"
#@   
#@ 	if {[info exists custom_cdl_path] && $custom_cdl_path != ""} {
#@     set cmd1 "$cmd1 -custom_cdl_path \"$custom_cdl_path\""
#@   }
#@   if {[info exists bgp_exclude] && $bpg_exclude != ""} {
#@     set cmd1 "$cmd1 -exclude \"$bpg_exclude\""
#@   }
#@   eval $cmd1
#@   source $env(INTEL_ASIC)/asicflows/synopsys/sta/bpg_set_attributes.tcl
#@ }
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/bpg_set_attributes.tcl

#@ ##############################################################################
#@ suppress_message LNK-041
#@ 
#@ define_user_attribute bare_passgate_pin -classes {lib_pin pin} -one_of {true false} -type string
#@ define_user_attribute high_output_stack_pin -classes {lib_pin pin}  -type int
#@ #define_user_attribute mult_stage_cell -classes {lib_cell cell} -one_of {true false} -type string
#@ 
#@ 
#@ if {[catch {open "./snapshot/bare_passgate_pins.txt" r} bare_pass]} {
#@   puts "WARNING - file ./snapshot/bare_passgate_pins.txt is not readable or does not exist. Check is Invalid."
#@ } else {
#@   while {[gets $bare_pass line] >= 0 } {
#@     if { [regexp "/" $line] } {
#@       set lib_pin $line
#@       if {[get_lib_pins */$lib_pin -quiet] != ""} {
#@         set_user_attribute -quiet [get_lib_pins */$lib_pin -quiet] bare_passgate_pin true
#@       }
#@     }
#@   }
#@   close $bare_pass
#@ }
#@ 
#@ unsuppress_message LNK-041
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/bpg_set_attributes.tcl

#@ # clock library cells
#@ define_user_attribute clock_cell -type boolean -class lib_cell
#@ foreach cell $clock_library_cells {
#@   foreach_in_collection lib_cell [get_lib_cells -quiet */$cell] {
#@   set_user_attribute -quiet $lib_cell clock_cell true
#@  }
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/sta/erc_setup.tcl

#@ 
#@ 
#@ #################################################################################################################
#@ # The ERC flow can be configured to run all checks either serially or in 2 parallel threads.
#@ #
#@ #  This code below requires these variables to be set:
#@ #
#@ #   erc_parallel
#@ #   erc_rule_list_1
#@ #   erc_rule_list_2
#@ #   erc_rule_final
#@ #
#@ # Parallel mode:
#@ #   The two variables erc_rule_list_1 and erc_rule_list_2 are run in 2 parallel threads.
#@ #
#@ # Serial:
#@ #   The two variables erc_rule_list_1 and erc_rule_list_2 are concateneted together and run in a
#@ #   single thread.
#@ #
#@ # The erc_rule_final is meant as a single check to be run after all the other rules because that the
#@ #   rule will modify the timing database.
#@ #
#@ echo [format "%-41s  %8s  %6s" Rule Count Runtime(hours)] > ./reports/erc_checks.sum
#@ if {$erc_parallel} {
#@   # we have 2 bins to run in parallel.
#@   puts "#INFO-MSG==> Staring ERC rule checks"
#@   parallel_execute {
#@     { foreach cmd $erc_rule_list_1 { set p [lindex [split $cmd " "] 0]; puts "#INFO-MSG==> Starting: $p"; eval $cmd; puts "#INFO-MSG==> Finished: $p" } } erc1.log
#@     { foreach cmd $erc_rule_list_2 { set p [lindex [split $cmd " "] 0]; puts "#INFO-MSG==> Starting: $p"; eval $cmd; puts "#INFO-MSG==> Finished: $p" } } erc2.log
#@   }
#@   # run this rule seperate because it alters the timing settings.
#@   if {$erc_rule_final != ""} {
#@     eval $erc_rule_final
#@   }
#@ } else {
#@   # non-parallel run
#@   set rules [concat $erc_rule_list_1 $erc_rule_list_2]
#@   foreach cmd $rules {
#@     set p [lindex [split $cmd " "] 0]
#@     puts "#INFO-MSG==> Starting: $p"
#@     eval $cmd
#@     puts "#INFO-MSG==> Finished: $p"
#@   }
#@   if {$erc_rule_final != ""} {
#@     eval $erc_rule_final
#@   }
#@ }
#@ 
#@ P_erc_combine_summary_files
#@ 
#@ puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/run_erc.tcl

#@ 
#@ # To generate interface logic models
#@ P_source_if_exists ilm.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/ilm.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used in this script
#@ # None
#@ ##########################
#@ 
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ if {[info exists INTEL_GENERATE_ILM] && $INTEL_GENERATE_ILM} {
#@ 
#@   #Creating ILM directory:
#@   #--------------------------
#@ 
#@   puts "==>INFORMATION: Setting the ILM directory"
#@   set ilm_dir       ./ilm_model
#@   set ilm_model_dir ./ilm_model/$INTEL_DESIGN_NAME
#@   set ilm_old_dir   ./ilm_model/$INTEL_DESIGN_NAME\_old/$INTEL_DESIGN_NAME
#@ 
#@   set_app_var pt_ilm_dir    $ilm_dir
#@ 
#@   if {[file exists $ilm_model_dir] || [file isdirectory $ilm_model_dir]} {
#@     puts "==>INFORMATION: Moving all the ILM related files from previous runs to old directory"
#@     if {[file exists $ilm_old_dir] || [file isdirectory $ilm_old_dir]} {
#@       exec rm -rf $ilm_old_dir
#@     }
#@     exec mv $ilm_model_dir $ilm_dir/$INTEL_DESIGN_NAME\_old
#@     set_app_var pt_ilm_dir $ilm_dir
#@   } else {
#@     if {![file exists $ilm_dir] || ![file isdirectory $ilm_dir]} {
#@       if {[catch {file mkdir $ilm_dir} err]} {
#@         puts "==>WARNING: Couldn't create directory $ilm_dir because: $err"
#@         puts "==>WARNING: Default directory $pt_ilm_dir for ILM model files will be used"
#@       } else {
#@         set_app_var pt_ilm_dir $ilm_dir
#@       }
#@     }
#@   }
#@ 
#@   puts "==>INFORMATION: pt_ilm_dir is set to $pt_ilm_dir"
#@ 
#@   # Generating ILM model
#@   #----------------------
#@ 
#@   puts "==>INFORMATION: Writing design interface timing for model checking"
#@   set ifc_tim_rpt_file     ${INTEL_DESIGN_NAME}.interface_timing.rpt
#@ 
#@   if {[regexp {((^noise))(.*)} $run_type]} {
#@     write_interface_timing -verbose -nosplit -include {noise}  -timing_type slack ${pt_ilm_dir}/$ifc_tim_rpt_file
#@   } else {
#@     write_interface_timing -verbose -nosplit -include {timing} -timing_type slack ${pt_ilm_dir}/$ifc_tim_rpt_file
#@   }
#@ 
#@   puts "==>INFORMATION: Creating the ILM model for the design $INTEL_DESIGN_NAME"
#@   create_ilm -verbose -verification_script -latch_level 10 -traverse_disabled_arcs       -parasitics_options {spef_format input_port_nets constant_nets}       -include {si_delay_pins net_pins boundary_cells} -block_scope
#@ 
#@   puts "==>INFORMATION: Writing out arrival annotations for the model to make sure si is taken care of"
#@   write_arrival_annotations -design
#@ 
#@   # Validating ILM model
#@   #----------------------
#@ 
#@   puts "==>INFORMATION: Removing design for ILM validation"
#@   remove_design -all
#@ 
#@   puts "==>INFORMATION: Validating ILM model"
#@   set ilm_ifc_tim_rpt_file  ${INTEL_DESIGN_NAME}.interface_timing_ilm.rpt
#@   set ifc_tim_rpt_file      ${INTEL_DESIGN_NAME}.interface_timing.rpt
#@ 
#@   if {[info exists INTEL_ILM_ABS_TOL] && $INTEL_ILM_ABS_TOL != ""} {
#@     set ilm_abs_tol $INTEL_ILM_ABS_TOL
#@   } else {
#@     puts "==>WARNING: Setting default value of absolute tolerance limit for ILM generation : 200"
#@     set ilm_abs_tol 200
#@   }
#@ 
#@   if {[info exists INTEL_ILM_PER_TOL] && $INTEL_ILM_PER_TOL != ""} {
#@     set ilm_per_tol $INTEL_ILM_PER_TOL
#@   } else { #set default value to 5%
#@     puts "==>WARNING: Setting default value of percentage tolerance limit for ILM generation : 5%"
#@     set ilm_per_tol 5
#@   }
#@ 
#@   #Read and Link the design
#@   #-------------------------
#@   if {[file exists $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.v]} {
#@     read_verilog $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.v
#@     current_design ${INTEL_DESIGN_NAME}
#@     link_design ${INTEL_DESIGN_NAME}
#@   } else {
#@     puts "==>FATAL: ILM verilog file does not exist in $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.v. Exiting..."
#@     exit
#@   }
#@ 
#@   # Read the parasitic file
#@   if {[file exists $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.spef.gz]} {
#@     read_parasitics -keep_capacitive_coupling $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.spef.gz
#@     complete_net_parasitics -complete_with zero
#@   } else {
#@     puts "==>FATAL: ILM parasicits file does not exist $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.spef.gz. Exiting..."
#@     exit
#@   }
#@ 
#@   # Read the ILM verification constraints file
#@   #---------------------------------------------
#@ 
#@   if {[file exists $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm_verif.pt.gz]} {
#@     source $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm_verif.pt.gz
#@   } else {
#@     puts "==>FATAL: ILM verification constraints file does not exist in $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm_verif.pt.gz. Exiting..."
#@     exit
#@   }
#@ 
#@   # Read noise annotations file
#@   #-----------------------------
#@ 
#@   if {[file exists $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.pt.gz]} {
#@     source $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.pt.gz
#@   } else {
#@     puts "==>FATAL: ILM noise annotations file does not exist in $pt_ilm_dir/$INTEL_DESIGN_NAME/ilm.pt.gz. Exiting ..."
#@     exit
#@   }
#@ 
#@   # Enable infinite arrival window
#@   #----------------------------------
#@   set_si_delay_analysis -ignore_arrival [get_nets -hierarchical *]
#@ 
#@   foreach_in_collection clock [all_clocks] {
#@     set ports [remove_from_collection [all_inputs] [get_attribute -quiet $clock sources]]
#@   }
#@ 
#@   set fanout_nets [get_nets -top_net_of_hierarchical_group -segments -of_objects [all_fanout -flat -from $ports]]
#@   set_si_delay_analysis -ignore_arrival $fanout_nets
#@   puts "==>INFORMATION: Set infinite_window analysis on [sizeof_collection $fanout_nets] boundary nets."
#@ 
#@   #Update Timing
#@   #---------------
#@   update_timing -full
#@ 
#@   # Write interface timing report for the ILM model
#@   #------------------------------------------------
#@   write_interface_timing -verbose -include {timing} -timing_type slack ${pt_ilm_dir}/$ilm_ifc_tim_rpt_file
#@ 
#@   # Comparison of timing reports
#@   #------------------------------
#@   set comp_pass_fail [compare_interface_timing -absolute_tolerance $ilm_abs_tol                           -percent_tolerance $ilm_per_tol                           -sort_by_worst -nosplit                           -output ${pt_ilm_dir}/$INTEL_DESIGN_NAME\.final.ilm_timing_compare.rpt                           ${pt_ilm_dir}/$ilm_ifc_tim_rpt_file ${pt_ilm_dir}/$ifc_tim_rpt_file]
#@ 
#@   if {$comp_pass_fail == 1} {
#@     # if model failed comparison then compare_interface_timing returns value of 1
#@     puts "==>INFORMATION: ILM model generation has failed check"
#@   } else {
#@     # if model passed comparison then compare_interface_timing returns value of 0
#@     puts "==>INFORMATION: ILM model generation has passed check"
#@   }
#@ 
#@ } else {
#@   puts "==>INFORMATION:  INTEL_GENERATE_ILM variable does not exist (or) has been set to 0. Interface Logic Model was not generated for the design."
#@ }
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/sta/ilm.tcl

#@ 
#@ 
#@ 
#@ exit
