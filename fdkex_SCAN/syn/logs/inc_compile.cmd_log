#@ # 
#@ # Running dc_shell Version J-2014.09 for suse64 -- Aug 25, 2014
#@ # Date:   Tue Mar 31 00:04:03 2015
#@ # Run by: spalutla@chlr16420
#@ 

source /p/foundry/eda/em64t_SLES11/designcompiler/J-2014.09/admin/setup/.synopsys_dc.setup
source $env(runTclScript); runDC; exit
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/syn/dot3/d04/run.tcl

#@ ##############################################################################
#@ 
#@ ####################################
#@ ## List of procs used by this script
#@ ## P_source_if_exists
#@ ## P_run_CheckDiskSpace
#@ ########################################
#@ 
#@ #######################################################################
#@ # SUMMARY: run.tcl to drive netlist2gds flow in ICC
#@ ######################################################################
#@ set echo_include_commands false
#@ set echo_include_commands FALSE
#@ 
#@ 
#@ set timestamp [sh date '+%m_%d_%H_%M']
#@ 
#@ puts "\n######## Synopsys Build Information ########"
#@ puts "Product Version:  $::sh_product_version"
#@ puts "Build Date:       $::product_build_date"
#@ puts "############################################\n"
#@ 
#@ #########################################
#@ # General/Project SPECIFIC CONFIGURATION
#@ #########################################
#@ 
#@ if { ![info exists env(INTEL_ASIC)] } {
#@   error "Required environment variable 'INTEL_ASIC' not set."
#@ } else {
#@   set INTEL_ASIC $env(INTEL_ASIC)
#@   puts "-I- Setting FDK DIR to $INTEL_ASIC"
#@ }
#@ 
#@ #setup all local paths
#@ set INTEL_LOG_PATH     ./logs
#@ set INTEL_SCRIPTS_PATH ./scripts
#@ set INTEL_INPUTS_PATH  ./inputs
#@ set INTEL_MW_LIB       ./ddc
#@ set INTEL_REPORTS_PATH ./reports
#@ set INTEL_OUTPUTS_PATH ./outputs
#@ 
#@ if { ![file isdirectory $INTEL_MW_LIB] } { file mkdir $INTEL_MW_LIB }
#@ if { ![file isdirectory $INTEL_LOG_PATH] } { file mkdir $INTEL_LOG_PATH }
#@ if { ![file isdirectory $INTEL_OUTPUTS_PATH] } { file mkdir $INTEL_OUTPUTS_PATH }
#@ if { ![file isdirectory $INTEL_REPORTS_PATH] } { file mkdir $INTEL_REPORTS_PATH }
#@ 
#@ set_app_var sh_command_log_file ./logs/cmd.log
#@ set_app_var sh_output_log_file  ./logs/dc.log
#@ 
#@ ### INTEL_SCRIPTS_SEARCH_PATH order as: highest to lowest
#@ set INTEL_SCRIPTS_SEARCH_PATH $INTEL_SCRIPTS_PATH
#@ set INTEL_SCRIPTS_SEARCH_PATH "$INTEL_SCRIPTS_SEARCH_PATH                              $env(INTEL_ASIC)/asicflows/synopsys/syn/dot3/d04                              $env(INTEL_ASIC)/asicflows/synopsys/syn                              $env(INTEL_ASIC)/asicflows/synopsys/common/dot3/d04                              $env(INTEL_ASIC)/asicflows/synopsys/common"
#@ 
#@ set COMMON_SCRIPTS $env(INTEL_ASIC)/asicflows/synopsys/common
#@ set SYN_SCRIPTS $env(INTEL_ASIC)/asicflows/synopsys/syn
#@ 
#@ puts "-I- scripts search path variable INTEL_SCRIPTS_SEARCH_PATH is set to: $INTEL_SCRIPTS_SEARCH_PATH"
#@ set search_path [concat $INTEL_SCRIPTS_SEARCH_PATH $search_path]
#@ 
#@ 
#@ source $env(INTEL_ASIC)/asicflows/synopsys/common/procs.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/common/procs.tcl

#@ ##############################################################################
#@ # This file sets up procedures used by the synthesis, APR & STA flows        #
#@ # This file is sectioned according to steps and tcl files which use them     #
#@ ##############################################################################
#@ 
#@ ##########################################
#@ # Common Procedures - Used by DC/ICC/STA
#@ ##########################################
#@ # P_source_if_exists: Used by all flows to source scripts from a provided INTEL_SCRIPTS_SEARCH_PATH
#@ # P_rdtConvertSeconds: Used by P_source_if_exists to convert time in a specific reporting format
#@ # P_get_scr_proc_name: Used by all flows to provide additional stack info when erroring out
#@ # P_msg_info: Used by all flows to provide info messages
#@ # P_msg_warn: Used by all flows to provide warning messages
#@ # P_msg_error: Used by all flows to provide error messages
#@ # P_msg_fatal: Used by all flows to provide fatal error messages
#@ # P_find_common_collection: Utility which can be used to find overlap/common elements between two collections
#@ 
#@ #################################################
#@ # Synthesis Procedures - Used by Synthesis flow
#@ #################################################
#@ # P_smash_design: Used by the synthesis flow  for smashing hierarchies
#@ # P_smash_design_recursive: Used by P_smash_design for smashing design to the lowest hierarchy
#@ # P_remove_donttouch_on_hier_cells: Used by P_smash_design for removing dont_touch on hierachical instances.
#@ 
#@ #######################################################
#@ # Floorplan Procedures - Used by floorplan step of APR
#@ #######################################################
#@ # P_add_bonuscore_core2h_rows: Used by init_floorplan.tcl to create site rows for different core tiles
#@ # P_get_techfile_info: Used by P_add_bonuscore_core2h_rows and stdcell PG hookup to get techfile related
#@ # P_set_repeating_custom_tracks: Used by set_wiretracks.tcl to create custom tracks based on track settings
#@ # P_check_boundary_contact: Used by halo.tcl to determine if the Core Boundary contacts with any cell
#@ # P_get_abut_chain: Used by halo.tcl to get list of macros abutting each other
#@ # P_get_abutted_cells: Used by halo.tcl to get macro ells which are abutting
#@ # P_get_boundary_polygon: Used by halo.tcl to calculate boundary polygon for halo insertion
#@ # P_lcount: Used by halo.tcl to get repeated element
#@ # P_place_halo: Used by halo.tcl to place a halo at a particular location
#@ # P_find_direction: Used by halo.tcl and halo_power_voltage_island.tcl to place correct ver/horiz halo cells according to direction
#@ # P_ret_intersect_list: Used by halo_power_voltage_island.tcl to get voltage areas abutting with boundary/macro/non-va-halo
#@ # P_check_exclusion: Used by halo_power_voltage_island.tcl to get intersection points of boundary/macro/non-va-halo
#@ # P_macro_route_guide_cmd: Used by create_power_straps.tcl to create correct PG pullback from macro boundaries
#@ # P_strap_cmd: Used by create_power_strpas.tcl to create power straps
#@ # P_check_partition_dimension: Used by check_floorplan.tcl to check if the partition dimensions are a multiple of the modular grid
#@ # P_adv_polygon_size: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_adv_polygon_check: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_adv_polygon_logic: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_create_diffcheck_grid: Used by create_check_grid.tcl to create diffcheckgrid over the partition
#@ # P_create_polycheck_grid: Used by create_check_grid.tcl to create polycheckgrid over the partition
#@ # P_placement_blockage_move_or_unmove: Used by pre_place_fiducial.tcl and add_filler_cells.tcl to move placement blockages
#@ # P_insert_pre_place_cells_blockage: Used by pre_place_fib_bonus.tcl to insert placement blockages at pre_place cells location or reverse locations
#@ # P_compare: Used by P_insert_pre_place_cells_blockage to do list comparison of blockages
#@ # P_adv_polygon_get: Used by P_insert_pre_place_cells_blockage to do polygon computations
#@ 
#@ ################################################################
#@ # Place-UPF Procedures - Used by UPF flow in Place step of APR
#@ ################################################################
#@ # P_parse_pwrgrid_params: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stages
#@ # P_ret_aon_net: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stage
#@ # P_check_sec_pg_overlap: Used by P_add_sec_pg_hookup defined within upf_sec_pg_hookup.tcl to determine if a secondary PG staple overlaps with another staple.
#@ 
#@ ###########################################################
#@ # CTS-UPF Procedures - Used by UPF flow in CTS step of APR
#@ ###########################################################
#@ # P_query_voltage_pgnet: Used by stdcell PG hookup procedure to find out primary pg net for each voltage area
#@ 
#@ ################################################
#@ # Route Procedures - Used by route step of APR
#@ ################################################
#@ # P_bonus_array_blockage: Used by add_filler_cells.tcl to create blockages for bonus array addition before decap insertion
#@ 
#@ ########################################################
#@ # Focal opt Procedures - Used by Focal opt step of APR
#@ ########################################################
#@ # P_fix_min_cap args: Used by focal_opt.tcl for fixing min-cap violations on design
#@ 
#@ ##################
#@ # STA Procedures
#@ ##################
#@ # P_report_xtalk_deltas: Used by STA flow to report xtalk delta delays
#@ # P_restore_dmsa_session: Used by DMSA flows of STA to restore dmsa sessions
#@ # P_report_qor: Used by STA flow to report QoR data in a format similar to DC/ICC
#@ 
#@ #################################
#@ # Reports and Outputs Procedures
#@ #################################
#@ # P_create_xyv_icc: Used by P_outputs_xyv procedure to dump out xyv file fo use by RV tools
#@ # P_report_related_supply_net: Used by P_reports to get related supply nets for generate reportsin UPF flow
#@ # P_reports: Used by Syn, APR & STA flows to generate design reports controlled by INTEL_REPORTS variable
#@ # P_get_logic_levels: Used by P_reports procedure to get logic levels during reporting
#@ # P_create_pg_terminals: Used by P_outputs_fram
#@ # P_outputs_linkname: Used by P_outputs_* procedures to get file name used to create link
#@ # P_outputs_verilog: Used by P_outputs to write a verilog output
#@ # P_outputs_verilog_pg: Used by P_outputs to write a verilog output with PG pin and physical-only cells
#@ # P_outputs_upf: Used by P_outputs to write a upf file
#@ # P_outputs_spef: Used by P_outputs to write output spef file
#@ # P_outputs_def: Used by P_outputs to write output def file
#@ # P_syn_output_def: Used by synthesis to write output def file
#@ # P_outputs_fp: Used by P_outputs to write floorplan outputs
#@ # P_outputs_sdc: Used by P_outputs to write sdc output
#@ # P_outputs_saif: Used by P_outputs to write saif output
#@ # P_outputs_scandef: Used by P_outputs at the end of syn flow to write scandef output
#@ # P_outputs_oas: Used by P_outputs to write oas output
#@ # P_outputs_gds: Used by P_outputs to write gds output
#@ # P_outputs_fram: Used by P_outputs to write fram output
#@ # P_outputs_lteloc: Used by P_outputs to create an output xyv file used for RV flow
#@ # P_outputs: Main Output procedure used by Synthesis and APR flow to write out outputs. It is controlled by INTEL_OUTPUTS variable
#@ # P_check_place_overlap: Used by Check_* scripts in APR for checking cell overlaps
#@ # P_check_cells: Used by Check_* scripts in APR for checking if dont use cells are used in design
#@ # P_check_power_ground_nets: Used by check_route.tcl to verify shorts/opens/floating metals in design
#@ 
#@ set start_time [clock seconds]
#@ puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## These procedures/variables are not uniformly available
#@ ## for all tools used in the flow. This section of code creates
#@ ## the procedures/variables if they are not available.
#@ ## -----------------------------------------------------------------------------
#@ 
#@ if { ![info exists synopsys_root] } {
#@   set synopsys_root "synopsys_root"
#@ }
#@ 
#@ if { ![info exists synopsys_program_name] } {
#@   set synopsys_program_name "tcl"
#@ }
#@ 
#@ if { $synopsys_program_name == "tcl" } {
#@   set sh_product_version [info patchlevel]
#@ }
#@ 
#@ if { [info command parse_proc_arguments] != "parse_proc_arguments" } {
#@   proc parse_proc_arguments { cmdSwitch procArgs optsRef } {
#@     upvar $optsRef opts
#@     if { $cmdSwitch == "-args" } {
#@       foreach arg $procArgs {
#@         if { [string index $arg 0] == "-" } {
#@           set curArg $arg
#@           set opts($curArg) 1
#@         } else {
#@           if { [info exists curArg] } {
#@             set opts($curArg) $arg
#@             unset curArg
#@           } else {
#@             puts "SNPS_ERROR: Found invalid argument: '$arg', with no preceding switch."
#@             puts "SNPS_ERROR: Called from procedure: [lindex [info level -1] 0]"
#@           }
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ if { [info command define_proc_attributes] != "define_proc_attributes" } {
#@   proc define_proc_attributes args {}
#@ }
#@ 
#@ if { [info command date] != "date" } {
#@   proc date {} {
#@     return [clock format [clock seconds] -format {%a %b %e %H:%M:%S %Y}]
#@   }
#@ }
#@ 
#@ ########################
#@ # Common Procedures
#@ ########################
#@ 
#@ ################################################################################
#@ # Procedure   : P_source_if_exists
#@ # Description : This sources the specified script.  It searches through directories
#@ #               in the following order:
#@ #                Local script
#@ #                ==> Project flow path flow specific (syn, apr, ..) script
#@ #                ==> Project flow path common script
#@ #                ==> Flow default flow specific (syn, apr, ..) script
#@ #                ==> Flow default common script
#@ #               When it finds the specified script in one of the above directoreis,
#@ #               it sources the script, and stops searching for the script in the
#@ #               next directory.
#@ #               If "-inclusive" option is specified, it sources the script inclusively
#@ #               in the following order:
#@ #                Flow default common script
#@ #                ==> Flow default flow specific (syn, apr, ..) script
#@ #                ==> Project flow path common script
#@ #                ==> Project flow path flow specific (syn, apr, ..) script
#@ #                ==> Local script
#@ #               If the specified script does not exists, it prints out a warning
#@ #               message.
#@ 
#@ 
#@ proc P_source_if_exists {args} {
#@   global INTEL_SCRIPTS_SEARCH_PATH
#@   global INTEL_SOURCE_OPTIONS
#@ 
#@   #parse_proc_arguments -args $args flag
#@ 
#@   foreach arg $args {
#@     if {$arg == "-require"} {
#@       set require 1
#@     } elseif {$arg == "-inclusive"} {
#@       set inclusive 1
#@     } elseif {$arg == "-display"} {
#@       set display 1
#@     } else {
#@       set filename $arg
#@     }
#@   }
#@   if {![info exists require]} {set require 0}
#@   if {![info exists inclusive]} {set inclusive 0}
#@   if {![info exists display]} {set display 0}
#@   #  set filename $flag(filename)
#@   #  if { [info exists flag(-require) ] } {
#@   #    set require 1
#@   #  } else {
#@   #    set require 0
#@   #  }
#@   #  if {[info exists flag(-inclusive)]} {
#@   #    set inclusive 1
#@   #  } else {
#@   #    set inclusive 0
#@   #  }
#@ 
#@   set prereq_list {}
#@   # Look for the file in the search_path, if file not yet determined
#@   if {[info exists INTEL_SCRIPTS_SEARCH_PATH]} {
#@     foreach search_dir $INTEL_SCRIPTS_SEARCH_PATH {
#@       set prereq [file join $search_dir $filename]
#@       if {[file exists $prereq]} {
#@         set prereq_list [linsert $prereq_list 0 $prereq]
#@         if {! $inclusive} {
#@           break ;# Found the file, so stop looking
#@         }
#@       }
#@     }
#@   }
#@ 
#@   if {$display} {
#@     foreach prereq $prereq_list {
#@       puts $prereq
#@     }
#@     return
#@   }
#@ 
#@   if {[llength $prereq_list] == 0} {
#@     if { $require == 1 } {
#@       P_msg_error "Required file not found: $filename."
#@     } else {
#@       puts "==>WARNING: File $filename does not exist."
#@       return 0
#@     }
#@   }
#@ 
#@   foreach prereq $prereq_list {
#@     # Now that the prereq has been determined, source it.
#@     set start_time [clock seconds]
#@     set cpu_start [cputime]
#@     set dates [exec date]
#@     puts "==>INFORMATION: P_source_if_exists: Sourcing $prereq : START $dates"
#@     # Source the file in the global scope
#@     if {[info exists INTEL_SOURCE_OPTIONS] && $INTEL_SOURCE_OPTIONS != ""} {
#@       set catch_return [catch {uplevel \#0 eval source $INTEL_SOURCE_OPTIONS $prereq} catch_result]
#@     } else {
#@       set catch_return [catch {uplevel \#0 source $prereq} catch_result]
#@     }
#@     # Check to see if an error occurred in the script
#@     if {$catch_return != 0} {
#@       puts "Error: Problem with sourced file \"$prereq\". See errorInfo below"
#@       error $catch_result
#@     }
#@     set end_time [clock seconds]
#@     set cpu_end [cputime]
#@     set dates [exec date]
#@     regexp {.*\/(\S+)} $prereq t localFile
#@     #    set elapsed_time [format "%6.4f" [expr ($end_time - $start_time) / 60.0 / 60.0]]
#@     set elapsed_time [P_rdtConvertSeconds [expr ($end_time - $start_time)]]
#@     set elapsed_cpu [P_rdtConvertSeconds [expr ($cpu_end - $cpu_start)]]
#@     puts "==>INFORMATION: P_source_if_exists: $localFile : END $dates : WALLCLOCK RUNTIME in (hh:mm:ss) : $elapsed_time hrs : CPU RUNTIME in (hh:mm:ss) : $elapsed_cpu hrs : MEMORY : [mem] KB"
#@   }
#@   return 1
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_source_if_exists       -info "source script, if it exists"       -define_args {                          {filename "file name to be sourced" filename string required}                          {-require "require file" "" boolean optional}                          {-display "Shows which file will be sourced without sourcing it" "" boolean optional}                          {-inclusive "Source all files found in all paths in the order of priority. Default is to source only the first found file" "" boolean optional}                        }
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_rdtConvertSeconds #{{{
#@ # Description : This is a time conversion utility
#@ 
#@ proc P_rdtConvertSeconds {secs} {
#@ 
#@   set h [expr {$secs/3600}]
#@   incr secs [expr {$h*-3600}]
#@   set m [expr {$secs/60}]
#@   set s [expr {$secs%60}]
#@   format "%02.2d:%02.2d:%02.2d" $h $m $s
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_get_scr_proc_name #{{{
#@ # Description : This gets the name of procedures, and returns names of all procedures
#@ #               on the stack.
#@ 
#@ proc P_get_scr_proc_name { args } {
#@ 
#@   set all [string match "*-all*" $args]
#@ 
#@   # Start with the current script
#@   set proc_list "[file tail [info script]]"
#@ 
#@   set start 1
#@   set end [info level]
#@ 
#@   # Special cases
#@   if {$end == 1} {
#@     # Called from script?
#@     if {$proc_list != ""} {
#@       return "$proc_list"
#@ 
#@       # Interactive call
#@     } else {
#@       return "<interactive>"
#@     }
#@   } elseif {$end >= 2} {
#@     # Don't consider the last procedure (which is P_get_scr_proc_name)
#@     incr end -1
#@   }
#@ 
#@   for {set i $start} {$i <= $end} {incr i} {
#@     set proc_name [lindex [info level $i] 0]
#@     lappend proc_list $proc_name
#@   }
#@ 
#@   # Return all if all was specified
#@   set len_proc_list [llength $proc_list]
#@   if {!$all && $len_proc_list > 2} {
#@     # Get the name of the last two procedures
#@     # or script & procedure
#@     # or script only
#@     # or procedure only
#@ 
#@     set proc_list [lrange $proc_list [expr {$len_proc_list - 2}] end]
#@   }
#@ 
#@   # Return values joined by ":" to make it one string
#@   return [join $proc_list ":"]
#@ 
#@ }; # P_get_scr_proc_name
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   create_command_group {flow_procs}
#@ }
#@ 
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_get_scr_proc_name       -command_group "flow_procs"       -info "Procedure to get caller and callee script and procedure names \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {-all "name of all the procedures on the stack is returned" "" boolean optional}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_info #{{{
#@ # Description : This prints information messages.
#@ 
#@ proc P_msg_info { args } {
#@   set prefix "#INFO-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_info       -command_group "flow_procs"       -info "Procedure to print info messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "info message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_warn #{{{
#@ # Description : This prints warning messages.
#@ 
#@ proc P_msg_warn { args } {
#@   set prefix "#WARNING-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_warn       -command_group "flow_procs"       -info "Procedure to print warning messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "warning message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_error #{{{
#@ # Description : This prints error messages.  The flow goes through, and does not stop.
#@ 
#@ proc P_msg_error { args } {
#@   set prefix "#ERROR-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_error       -command_group "flow_procs"       -info "Procedure to print error messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "error message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_fatal #{{{
#@ # Description : This prints messages about fatal errors, and exits from the shell.
#@ 
#@ proc P_msg_fatal { args } {
#@   set prefix "\n#INFO-STACK==> [uplevel 1 {P_get_scr_proc_name -all}] \n#FATALERROR-MSG==> "
#@   puts stderr "$prefix [join [concat $args] { }]"
#@   exit 1
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_fatal       -command_group "flow_procs"       -info "Procedure to print fatal messages and exit the tool \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {target "file to create before exiting" target.db string required}
#@         {args "fatal message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ proc P_find_common_collection {a b} {
#@   set in_a_but_notin_b [remove_from_collection $a $b]
#@   set in_b_but_notin_a [remove_from_collection $b $a]
#@   set common_a_b [remove_from_collection $a $in_a_but_notin_b]
#@   if { [sizeof_collection $b] == 0 } {
#@     return $a
#@   } else {
#@     return $common_a_b
#@   }
#@ }
#@ 
#@ define_proc_attributes P_find_common_collection     -info "Returns common elements between 2 collections"     -define_args {
#@       {a "First Coll" "First Coll" string required}
#@       {b "Second Coll" "Second Coll" string required}
#@     }
#@ 
#@ ########################
#@ # Synthesis Procedures
#@ ########################
#@ 
#@ ##############################################################################
#@ # Procedure   : P_smash_design
#@ # Description : This proc smashes the design but presevers the hierarchies listed in the argument.
#@ #               It also takes the numbers of level below which the smashing has to happen.
#@ #   If 2 is given, the it descends to 2 levels of hierarchy below the top and smashes thoses levels.
#@ #               But regardless of levels specified, the list specified in \$preserve_hier_instance_list will be honored.
#@ #   If levels is less than 0, then no smashing is done
#@ 
#@ proc P_smash_design {{preserve_hier_instance_list {}} {levels 0}} {
#@   if {$levels < 0} {return 0}
#@   global smashed_designs_hash
#@   set start_time [clock seconds]
#@   set cur_design [get_attribute [current_design] name]
#@   set hiers_level_list {}
#@   foreach preserve_hier_instance $preserve_hier_instance_list {
#@     if {[get_attribute [get_cells $preserve_hier_instance] is_hierarchical] == "true"} {
#@       set hiers [split $preserve_hier_instance "/"]
#@       set mid_index [expr [llength $hiers] - 2]
#@       set end_index [expr [llength $hiers] - 1]
#@       set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
#@       set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
#@       while {([get_cells -quiet $parent_hier] == "") && ($mid_index >= 0)} {
#@         incr mid_index -1
#@         set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
#@         set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
#@       }
#@       if {$parent_hier == ""} {
#@         set parent_hier_ref $cur_design
#@       } else {
#@         set parent_hier_ref [get_attribute [get_cells $parent_hier] ref_name]
#@       }
#@       set hier_hash($preserve_hier_instance) [list $parent_hier_ref $child_inst]
#@       lappend hiers_level_list [list $preserve_hier_instance [llength $hiers] $parent_hier_ref $child_inst]
#@     }
#@   }
#@   current_design $cur_design
#@   foreach hiers_level_pair [lsort -decreasing -index 1 $hiers_level_list] {
#@     set parent_hier_ref [lindex $hiers_level_pair 2]
#@     set child_inst [lindex $hiers_level_pair 3]
#@     set preserve_hier_instance [lindex $hiers_level_pair 0]
#@     set child_hier_level [lindex $hiers_level_pair 1]
#@     if {$child_hier_level > $levels} {
#@       set preserve_hier_ref [get_attribute [get_cells $preserve_hier_instance] ref_name]
#@       current_design $preserve_hier_ref
#@       set smashed_designs_hash($preserve_hier_ref) 1
#@       ungroup -all -flatten
#@       current_design $parent_hier_ref
#@       set_dont_touch $child_inst
#@       current_design $cur_design
#@     }
#@   }
#@   current_design $cur_design
#@ 
#@   P_smash_design_recursive $levels
#@   P_remove_donttouch_on_hier_cells
#@   array unset smashed_designs_hash
#@   set end_time [clock seconds]
#@   set elapsed_time [expr ($end_time - $start_time) / 60.0 / 60.0]
#@   #echo "Runtime to smash the design = $elapsed_time hrs"
#@ }
#@ 
#@ #################################################################
#@ # Procedure   : P_smash_design_recursive
#@ # Description : This proc starts at the current design and descends into the lowest hierarchy and smashes from that level upwards.
#@ #   This proc is called from proc:P_smash_design
#@ 
#@ proc P_smash_design_recursive {levels} {
#@   global smashed_designs_hash
#@   set cur_design [current_design]
#@   set cur_design_name [get_attribute $cur_design name]
#@   if {[info exists smashed_designs_hash($cur_design_name)]} {
#@     return 0
#@   }
#@   if {$levels <= 0} {
#@     ungroup -all -flatten
#@     set smashed_designs_hash($cur_design_name) 1
#@   } else {
#@     set ref_designs {}
#@     set insts_col [get_cells -filter is_hierarchical==true]
#@     set insts_count [sizeof_collection $insts_col]
#@     foreach_in_collection inst_col $insts_col {
#@       lappend ref_designs [get_attribute $inst_col ref_name]
#@     }
#@     foreach ref_design $ref_designs {
#@       if {![info exists smashed_designs_hash($ref_design)]} {
#@         current_design $ref_design
#@         P_smash_design_recursive [expr $levels - 1]
#@       }
#@     }
#@     current_design $cur_design
#@   }
#@ }
#@ 
#@ ##################################################################
#@ # Procedure   : P_remove_donttouch_on_hier_cells
#@ # Description : This proc recursively traverses the hierarchies in the design.
#@ #   If a hiararchical instance as a dont touch on it remove that dont touch attribute
#@ 
#@ proc P_remove_donttouch_on_hier_cells {} {
#@   set cur_design [current_design]
#@   set ref_designs {}
#@   set insts_col [get_cells -filter is_hierarchical==true]
#@   foreach_in_collection inst_col $insts_col {
#@     lappend ref_designs [get_attribute $inst_col ref_name]
#@     remove_attribute $inst_col dont_touch -quiet
#@   }
#@   foreach ref_design $ref_designs {
#@     current_design $ref_design
#@     P_remove_donttouch_on_hier_cells
#@   }
#@   current_design $cur_design
#@ }
#@ 
#@ ########################
#@ # Floorplan Procedures
#@ ########################
#@ 
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_add_bonuscore_core2h_rows
#@ # __description:  add bonuscore & core2h site_rows to an existing FP
#@ # __proc returns: 0 = successful
#@ #                 1 = error
#@ # __required_args:  -unit_tile    = name of base unit tile
#@ # __optional_args:  -bonus_tile   = name of bonus tile
#@ #                   -unit_2h_tile = name of double height tile
#@ # __end
#@ #-------------------------------------------------------------------
#@ #
#@ proc P_add_bonuscore_core2h_rows { args } {
#@   parse_proc_arguments -args $args flag
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   # set up error outputs
#@   set puts "puts"
#@   set puts_nnl "puts -nonewline"
#@   set info_stack "\n#INFO-STACK==> $func_name"
#@   set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
#@   set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
#@   if { [llength [info commands da_error]] > 0 } { set da_error da_error
#@   } else { set da_error [eval $fmte ERROR] }
#@   if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
#@   } else { set da_warn [eval $fmt WARNING] }
#@   if { [llength [info commands da_info]] > 0 } { set da_info da_info
#@   } else { set da_info [eval $fmt INFO] }
#@ 
#@   ###########################################################################
#@   # procedure P_add_bonuscore_core2h_rows
#@   # the function assumes that only single tile pattern exists in the design
#@   # assumes that rows alternate between N & S with no gaps in site_rows.
#@   # bonuscore rows are the same height & orientation as existing core tile
#@   # core2h rows are the same width as existing core tile, and require N-S pair
#@   ###########################################################################
#@ 
#@ 
#@   # get techfile info
#@   set tech_info [P_get_techfile_info]
#@   if { [llength $tech_info] == 0 } {
#@     eval $da_error "\"No MW library open or insufficient disk space\""
#@     return 1
#@   }
#@   # look up info for tiles
#@   set all_tiles {}
#@   set all_tile_names {}
#@   foreach tech_item $tech_info {
#@     if { ! [string equal "Tile" [lindex $tech_item 0]] } {
#@       continue
#@     }
#@     unset -nocomplain tech_tile_name tech_tile_width tech_tile_length
#@     set tech_tile_name [lindex $tech_item 1]
#@     foreach sub_item [lrange $tech_item 2 end] {
#@       if { [string equal -nocase "width" [lindex $sub_item 0]] } {
#@         set tech_tile_width [lindex $sub_item 1]
#@       } elseif { [string equal -nocase "height" [lindex $sub_item 0]] } {
#@         set tech_tile_height [lindex $sub_item 1]
#@       }
#@     }
#@     if { (! [info exists tech_tile_width]) || (! [info exists tech_tile_height]) } {
#@       continue
#@     }
#@     set new_tile [list $tech_tile_name $tech_tile_width $tech_tile_height]
#@     lappend all_tiles $new_tile
#@     lappend all_tile_names $tech_tile_name
#@   }
#@ 
#@ 
#@ 
#@   # ensure that a design is open and has core_area
#@   redirect /dev/null {catch {set core_area [get_core_area]}}
#@   if { (! [info exists core_area]) || ([llength $core_area] == 0) } {
#@     # no design is open or core_area isn't defined
#@     eval $da_error "\"No design open or undefined core_area\""
#@     return 1
#@   }
#@ 
#@ 
#@   # get min resolution (the round about method for icc)
#@   redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
#@   regexp -line {^length.*} $unit_vars length_units
#@   set resolution [expr 1.0 / ([lindex $length_units 2] + 0.0)]
#@ 
#@ 
#@   # check that each tile specified exists
#@   set error 0
#@   set core_step 1.0
#@   set core2h_width 1.0
#@   set core2h_height 1.0
#@   set bonus_width  1.0
#@   set bonuscore_mult 1
#@   if { [info exists flag(-unit_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-unit_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"unit_tile '$flag(-unit_tile)' doesn't exist\""
#@     } else {
#@       set core_tile $flag(-unit_tile)
#@       set core_item [lindex $all_tiles $tile_number]
#@       set tile_width  [lindex $core_item 1]
#@       set tile_height [lindex $core_item 2]
#@       set core_step [expr int(round($tile_width / $resolution))]
#@     }
#@   }
#@   if { [info exists flag(-bonus_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-bonus_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"bonus_tile '$flag(-bonus_tile)' doesn't exist\""
#@     } else {
#@       set bonuscore_tile $flag(-bonus_tile)
#@       set bonus_item [lindex $all_tiles $tile_number]
#@       set bonus_width  [lindex $bonus_item 1]
#@       set bonuscore_step [expr int(round($bonus_width / $resolution))]
#@       set bonuscore_mult [expr int(round($bonuscore_step / $core_step))]
#@     }
#@   }
#@   if { [info exists flag(-unit_2h_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-unit_2h_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' doesn't exist\""
#@     } else {
#@       set core2h_tile $flag(-unit_2h_tile)
#@       set core2h_item [lindex $all_tiles $tile_number]
#@       set core2h_width  [lindex $core2h_item 1]
#@       set core2h_height  [lindex $core2h_item 2]
#@       set core2h_step [expr int(round($core2h_width / $resolution))]
#@       set core2h_mult [expr int(round($core2h_step / $core_step))]
#@       if { (int(round($tile_height/$resolution)) * 2) != int(round($core2h_height/$resolution)) } {
#@         set error 1
#@         eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' is not double the height of the unit_tile\""
#@       }
#@       set tile_height [lindex $core_item 2]
#@     }
#@   }
#@ 
#@ 
#@   # exit if error
#@   if { $error } {
#@     eval $da_error "\"Problem specified tiles don't exist\""
#@     return 1
#@   }
#@ 
#@ 
#@ 
#@   # get information on existing site_rows
#@   # use win_select_objects (rather than get_site_rows)
#@   # -- this is due to an early bug where get_site_rows didn't get unnamed rows
#@   set design_bbox [get_attribute -quiet [get_die_area] bbox]
#@   if { [llength $design_bbox] == 1 } { set design_bbox [lindex $design_bbox 0] }
#@   set design_bbox [join $design_bbox]
#@   change_selection -remove [get_selection]
#@   win_set_select_class {site_row}
#@   win_set_filter -class site -filter {site_row}
#@   win_select_objects -within $design_bbox -slct_targets global -slct_targets_operation clear -intersect
#@   set site_rows [sort_collection [sort_collection [filter_collection [get_selection] "object_class==\"site_row\""] bbox_llx] bbox_lly]
#@   change_selection $site_rows
#@   if { [sizeof_collection $site_rows] == 0 } {
#@     eval $da_warn "\"no site_row in design\""
#@     return 1
#@   }
#@ 
#@   # record existing site_row information
#@   set existing_rows {}
#@   set existing_names {}
#@   set core2h_N_rows {}
#@   set core2h_S_rows {}
#@   set core_sites {}
#@   set bonuscore_sites {}
#@   set core2h_sites {}
#@   unset -nocomplain min_y
#@   foreach_in_collection site_row $site_rows {
#@     set site_space  [get_attribute -quiet $site_row site_space]
#@     set site_count  [get_attribute -quiet $site_row site_count]
#@     set site_type   [get_attribute -quiet $site_row site_type]
#@     if { ! [string equal $core_tile $site_type] } { continue }
#@     set origin      [get_attribute -quiet $site_row origin]
#@     if { [llength $origin] == 1 } { set origin [lindex $origin 0] }
#@     foreach { x y } $origin { break }
#@     if { (! [info exists min_y]) || ($y < $min_y) } {
#@       set min_y $y
#@     }
#@     set orientation [get_attribute -quiet $site_row orientation]
#@     set direction   [get_attribute -quiet $site_row direction]
#@     set name        [get_attribute -quiet $site_row name]
#@     switch -glob $orientation {
#@       *N { set flip_orient "FS" }
#@       *S { set flip_orient "N" }
#@       default { set flip_orient $orientation }
#@     }
#@     set add_row [list $site_space $site_count $site_type $origin $orientation $direction $name $flip_orient]
#@     lappend existing_rows $add_row
#@     lappend existing_names $name
#@ 
#@     # core sites
#@     lappend core_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation $site_count]
#@ 
#@     # bonuscore sites are original core sites with site_count divided by 4
#@     set x_length [expr $site_count * $tile_width]
#@     lappend bonuscore_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation [expr int(floor(($x_length/$bonus_width) + $resolution))]]
#@ 
#@     #
#@     # compute rows for core2h
#@     # use polygon operation, build bbox for each site_row
#@     #   BUT ... stretch N rows up by tile_height, S rows down by tile_height
#@     #   core2h site_rows described by the intersection of N & S polygons
#@     #
#@     switch -glob $orientation {
#@       *N { set yll $y
#@         set yur [expr $y + $tile_height]
#@         set north 1
#@       }
#@       *S { set yll [expr $y - $tile_height]
#@         set yur $y
#@         set north 0
#@       }
#@       default { set yll 0.0
#@         set yur 0.0
#@         set north -1
#@       }
#@     }
#@     set xll $x
#@     set xur [expr $x + ($site_space * $site_count)]
#@     set bbox [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     if { $north == 1 } {
#@       lappend core2h_N_rows $bbox
#@     } elseif { $north == 0 } {
#@       lappend core2h_S_rows $bbox
#@     }
#@   }
#@   if { [llength $core_sites] == 0 } {
#@     eval $da_error "\"No $core_tile site_rows found in design\""
#@     return 1
#@   }
#@   remove_site_row [get_selection]
#@   change_selection -remove [get_selection]
#@ 
#@   # make a list of core2h sites from the intersection of N & S polygons
#@   foreach row2h [compute_polygons -boolean and $core2h_N_rows $core2h_S_rows] {
#@     # get the bounds of each polygon to figure out core2h sites
#@     set xll [lindex [lindex [lsort -real -index 0 -increasing $row2h] 0] 0]
#@     set yll [lindex [lindex [lsort -real -index 1 -increasing $row2h] 0] 1]
#@     set xur [lindex [lindex [lsort -real -index 0 -decreasing $row2h] 0] 0]
#@     if { int(round(($yll - $min_y)/$core2h_height)) % 2 } {
#@       set core_orient "N"
#@     } else {
#@       set core_orient "FS"
#@     }
#@     lappend core2h_sites [list [expr int(round($xll/$resolution))] [expr int(round($yll/$resolution))] $core_orient [expr int(floor((($xur-$xll)/$core2h_width) + $resolution))]]
#@ 
#@   }
#@ 
#@   # create DEF file
#@   write_def -rows_tracks_gcells -output core_[pid].def
#@   set f1 [open core_[pid].def  ]
#@   redirect -variable file_dump {set tmp [read $f1]}
#@   close $f1
#@ 
#@   set f2 [open core_[pid].def   w]
#@   regsub -all "ROW STD_ROW_\[\^\n\]*\n" $tmp "" tmpnew1
#@   regsub -all "DIEAREA " $tmpnew1 "\#DIEAREA" tmpnew2
#@   regsub -all "END DESIGN.*" $tmpnew2 "" tmpnew
#@   puts $f2 "[string trimright $tmpnew]\n"
#@   # add core
#@   # DEF line looks like;
#@   #  ROW STD_ROW_1 core 0 2784 N DO 7080 BY 1 STEP 116 0 ;
#@   if { ! [info exists core_tile] } {
#@     set core_sites {}
#@   }
#@   set i 1
#@   foreach site_row [lsort -index 0 [lsort -index 1 $core_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_$i $core_tile $x $y $orient DO $step BY 1 STEP $core_step 0 ;"
#@     incr i
#@   }
#@   # add bonuscore
#@   # DEF line looks like;
#@   #  ROW STD_ROW_BONUSCORE_1 bonuscore 0 2784 N DO 7080 BY 1 STEP 464 0 ;
#@   if { ! [info exists bonuscore_tile] } {
#@     set bonuscore_sites {}
#@   }
#@   foreach site_row [lsort -index 0 [lsort -index 1 $bonuscore_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_BONUSCORE_$i $bonuscore_tile $x $y $orient DO $step BY 1 STEP $bonuscore_step 0 ;"
#@     incr i
#@   }
#@   # add core2h (if available)
#@   # DEF line looks like;
#@   #  ROW STD_ROW_CORE2H_1 core2h 0 2784 N DO 7080 BY 1 STEP 116 0 ;
#@   if { ! [info exists core2h_tile] } {
#@     set core2h_sites {}
#@   }
#@   foreach site_row [lsort -index 0 [lsort -index 1 $core2h_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_CORE2H_$i $core2h_tile $x $y $orient DO $step BY 1 STEP $core2h_step 0 ;"
#@     incr i
#@   }
#@   close $f2
#@ 
#@   # load def
#@   read_def core_[pid].def
#@   file delete -force "core_[pid].def"
#@ 
#@ 
#@   return 0
#@ 
#@ }
#@ 
#@ define_proc_attributes P_add_bonuscore_core2h_rows     -info "Create site_rows for core2h and bonuscore"     -define_args {
#@       {-unit_tile "name of unit tile" unit_tile string required}
#@       {-bonus_tile "name of bonus tile" bonus_tile string optional}
#@       {-unit_2h_tile "name of 2x height tile" unit_2h_tile string optional}
#@     }
#@ 
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_get_techfile_info
#@ # __description:  dump & read in contents of techfile for current_mw_lib
#@ #                 ignores comment fields
#@ # __proc returns:  a list of lists of technology information
#@ #                  i.e.
#@ #                  {{Technology {name "name-string"} {date "date-string"}
#@ #                               {dielectric 3.45e-5} ...}
#@ #                   {Color 19 {{name 19} {rgbDefined 1} ...}}
#@ #                   {Stipple patternM1 {{width 8} {height 8}
#@ #                                       {pattern {0 0 0 1 0 0 ...}  ...}}
#@ #                   {Tile unit {{width 0.xx} {height x.xx}}}
#@ #                   {Tile core {{width 0.xx} {height x.xx}}}
#@ #                   {Layer poly {{layerNumber #} {maskName poly} {visible 1} ...}}
#@ #                   {ContactCode via1 {{contactCodeNumber #} {cutLayer via1} ...}}
#@ #                   .....}
#@ # __required_args:  none
#@ # __optional_args:
#@ # __end
#@ #-------------------------------------------------------------------
#@ #
#@ proc P_get_techfile_info {} {
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   # set up error outputs
#@   set puts "puts"
#@   set puts_nnl "puts -nonewline"
#@   set info_stack "\n#INFO-STACK==> $func_name"
#@   set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
#@   set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
#@   if { [llength [info commands da_error]] > 0 } { set da_error da_error
#@   } else { set da_error [eval $fmte ERROR] }
#@   if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
#@   } else { set da_warn [eval $fmt WARNING] }
#@   if { [llength [info commands da_info]] > 0 } { set da_info da_info
#@   } else { set da_info [eval $fmt INFO] }
#@ 
#@   redirect /dev/null {catch {set mw_lib [current_mw_lib]}}
#@   if { (! [info exists mw_lib]) || ([llength $mw_lib] == 0) } {
#@     # no library is open
#@     return {}
#@   }
#@   write_mw_lib_files -technology -output tech_[pid].tf [current_mw_lib]
#@ 
#@   set tfh [open tech_[pid].tf r]
#@   set tech_lines {}
#@   set start_comment -1
#@   while { ! [eof $tfh] } {
#@     gets $tfh line
#@     set new_line ""
#@     while { [string length $line] > 0 } {
#@       if { $start_comment >= 0 } {
#@         set stop_comment [string first "*/" $line $start_comment]
#@         if { $stop_comment < 0 } {
#@           set line ""
#@           set start_comment 0
#@           break
#@         } else {
#@           set line [string range $line [expr $stop_comment + 2] end]
#@           set start_comment -1
#@         }
#@       } else {
#@         set start_comment [string first "/*" $line]
#@         if { $start_comment > 0 } {
#@           append new_line [string range $line 0 [expr $start_comment - 1]]
#@           set line [string range $line [expr $start_comment + 2] end]
#@           set start_comment 0
#@         } elseif { $start_comment < 0 } {
#@           append new_line $line
#@           set line ""
#@         }
#@       }
#@       set new_line [string trim $new_line]
#@       if { [string length $new_line] > 0 } {
#@         lappend tech_lines $new_line
#@       }
#@     }
#@   }
#@   close $tfh
#@ 
#@   set tech_info {}
#@   set in_section 0
#@   set line ""
#@   # have a techfile with all comments stripped
#@   foreach read_line $tech_lines {
#@     append line " $read_line"
#@     if { ! $in_section } {
#@       unset -nocomplain field type new_list end
#@       if { [regexp {^\s*(\S+)\s+"(\S+)"\s+\{\s*(\}?)$} $line all field type end] } {
#@         set new_list [list $field $type]
#@       } elseif { [regexp {^\s*(\S+)\s+(\d+)\s+\{\s*(\}?)$} $line all field type end] } {
#@         set new_list [list $field $type]
#@       } elseif { [regexp {^\s*(\S+)\s+\{\s*(\}?)$} $line all field end] } {
#@         set new_list [list $field]
#@       } else {
#@         continue
#@       }
#@       set in_section 1
#@     } else {
#@       if { [regexp {^\s*(\S+)\s*=\s*"([^\"]+)"\s*(\}?)$} $line all item value end] } {
#@         lappend new_list [list $item $value]
#@       } elseif { [regexp {^\s*(\S+)\s*=\s*\(([^\)]+)\)\s*(\}?)$} $line all item value_list end] } {
#@         set value [regsub -all {[\s,]+} [string trim $value_list] { }]
#@         lappend new_list [list $item $value]
#@       } elseif { [regexp {^\s*(\S+)\s*=\s*([^\s\(]+)\s*(\}?)$} $line all item value end] } {
#@         lappend new_list [list $item $value]
#@       } elseif { ! [regexp {^\s*(\})$} $line all end] } {
#@         continue
#@       }
#@     }
#@     if { [info exists end] && [string equal "\}" $end] } {
#@       lappend tech_info $new_list
#@       set in_section 0
#@     }
#@     set line ""
#@ 
#@   }
#@ 
#@   # remove the temporary techfile
#@   file delete -force "tech_[pid].tf"
#@ 
#@   return $tech_info
#@ 
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_set_repeating_custom_tracks
#@ # Input(s)    : -track_settings {list}
#@ # Output(s)   : none
#@ # Help line   : sets custom tracks based on track_settings
#@ #                  list that describes track settings
#@ # Description : set preferred directions, preferred
#@ #               and non-preferred routing tracks.
#@ #               The procedure will set tracks across the
#@ #               entire floorplan and allows a either a
#@ #               single repeating track or set of
#@ #               (non-uniform) repeating tracks.
#@ #               Non-preferred tracks can be explicitly set
#@ #               or if not set then are derived from preferred
#@ #               tracks above & below the current layer.
#@ #               Tracks are built to avoid wires
#@ #               that won't be contained in the floorplan area.
#@ #
#@ #               {list} format for -track_settings:
#@ #                  => per layer list specifying:
#@ #                   layer                string(layer_name)
#@ #                   preferred-direction  string(horizontal or vertical)
#@ #                   preferred-tracks     list(offsets,repeat)
#@ #                   non-preferred-tracks list(offsets,repeat)
#@ #                   {offsets} - (list of) number(s)
#@ #                   {repeat}  - number (step value for tracks)
#@ #
#@ # Example(s)  : Suppose you are running script called "check_hier.tcl"
#@ #               set my_tracks {
#@ #                   { { layer metal1 }
#@ #                          { preferred-direction vertical }
#@ #                          { preferred-tracks { offsets 0 }
#@ #                                             { repeat 0.116 } } }
#@ #                      { { layer metal2 }
#@ #                          { preferred-direction horizontal }
#@ #                          { preferred-tracks { offsets { 0.029 0.145 0.464 0.580
#@ #                                                         0.696 0.812 0.928
#@ #                                                         1.247 1.363 1.479 } }
#@ #                                             { repeat  1.566 } } }
#@ #                      { { layer metal3 }
#@ #                          { preferred-direction vertical }
#@ #                          { preferred-tracks { offsets 0.116 }
#@ #                                             { repeat 0.116 } } }
#@ #                      { { layer metal4 }
#@ #                          { preferred-direction horizontal } }
#@ #                   }
#@ #               P_set_repeating_custom_tracks -track_settings $my_tracks
#@ #
#@ # Notes(s)    :
#@ #      1) arguments are given as lists (lists of lists with keyword directives)
#@ #      2) it is not necessary to specify preferred-direction, values set
#@ #             up in the design are used by default
#@ #      3) offsets should be given from the bottom & left
#@ #      4) tracks are only added if the entire metal width fits in the fub
#@ #      5) non-preferred tracks by default will be derived from the
#@ #           preferred tracks of the layers above & below the current layer
#@ #      6) non-preferred tracks can be forced if needed using the
#@ #           non-preferred-tracks directive
#@ #      7) if two different sets of repeats are required for a particular
#@ #           track setup, then they need to be given as 2 separate layer sets
#@ #           i.e. (this example pushes preferred tracks from
#@ #                         metal2 & metal4 to metal3 non-preferred tracks)
#@ #
#@ #               set my_tracks {
#@ #                      { { layer metal3 }
#@ #                          { non-preferred-tracks { offsets
#@ #                                                    { 0.029 0.145 0.464 0.580
#@ #                                                      0.696 0.812 0.928
#@ #                                                      1.247 1.363 1.479 } }
#@ #                                             { repeat  1.566 } } }
#@ #                      { { layer metal3 }
#@ #                          { non-preferred-tracks { offsets 0.087 }
#@ #                                                 { repeat 0.174 } } }
#@ #                   }
#@ #               P_set_repeating_custom_tracks -track_settings $my_tracks
#@ #
#@ # -----------------------------------------------------------------------------
#@ #
#@ 
#@ 
#@ proc P_set_repeating_custom_tracks {args } {
#@   parse_proc_arguments -args $args flag
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   if { [info exists flag(-track_settings)] } {
#@     if { $flag(-track_settings) == "help" } {
#@       puts "need help"
#@       puts "Usage: $func_name # set custom tracks"
#@       puts "        -track_settings TrackInfoList"
#@       puts "   (TrackInfoList of type list)"
#@       puts "   TrackInfoList format:"
#@       puts "      {"
#@       puts "         { {layer LAYER_1}"
#@       puts "              {preferred-direction HORIZONTAL|VERTICAL}"
#@       puts "              {preferred-tracks"
#@       puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
#@       puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
#@       puts "              }"
#@       puts "              {non-preferred-tracks"
#@       puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
#@       puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
#@       puts "              }"
#@       puts "         }"
#@       puts "         { {layer LAYER_N}"
#@       puts "           {preferred-direction HORIZONTAL|VERTICAL}"
#@       puts "         }"
#@       puts "      }"
#@       puts "   - - - - - - - -"
#@       puts "   (optional) non-preferred-tracks"
#@       puts "        - if not given, then derived from preferred-tracks above/below"
#@       puts ""
#@       return
#@     }
#@     set track_settings $flag(-track_settings)
#@   }
#@ 
#@   # set default offset reference to the lowerLeft unless 'origin' is specified
#@   set reference_origin 0
#@   if { [info exists flag(-offset_reference)] } {
#@     if { [string equal "origin" $flag(-offset_reference)] } {
#@       set reference_origin 1
#@     }
#@   }
#@ 
#@   # record if tracks can land on the boundary
#@   set no_sharing_boundary [info exists flag(-no_tracks_on_boundary)]
#@ 
#@   # All track settings are done HERE with track_settings
#@ 
#@   # get length precision (the round about method for icc)
#@   redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
#@   regexp -line {^length.*} $unit_vars length_units
#@   set lengthPrecision [expr [lindex $length_units 2] + 0.0]
#@   # hard code length precision - not easily available in tcl
#@   # set lengthPrecision 1000.0
#@ 
#@   # base on bounds of the block to set range of wiretracks
#@   set bound_llx [expr [get_attribute [current_design] die_area_llx]                      / $lengthPrecision]
#@   set bound_lly [expr [get_attribute [current_design] die_area_lly]                      / $lengthPrecision]
#@   set bound_urx [expr [get_attribute [current_design] die_area_urx]                      / $lengthPrecision]
#@   set bound_ury [expr [get_attribute [current_design] die_area_ury]                      / $lengthPrecision]
#@ 
#@   # find metal routing layers
#@   set layer_pairs {}
#@   foreach_in_collection layer [get_layers] {
#@     set layer_name [get_attribute $layer name]
#@     if { [string match [get_layer_attribute -layer $layer_name isDefaultLayer] 0] } {
#@       continue
#@     }
#@     if { [string match metal*               [get_layer_attribute -layer $layer_name mask_name]] } {
#@       lappend layer_pairs [list [get_layer_attribute -layer $layer_name mask_name] $layer_name]
#@     }
#@   }
#@   set layer_pairs [lsort -index 0 -dictionary $layer_pairs]
#@   set layers {}
#@   foreach item $layer_pairs {
#@     lappend layers [lindex $item 1]
#@   }
#@   unset layer_pairs
#@ 
#@   # get existing preferred directions
#@   set preferred_dir_list {}
#@   redirect -variable dump_preferred_dir { report_preferred_routing_direction }
#@   set next_match 0
#@   if { [regexp -start $next_match -indices -lineanchor             "Layer Name  \[^\n]*"             $dump_preferred_dir dump_indices] } {
#@     set new_str [string range $dump_preferred_dir [lindex $dump_indices 0]                      [lindex $dump_indices 1]]
#@     set next_match [expr [lindex $dump_indices 1] + 2]
#@     regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_fields
#@     # find fields for layer_name & design
#@     set layer_index [lsearch [string tolower $dump_fields] layer_name]
#@     set design_index [lsearch [string tolower $dump_fields] design]
#@     set num_fields [llength $dump_fields]
#@ 
#@     # now search for fields
#@     while { [regexp -start $next_match -indices -lineanchor                  "\[^\n]*"                  $dump_preferred_dir dump_indices] } {
#@       if { $layer_index < 0 || $design_index < 0 } {
#@         break
#@       }
#@       set new_str [string range $dump_preferred_dir                        [lindex $dump_indices 0]                        [lindex $dump_indices 1]]
#@       set next_match [expr [lindex $dump_indices 1] + 2]
#@       regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_string
#@       if { [llength $dump_string] < $num_fields } {
#@         unset dump_string new_str
#@         break
#@       }
#@       set prefer_layer [lindex $dump_string $layer_index]
#@       set prefer_dir   [string tolower [lindex $dump_string $design_index]]
#@       lappend preferred_dir_list [list $prefer_layer $prefer_dir]
#@       unset prefer_layer prefer_dir dump_string new_str
#@     }
#@     unset layer_index design_index num_fields
#@   }
#@   unset dump_preferred_dir next_match
#@   set preferred_dir_list [lsort -index 0 -dictionary $preferred_dir_list]
#@ 
#@ 
#@   # begin processing track settings for layer
#@   set error 0
#@   set tracks_actually_set {}
#@   set nprfr_adds {}
#@   set dir_updates {}
#@   foreach track_set $track_settings {
#@     unset -nocomplain layer_name preferred_dir         PT NPT unknown_opt comment_field err_type
#@     foreach item $track_set {
#@       if { $error } {
#@         break
#@       }
#@       if { [llength $item] < 2 } {
#@         continue
#@       }
#@       set chk_field [string tolower [lindex $item 0]]
#@       switch -- ${chk_field} {
#@         layer                { if { [info exists layer_name] } {
#@           set err_type layer
#@         } else {
#@           set layer_name [lindex $item 1]
#@         }
#@         }
#@         preferred-direction  { if { [info exists preferred_dir] } {
#@           set err_type preferred-direction
#@         } else {
#@           set preferred_dir [lindex $item 1]
#@         }
#@         }
#@         non-preferred-tracks { if { [info exists NPT] } {
#@           set err_type non-preferred-tracks
#@         } else {
#@           set NPT [lrange $item 1 end]
#@         }
#@         }
#@         preferred-tracks     { if { [info exists PT] } {
#@           set err_type preferred-tracks
#@         } else {
#@           set PT [lrange $item 1 end]
#@         }
#@         }
#@         comment              { set comment_field 1 }
#@         default        { set unknown_opt $item }
#@       }
#@       if { [info exists err_type] } {
#@         puts "ERROR - duplicate option for \"$err_type\" in 'track_settings' for \{ $track_set \}"
#@         set error 1
#@         break
#@       }
#@       if { [info exists comment_field] } {
#@         unset comment_field
#@         continue
#@       }
#@       if { [info exists unknown_opt] } {
#@         break
#@       }
#@     }
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists unknown_opt] } {
#@       puts "WARNING - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $track_set \}"
#@       continue
#@     }
#@     if { ! [info exists layer_name] } {
#@       puts "ERROR - Required 'layer' option missing in 'track_settings' for \{ $track_set \}"
#@       set error 1
#@       break
#@     }
#@     if { [lsearch -exact $layers $layer_name] < 0 } {
#@       puts "ERROR - Unknown 'layer' \"$layer_name\" specified in 'track_settings' for \{ $track_set \}"
#@       puts "      - layer must be one of: $layers"
#@       set error 1
#@       break
#@     }
#@     if { [info exists preferred_dir] } {
#@       switch -- [string tolower ${preferred_dir}] {
#@         vertical    { set new_dir vertical }
#@         horizontal  { set new_dir horizontal }
#@         default     { set unknown_opt $item }
#@       }
#@       if { [info exists unknown_opt] } {
#@         puts "ERROR - bad preferred-direction \"$preferred_dir\" defined for layer \"$layer_name\" "
#@         set error 1
#@         break
#@       }
#@       if { [info exists ${layer_name}(dir)] && (! [string match $new_dir [expr $${layer_name}(dir)]]) } {
#@         puts "ERROR - preferred-direction defined as both horizontal & vertical for layer \"$layer_name\" "
#@         set error 1
#@         break
#@       }
#@       set ${layer_name}(dir) $new_dir
#@     }
#@ 
#@     set track_items {}
#@     if { [info exists PT] } {
#@       lappend track_items [list PT $PT]
#@     }
#@     if { [info exists NPT] } {
#@       lappend track_items [list NPT $NPT]
#@     }
#@     unset -nocomplain comment_field PT_track_offsets PT_track_repeats NPT_track_offsets NPT_track_repeats
#@     foreach N_item $track_items {
#@       set N_dir [string toupper [lindex $N_item 0]]
#@       foreach item [lindex $N_item 1] {
#@         set chk_field [string tolower [lindex $item 0]]
#@         switch -- ${N_dir}_${chk_field} {
#@           NPT_offsets { if { [info exists NPT_track_offsets] } {
#@             set err_type "non-preferred-tracks offsets"
#@           } else {
#@             set NPT_track_offsets [lindex $item 1]
#@           }
#@           }
#@           NPT_repeat  { if { [info exists NPT_track_repeats ] } {
#@             set err_type "non-preferred-tracks repeat"
#@           } else {
#@             set NPT_track_repeats [lindex $item 1]
#@           }
#@           }
#@           NPT_comment { set comment_field 1 }
#@           PT_offsets  { if { [info exists PT_track_offsets] } {
#@             set err_type "preferred-tracks offsets"
#@           } else {
#@             set PT_track_offsets [lindex $item 1]
#@           }
#@           }
#@           PT_repeat   { if { [info exists PT_track_repeats ] } {
#@             set err_type "preferred-tracks repeat"
#@           } else {
#@             set PT_track_repeats [lindex $item 1]
#@           }
#@           }
#@           PT_comment  { set comment_field 1 }
#@           default     { set unknown_opt $item }
#@         }
#@         if { [info exists comment_field] } {
#@           unset comment_field
#@           continue
#@         }
#@         if { [info exists unknown_opt] } {
#@           break
#@         }
#@         if { [info exists err_type] } {
#@           if { ($N_dir == "PT") } {
#@             set type "preferred-tracks"
#@           } else {
#@             set type "non-preferred-tracks"
#@           }
#@           puts "ERROR - duplicate option for \"$err_type\" in $layer_name '${type}' for \{ $item \}"
#@           set error 1
#@           break
#@         }
#@       }
#@       if { [info exists unknown_opt] } {
#@         break
#@       }
#@     }
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists unknown_opt] } {
#@       if { ($N_dir == "PT") } {
#@         set type "preferred-tracks"
#@       } else {
#@         set type "non-preferred-tracks"
#@       }
#@       puts "ERROR - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $layer_name $N_dir \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists PT_track_offsets] } {
#@       foreach t_item $PT_track_offsets {
#@         if { ! [string is double $t_item] } {
#@           set error 1
#@           break
#@         }
#@       }
#@       if { $error } {
#@         puts "ERROR - illegal \"preferred-tracks offsets\". Value must be real on $layer_name for $PT \}"
#@         break
#@       }
#@     }
#@     if { [info exists PT_track_repeats] && ((! [string is double $PT_track_repeats]) || ($PT_track_repeats < (1.0 / $lengthPrecision))) } {
#@       puts "ERROR - illegal \"preferred-tracks repeat\". Value must be positive real on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_offsets] } {
#@       foreach t_item $NPT_track_offsets {
#@         if { ! [string is double $t_item] } {
#@           set error 1
#@           break
#@         }
#@       }
#@       if { $error } {
#@         puts "ERROR - illegal \"non-preferred-tracks offsets\". Value must be real on $layer_name for $NPT \}"
#@         break
#@       }
#@     }
#@     if { [info exists NPT_track_repeats] && ((! [string is double $NPT_track_repeats]) || ($NPT_track_repeats < (1.0 / $lengthPrecision))) } {
#@       puts "ERROR - illegal \"non-preferred-tracks repeat\". Value must be positive real on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@ 
#@     if { [info exists PT_track_offsets] && (! [info exists PT_track_repeats]) } {
#@       puts "ERROR - \"preferred-tracks\" missing \"repeat\" on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists PT_track_repeats] && (! [info exists PT_track_offsets]) } {
#@       puts "ERROR - \"preferred-tracks\" missing \"offsets\" on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_offsets] && (! [info exists NPT_track_repeats]) } {
#@       puts "ERROR - \"non-preferred-tracks\" missing \"repeat\" on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_repeats] && (! [info exists NPT_track_offsets]) } {
#@       puts "ERROR - \"non-preferred-tracks\" missing \"offsets\" on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@ 
#@     if { [info exists PT_track_repeats] } {
#@       if { ! [info exists ${layer_name}(PT)] } {
#@         set ${layer_name}(PT) {}
#@       }
#@       lappend ${layer_name}(PT) [list $PT_track_repeats $PT_track_offsets]
#@     }
#@     if { [info exists NPT_track_repeats] } {
#@       if { ! [info exists ${layer_name}(NPT)] } {
#@         set ${layer_name}(NPT) {}
#@       }
#@       lappend ${layer_name}(NPT) [list $NPT_track_repeats $NPT_track_offsets]
#@     }
#@ 
#@   }
#@ 
#@   foreach layer_name $layers {
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists ${layer_name}(dir)] } {
#@       set preferred_dir [expr $${layer_name}(dir)]
#@     } elseif { ! ([info exists ${layer_name}(PT)] || [info exists ${layer_name}(PT)]) } {
#@       # no tracks or preferred_dir defined for the layer
#@       continue
#@     }
#@     unset -nocomplain act_dir
#@     set dir_index [lsearch -glob $preferred_dir_list "$layer_name *"]
#@     if { $dir_index >= 0 } {
#@       set act_dir [lindex [lindex $preferred_dir_list $dir_index] 1]
#@     }
#@     if { [info exists preferred_dir] } {
#@       # see if preferred_dir needs to be changed
#@       if { [info exists act_dir] } {
#@         if { ! [string match -nocase $act_dir $preferred_dir] } {
#@           # mismatched preferred direction
#@           puts "INFO - Changing $layer_name preferred direction to \"${preferred_dir}\""
#@           unset_preferred_routing_direction -layer $layer_name
#@           set_preferred_routing_direction -layers $layer_name -direction $preferred_dir
#@           set act_dir $preferred_dir
#@           set preferred_dir_list               [lreplace $preferred_dir_list $dir_index $dir_index                    [list $layer_name $preferred_dir]]
#@           lappend dir_updates [list $layer_name $preferred_dir]
#@         }
#@       } else {
#@         puts "ERROR - $layer_name has no preferred direction"
#@         set error 1
#@         continue
#@       }
#@     } else {
#@       if { [info exists act_dir] &&                ( [string match horizontal $act_dir] ||                      [string match vertical $act_dir] ) } {
#@         puts "INFO - $layer_name using $act_dir preferred direction"
#@         set preferred_dir $act_dir
#@       } else {
#@         puts "WARNING - $layer_name has no preferred direction"
#@         continue
#@       }
#@     }
#@   }
#@ 
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { ! [info exists ${layer_name}(PT) ] } {
#@       # no defined preferred tracks to add
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     # set layer_index [lsearch -exact $layers $layer_name]
#@ 
#@     unset -nocomplain tracks_actually_set
#@     set tracks_actually_set {}
#@ 
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 1
#@       set XY Y
#@       set bound_ll $bound_lly
#@       set bound_ur $bound_ury
#@     } else {
#@       set horizontal 0
#@       set XY X
#@       set bound_ll $bound_llx
#@       set bound_ur $bound_urx
#@     }
#@ 
#@     # find start track (based on reference_origin) relative to lower-left
#@     if { $reference_origin } {
#@       # reference for offset is origin
#@       set start_ref 0
#@     } else {
#@       # reference for offset is lower-left
#@       set start_ref $bound_ll
#@     }
#@ 
#@     set PT_list [expr $${layer_name}(PT)]
#@ 
#@     # get default layer width
#@     set width [get_layer_attribute -layer $layer_name defaultWidth]
#@     # if no_sharing_boundary use width, else treat as if width=0
#@     #   (since only the track not the metal must fall within/touching boundary)
#@     if { ! $no_sharing_boundary } {
#@       set width 0
#@     }
#@     set removed_track 0
#@ 
#@     foreach PT $PT_list {
#@       set PT_track_repeats [lindex $PT 0]
#@       set PT_track_offsets [lindex $PT 1]
#@ 
#@ 
#@       # figure out offsets and repeats for actual tracks
#@       set item_list {}
#@       foreach PT_offset $PT_track_offsets  {
#@         # find start track based on start_ref (wire width must fit in bounds)
#@         set offset_adjust [expr $PT_offset                                - ($PT_track_repeats *floor($PT_offset / $PT_track_repeats))]
#@         set PT_start [expr $start_ref + $offset_adjust                           + (($offset_adjust < (0.5 * $width))? $PT_track_repeats : 0)]
#@         set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $PT_start)                                          / $PT_track_repeats)) ]
#@         if { $tcnt > 0 } {
#@           set new_item [list $PT_start $tcnt]
#@           if { [lsearch -exact $item_list $new_item] < 0 } {
#@             lappend item_list $new_item
#@           }
#@         }
#@       }
#@       if { (! $removed_track) && ([llength $item_list] > 0) } {
#@         puts "INFO: Forcing preferred track to defined values on -layer $layer_name"
#@         remove_track -layer $layer_name -dir $XY
#@         set removed_track 1
#@       }
#@       foreach new_item $item_list  {
#@         set PT_start [lindex $new_item 0]
#@         set tcnt [lindex $new_item 1]
#@         set new_track "create_track -layer $layer_name -dir $XY -coord $PT_start                       -space $PT_track_repeats -count $tcnt"
#@         eval $new_track
#@         lappend tracks_actually_set $new_track
#@       }
#@     }
#@     if { [llength $tracks_actually_set] > 0 } {
#@       set ${layer_name}(tracks) $tracks_actually_set
#@     }
#@   }
#@ 
#@   # loop to add defined non-preferred tracks
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { ! [info exists ${layer_name}(NPT)] } {
#@       # no defined non-preferred tracks to add
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     set layer_index [lsearch -exact $layers $layer_name]
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 0
#@       set XY X
#@       set bound_ur $bound_urx
#@     } else {
#@       set horizontal 1
#@       set XY Y
#@       set bound_ur $bound_ury
#@     }
#@ 
#@     set NPT_list [expr $${layer_name}(NPT)]
#@ 
#@     # get default layer width
#@     set width [get_layer_attribute -layer $layer_name defaultWidth]
#@     # if no_sharing_boundary use width, else treat as if width=0
#@     #   (since only the track not the metal must fall within/touching boundary)
#@     if { ! $no_sharing_boundary } {
#@       set width 0
#@     }
#@     set removed_track 0
#@ 
#@     foreach NPT $NPT_list {
#@       set NPT_track_repeats [lindex $NPT 0]
#@       set NPT_track_offsets [lindex $NPT 1]
#@ 
#@       # figure out offsets and repeats for actual tracks
#@       set item_list {}
#@       foreach NPT_offset $NPT_track_offsets  {
#@         # find start track based on start_ref (wire width must fit in bounds)
#@         set offset_adjust [expr $NPT_offset                                - ($NPT_track_repeats                                       * floor($NPT_offset / $NPT_track_repeats))]
#@         set NPT_start [expr $start_ref + $offset_adjust                            + (($offset_adjust < (0.5 * $width))? $NPT_track_repeats : 0)]
#@         set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $NPT_start)                                          / $NPT_track_repeats)) ]
#@         if { $tcnt > 0 } {
#@           set new_item [list $NPT_start $tcnt]
#@           if { [lsearch -exact $item_list $new_item] < 0 } {
#@             lappend item_list $new_item
#@           }
#@         }
#@       }
#@       if { (! $removed_track) && ([llength $item_list] > 0) } {
#@         puts "INFO: Forcing non-preferred track to defined values on -layer $layer_name"
#@         remove_track -layer $layer_name -dir $XY
#@         set removed_track 1
#@       }
#@       foreach new_item $item_list  {
#@         set NPT_start [lindex $new_item 0]
#@         set tcnt [lindex $new_item 1]
#@         set new_track "create_track -layer $layer_name -dir $XY -coord $NPT_start                       -space $NPT_track_repeats -count $tcnt"
#@         eval $new_track
#@       }
#@     }
#@   }
#@ 
#@   # loop to check if default non-preferred tracks are needed
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { [info exists ${layer_name}(NPT)] } {
#@       # already added non-preferred tracks
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     set layer_index [lsearch -exact $layers $layer_name]
#@     if { $layer_index > 0 } {
#@       set lower_layer [lindex $layers [expr $layer_index - 1]]
#@     } else {
#@       set lower_layer ""
#@     }
#@     if { $layer_index < ([llength $layers] - 1) } {
#@       set upper_layer [lindex $layers [expr $layer_index + 1]]
#@     } else {
#@       set upper_layer ""
#@     }
#@ 
#@     if { ! ([info exists ${upper_layer}(tracks)] || [info exists ${lower_layer}(tracks)]) } {
#@       # no preferred tracks defined on adjacent tracks
#@       continue
#@     }
#@ 
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 0
#@       set XY X
#@     } else {
#@       set horizontal 1
#@       set XY Y
#@     }
#@ 
#@     set np_list {}
#@     if { [llength $lower_layer] } {
#@       unset -nocomplain lower_tracks
#@       redirect -variable lower_tracks { report_track -layer $lower_layer -dir $XY }
#@       set next_match 0
#@       while { [regexp -start $next_match -indices                    "$lower_layer \[^\n]*"                    $lower_tracks np_indices] } {
#@         lappend np_list             [lreplace [lrange [string range $lower_tracks                                    [lindex $np_indices 0]                                    [lindex $np_indices 1]]                            0 4] 0 0 $layer_name]
#@         set next_match [expr [lindex $np_indices 1] + 1]
#@       }
#@       unset -nocomplain lower_tracks np_indices next_match
#@     }
#@     if { [llength $upper_layer] } {
#@       unset -nocomplain upper_tracks
#@       redirect -variable upper_tracks { report_track -layer $upper_layer -dir $XY }
#@       set next_match 0
#@       while { [regexp -start $next_match -indices                    "$upper_layer \[^\n]*"                    $upper_tracks np_indices] } {
#@         lappend np_list             [lreplace [lrange [string range $upper_tracks                                    [lindex $np_indices 0]                                    [lindex $np_indices 1]]                            0 4] 0 0 $layer_name]
#@         set next_match [expr [lindex $np_indices 1] + 1]
#@       }
#@       unset -nocomplain upper_tracks np_indices next_match
#@     }
#@     set np_list [lsort -unique $np_list]
#@ 
#@     if { [llength $np_list] > 0 } {
#@       puts "INFO: Resetting non-preferred track to adjacent layer preferred tracks settings on -layer $layer_name"
#@       remove_track -layer $layer_name -dir $XY
#@     }
#@     foreach np_track $np_list {
#@       if { [llength $np_track] < 5 } {
#@         continue
#@       }
#@       set new_track "create_track -layer $layer_name -dir $XY -coord [lindex $np_track 2]                         -space [lindex $np_track 4] -count [lindex $np_track 3]"
#@       eval $new_track
#@     }
#@ 
#@   }
#@ 
#@   if { $error } {
#@     puts "ERROR - $func_name stopped due to errors"
#@   }
#@ 
#@ }
#@ define_proc_attributes P_set_repeating_custom_tracks -info "set custom tracks"     -define_args {{-track_settings "provide list or use '-track_settings help' for TrackInfoList format" TrackInfoList list required }                       {-offset_reference "reference for track offsets {default=lowerLeft}" offset_reference one_of_string { optional value_help {values {lowerLeft origin}}}}                       {-no_tracks_on_boundary "require tracks produce wires fully in the boundary" "" boolean optional} }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_check_boundary_contact
#@ # Description : The procedure to determine if the Core Boundary contacts with any cell
#@ #               which has start point coordinates as cell_llx, cell_lly
#@ #               Used in halo insertion
#@ 
#@ proc P_check_boundary_contact {cell_llx cell_lly} {
#@ 
#@   set bbox [get_attribute [get_core_area] bbox]
#@   set bbox_x1 [lindex [lindex $bbox 0] 0]
#@   set bbox_y1 [lindex [lindex $bbox 0] 1]
#@   set bbox_x2 [lindex [lindex $bbox 1] 0]
#@   set bbox_y2 [lindex [lindex $bbox 1] 1]
#@ 
#@   global diehalo_width
#@   global diehalo_height
#@ 
#@   set flag 0
#@   set prs_flag 0
#@ 
#@   # Checking if the cell that gets placed will be within the die boundary.
#@   # Uncomment line from 78-83 and comment line 85-90 if die-edge halo is considered within Core
#@   #  if {($cell_llx <= [expr $bbox_x1 + 0.54 - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + 1.68 - 0.001]) || ($cell_llx >= [expr $bbox_x2 - 0.54 - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - 1.68 - 0.001] )} {
#@   # set flag 1
#@   #   } else {
#@   #       set flag 0
#@   #   }
#@   #   return $flag
#@ 
#@   if {($cell_llx <= [expr $bbox_x1 + $diehalo_width - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + $diehalo_height - 0.001]) || ($cell_llx >= [expr $bbox_x2 - $diehalo_width - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - $diehalo_height - 0.001] )} {
#@     set flag 1
#@   } else {
#@     set flag 0
#@   }
#@   return $flag
#@ }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_get_abut_chain
#@ # Description : This proc is used to get list of macros which are abutting each other
#@ #               Used in halo insertion
#@ 
#@ proc P_get_abut_chain {abut_master} {
#@   global cellabutlist
#@   set cellabutlist [add_to_collection $cellabutlist $abut_master]
#@   set macro_bbox [list [get_attribute $abut_master boundary]]
#@   set overlapcells [remove_from_collection [get_cells -all -intersect $macro_bbox] $cellabutlist]
#@   foreach_in_collection ovcell $overlapcells {
#@     P_get_abut_chain $ovcell
#@   }
#@   return $cellabutlist
#@ }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_get_abutted_cells
#@ # Description : This proc is used to get macro cells which are abutting
#@ #               Used in halo insertion
#@ 
#@ proc P_get_abutted_cells {input_master} {
#@   set macro_groups ""
#@   set fullabutlist ""
#@   global cellabutlist
#@   foreach_in_collection macrolist $input_master {
#@     if {[sizeof_collection [remove_from_collection $fullabutlist $macrolist -intersect]] == 0} {
#@       set cellabutlist ""
#@       set out_list [P_get_abut_chain $macrolist]
#@       set fullabutlist [add_to_collection $fullabutlist $out_list]
#@       lappend macro_groups [lsort -unique [get_object_name $out_list]]
#@     }
#@   }
#@ 
#@   return $macro_groups
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_get_boundary_polygon
#@ # Description : This proc is used boundary polygon computation for halo insertion
#@ 
#@ proc P_get_boundary_polygon {list_macros} {
#@   set result_polygon [list]
#@   while {[llength $list_macros] > 0} {
#@     set copy_macros $list_macros
#@     for { set i 0 } { $i < [llength $copy_macros] } { incr i } {
#@       if {[llength $result_polygon] > 0 } {
#@         set polygon [compute_polygons -boolean or "$result_polygon" [get_attribute [get_cells -all [lindex $copy_macros $i]] boundary]]
#@         if {[llength $polygon] == 1} {
#@           set result_polygon $polygon
#@           set list_macros [lsearch -inline -all -not -exact $list_macros [lindex $copy_macros $i]]
#@         }
#@       } else {
#@         set first_macro [lindex $copy_macros 0]
#@         set list_macros [lsearch -inline -all -not -exact $list_macros $first_macro]
#@         set result_polygon [get_attribute [get_cells -all $first_macro] boundary]
#@       }
#@     }
#@   }
#@ 
#@   if {[llength $result_polygon] != 1} {
#@     set result_polygon [list $result_polygon];
#@   }
#@ 
#@   return $result_polygon
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_lcount
#@ # Description : This proc is used to get repeated elements from a list
#@ 
#@ proc P_lcount list {
#@   foreach x $list {lappend arr($x) {}}
#@   set res {}
#@   foreach name [array names arr] {
#@     if { [llength $arr($name)] == 2 } {
#@       set res $name
#@     }
#@   }
#@   return $res
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_place_halo
#@ # creates and places a HALO cell at a specific location
#@ # to improve run time, save orientation in list and run at the end
#@ #
#@ proc P_place_halo {cell inst x y orientation} {
#@   global halo_counter
#@   global halo_orient_N halo_orient_FN halo_orient_S halo_orient_FS
#@   create_cell $inst $cell > /dev/null
#@   set_cell_location $inst -coordinates "$x $y" -ignore_fixed
#@   #rotate_objects $inst -to $orientation -ignore_fixed > /dev/null
#@   #this command is slow, so create a list of cell first, then run at once
#@   if {$orientation == "N"} {
#@     lappend halo_orient_N "$inst"
#@   } elseif {$orientation == "FN"} {
#@     lappend halo_orient_FN "$inst"
#@   } elseif {$orientation == "S"} {
#@     lappend halo_orient_S "$inst"
#@   } elseif {$orientation == "FS"} {
#@     lappend halo_orient_FS "$inst"
#@   } else {
#@     P_msg_error "set orientation error"
#@   }
#@   incr halo_counter
#@   #puts "==>INFORMATION: Placed $cell $inst $x $y $orientation"
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_find_direction
#@ # This procedure just finds the direction of the boundary edge
#@ # by looking at the coordinate of start point and end point
#@ # returns "up", "down", "left", "right"
#@ #
#@ proc P_find_direction {start end} {
#@   set startx [lindex $start 0]
#@   set starty [lindex $start 1]
#@   set endx [lindex $end 0]
#@   set endy [lindex $end 1]
#@   if {$startx == $endx && $starty==$endy} {
#@     return "nochange"
#@   } elseif {$startx<$endx && $starty==$endy} {
#@     return "right"
#@   } elseif {$startx==$endx && $starty<$endy} {
#@     return "up"
#@   } elseif {$startx>$endx && $starty==$endy} {
#@     return "left"
#@   } elseif {$startx==$endx && $starty>$endy} {
#@     return "down"
#@   } else {
#@     P_msg_error "Cannot determine direction"
#@   }
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_ret_intersect_list
#@ # Description : This proc returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo 
#@ #               Used during halo insertion around voltage areas
#@ 
#@ proc P_ret_intersect_list {args} {
#@   parse_proc_arguments -args $args inputs
#@   set vboundary $inputs(-input_boundary)
#@   set input_va_name $inputs(-input_va)
#@ 
#@   set check_boundary_list [list ]
#@   set volt_boundary [lsort -unique -dict -increasing $vboundary]
#@ 
#@   set die_boundary [lsort -unique -dict -increasing [get_attribute [get_die_area] boundary]]
#@   lappend check_boundary_list $die_boundary
#@   
#@   set intersect_macros [get_cells -all -intersect $vboundary -quiet -filter "name !~ *halo_va*"]
#@   foreach_in_collection  macro $intersect_macros {
#@     lappend check_boundary_list [lsort -unique -incr -dict [get_attribute $macro boundary]]
#@   }
#@   
#@   set ret_list ""
#@   set volt_count -1
#@ 
#@   foreach volt_point $volt_boundary {
#@     incr volt_count
#@     foreach volt_x_val [lindex $volt_point 0] {
#@       foreach check_bound $check_boundary_list {
#@         set ch_count -1
#@         set x_val ""
#@         foreach check_point $check_bound {
#@           incr ch_count
#@           foreach check_x_val [lindex $check_point 0] {
#@             if {[lsearch $x_val $volt_x_val] > -1} {continue}
#@             if {$check_x_val == $volt_x_val} {
#@               lappend x_val $check_x_val
#@               set check_curr_y_val [lindex $check_point 1]
#@               set check_next_y_val [lindex [lindex $check_bound [expr $ch_count + 1]] 1]
#@               set volt_curr_y_val [lindex $volt_point 1]
#@               set volt_next_y_val [lindex [lindex $volt_boundary [expr $volt_count + 1]] 1]
#@               
#@               if {($check_curr_y_val <= $volt_curr_y_val) && ($check_next_y_val > $volt_curr_y_val)} {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$volt_curr_y_val y2_$check_next_y_val"
#@               } elseif {($check_curr_y_val < $volt_next_y_val) && ($check_next_y_val >= $volt_next_y_val)} {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$volt_next_y_val"
#@               } elseif {($check_curr_y_val > $volt_curr_y_val) && ($check_next_y_val < $volt_next_y_val)}  {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$check_next_y_val"
#@               }
#@             }
#@           }
#@         }
#@       }
#@     }
#@   }
#@ 
#@   return $ret_list
#@ }
#@ 
#@ define_proc_attributes P_ret_intersect_list     -info "Returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo"     -define_args {
#@       {"-input_boundary" "Voltage area boundary" "" list required}
#@       {"-input_va" "Voltage area name" "" string required}
#@     }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_check_exclusion
#@ # Description : This proc returns the returns y1 y2 intersect points of boundary/macro/non-va-halo
#@ #               Used during halo insertion around voltage areas
#@ 
#@ proc P_check_exclusion {args} {
#@   parse_proc_arguments -args $args inputs
#@   set x $inputs(-x)
#@   set y $inputs(-y)
#@   set ret 1
#@ 
#@   foreach in_list $inputs(-list) {
#@     set match_index [lsearch -all $in_list x_$x]
#@     foreach x_index $match_index {
#@       if {$x_index > -1} {
#@         set y1 [lindex [split [lindex $in_list [expr $x_index + 1]] "_"] 1]
#@         set y2 [lindex [split [lindex $in_list [expr $x_index + 2]] "_"] 1]
#@         if {[expr $y >= $y1] && [expr $y < $y2]} {
#@           set ret 0
#@           return $ret
#@         }
#@       }
#@     }
#@   }
#@ 
#@   return $ret
#@ 
#@ }
#@ 
#@ define_proc_attributes P_check_exclusion     -info "Returns y1 y2 intersect points"     -define_args {
#@       {"-list" "input list" "" string required}
#@       {"-x" "x coordinate to check" "" string required}
#@       {"-y" "y coordinate to check" "" string required}
#@     }
#@ 
#@ ####################################################################################################
#@ # Procedure   : P_macro_route_guide_cmd
#@ # Description : This proc is a PG pullback solution.
#@ #               It creates route-guides for all IPs for all specified layers and pulls back the PG when power straps are created.
#@ #               The route guide is removed when the proc is executed again for the next metal layer.
#@ 
#@ proc P_macro_route_guide_cmd {layer} {
#@   global INTEL_MACRO_EXCLUSION_LIST
#@   global INTEL_MACRO_RG_LIST
#@   remove_route_guide macroblkg*
#@ 
#@   foreach_in_collection macro [all_macro_cells] {
#@     set macro_ref_name [get_attribute $macro ref_name]
#@     set macro_index ""
#@     set default_index ""
#@     set exclusion_list -1
#@ 
#@     #Sets up exclusion list for macro references which should not have RGs for any layer
#@     #------------------------------------------------------------------------------------
#@     if {[info exists INTEL_MACRO_EXCLUSION_LIST] && $INTEL_MACRO_EXCLUSION_LIST != ""} {
#@       set exclusion_list [lsearch $INTEL_MACRO_EXCLUSION_LIST $macro_ref_name]
#@     }
#@ 
#@     if {$exclusion_list >= 0} {
#@       P_msg_info "Route Guides not created for macro:$macro_ref_name as it is part of exclusion list..."
#@     } else {
#@ 
#@       #Overrides default bloat values of current layer for specified macros
#@       #---------------------------------------------------------------------------------
#@       if {[info exists INTEL_MACRO_RG_LIST($macro_ref_name)]} {
#@         set macro_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST($macro_ref_name)] $layer]
#@         if {$macro_index != -1} {
#@           set x_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 1]]
#@           set y_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 2]]
#@         }
#@       }
#@ 
#@       #Defaults bloat values for current layer if not overriden for a macro
#@       #-------------------------------------------------------------------------
#@ 
#@       if {![info exists INTEL_MACRO_RG_LIST($macro_ref_name)] || $macro_index == -1} {
#@         if {[info exists INTEL_MACRO_RG_LIST(DEFAULT)]} {
#@           set default_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST(DEFAULT)] $layer]
#@           if {$default_index != -1} {
#@             set x_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 1]]
#@             set y_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 2]]
#@           }
#@         }
#@       }
#@ 
#@       #No route guides will be created for current layer, if bloat values were neither provided in default or override list
#@       #----------------------------------------------------------------------------------------------------------------------
#@ 
#@       if {![info exists INTEL_MACRO_RG_LIST(DEFAULT)] || $default_index == -1} {
#@         puts "==>ERROR: Neither \$INTEL_MACRO_RG_LIST($macro_ref_name) nor \$INTEL_MACRO_RG_LIST(DEFAULT) have been defined for layer $layer. Route Guides will not be created..."
#@         return
#@       }
#@ 
#@       #Check to ensure that both bloats should either be NA or should be a double value.
#@       #----------------------------------------------------------------------------
#@       if {!(($x_bloat eq "NA") && ($y_bloat eq "NA")) && !([string is double $x_bloat] && [string is double $y_bloat])} {
#@         puts "==>ERROR: Bloat values specified incorrectly for $macro_ref_name. Either x_bloat and y_bloat should both be NA (or) a double value. Route Guides will not be created..."
#@         return
#@       }
#@ 
#@ 
#@       #Route Guides will not be created if both x and y bloats equal NA
#@       #-------------------------------------------------------------------
#@       if {($x_bloat eq "NA") && ($y_bloat eq "NA")} {
#@         return
#@       }
#@ 
#@ 
#@       #Route Guides will be created around macros on layers m0-m4 + layers containing macro pins.
#@       #-------------------------------------------------------------------------------------------
#@ 
#@       set macro_name [get_attribute $macro full_name]
#@       set macro_bound [get_attribute $macro boundary]
#@       set rect_box [convert_from_polygon -format rectangle $macro_bound]
#@       set i 0
#@       foreach rect $rect_box {
#@         scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@         set macrobbox_bloat "[expr $b_llx - $x_bloat] [expr $b_lly - $y_bloat] [expr $b_urx + $x_bloat] [expr $b_ury + $y_bloat]"
#@ 
#@         set pin_names [get_pins -all -quiet -filter "layer=~*$layer*" -of_objects $macro ]
#@         if {[sizeof_collection $pin_names] > 0 || [regexp {m[0-5]$} $layer]} {
#@           create_route_guide -no_preroute_layers $layer               -name macroblkg_${macro_name}_${layer}_${i}               -coordinate $macrobbox_bloat
#@           incr i
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ #########################################################################################################
#@ # Procedure   : P_strap_cmd
#@ # Common procedure to create power straps
#@ # step_at: the offset from which the start the first strap
#@ # step: pitch
#@ # pullback: distance to pull the end of strap away from bondary to isolate from neighbor partition
#@ 
#@ proc P_strap_cmd {layer direction net width start_at step pullback} {
#@   global bound_llx bound_lly bound_urx bound_ury
#@   set cmd "create_power_straps -layer $layer -nets $net -width $width                                  -start_at $start_at -step $step                                  -configure step_and_stop                                  -clip_at_top_cell_boundaries                                  -advanced_via_rules                                  -keep_floating_wire_pieces"
#@   if {$direction == "horizontal"} {
#@     set high_ends [expr $bound_urx - $pullback]
#@     set low_ends [expr $bound_llx + $pullback]
#@     set cmd "$cmd -direction horizontal                       -start_high_ends coordinate -start_high_ends_coordinate [expr $bound_urx - $pullback]                       -start_low_ends coordinate -start_low_ends_coordinate [expr $bound_llx + $pullback]                       -stop $bound_ury"
#@   } else {
#@     set high_ends [expr $bound_ury - $pullback]
#@     set low_ends [expr $bound_lly + $pullback]
#@     set cmd "$cmd -direction vertical                       -start_high_ends coordinate -start_high_ends_coordinate $high_ends                       -start_low_ends coordinate -start_low_ends_coordinate $low_ends                       -stop $bound_urx"
#@   }
#@   if {$pullback == 0} {
#@     set cmd "$cmd -extend_low_ends to_boundary_and_generate_pins                       -extend_high_ends to_boundary_and_generate_pins"
#@   }
#@   set cmd [regsub -all {\s+} $cmd " "]; #clean up extra spaces
#@   puts "==>INFORMATION: Running \"$cmd\""
#@   eval $cmd
#@ }
#@ 
#@ #########################################################################################################
#@ # Procedure   : P_check_partition_dimension
#@ # Check if the partition dimension is modular-grid multiple
#@ 
#@ proc P_check_partition_dimension {} {
#@ 
#@   global INTEL_DESIGN_WIDTH INTEL_DESIGN_HEIGHT INTEL_FP_BOUNDARY
#@   global INTEL_FP_INPUT
#@   global INTEL_MD_GRID_X INTEL_MD_GRID_Y
#@ 
#@   if {[info exists INTEL_DESIGN_WIDTH] && $INTEL_DESIGN_WIDTH != "" && [info exists INTEL_DESIGN_HEIGHT] && $INTEL_DESIGN_HEIGHT != ""} {
#@     P_msg_info "Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
#@     if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X) - round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X))]] != 0.0 } {
#@       P_msg_error "Block width is NOT n * $INTEL_MD_GRID_X, please adjust the design width setting INTEL_DESIGN_WIDTH."
#@       P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_X is [expr round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X)]"
#@     }
#@     if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y) - round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@       P_msg_error "Block height is NOT n * $INTEL_MD_GRID_Y, please adjust the design height setting INTEL_DESIGN_HEIGHT."
#@       P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_Y is [expr round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y)]"
#@     }
#@     P_msg_info "Done: Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
#@   } elseif {[info exists INTEL_FP_BOUNDARY] && $INTEL_FP_BOUNDARY != ""} {
#@     P_msg_info "Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
#@     redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $INTEL_FP_BOUNDARY $INTEL_FP_BOUNDARY]}}
#@     if { ! [info exists _bndry] } {
#@       P_msg_error "INTEL_FP_BOUNDARY is not valid.  May require additional set of {} braces"
#@     } elseif { $_bndry == 0 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified is not a valid polygon"
#@     } elseif { [llength $_bndry] == 0 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified has no defined area"
#@     } elseif { [llength $_bndry] != 1 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified is not a single polygon shape"
#@     } else {
#@       set _bndry [lindex $_bndry 0]
#@     }
#@     foreach xy $INTEL_FP_BOUNDARY {
#@       set x [lindex $xy 0]
#@       set y [lindex $xy 1]
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
#@         P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
#@       }
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
#@         P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
#@       }
#@     }
#@     P_msg_info "Done: Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
#@   } elseif { ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "DEF") || ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "FP_TCL") } {
#@     set fp_boundary [get_attribute [get_die_area] boundary]
#@     P_msg_info "Checking if coordinates of the die area are integer multiples of the modular grid."
#@     redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $fp_boundary $fp_boundary]}}
#@     if { ! [info exists _bndry] } {
#@       P_msg_error "The die area is not valid.  May require additional set of {} braces"
#@     } elseif { $_bndry == 0 } {
#@       P_msg_error "The die area specified is not a valid polygon"
#@     } elseif { [llength $_bndry] == 0 } {
#@       P_msg_error "The die area specified has no defined area"
#@     } elseif { [llength $_bndry] != 1 } {
#@       P_msg_error "The die area specified is not a single polygon shape"
#@     } else {
#@       set _bndry [lindex $_bndry 0]
#@     }
#@     foreach xy $fp_boundary {
#@       set x [lindex $xy 0]
#@       set y [lindex $xy 1]
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
#@         P_msg_error "Please adjust the die area."
#@       }
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
#@         P_msg_error "Please adjust the die area."
#@       }
#@     }
#@     P_msg_info "Done: Checking if coordinates of the die area are integer multiples of the modular grid."
#@   } else {
#@     P_msg_error "None of the following is set: INTEL_DESIGN_WIDTH/INTEL_DESIGN_HEIGHT, INTEL_FP_BOUNDARY, INTEL_FP_DEF or INTEL_FP_TCL"
#@   }
#@ }
#@ 
#@ proc P_adv_polygon_size { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon)]) || [info exists inputs(-list)]]
#@ 
#@   # get size argument, see if valid
#@   set size $inputs(size)
#@ 
#@   # allow for separate x,y size
#@   # if only a single value, then x,y default to that value
#@   set xsize [lindex $size 0]
#@   set ysize [lindex $size end]
#@   if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@     error "$func_name: size value \"$size\" is not a float or pair of floats."
#@     unset size xsize ysize
#@   }
#@ 
#@   set no_sizing 0
#@   set single_resize 1
#@   set directional_resize 0
#@   if { $xsize == $ysize } {
#@     set simple_size 1
#@     set size $xsize
#@     if { $xsize == 0 } {
#@       set no_sizing 1
#@     } else {
#@       redirect -variable resize_help {resize_polygon -help}
#@       set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     }
#@   } else {
#@     set simple_size 0
#@     redirect -variable resize_help {resize_polygon -help}
#@     set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     set directional_resize [regexp -- {-size_left} $resize_help]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     error "'${func_name}': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # suppress message MWUI-087 when downsizing removes a polygon
#@   set no_MWUI_087_suppress 0
#@   if { (! $single_resize) && (($xsize < 0) || ($ysize < 0)) } {
#@     redirect -variable suppress_chk_str {print_suppressed_messages}
#@     if { [lsearch -exact [split [regsub -all {[\{\},\s]+} $suppress_chk_str { }]] {MWUI-087}] == -1 } {
#@       set no_MWUI_087_suppress 1
#@       suppress_message {MWUI-087}
#@     }
#@   }
#@ 
#@   # go through sizing scenarios
#@   if { $no_sizing || ([llength $polygon] < 1) } {
#@     # no sizing or no polygon - nothing to do
#@     set final $polygon
#@   } elseif { $simple_size && $single_resize } {
#@     # use simple sizing function
#@     set final {}
#@     foreach shape $polygon {
#@       foreach sized_poly [resize_polygon -size $size $shape] {
#@         # ensure a valid polygon was returned
#@         # - some Synopsys versions return '0' rather than {} if empty
#@         if { [llength $sized_poly] > 3 } {
#@           lappend final $sized_poly
#@         }
#@       }
#@     }
#@   } elseif { $simple_size } {
#@     set final [resize_polygon -size $size $polygon]
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } elseif { $directional_resize } {
#@     if { (($xsize < 0) && ($ysize < 0)) || (($xsize > 0) && ($ysize > 0)) } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize -size_top $ysize -size_bottom $ysize $polygon]
#@     } elseif { $ysize < 0 } {
#@       set pre_final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $xsize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_left $xsize -size_right $xsize $pre_final]
#@       }
#@     } elseif { $xsize < 0 } {
#@       set pre_final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $ysize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_top $ysize -size_bottom $ysize $pre_final]
#@       }
#@     } elseif { $ysize == 0 } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@     } elseif { $xsize == 0 } {
#@       set final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@     } else {
#@       set final $polygon
#@     }
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } else {
#@     # first perform any necessary shrink
#@     if { ($xsize < 0) || ($ysize < 0) } {
#@       # to avoid issues with breaking apart during shrink,
#@       # the shrink is done as an inverse image using a grow
#@       #   expand_bound = (expand BOUND(polygon) by size)
#@       #   shrink_poly = expand_bound NOT
#@       #         (expand (poly_to_rects(expand_bound NOT polygon)) by shrink)
#@       set shrunk_poly {}
#@ 
#@       # expand by 0.1 more than smallest negative value
#@       set ovrsize [expr ($xsize < $ysize) ? (0.1 - $xsize) : (0.1 - $ysize)]
#@       set rect_shrink_factor_x [expr ($xsize<0) ?  abs($xsize) : 0]
#@       set rect_shrink_factor_y [expr ($ysize<0) ?  abs($ysize) : 0]
#@ 
#@       foreach shape $polygon {
#@         # get x extents using a list sort
#@         set x_sort [lsort -index 0 -increasing -real $shape]
#@         set xll [expr [lindex [lindex $x_sort 0] 0] - $ovrsize]
#@         set xur [expr [lindex [lindex $x_sort end] 0] + $ovrsize]
#@ 
#@         # get y extents using a list sort
#@         set y_sort [lsort -index 1 -increasing -real $shape]
#@         set yll [expr [lindex [lindex $y_sort 0] 1] - $ovrsize]
#@         set yur [expr [lindex [lindex $y_sort end] 1] + $ovrsize]
#@ 
#@         set expand_bound [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         set inv_polygon [compute_polygons -boolean not $expand_bound $shape]
#@ 
#@         # create inverse sized polygon
#@         set inv_sized_polygon {}
#@         foreach inv_shape $inv_polygon {
#@           foreach rect [convert_from_polygon -format polygon $inv_shape] {
#@             # get x extents using a list sort
#@             set x_sort [lsort -index 0 -increasing -real $rect]
#@             set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_shrink_factor_x]
#@             set xur [expr [lindex [lindex $x_sort end] 0] + $rect_shrink_factor_x]
#@ 
#@             # get y extents using a list sort
#@             set y_sort [lsort -index 1 -increasing -real $rect]
#@             set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_shrink_factor_y]
#@             set yur [expr [lindex [lindex $y_sort end] 1] + $rect_shrink_factor_y]
#@ 
#@             lappend inv_sized_polygon [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@           }
#@         }
#@ 
#@         # merge inverse sized polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain merge_polygon
#@         redirect /dev/null {
#@           catch {set merge_polygon [compute_polygons -boolean or $inv_sized_polygon [lindex $inv_sized_polygon 0]]}
#@         }
#@         if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set inv_sized_polygon $merge_polygon
#@           unset -nocomplain merge_polygon
#@         } else {
#@           for { set i 0 } { $i < [llength $inv_sized_polygon] } {incr i} {
#@             for { set j [expr $i + 1] } { $j < [llength $inv_sized_polygon] } {incr j} {
#@               set new [compute_polygons -boolean or [lindex $inv_sized_polygon $i] [lindex $inv_sized_polygon $j]]
#@               if { [llength $new] > 1 } {
#@                 continue
#@               }
#@               set inv_sized_polygon [lreplace [lreplace $inv_sized_polygon $i $i [lindex $new 0]] $j $j]
#@               incr i -1
#@               break
#@             }
#@           }
#@         }
#@ 
#@         # re-invert the polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain re_inv_polygon
#@         redirect /dev/null {
#@           catch {set re_inv_polygon [compute_polygons -boolean not [list $expand_bound] $inv_sized_polygon]}
#@         }
#@         if { [info exists re_inv_polygon] && (! [string equal $re_inv_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         } else {
#@           set re_inv_polygon [list $expand_bound]
#@           foreach inv_shape $inv_sized_polygon {
#@             set new_shrink {}
#@             foreach re_shape $re_inv_polygon {
#@               foreach poly_not [compute_polygons -boolean not $re_shape $inv_shape] {
#@                 lappend new_shrink $poly_not
#@               }
#@             }
#@             set re_inv_polygon $new_shrink
#@           }
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         }
#@       }
#@     } else {
#@       set shrunk_poly $polygon
#@     }
#@ 
#@     # then perform any necessary grow
#@     set final {}
#@     if { ($xsize > 0) || ($ysize > 0) } {
#@       # the grow is a directional grow on the rectangles of the polygon
#@       set rect_grow_factor_x [expr ($xsize>0) ?  $xsize : 0]
#@       set rect_grow_factor_y [expr ($ysize>0) ?  $ysize : 0]
#@ 
#@       foreach shape $shrunk_poly {
#@         foreach rect [convert_from_polygon -format polygon $shape] {
#@           # get x extents using a list sort
#@           set x_sort [lsort -index 0 -increasing -real $rect]
#@           set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_grow_factor_x]
#@           set xur [expr [lindex [lindex $x_sort end] 0] + $rect_grow_factor_x]
#@ 
#@           # get y extents using a list sort
#@           set y_sort [lsort -index 1 -increasing -real $rect]
#@           set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_grow_factor_y]
#@           set yur [expr [lindex [lindex $y_sort end] 1] + $rect_grow_factor_y]
#@ 
#@           lappend final [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         }
#@       }
#@     } else {
#@       set final $shrunk_poly
#@     }
#@   }
#@ 
#@   if { $no_MWUI_087_suppress } {
#@     set no_MWUI_087_suppress 0
#@     unsuppress_message {MWUI-087}
#@   }
#@ 
#@   # merge final polygons
#@   if { (! $no_sizing) && $single_resize } {
#@     # first see if compute_polygons works for lists of polygons
#@     unset -nocomplain merge_polygon
#@     redirect /dev/null {
#@       catch {set merge_polygon [compute_polygons -boolean or $final [lindex $final 0]]}
#@     }
#@     if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@       # compute_polygons took the list of polygons
#@       set final $merge_polygon
#@       unset -nocomplain merge_polygon
#@     } else {
#@       # compute_polygons didn't take the list of polygons
#@       for { set i 0 } { $i < [llength $final] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $final] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $final $i] [lindex $final $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set final [lreplace [lreplace $final $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # return result or assign to polygon_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon) $final
#@     return {}
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_adv_polygon_size     -info "grow/shrink polygon"     -define_args {
#@       {polygon "polygon" polygon string required}
#@       {"size" "size {+grow / -shrink} float or list {x y} of float" "" string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ 
#@ 
#@ 
#@ proc P_adv_polygon_check { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set poly_args {}
#@   set poly_cnt 1
#@ 
#@   if { [string equal $option "identical"] } {
#@     if { [info exists inputs(other_polygon)] } {
#@       incr poly_cnt
#@     }
#@   } elseif { [string equal $option "polygon"] } {
#@     if { [info exists inputs(other_polygon)] &&  [string equal -nocase "$inputs(other_polygon)" "-list"]} {
#@       set option "return_expression"
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   # store as list for each polygon { name_or_NULL is_simple_polygon
#@   #                                  is_polygon is_rect_array
#@   #                                  is_compressed_set complex_polygon_list }
#@   #    where name_or_NULL = name of defined polygon set if valid, else {}
#@   #          is_simple_polygon    = 1 if a simple polygon, else 0
#@   #          is_polygon           = 1 if a polygon, else 0
#@   #          is_rect_array        = 1 if paired coordinates for rect, else 0
#@   #          is_compressed_set    = 1 if a compressed polygon set, else 0
#@   #          complex_polygon_list = polygon value as a complex polygon list
#@   set polygon_info {}
#@   for { set i 1 } { $i <= $poly_cnt } { incr i } {
#@     if { $i == 1 } {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(polygon)
#@       set item $inputs(polygon)
#@     } else {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(other_polygon)
#@       set item $inputs(other_polygon)
#@     }
#@     # check if the polygon is defined in a polygon set
#@     if { [info exists $source_polygon] } {
#@       set polygon_set [expr $$source_polygon]
#@       lappend polygon_info [list $item 0 1 0 0 $polygon_set]
#@       continue
#@     }
#@ 
#@     # check to see if the cell is either a simple/complex polygon or rectArray
#@     #    or a compressed polygon set
#@ 
#@     # First ensure that coordinates if paired are at consistent level
#@     # - first ensure that a double coordinate value is in the expected levels
#@     # - max levels to first double = 3
#@     # -    complex_polygon = { simple_polygon_1 ... simple_polygon_n }
#@     # -    simple_polygon  = { list_of_coordinates }
#@     # -    coordinate      = { x y }
#@     if { ! [string is double -strict [lindex [lindex [lindex $item 0] 0] 0]] } {
#@       # may be that this is an empty list
#@       if { [llength $item] == 0 } {
#@         lappend polygon_info [list {} 1 1 1 1 {}]
#@       } else {
#@         lappend polygon_info [list {} 0 0 0 0 {}]
#@       }
#@       continue
#@     }
#@ 
#@     # while the length of list is one, strip the nesting level
#@     while { [llength $item] == 1 } {
#@       set item [lindex $item 0]
#@     }
#@ 
#@     # - find up one level from the first double coordinate x or y value
#@     # - ensure that the level is always consistent
#@     set paired 1
#@     if { [string is double -strict [lindex $item 0]] } {
#@       # only a single level - this can only be a rectArray or compressedSet
#@       set is_simple_polygon 0
#@       set is_rectArray 1
#@       set is_compressedSet 1
#@       set is_polygon 0
#@       # all items can only be double floats and must be paired set of coords
#@       # this means the length must be a multiple of 4
#@       if { ([llength $item] % 4) == 0 } {
#@         # run a quick check to see if all numbers are double
#@         if { [catch { lsort -real $item } catch_result] != 0 } {
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         set paired 0
#@       }
#@     } else {
#@       if { [string is double -strict [lindex [lindex $item 0] 0]] } {
#@         # this can only be a list of coordinate pairs
#@         # which can be either a compressedSet, rectArray, or simple polygon
#@         set is_simple_polygon 1
#@         set is_compressedSet 1
#@         set is_polygon 1
#@         # for rectArray, must have an even number of points
#@         set is_rectArray [expr ([llength $item] % 2) == 0]
#@ 
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         if { ([lsearch -glob $item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         } elseif { [llength $item] > 4 } {
#@           # for this one case see if same start+end and common x or y
#@           # in this case then an empty set (must be at least 5 pairs)
#@           foreach {x1 y1} [lindex $item 0] { break }
#@           foreach {x2 y2} [lindex $item end] { break }
#@           if { ($x1 == $x2) && ($y1 == $y2) } {
#@             if { [llength [lsort -real -unique -index 0 $item]] eq 1 } {
#@               # fixed x, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             } elseif { [llength [lsort -real -unique -index 1 $item]] eq 1 } {
#@               # fixed y, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             }
#@           }
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         # with the levels involved this can only be a complex polygon
#@         set is_simple_polygon 0
#@         set is_compressedSet 0
#@         set is_polygon 1
#@         set is_rectArray 0
#@         # check that all coordinates are paired sets of real/double
#@         # discard trivial shapes of <3 coordinates
#@         set polygon {}
#@         foreach shape $item {
#@           if { [llength $shape] < 3 } {
#@             # ignore trivial shapes
#@             continue
#@           }
#@           lappend polygon $shape
#@         }
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of joined item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         set joined_item [join $item]
#@         if { ([lsearch -glob $joined_item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $joined_item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $joined_item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         unset -nocomplain joined_item
#@       }
#@ 
#@     }
#@     if { ! $paired } {
#@       # bad pairing of coordinates found, this is a bad polygon
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@       continue
#@     }
#@ 
#@ 
#@     # step through the actual shapes and check to see if a valid polygon
#@     set rectArray {}
#@     if { $is_rectArray } {
#@       foreach {xl yl xu yu} [join [join [join $polygon]]] {
#@         if { ($xl<$xu) && ($yl<$yu) } {
#@           lappend rectArray [list [list $xl $yl] [list $xl $yu] [list $xu $yu] [list $xu $yl] [list $xl $yl]]
#@         } else {
#@           set is_rectArray 0
#@           break
#@         }
#@       }
#@     }
#@ 
#@     if { $is_compressedSet } {
#@       set compressedSet {}
#@       set partialSet {}
#@       # can only be a length of 1
#@       set joined_polygon [join [join [join $polygon]]]
#@       set shifted_polygon [join [list [lrange $joined_polygon 2 end] 0 0]]
#@       unset -nocomplain x0 y0
#@       foreach {x1 y1} $joined_polygon {x2 y2} $shifted_polygon {
#@         lappend partialSet [list $x1 $y1]
#@         if { [info exists x0] } {
#@           if { ($x0==$x1) && ($y0==$y1) } {
#@             # shape valid if both x & y have more than one value (there is size to the shape)
#@             if { ([llength [lsort -unique -real -index 0 $partialSet]] > 1) && ([llength [lsort -unique -real -index 1 $partialSet]] > 1) } {
#@               lappend compressedSet $partialSet
#@             }
#@             set partialSet {}
#@             unset -nocomplain x0 y0
#@             continue
#@           }
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         } else {
#@           if { ($x1==$x2) && ($y1==$y2) } {
#@             continue
#@           }
#@           if { ($x1==$x2) || ($y1==$y2) } {
#@             set x0 $x1
#@             set y0 $y1
#@           } else {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@       }
#@       if { [info exists x0] } {
#@         # didn't complete the final polygon shape
#@         set is_simple_polygon 0
#@         set is_polygon 0
#@         set is_compressedSet 0
#@       }
#@     } elseif { $is_polygon } {
#@       set new_polygon {}
#@       foreach shape $polygon {
#@         # check that first/last coordinate match
#@         foreach {x0 y0} [join [lindex $shape 0]] { break }
#@         foreach {xend yend} [join [lindex $shape end]] { break }
#@         if { ($x0!= $xend) || ($y0 != $yend) } {
#@           set is_simple_polygon 0
#@           set is_polygon 0
#@           break
#@         }
#@         set joined_shape [join [join $shape]]
#@         set joined_shape1 [lrange $joined_shape 0 end-2]
#@         set joined_shape2 [lrange $joined_shape 2 end]
#@         foreach {x1 y1} $joined_shape1 {x2 y2} $joined_shape2 {
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@         if { ! $is_polygon } {
#@           break
#@         }
#@         # shape is valid if both x & y have more than one value (there is size to the shape)
#@         if { ([llength [lsort -unique -real -index 0 $shape]] > 1) && ([llength [lsort -unique -real -index 1 $shape]] > 1) } {
#@           lappend new_polygon $shape
#@         }
#@       }
#@       set polygon $new_polygon
#@     }
#@ 
#@     if { $is_rectArray } {
#@       lappend polygon_info [list {} 0 0 1 0 $rectArray]
#@     } elseif { $is_polygon && (! $is_compressedSet) } {
#@       lappend polygon_info [list {} $is_simple_polygon 1 0 0 $polygon]
#@     } elseif { $is_compressedSet } {
#@       set is_simple_polygon [expr [llength $compressedSet] < 2]
#@       lappend polygon_info [list {} $is_simple_polygon $is_simple_polygon 0 [expr ! $is_simple_polygon] $compressedSet]
#@     } else {
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@     }
#@   }
#@ 
#@   set is_polygon [expr [lindex [lindex $polygon_info 0] 2] ||                       [lindex [lindex $polygon_info 0] 3] ||                       [lindex [lindex $polygon_info 0] 4] ||                       ([llength [lindex [lindex $polygon_info 0] 0]] > 0)]
#@   switch -exact -- $option {
#@     simple      {
#@       set is_simple           [expr [lindex [lindex $polygon_info 0] 1]  && ([llength [lindex                                                                        [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_simple
#@     }
#@     complex     {
#@       set is_complex           [expr (! [lindex [lindex $polygon_info 0] 1]) && ([llength [lindex                                                                           [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_complex
#@     }
#@     defined_set {
#@       return [expr [llength [lindex [lindex $polygon_info 0] 0]] > 0]
#@     }
#@     rectArray   {
#@       return [expr [lindex [lindex $polygon_info 0] 3] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     compressed  {
#@       return [expr [lindex [lindex $polygon_info 0] 4] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     polygon     {
#@       return $is_polygon
#@     }
#@     default     {
#@       if { ! $is_polygon } {
#@         error "'${func_name} $option': polygon \"$inputs(polygon)\" is not a valid polygon."
#@         return
#@       }
#@       set is_polygon [expr                           [lindex [lindex $polygon_info end] 2] || [lindex [lindex $polygon_info end] 3] ||                           [lindex [lindex $polygon_info end] 4] || ([llength [lindex [lindex $polygon_info end] 0]] > 0)]
#@       if { (! $is_polygon) && [string equal $option "identical"] && ([llength $polygon_info] > 1) } {
#@         error "'${func_name} $option': other_polygon \"$inputs(other_polygon)\" is not a valid polygon."
#@         return
#@       }
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (if so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_help]
#@ 
#@   # simplify polygon structure
#@   set check_empty [string equal $option "empty"]
#@   if { [llength [lindex [lindex $polygon_info 0] 0]] == 0 } {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@ 
#@     # merge polygon
#@     # (see if compute_polygons works for lists of polygons - avail in icc)
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $polygon [lindex $polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set polygon {}
#@       } else {
#@         set polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $polygon $i] [lindex $polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set polygon [lreplace [lreplace $polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@   }
#@ 
#@   if { $check_empty } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $polygon] < 1]
#@   }
#@ 
#@   if { [string equal $option "return_expression"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $polygon
#@   }
#@ 
#@ 
#@   # determine if the polygon is now only a single rectangle
#@   if { [string equal $option "rectangle"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr ([llength $polygon]==1) && ([llength [lindex $polygon 0]]==5)]
#@   }
#@ 
#@   # ONLY CHECK remaining is "identical"
#@ 
#@   # simplify other_polygon structure for performing "identical" check
#@   if { [llength [lindex [lindex $polygon_info end] 0]] == 0 } {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@ 
#@     # merge other_polygon
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $other_polygon [lindex $other_polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set other_polygon {}
#@       } else {
#@         set other_polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $other_polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $other_polygon $i] [lindex $other_polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set other_polygon [lreplace [lreplace $other_polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@   }
#@ 
#@   # simple check is if one empty, then they both must be empty
#@   if { ([llength $polygon] == 0) && ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 1
#@   } elseif { ([llength $polygon] == 0) || ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 0
#@   }
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   if { ! $simple_polygons } {
#@     # compute_polygons takes a list of polygons
#@     unset -nocomplain xor_polygon
#@     redirect /dev/null {
#@       catch {set xor_polygon [compute_polygons -boolean xor $polygon $other_polygon]}
#@     }
#@     if { $xor_polygon == "0" } {
#@       set xor_polygon {}
#@     }
#@ 
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $xor_polygon] == 0]
#@   }
#@ 
#@   # otherwise to be identical,
#@   # each piece of polygon must have a corresponding piece of other_polygon
#@   foreach shape $polygon {
#@     set poly_and {}
#@     set poly_xor $polygon
#@     for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@       set other_shape [lindex $other_polygon $i]
#@       set poly_and [compute_polygons -boolean and $shape $other_shape]
#@       if { [llength $poly_and] != 0 } {
#@         set poly_xor [compute_polygons -boolean xor $shape $other_shape]
#@         break
#@       }
#@     }
#@     if { [llength $poly_xor] != 0 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return 0
#@     }
#@     set other_polygon [lreplace $other_polygon $i $i]
#@   }
#@ 
#@   # polygon is identical if no remaining portions of other_polygon to match
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return [expr [llength $other_polygon] == 0]
#@ 
#@ }
#@ 
#@ define_proc_attributes P_adv_polygon_check     -info "check condition 'option' on polygon"     -define_args {
#@       {option "check option" option one_of_string { required value_help {values { simple complex defined_set rectArray compressed polygon empty rectangle identical }}}}
#@       {polygon "polygon" polygon string required}
#@       {other_polygon "second polygon -> only used for identical check" other_polygon string optional}}
#@ #}}}
#@ 
#@ 
#@ 
#@ proc P_adv_polygon_logic { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set operation $inputs(operation)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set copy_set   [string equal $operation "copy"]
#@   set or_set     [string equal $operation "or"]
#@   set and_set    [string equal $operation "and"]
#@   set not_set    [string equal $operation "not"]
#@   set xor_set    [string equal $operation "xor"]
#@   set select_set [string equal $operation "select"]
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon_a)])]
#@   if { $copy_set && $return_expression } {
#@     error "'$func_name copy': polygon \"$inputs(polygon_a)\" is not a defined_set."
#@   } else {
#@     set return_expression [expr $return_expression || [info exists inputs(-list)]]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_a) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_a)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_a)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_a)"
#@     }
#@     error "'${func_name} $operation': polygon_a \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_b) -list} other_polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_b)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_b)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_b)"
#@     }
#@     error "'${func_name} $operation': polygon_b \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # return if copy
#@   if { $copy_set } {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $other_polygon
#@     return {}
#@   }
#@ 
#@   # do simple cases where either polygon is empty
#@   unset -nocomplain final_polygon
#@   if { [llength $polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon {}
#@     } elseif { $xor_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   } elseif { [llength $other_polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon $polygon
#@     } elseif { $xor_set } {
#@       set final_polygon $polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   }
#@   if { [info exists final_polygon] } {
#@     if { $return_expression } {
#@       return $final_polygon
#@     } else {
#@       set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@       return {}
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_polygons_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_polygons_help]
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   # can do all operations except select which requires 2 steps
#@   unset -nocomplain final_polygon
#@   if { $select_set } { set op "and" } else { set op $operation }
#@   unset -nocomplain or_polygon
#@ 
#@   if { ! $simple_polygons } {
#@     redirect /dev/null {
#@       catch {set final_polygon [compute_polygons -boolean $op $polygon $other_polygon]}
#@     }
#@     if { (! [info exists final_polygon]) || [string equal $final_polygon "0"] } {
#@       # compute_polygons didn't take the list of polygons
#@       set final_polygon {}
#@     } elseif { $select_set } {
#@       if { [llength $final_polygon] < [llength $other_polygon] } {
#@         set other_polygon $final_polygon
#@       }
#@       unset -nocomplain final_polygon
#@     }
#@   }
#@ 
#@   # perform OR operation if needed ("or" & "xor")
#@   set or_polygon {}
#@   if { [info exists final_polygon] } {
#@     set or_polygon $final_polygon
#@   } elseif { $or_set || $xor_set } {
#@     set or_polygon [concat $polygon $other_polygon]
#@     # merge or_polygon
#@     for { set i 0 } { $i < [llength $or_polygon] } {incr i} {
#@       for { set j [expr $i + 1] } { $j < [llength $or_polygon] } {incr j} {
#@         set new [compute_polygons -boolean or [lindex $or_polygon $i] [lindex $or_polygon $j]]
#@         if { [llength $new] > 1 } {
#@           continue
#@         }
#@         set or_polygon [lreplace [lreplace $or_polygon $i $i [lindex $new 0]] $j $j]
#@         incr i -1
#@         break
#@       }
#@     }
#@   }
#@ 
#@   # perform AND operation if needed ("and" "not" "xor" "select")
#@   set and_polygon {}
#@   set select_polygon {}
#@   if { [info exists final_polygon] } {
#@     set and_polygon $final_polygon
#@   } elseif { $select_set && (! $simple_polygons) } {
#@     if { [llength $other_polygon] != 0 } {
#@       # evaluating select in subsets of from 20-50 tend to give best runtimes
#@       set incr_value 30
#@       for { set i 0 } { $i < [llength $polygon] } { incr i $incr_value } {
#@         set sub_range [lrange $polygon $i [expr $i + $incr_value]]
#@         set sub_range_and [compute_polygons -boolean and $sub_range $other_polygon]
#@         if { ($sub_range_and == "0") || ([llength $sub_range_and] == 0) } {
#@           # no intersection, skip this subset of polygons
#@           continue
#@         } elseif { [llength $sub_range] == 1 } {
#@           lappend select_polygon [lindex $sub_range 0]
#@           continue
#@         } elseif { [llength $sub_range_and] > [llength $other_polygon] } {
#@           # try to minimize the number of shapes being worked with
#@           set sub_range_and $other_polygon
#@         }
#@         foreach shape $sub_range {
#@           set shape_and [compute_polygons -boolean and $shape $sub_range_and]
#@           if { ($shape_and != "0") && ([llength $shape_and] != 0) } {
#@             lappend select_polygon $shape
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $and_set || $not_set || $xor_set || $select_set } {
#@     foreach shape $polygon {
#@       set poly_and {}
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         set other_shape [lindex $other_polygon $i]
#@         set poly_and [compute_polygons -boolean and $shape $other_shape]
#@         if { [llength $poly_and] != 0 } {
#@           if { $select_set } {
#@             lappend select_polygon $shape
#@             break
#@           } else {
#@             foreach and_item $poly_and {
#@               lappend and_polygon $and_item
#@             }
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $or_set } {
#@     set and_polygon $or_polygon
#@   }
#@ 
#@   # perform NOT operation if needed ("not" "xor")
#@   if { (! [info exists final_polygon]) && ($not_set || $xor_set) } {
#@     if { $not_set } {
#@       set final_polygon $polygon
#@       set not_polygon   $other_polygon
#@     } else {
#@       set final_polygon $or_polygon
#@       set not_polygon   $and_polygon
#@     }
#@     foreach other_shape $not_polygon {
#@       set new_final_polygon {}
#@       foreach shape $final_polygon {
#@         foreach not_poly [compute_polygons -boolean not $shape $other_shape] {
#@           lappend new_final_polygon $not_poly
#@         }
#@       }
#@       set final_polygon $new_final_polygon
#@     }
#@   } elseif { $or_set } {
#@     set final_polygon $or_polygon
#@   } elseif { $select_set } {
#@     set final_polygon $select_polygon
#@   } elseif { $and_set } {
#@     set final_polygon $and_polygon
#@   } elseif { ! [info exists final_polygon] } {
#@     set final_polygon {}
#@   }
#@ 
#@   # return polygon or set value in defined_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final_polygon
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@     return {}
#@   }
#@ 
#@ }
#@ 
#@ 
#@ define_proc_attributes P_adv_polygon_logic     -info "perform logic 'operation' between polygons"     -define_args {
#@       {operation "logic operation" operation one_of_string { required value_help {values { copy or and not xor select }}}}
#@       {polygon_a "polygon_a" polygon_a string required}
#@       {polygon_b "polygon_b" polygon_b string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ # Proc: P_create_diffcheck_grid
#@ # Description: Draws diffcheck grid over design that will show up as DRC violations
#@ # if the diffusion layer is misaligned in any areas. The diffcheck is removed over macros/DICs
#@ proc P_create_diffcheck_grid {layer start width step stop {hard_macro_refs ""}} {
#@ 
#@   set _bndry [get_attribute -quiet [get_die_area] boundary]
#@   set layer $layer
#@   remove_user_shape  [get_user_shapes -quiet -filter layer_name==$layer]
#@ 
#@   set rect_box [convert_from_polygon  -format rectangle $_bndry]
#@   foreach rect $rect_box {
#@     scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@     set y [expr $start + $b_lly]
#@     while { $y < [expr $b_ury - $stop]} {
#@       create_user_shape -layer $layer  -datatype 24 -bbox [list $b_llx $y $b_urx [expr $y + $width]]
#@       set y [expr $y + $step + $width]
#@     }
#@   }
#@ 
#@   # Remove user shapes over HIP/DIC
#@   set hard_macro_cells ""
#@   if {$hard_macro_refs == "" } {
#@     set hard_macro_cells  [all_macro_cells]
#@   } else {
#@     foreach cell $hard_macro_refs {
#@       set hard_macro_cells [add_to_collection $hard_macro_cells [get_cells -quiet -hierarchical -all -filter ref_name==$cell]]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $hard_macro_cells]>0} {
#@     cut_objects  -by $hard_macro_cells [get_user_shapes -quiet -filter layer_name==$layer]
#@   }
#@ 
#@ }
#@ define_proc_attributes P_create_diffcheck_grid     -info "Creates diffcheck grid over design"     -define_args {                        {layer "diffcheck grid layer name" layer string required}                        {start "Offset to start grid relative to boundary" start string required}                        {width "Path to overlay cell gds file" width string required}                        {step "Pitch between shapes" step string required}                        {stop "Offset to stop grid relative to boundary" stop string required}                        {hard_macro_refs "Macro reference names. If blank, then grid removed over all_macro_cells" hard_macro_refs list required}                      }
#@ 
#@ # Proc: P_create_polycheck_grid
#@ # Description: Draws polycheck grid over design that will show up as DRC violations
#@ # if the poly layer is misaligned in any areas. The polycheck is removed over macros/DICs
#@ 
#@ proc P_create_polycheck_grid { layer start width step stop {hard_macro_refs ""}} {
#@ 
#@   set _bndry [get_attribute -quiet [get_die_area] boundary]
#@   set layer $layer
#@   remove_user_shape  [get_user_shapes -quiet -filter layer_name==$layer]
#@ 
#@   set rect_box [convert_from_polygon  -format rectangle $_bndry]
#@   foreach rect $rect_box {
#@     scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@     set x [expr $start + $b_llx]
#@     while { $x < [expr $b_urx - $stop]} {
#@       create_user_shape -layer $layer -bbox [list $x $b_lly [expr $x + $width] $b_ury]
#@       set x [expr $x + $step + $width]
#@     }
#@   }
#@ 
#@   # Remove user shapes over HIP/DIC
#@   set hard_macro_cells ""
#@   if {$hard_macro_refs == "" } {
#@     set hard_macro_cells  [all_macro_cells]
#@   } else {
#@     foreach cell $hard_macro_refs {
#@       set hard_macro_cells [add_to_collection $hard_macro_cells [get_cells -quiet -hierarchical -all -filter ref_name==$cell]]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $hard_macro_cells]>0} {
#@     cut_objects -by $hard_macro_cells [get_user_shapes -quiet -filter layer_name==$layer]
#@   }
#@ 
#@ }
#@ define_proc_attributes P_create_polycheck_grid     -info "Creates polycheck grid over design"     -define_args {                        {layer "Polycheck layer name" layer string required}                        {start "Offset to start grid relative to boundary" start string required}                        {width "Path to overlay cell gds file" width string required}                        {step "Pitch between shapes" step string required}                        {stop "Offset to stop grid relative to boundary" stop string required}                        {hard_macro_refs "Macro reference names. If blank, then grid removed over all_macro_cells" hard_macro_refs list required}                      }
#@ 
#@ proc P_placement_blockage_move_or_unmove { {mode report_usage} } {
#@   ###  move placement blockage out of bounds Or back  ###
#@   if {$mode=="report_usage"} {
#@     puts "  usage1 ->  set blockage_bbox_pairs \[P_placement_blockage_move_or_unmove move\]; ## to move blockage out of bounds ##";
#@     puts "  usage2 ->  P_placement_blockage_move_or_unmove \$blockage_bbox_pairs;           ## to restore blockage ##";
#@     return;
#@   }
#@   ###  mode=move - moves blockage and returns blockage_bbox_pairs variable | mode=$blockage_bbox_pairs - restores blockage  ###
#@   set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
#@   if {"$mode"=="move"} {
#@     set boundary [get_attribute -quiet [get_core_area] boundary]
#@     set boundary_llx [lindex [lindex [lsort -index 0 -real -increasing $boundary] 0] 0]
#@     set boundary_lly [lindex [lindex [lsort -index 1 -real -increasing $boundary] 0] 1]
#@     set hard_pb_llx [expr $boundary_llx - .01]; set hard_pb_lly [expr $boundary_lly - .01]
#@     set hard_placement_box [list [list $hard_pb_llx  $hard_pb_lly]  [list $boundary_llx $boundary_lly]]
#@     set blockage_bbox_pairs {}
#@     foreach_in_collection blkg_obj [remove_from_collection [get_placement_blockages -quiet] [get_placement_blockages -quiet halo_adjacent_placement_blk_*]] {
#@       lappend blockage_bbox_pairs  [list $blkg_obj [get_attribute -quiet $blkg_obj bbox]]
#@       set_attribute -quiet $blkg_obj bbox $hard_placement_box
#@     }
#@     return $blockage_bbox_pairs;
#@   } else {
#@     foreach blkg_pair $mode {
#@       foreach {blkg_obj blkg_bbox} $blkg_pair { break }
#@       set_attribute -quiet $blkg_obj bbox $blkg_bbox
#@     }
#@   }
#@   set_object_snap_type -enabled $oldSnapState; set flag 1;
#@ }
#@ 
#@ ##########################################################################
#@ # Procedure   : P_insert_pre_place_cells_blockage
#@ #
#@ # Description : To insert the placement blockage at the intended pre-place cells
#@ #               locations if option -as_blockage useage.
#@ #               Otherwise, To insert the placement blockage everywhere except
#@ #               pre-place cells locations
#@ #
#@ # Inputs      :
#@ #
#@ # Returns     :
#@ #
#@ # Note        :
#@ #
#@ ##########################################################################
#@ proc P_insert_pre_place_cells_blockage {args} {
#@ 
#@   global INTEL_STDCELL_BONUS_GATEARRAY_TILE INTEL_STDCELL_TILE INTEL_TAP_CELL
#@   parse_proc_arguments -args $args flag
#@   set x_start $flag(-x_start)
#@   set y_start $flag(-y_start)
#@   set x_increment $flag(-x_increment)
#@   set y_increment $flag(-y_increment)
#@   set width_prplace_cell $flag(-w_preplace_cell)
#@   set height_prplace_cell $flag(-h_preplace_cell)
#@ 
#@   if { [info exists flag(-x_trim)] } {
#@     set x_trim $flag(-x_trim)
#@   } else {
#@     set x_trim 0
#@   }
#@   if { [info exists flag(-y_trim)] } {
#@     set y_trim $flag(-y_trim)
#@   } else {
#@     set y_trim 0
#@   }
#@   if { [info exists flag(-as_blockage)] } {
#@     set as_blockage 1
#@   } else {
#@     set as_blockage 0
#@   }
#@   if { [info exists flag(-ignore_hard_blockage)] } {
#@     set ignore_hard_blockage 1
#@   } else {
#@     set ignore_hard_blockage 0
#@   }
#@   if { [info exists flag(-no_flip)] } {
#@     set no_flip 1
#@   } else {
#@     set no_flip 0
#@   }
#@ 
#@   if { [info exists flag(-stagger)] } {
#@     set stagger 1
#@   } else {
#@     set stagger 0
#@   }
#@ 
#@   ### Derive tile widths
#@   set sample_site [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_TILE"]] 0]
#@   set stdcell_tile_height [expr [get_attribute [get_site_row $sample_site] bbox_ury] - [get_attribute [get_site_row $sample_site] bbox_lly]]
#@   set stdcell_tile_width [get_attribute [get_site_rows $sample_site] site_space]
#@   if { [info exists INTEL_STDCELL_BONUS_GATEARRAY_TILE] } {
#@     set stdcell_bonus_tile_width [get_attribute [get_site_rows [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_BONUS_GATEARRAY_TILE"]] 0]] site_space]
#@   }
#@ 
#@   if { [info exists flag(-tile)] } {
#@     if { [regexp "bonuscore" $flag(-tile) ] } {
#@       set tile_width $stdcell_bonus_tile_width
#@     } else {
#@       set tile_width $stdcell_tile_width
#@     }
#@   } else {
#@     set tile_width $stdcell_tile_width
#@   }
#@ 
#@   if { [info exists flag(-ignore_tap_cell)] } {
#@     set ignore_tap_cell 1
#@   } else {
#@     set ignore_tap_cell 0
#@   }
#@ 
#@   ###Find the first ROW rotation
#@   scan [get_attribute [get_core_areas] bbox] "{%f %f} {%f %f}" core_llx core_lly core_urx core_ury
#@   set my_site_rows [get_site_rows -quiet -filter "bbox_lly == $core_lly && bbox_ury == [expr $core_lly + $stdcell_tile_height]       && site_type ==  $INTEL_STDCELL_TILE"]
#@   if {$my_site_rows ne ""} {
#@     set first_cell_orientation [lindex [get_attribute [get_site_rows [lindex $my_site_rows 0]] orientation] 0]
#@   } else {
#@     set first_cell_orientation "N"
#@   }
#@ 
#@   set step_y [expr (floor ( [expr $y_increment / ( 2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@   set half_step_y  [expr $step_y / 2.0]
#@   if { $no_flip == 1 } {
#@     # Need to find the VSS row
#@     if { $first_cell_orientation == "N"} {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@     }  else {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
#@     }
#@   } else {
#@     if { $first_cell_orientation == "N"} {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
#@     }  else {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@     }
#@   }
#@ 
#@   set step_x [expr (floor ( [expr $x_increment / $tile_width] )) *  $tile_width]
#@   set half_step_x  [expr $step_x / 2.0]
#@   set xstart [expr (floor ( [expr ($x_start) / $tile_width] )) *  $tile_width + $core_llx]
#@ 
#@   remove_placement_blockage _tmp_pre_place_placement_blk_*
#@   set_object_snap_type -enabled 0
#@ 
#@   unset -nocomplain boundary
#@   set boundary [get_attribute -quiet [get_die_area] boundary]
#@   # to cover paranoid case of extra braces, remove a set if only 1 point
#@   if { [llength $boundary] == 1 } { set boundary [lindex $boundary 0] }
#@ 
#@   unset -nocomplain all_locations_newpolygon
#@   unset -nocomplain all_blk_newpolygon
#@   set all_locations_newpolygon $boundary
#@ 
#@   ### Find the original placement blockage
#@   set original_placement_blks [get_placement_blockages -type hard ]
#@ 
#@   ### Find the Voltage area rings
#@   unset -nocomplain _va_boundary_polys
#@   unset -nocomplain _tmp_use_polys _tmp_use_polys2
#@   set _va_boundary_polys ""
#@   foreach_in_collection _va [get_voltage_areas] {
#@     set _tmp_use_polys [get_attribute [get_voltage_areas $_va] points]
#@     set _va_boundary_polys [P_adv_polygon_logic or $_va_boundary_polys                                 [P_adv_polygon_logic not $_tmp_use_polys [P_adv_polygon_size $_tmp_use_polys "-$stdcell_tile_height -$stdcell_tile_height"]]]
#@   }
#@   set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_va_boundary_polys]
#@ 
#@   ### Find all is_fixed cells
#@   set _tmp_use_polys {}
#@   if { $ignore_tap_cell ==1 } {
#@     foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true && ref_name!=$INTEL_TAP_CELL"]                                  [all_macro_cells]] {
#@                                    lappend _tmp_use_polys [get_attribute $c boundary]
#@                                  }
#@   } else {
#@     foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true"]                                  [all_macro_cells]] {
#@                                    lappend _tmp_use_polys [get_attribute $c boundary]
#@                                  }
#@   }
#@   ### To prevent pre_place cells too close to EBB (might cause density violation)
#@   set _tmp_use_polys2 {}
#@   foreach_in_collection c [all_macro_cells] {
#@     foreach poly_shape [P_adv_polygon_size [get_attribute $c boundary] "[expr 3 * $stdcell_tile_width] 0.0"] {
#@       lappend _tmp_use_polys2 $poly_shape
#@     }
#@   }
#@   if { ![P_adv_polygon_check empty $_tmp_use_polys2]} {
#@     set _tmp_use_polys [P_adv_polygon_logic or $_tmp_use_polys $_tmp_use_polys2]
#@   }
#@   set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]
#@ 
#@   ### Find all existing placement blockages
#@   set _tmp_use_polys {}
#@   if { $ignore_hard_blockage != 1 } {
#@     foreach_in_collection blk $original_placement_blks {
#@       if { [llength [convert_to_polygon [get_placement_blockage $blk]]] >= 5 } {
#@         lappend _tmp_use_polys [convert_to_polygon [get_placement_blockage $blk]]
#@       } elseif { [llength [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]] >= 5 } {
#@         lappend _tmp_use_polys [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]
#@       }
#@     }
#@     set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]
#@   }
#@ 
#@   set switch 0
#@   set i 0
#@   set _tmp_use_polys {}
#@   unset -nocomplain _tmp_area_array
#@   for {set y $ystart } {$y < $core_ury } {set y [expr $y+$step_y]} {
#@     if { $stagger == 1 } {
#@       if { $switch == 1 } {
#@         set newxstart [expr $xstart + $half_step_x]
#@         set switch 0
#@       } else {
#@         set newxstart $xstart
#@         set switch 1
#@       }
#@     } else {
#@       set newxstart $xstart
#@     }
#@ 
#@     set core_urx_2 [expr $core_urx - $x_trim]
#@     for {set x $newxstart } {$x < $core_urx_2 } {set x [expr $x+$step_x]} {
#@       set x2 [expr $x + $half_step_x]
#@       if { $half_step_y < $height_prplace_cell } {
#@         set y2 [expr $y + $height_prplace_cell]
#@       } else {
#@         set y2 [expr $y + $half_step_y]
#@       }
#@       if {$y2 > [expr $core_ury - $y_trim] } { set y2  $core_ury }
#@       lappend _tmp_use_polys "{$x $y} {$x $y2} {$x2 $y2} {$x2 $y} {$x $y}"
#@       set _tmp_area_array($i) "{{$x $y} {$x2 $y2}}"
#@       incr i
#@     }
#@   }
#@   set all_blk_newpolygon [P_adv_polygon_logic and $all_locations_newpolygon $_tmp_use_polys]
#@ 
#@   unset -nocomplain _tmp_use_polys _tmp_use_polys2 my_pgon all_blk_newpolygon_final
#@   set all_blk_newpolygon_final {}
#@   foreach _tmp_use_polys $all_blk_newpolygon  {
#@     unset -nocomplain newbox
#@     scan [P_adv_polygon_get bbox $_tmp_use_polys] "{%f %f} {%f %f}" _llx _lly _urx _ury
#@     for {set y $_lly } {$y < $_ury } {set y [expr $y+$stdcell_tile_height]} {
#@       if { $no_flip == 1 } {
#@         if { $first_cell_orientation == "N"} {
#@           set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
#@         }  else {
#@           set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
#@         }
#@       } else {
#@         if { $first_cell_orientation == "N"} {
#@           set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
#@         }  else {
#@           set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
#@         }
#@       }
#@       for {set x $_llx } {$x < $_urx } {set x [expr $x+$tile_width]} {
#@         set snap_x [expr ( ceil ( $x / $tile_width)) * $tile_width + $core_llx]
#@         set x2 [expr $snap_x + $width_prplace_cell]
#@         set y2 [expr $snap_y + $height_prplace_cell]
#@         set _tmp_use_polys2 "{$snap_x $snap_y} {$snap_x $y2} {$x2 $y2} {$x2 $snap_y} {$snap_x $snap_y}"
#@         set my_pgon [P_adv_polygon_logic and $_tmp_use_polys $_tmp_use_polys2]
#@         set area_diff [expr [P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)]
#@         if { [expr (abs ([P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)))] < 0.001 } {
#@           set all_blk_newpolygon_final [P_adv_polygon_logic or $all_blk_newpolygon_final $my_pgon]
#@           set x $_urx
#@           set y $_ury
#@         }
#@       }
#@     }
#@   }
#@ 
#@   remove_placement_blockage _tmp_pre_place_placement_blk_*
#@   set count 0
#@   if { $as_blockage != 1 } {
#@     set all_blk_newpolygon_final [P_adv_polygon_logic not $boundary $all_blk_newpolygon_final]
#@     foreach my_pgon $all_blk_newpolygon_final {
#@       foreach box [convert_from_polygon -format rectangle $my_pgon] {
#@         create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
#@         incr count
#@       }
#@     }
#@   } else {
#@     foreach my_pgon $all_blk_newpolygon_final {
#@       foreach box [convert_from_polygon -format rectangle $my_pgon] {
#@         create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
#@         incr count
#@       }
#@     }
#@   }
#@ 
#@   set rm_placement_blk_list ""
#@   foreach i [array names _tmp_area_array] {
#@     if {([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet]] > 1) ||              ([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet]]  > 1) } {
#@       set _tmp_placement_blk_list [lsort -unique [get_object_name [add_to_collection                                                                        [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet ]                                                                        [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet ]]]]
#@       set _tmp_placement_blk_list_bb [lsort -command P_compare [get_attribute  [get_placement_blockages $_tmp_placement_blk_list -quiet ] bbox]]
#@       foreach box [lrange $_tmp_placement_blk_list_bb 1 [expr [llength $_tmp_placement_blk_list] - 1 ]] {
#@         lappend rm_placement_blk_list [get_object_name [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $box]]
#@       }
#@     }
#@   }
#@   foreach blk $rm_placement_blk_list {
#@     remove_placement_blockage $blk
#@   }
#@ 
#@   set_object_snap_type -enabled 1
#@ }
#@ 
#@ define_proc_attributes P_insert_pre_place_cells_blockage     -info "insert the placement blockages at pre_place cells location or reverse locations"     -define_args {
#@       {-x_start "Left point of region which cell be pre-placed" x_start float required}
#@       {-y_start "Bottom point of region which cell be pre-placed" y_start float required}
#@       {-x_increment "X direction increment distance" x_increment float required}
#@       {-y_increment "Y direction increment distance" y_increment float required}
#@       {-x_trim "X direction distance away from core boundary" x_trim float optional}
#@       {-y_trim "Y direction  distance away from core boundary" y_trim float optional}
#@       {-w_preplace_cell "Width of the pre-placed cell" w_preplace_cell float required}
#@       {-h_preplace_cell "Height of the pre-placed cell" h_preplace_cell float required}
#@       {-as_blockage "Create placement blockage at Pre-place cells locations or reverse locations" "" boolean optional}
#@       {-ignore_hard_blockage "Ignore the existing hard placement blockage" "" boolean optional}
#@       {-no_flip "The rotation of pre-place cells as N" "" boolean optional}
#@       {-stagger "Preplace cells in the stagger pattern" "" boolean optional}
#@       {-tile "The tile name for the pre_place_cells" tile string optional}
#@       {-ignore_tap_cell "Ignore the existing tap cells" "" boolean optional}
#@     }
#@ 
#@ ###############################################################################
#@ # Procedure   : P_compare
#@ # Description :
#@ 
#@ proc P_compare {a b} {
#@   set a0 [lindex [lindex $a 0] 0]
#@   set b0 [lindex [lindex $b 0] 0]
#@   if {$a0 < $b0} {
#@     return -1
#@   } elseif {$a0 > $b0} {
#@     return 1
#@   }
#@   set a1 [lindex [lindex $a 0] 1]
#@   set b1 [lindex [lindex $b 0] 1]
#@   if {$a1 < $b1 } {
#@     return -1
#@   } elseif {$a1  > $b1} {
#@     return 1
#@   }
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_adv_polygon_get #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_adv_polygon_get
#@ # __description:  get 'option' from polygon
#@ #                 polygon can be polygon_set, simple polygon, complex polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result --- (dependent on option: float or (list of) rectangle
#@ #                       area       = return area of the polygon
#@ #                       bound      = return bounding rectangle of the polygon
#@ #                       rectangles = return list of rectangles of the polygon
#@ # __required_args:  option (one of): area bbox bound rectangles
#@ #                   polygon:         polygon_set, simple or complex polygon
#@ # __optional_args:  -size
#@ #                   if size, then post size the rectangles
#@ #                   (i.e. using 'size' can create overlaps or gaps)
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc P_adv_polygon_get { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # check size argument to see if valid
#@   if { [info exists inputs(-size)] } {
#@     set size $inputs(-size)
#@     # allow for separate x,y size
#@     # if only a single value, then x,y default to that value
#@     set xsize [lindex $size 0]
#@     set ysize [lindex $size end]
#@     if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@       error "$func_name: size value \"$size\" is not a float or pair of floats."
#@       unset size xsize ysize
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     error "'${func_name} $option': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # perform area calculation if "area" option, return result
#@   if { [string equal $option "area"] } {
#@     set area 0.0
#@ 
#@     # see if polygon lists are accepted or only simple polygons
#@     redirect -variable get_polygon_area_help {get_polygon_area -help}
#@     set simple_polygons [regexp -- {points list of } $get_polygon_area_help]
#@ 
#@     if { $simple_polygons } {
#@       foreach poly_segment $polygon {
#@         set area [expr $area + [get_polygon_area $poly_segment]]
#@       }
#@     } elseif { [llength $polygon] > 0 } {
#@       set area [expr $area + [get_polygon_area $polygon]]
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $area
#@   }
#@ 
#@   # perform bound check if "bound" option, return resulting rectangle
#@   if { [string equal $option "bbox"] || [string equal $option "bound"] } {
#@     # see if polygon is empty
#@     if { [llength $polygon] < 1 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return {}
#@     }
#@ 
#@     set joined_polygon [join $polygon]
#@ 
#@     # get x extents using a list sort
#@     set x_sort [lsort -index 0 -increasing -real $joined_polygon]
#@     set xll [lindex [lindex $x_sort 0] 0]
#@     set xur [lindex [lindex $x_sort end] 0]
#@ 
#@     # get y extents using a list sort
#@     set y_sort [lsort -index 1 -increasing -real $joined_polygon]
#@     set yll [lindex [lindex $y_sort 0] 1]
#@     set yur [lindex [lindex $y_sort end] 1]
#@ 
#@     # optionally size the box
#@     if { [info exists xsize] && [info exists ysize] } {
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@         return {}
#@       }
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     if { [string equal $option "bbox"] } {
#@       return [list [list $xll $yll] [list $xur $yur]]
#@     } else {
#@       return [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@   }
#@ 
#@   ### only option left is "rectangles"
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable convert_from_polygon_help {convert_from_polygon -help}
#@   set simple_polygons [regexp -- {points list of } $convert_from_polygon_help]
#@ 
#@   # create list of rectangles
#@   if { $simple_polygons } {
#@     set rectangles {}
#@     foreach poly_segment $polygon {
#@       foreach rect [convert_from_polygon -format polygon $poly_segment] {
#@         lappend rectangles $rect
#@       }
#@     }
#@   } else {
#@     if { [llength $polygon] == 0 } {
#@       set rectangles {}
#@     } else {
#@       set rectangles [convert_from_polygon -format polygon $polygon]
#@     }
#@     if { $rectangles == "0" } {
#@       set rectangles {}
#@     }
#@   }
#@ 
#@   # optionally size the box
#@   if { [info exists xsize] && [info exists ysize] } {
#@     set sized_rects {}
#@     foreach rect $rectangles {
#@       set x_sort [lsort -index 0 -increasing -real $rect]
#@       set xll [lindex [lindex $x_sort 0] 0]
#@       set xur [lindex [lindex $x_sort end] 0]
#@       set y_sort [lsort -index 1 -increasing -real $rect]
#@       set yll [lindex [lindex $y_sort 0] 1]
#@       set yur [lindex [lindex $y_sort end] 1]
#@ 
#@       # apply sizing
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         continue
#@       }
#@       lappend  sized_rects [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@     set rectangles $sized_rects
#@   }
#@ 
#@   # return list of rectangles
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return $rectangles
#@ 
#@ }
#@ define_proc_attributes P_adv_polygon_get     -info "get 'option' information from polygon"     -define_args {
#@       {option "get option" option one_of_string { required value_help {values { area bbox bound rectangles }}}}
#@       {polygon "polygon" polygon string required}
#@       {"-size" "size (+grow / -shrink)" "" string optional}}
#@ #}}}
#@ 
#@ 
#@ ##########################
#@ # Place-UPF Procedures
#@ ##########################
#@ 
#@ proc P_parse_pwrgrid_params {args} {
#@   parse_proc_arguments -args $args inputs
#@ 
#@   set attribute $inputs(-attribute)
#@   set layer $inputs(-layer)
#@   set param_list $inputs(-params)
#@ 
#@   set layer_index [lsearch [regexp -inline -all -- {\S+} $param_list] $layer]
#@   set width_val [lindex $param_list [expr $layer_index + 1]]
#@   set pitch_val [lindex $param_list [expr $layer_index + 2]]
#@   set offset_val [lindex $param_list [expr $layer_index + 3]]
#@ 
#@   if {$attribute == "offset"} {
#@     return $offset_val
#@   } elseif {$attribute == "pitch"} {
#@     return $pitch_val
#@   } elseif {$attribute == "width"} {
#@     return $width_val
#@   }
#@ }
#@ 
#@ define_proc_attributes P_parse_pwrgrid_params     -info "Parses powergrid parameters to determine offset and pitch values of various layers"     -define_args {
#@       {"-layer"  "Layer for which offset/pitch value is required" "" string required}
#@       {"-params" "INTEL_ parameter variable that contains layer, pitch and offset values" "" list required}
#@       {"-attribute" "Specify the attribute to be fetched" "" one_of_string {required value_help {values {offset pitch width}}}}
#@     }
#@ 
#@ proc P_ret_aon_net {args} {
#@   parse_proc_arguments -args $args inputs
#@ 
#@   set pwr_domain $inputs(-pwr_domain)
#@   redirect -variable rpt_pd {report_power_domain $pwr_domain}
#@ 
#@   set switch_line [regexp -inline -lineanchor -linestop {^Switch:.*} $rpt_pd]
#@   set switch_aon_vcc [lindex [regexp -inline -all {\S+} $switch_line] 2]
#@ 
#@   set primary_line [regexp -inline -lineanchor -linestop {^Primary:.*} $rpt_pd]
#@   set primary_aon_vcc [lindex [regexp -inline -all {\S+} $primary_line] 1]
#@ 
#@ 
#@   if {$switch_aon_vcc != ""} {
#@     return $switch_aon_vcc
#@   } elseif {$primary_aon_vcc != ""} {
#@     return $primary_aon_vcc
#@   } else {
#@     P_msg_error "P_ret_aon_net: Parsing report_power_domain failed. Aborting..."
#@     return
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_ret_aon_net     -info "Returns the always on power net for the provided power domain"     -define_args {
#@       {"-pwr_domain" "Domain for which the always on power net should be returned" "" string required}
#@     }
#@ 
#@ proc P_check_sec_pg_overlap {args} {
#@   parse_proc_arguments -args $args inputs
#@   set aon_net $inputs(-aon_net)
#@   set origin_x $inputs(-origin_x)
#@   set origin_y $inputs(-origin_y)
#@   set length $inputs(-length)
#@   set layer $inputs(-layer)
#@   set width $inputs(-width)
#@ 
#@   set vcc_base [get_attribute [get_nets $aon_net -all] base_name]
#@   set direction [get_attribute [get_layer $layer] preferred_direction]
#@ 
#@   if {$direction == "horizontal"} {
#@     set shape_bbox "{$origin_x $origin_y} {[expr $origin_x + $length] [expr $origin_y + $width]}"
#@   } else {
#@     set shape_bbox "{$origin_x $origin_y} {[expr $origin_x + $width] [expr $origin_y + $length]}"
#@   }
#@   set overlap [get_net_shapes -intersect $shape_bbox -filter "layer == $layer && owner_net != $vcc_base" -quiet]
#@   if {[sizeof_collection $overlap] == 0} {
#@     set overlap [get_vias -intersect $shape_bbox -filter "layer =~ *$layer* && owner_net != $vcc_base" -quiet]
#@   }
#@   if {[sizeof_collection $overlap] == 0} {
#@     set overlap [get_route_guides -intersect $shape_bbox -filter "no_signal_layers == $layer || no_preroute_layers == $layer" -quiet]
#@   }
#@ 
#@   if {[sizeof_collection $overlap] > 0} {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ define_proc_attributes  P_check_sec_pg_overlap     -info "Checks to see if sec pg staples overlap with one another"     -define_args {
#@       {"-layer"  "Staple layer" "" string required}
#@       {"-aon_net"  "AON net name" "" string required}
#@       {"-origin_x"  "Staple shape llx" "" string required}
#@       {"-origin_y"  "Staple shape lly" "" string required}
#@       {"-length"  "Staple length" "" string required}
#@       {"-width"  "Staple width" "" string required}
#@     }
#@ 
#@ ##############################
#@ # CTS-UPF Procedures
#@ ##############################
#@ 
#@ ##########################################################################################################
#@ # Procedure   : P_query_voltage_pgnet
#@ # Description : This proc is to find out the primary pg net for each voltage area for stdcell PG hookup
#@ 
#@ proc P_query_voltage_pgnet {} {
#@   global INTEL_VA_PWR INTEL_AON_PWR
#@   global INTEL_VA_GND
#@ 
#@   # determine if power domains are used in the design
#@   redirect /dev/null {set domains [get_power_domains -hierarchical ] }
#@   # get list of voltage_areas
#@   set va_list {}
#@   foreach_in_collection va [get_voltage_areas] {
#@     set va_name [get_attribute -quiet $va name]
#@     lappend va_list $va_name
#@   }
#@   unset -nocomplain  INTEL_VA_PWR INTEL_VA_GND INTEL_AON_PWR
#@ 
#@   # determine power & ground nets based on whether domains are present
#@   if { ([info exists domains]) && ([sizeof_collection $domains] > 0) } {
#@     # power domains exist
#@     # determine power & ground supplies for each voltage_area
#@ 
#@     # check power domains for corresponding voltage_area (then pwr/gnd nets)
#@     foreach_in_collection domain $domains {
#@       set domain_name [collection_to_list $domain -no_braces -name_only]
#@       redirect -variable rpt_pd  {report_power_domain $domain}
#@       set va_line [regexp -inline -lineanchor -linestop {^Voltage Area Information:\s+(\S+)} $rpt_pd]
#@ 
#@       if { ! [llength $va_line] } {
#@         continue
#@       } elseif { [string equal "N/A" [lindex $va_line 1]] } {
#@         continue
#@       } else {
#@         set voltage_area [lindex $va_line 1]
#@       }
#@ 
#@       # ensure the voltage_area is defined
#@       if { [lsearch -exact $va_list $voltage_area] < 0 } { continue }
#@ 
#@       # get supply info
#@       set primary_line [regexp -inline -lineanchor -linestop {^Primary:\s+(\S+)(\s+\([^\)]*\))?\s*(\S+)} $rpt_pd]
#@       if { [llength $primary_line] >= 4 } {
#@         set INTEL_VA_PWR($voltage_area) [lindex $primary_line 1]
#@         set INTEL_VA_GND($voltage_area) [lindex $primary_line 3]
#@       }
#@       # get AON supply info (if switched)
#@       set switch_line [join [regexp -inline -lineanchor -linestop {^Switch:.*} $rpt_pd]]
#@       if { [llength $switch_line] >= 4 } {
#@         set INTEL_AON_PWR($voltage_area) [lindex $switch_line 2]
#@       } else {
#@         set INTEL_AON_PWR($voltage_area) $INTEL_VA_PWR($voltage_area)
#@       }
#@     }
#@   }
#@ }
#@ 
#@ #######################
#@ # Route Procedures
#@ #######################
#@ 
#@ proc P_bonus_array_blockage {oddeven mode} {
#@   ###  add bonus array placement blockage - decap or spacer cell  ###
#@   ## oddeven - even_blockage | odd_blockage | remove_blockage ## mode - decap | spacer | spacer_vcnv0
#@   set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
#@   set die_area [get_attribute -quiet [get_die_area] bbox];
#@   regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} $die_area match dllx dlly durx dury; set blkgname "spcrblkg_";
#@   if {[get_placement_blockages -quiet -filter "name=~${blkgname}_*"] != ""} {
#@     remove_placement_blockage -name ${blkgname}_*;  ## always remove previous blockage or get name collision ##
#@   }
#@   if {$oddeven=="odd_blockage" || $oddeven=="even_blockage"} {
#@     set offx 0.28
#@     if {$mode=="decap"} {
#@       set step 4.48
#@       set gap 0
#@       if {$oddeven=="odd_blockage"} {
#@         set startx [expr 0 + $offx + $step + $gap]
#@       } else {
#@         set startx [expr 0 + $offx]
#@       }
#@       while {$startx<$durx} {
#@         create_placement_blockage -bbox "$startx $dlly [expr $startx+$step+$gap] $dury" -name ${blkgname}_${cnt}
#@         set startx [expr $startx+2*$step+2*$gap];
#@         incr cnt
#@       }
#@     }
#@ 
#@     regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} [get_attribute [index_collection  [get_site_rows -filter "site_type==$::INTEL_STDCELL_TILE"] 0] bbox] match llx lly urx ury
#@     set row_height [expr $ury-$lly]
#@     if {$oddeven=="even_blockage"} {
#@       set starty 0
#@     } else {
#@       set starty [expr 2*$row_height]
#@     }
#@     while {$starty<$dury} {
#@       create_placement_blockage -bbox "$dllx $starty $durx [expr $starty+2*$row_height]" -name ${blkgname}_${cnt}
#@       set starty [expr $starty+4*$row_height];
#@       incr cnt
#@     }
#@ 
#@   }
#@   set_object_snap_type -enabled $oldSnapState; set flag 1;
#@ }
#@ 
#@ #######################
#@ # Focal opt Procedures
#@ #######################
#@ 
#@ proc P_fix_min_cap args {
#@   global synopsys_program_name
#@   set DEBUG 0
#@   # Get arguments passed to this proc
#@   parse_proc_arguments -args $args results
#@ 
#@   # Default values
#@   set report_timing_cmd "report_timing -slack_lesser_than 0"
#@   set _iterations 10
#@   set _threshold -100
#@   set _reports [list mincap]
#@   upvar report_timing_cmd _report_timing_cmd
#@ 
#@   # Create variables from arguments with this format: $_<argument name>
#@   foreach _argname [array names results] {
#@     regsub -- {-} $_argname {_} _varname
#@     set $_varname $results($_argname)
#@   }
#@ 
#@   # Initialize argument variables
#@   set iteration_cnt 0
#@   if {[info exists _report_timing] && $_report_timing == 1} {
#@     lappend _reports [list timing]
#@   }
#@   if {[info exists _fix_dont_touch] && $_fix_dont_touch == 1} {
#@     set _fix_dont_touch "true"
#@   } else {
#@     set _fix_dont_touch "false"
#@   }
#@   if {[info exists _fix_cts_fixed] && $_fix_cts_fixed == 1} {
#@     set _fix_cts_fixed "true"
#@   } else {
#@     set _fix_cts_fixed "false"
#@   }
#@   if {[info exists _fix_is_fixed] && $_fix_is_fixed == 1} {
#@     set _fix_is_fixed "true"
#@   } else {
#@     set _fix_is_fixed "false"
#@   }
#@ 
#@   # Issue warning if user is in pt_shell
#@   if {$synopsys_program_name == "pt_shell"} {
#@     P_msg_warn "User is in pt_shell: Clock cells, fixed cells, and cells not explicitly marked as dont_touch will be modified"
#@   }
#@ 
#@   # Begin iterations for min cap fixing
#@   P_msg_info "Beignning min cap fixing"
#@   while {$iteration_cnt < $_iterations} {
#@     incr iteration_cnt
#@     P_msg_info "Begin iteration $iteration_cnt"
#@     P_msg_info "Printing reports..."
#@     foreach report $_reports {
#@       if {$report == "mincap"} {
#@         report_constraint -all_violators -min_capacitance
#@       }
#@       if {$report == "timing"} {
#@         eval $_report_timing_cmd
#@       }
#@     }
#@ 
#@     # Writing out violations
#@     P_msg_info "Getting violations..."
#@     redirect -file ./temp_mincap_rpt.txt {report_constraint -all_violators -min_capacitance -nosplit}
#@     set noviol 0
#@     # Grep violations from report
#@     set rc [catch {eval exec "grep VIOLATED ./temp_mincap_rpt.txt > ./temp_mincap.txt"} output]
#@     if {$rc == 0} {
#@       P_msg_info "Successfully grepped violations"
#@       sh rm ./temp_mincap_rpt.txt
#@     } else {
#@       if {[lindex $::errorCode 0] eq "CHILDSTATUS"} {
#@         if {[lindex $::errorCode 2] == 1} {
#@           P_msg_info "No violations found"
#@           # show output with "child process exited abnormally message
#@           P_msg_info "Exit status: $output"
#@           # Stop fixing violations
#@           set noviol 1
#@           sh rm ./temp_mincap_rpt.txt
#@           sh rm ./temp_mincap.txt
#@         } else {
#@           P_msg_error "grep error: $output"
#@         }
#@       } else {
#@         P_msg_error "error calling grep: $output"
#@       }
#@     }
#@ 
#@     if {$noviol == 1} {
#@       set vcnt 0
#@       set nofixcnt 0
#@       # No violations found in the file - can skip
#@       break
#@     }
#@ 
#@     # Parse violations
#@     P_msg_info "Parsing violations..."
#@     set fd [open "./temp_mincap.txt" "r"]
#@     # Violation Count
#@     set nofixcnt 0
#@     set vcnt 0
#@     while {[gets $fd line] > -1} {
#@       # Get Data
#@       set sline ""
#@       foreach item [split $line] {
#@         if {$item ne ""} { lappend sline $item }
#@       }
#@ 
#@       # In ICC _name is a net, in PT _name is a pin
#@       set _name [lindex $sline 0]
#@       set _is_port [sizeof_collection [get_ports $_name -quiet]]
#@       if {$_is_port} {
#@         P_msg_info "Skipping net $_name because its driver is a port"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       set _net_name $_name
#@       if {$synopsys_program_name == "pt_shell"} {
#@         set _net_name [get_object_name [get_nets -of_objects [get_pins $_name]]]
#@         set _driver [get_cells -of_objects [get_pins $_name]]
#@       } elseif {$synopsys_program_name == "icc_shell"} {
#@         set _driver [get_cells -of_objects [get_pins -of_objects [get_nets $_name] -filter "pin_direction==out" -leaf]]
#@       }
#@ 
#@       set _net_dont_touch [get_attribute [get_net $_net_name] is_dont_touch -quiet]
#@       set _is_macro [get_attribute $_driver is_macro -quiet]
#@       set _cell_dont_touch [get_attribute $_driver is_dont_touch -quiet]
#@       set _cell_cts_fixed "false"
#@       if {$_fix_cts_fixed == "false" && [get_attribute $_driver cts_fixed -quiet] == "true"} {
#@         set _cell_cts_fixed "true"
#@       }
#@       set _cell_is_fixed "false"
#@       if {$_fix_is_fixed == "false" && [get_attribute $_driver is_fixed -quiet] == "true"} {
#@         set _cell_is_fixed "true"
#@       }
#@ 
#@       if {$DEBUG} {
#@         puts "**DEBUG-MSG**> net: $_net_name"
#@         puts "**DEBUG-MSG**> driver: [get_object_name $_driver]"
#@       }
#@ 
#@       # NO FIX CONDITIONS
#@       # Driver is a macro
#@       if {$_is_macro == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is a macro ([get_object_name $_driver])"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver has cts_fixed==true attribute
#@       if {$_cell_cts_fixed == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is cts_fixed"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver has is_fixed==true attribute
#@       if {$_cell_is_fixed == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is fixed"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver is dont_touch
#@       if {$_fix_dont_touch == "false"} {
#@         if {$_net_dont_touch == "true"} {
#@           P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is dont_touch"
#@           incr nofixcnt
#@           continue
#@         } elseif {$_cell_dont_touch == "true"} {
#@           P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because driver [get_object_name $_driver] is dont_touch"
#@           incr nofixcnt
#@           continue
#@         }
#@       }
#@       # Output net is a dangling net
#@       if {[sizeof_collection [all_connected [get_nets $_net_name] -leaf]] <= 1} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is a dangling net.  Consider waiving this violation"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       # Get slack
#@       if {$_net_dont_touch == "true"} {
#@         set slack_column 4
#@       } else {
#@         set slack_column 3
#@       }
#@       set _slack [lindex $sline $slack_column]
#@ 
#@       # Don't fix if slack is greater than threshold
#@       if {[expr $_slack < $_threshold]} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its slack ($_slack) is greater than the threshold ($_threshold)"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       set ref_name [get_attribute $_driver ref_name]
#@       set base [string replace $ref_name 9 [string length $ref_name]]
#@       if {$synopsys_program_name == "icc_shell"} { set _attr "name" } else { set _attr "base_name" }
#@       set libcells [get_attribute [get_lib_cells */$base*] $_attr]
#@       set libcells [lsort -dictionary -unique $libcells]
#@       # Find cells and downsize
#@       set prev ""
#@       for {set j 0} {[expr $j < [llength $libcells]]} {incr j} {
#@         set mylibcell [lindex $libcells $j]
#@         if {$mylibcell == $ref_name} {
#@           if {$prev == ""} {
#@             P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is already minimum size."
#@             incr nofixcnt
#@           } else {
#@             P_msg_info "Swapping cell [get_object_name $_driver] from $ref_name to $prev"
#@             size_cell $_driver $prev
#@             incr vcnt
#@           }
#@           continue
#@         } else {
#@           set prev $mylibcell
#@         }
#@       }
#@     }
#@     sh rm ./temp_mincap.txt
#@     P_msg_info "Iteration $iteration_cnt complete"
#@     if {$vcnt == 0} {
#@       break
#@     }
#@   }
#@   report_constraint -all_violators -min_capacitance
#@   P_msg_info "Min Cap Fixing complete after $iteration_cnt iterations"
#@   P_msg_info "$vcnt fixable violations remain"
#@   P_msg_info "$nofixcnt non-fixable violations remain"
#@ }
#@ 
#@ #-----------------------------------#
#@ #--- Proc Attributes & Arguments ---#
#@ #-----------------------------------#
#@ define_proc_attributes P_fix_min_cap -info "Fixes mincap violations by down-sizing cells"     -define_args {                        {-iterations "Max number of downsizing iterations" iterations int optional}                        {-threshold  "Slack threshold - violations worse than this  will not be fixed" threshold float optional}                        {-report_timing "Prints timing report before each iteration" "" boolean optional}                        {-fix_dont_touch "Fix dont_touch nets & instances" "" boolean optional}                        {-fix_cts_fixed "Fix cts_fixed cells (Mainly flops)" "" boolean optional}                        {-fix_is_fixed "Fix fixed-placement cells" "" boolean optional}                      }
#@ 
#@ #####################
#@ # STA Procedures
#@ #####################
#@ 
#@ #######################################################################
#@ # Usage: P_report_xtalk_deltas
#@ #
#@ # This procedure reports xtalk delta delays
#@ #######################################################################
#@ suppress_message UIAT-4
#@ 
#@ proc P_report_xtalk_deltas {args} {
#@   global sh_dev_null
#@ 
#@   set results(nets) {}
#@   set results(-sort) {}
#@   set results(-verbose) 0
#@   parse_proc_arguments -args $args results
#@ 
#@   if {$results(nets) == ""} {
#@     set results(nets) [get_nets -hierarchical *]
#@   }
#@ 
#@   set sort_type $results(-sort)
#@ 
#@   set nets [get_nets $results(nets)]
#@   define_user_attribute -type float -class net dtrans_min_attr
#@   define_user_attribute -type float -class net dtrans_max_attr
#@   define_user_attribute -type float -class net delta_min_attr
#@   define_user_attribute -type float -class net delta_max_attr
#@   define_user_attribute -type float -class net abs_dtrans_attr
#@   define_user_attribute -type float -class net abs_delta_attr
#@ 
#@   echo ""
#@   echo ""
#@   set header [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"                   "Net Name" "Abs Dtrans" "Min Dtrans" "Max Dtrans" "Abs Delta" "Min Delta" "Max Delta"]
#@   echo $header
#@   echo [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"             "----------" "----------" "----------" "----------" "----------" "----------" "----------"]
#@ 
#@   foreach_in_collection this_net $nets {
#@     set net_loads {}
#@     set net_drivers {}
#@     set this_net_name [get_attribute -quiet $this_net full_name]
#@     set connections [all_connected [get_nets $this_net_name]]
#@     foreach_in_collection this_connection $connections {
#@       if {[get_attribute -quiet $this_connection object_class] == "port"} {
#@         if {[get_attribute -quiet [get_ports $this_connection] direction] == "in"} {
#@           set net_drivers [add_to_collection $net_drivers [get_ports $this_connection]]
#@         }
#@         if {[get_attribute -quiet [get_ports $this_connection] direction] == "out"} {
#@           set net_loads [add_to_collection $net_loads [get_ports $this_connection]]
#@         }
#@       }
#@       if {[get_attribute -quiet $this_connection object_class] == "pin"} {
#@         if {[get_attribute -quiet [get_pins $this_connection] direction] == "in"} {
#@           set net_loads [add_to_collection $net_loads [get_pins $this_connection]]
#@         }
#@         if {[get_attribute -quiet [get_pins $this_connection] direction] == "out"} {
#@           set net_drivers [add_to_collection $net_drivers [get_pins $this_connection]]
#@         }
#@       }
#@     }
#@ 
#@     set dtrans_min 0.00000
#@     set dtrans_max 0.00000
#@     set delta_min 0.00000
#@     set delta_max 0.00000
#@     set report ""
#@     foreach_in_collection this_load $net_loads {
#@       if {[get_attribute -quiet $this_load object_class] == "pin"} {
#@         if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]} {
#@           set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]
#@         }
#@         if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]} {
#@           set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]
#@         }
#@         if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]} {
#@           set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]
#@         }
#@         if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]} {
#@           set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]
#@         }
#@       }
#@       foreach_in_collection this_net_driver $net_drivers {
#@         set arcs [get_timing_arcs -from $this_net_driver -to $this_load]
#@         foreach_in_collection arc $arcs {
#@           if {$delta_min > [get_attribute -quiet $arc                                 annotated_delay_delta_min_rise]} {
#@             set delta_min [get_attribute -quiet $arc                                annotated_delay_delta_min_rise]
#@           }
#@           if {$delta_min > [get_attribute -quiet $arc                                 annotated_delay_delta_min_fall]} {
#@             set delta_min [get_attribute -quiet $arc                                annotated_delay_delta_min_fall]
#@           }
#@           if {$delta_max < [get_attribute -quiet $arc                                 annotated_delay_delta_max_rise]} {
#@             set delta_max [get_attribute -quiet $arc                                annotated_delay_delta_max_rise]
#@           }
#@           if {$delta_max < [get_attribute -quiet $arc                                 annotated_delay_delta_max_fall]} {
#@             set delta_max [get_attribute -quiet $arc                                annotated_delay_delta_max_fall]
#@           }
#@         }
#@       }
#@       if {$dtrans_min != ""} {
#@         set dtrans_min_nosign [expr abs($dtrans_min)]
#@       }
#@       if {$delta_min != ""} {
#@         set delta_min_nosign [expr abs($delta_min)]
#@       }
#@       set abs_dtrans $dtrans_max
#@       set abs_delta $delta_max
#@       if {$dtrans_min_nosign > $dtrans_max} {
#@         set abs_dtrans $dtrans_min_nosign
#@       }
#@       if {$delta_min_nosign > $delta_max} {
#@         set abs_delta $delta_min_nosign
#@       }
#@     }
#@ 
#@     if {$dtrans_min == 0.00000 && $dtrans_max == 0.00000 && $delta_min == 0.00000 &&             $delta_max == 0.00000 && !$results(-verbose)} {
#@       set_user_attribute -quiet -class net $this_net_name dtrans_min_attr 9999
#@       continue
#@     }
#@     set_user_attribute -quiet -class net $this_net_name dtrans_min_attr $dtrans_min
#@     set_user_attribute -quiet -class net $this_net_name dtrans_max_attr $dtrans_max
#@     set_user_attribute -quiet -class net $this_net_name delta_min_attr $delta_min
#@     set_user_attribute -quiet -class net $this_net_name delta_max_attr $delta_max
#@     set_user_attribute -quiet -class net $this_net_name abs_dtrans_attr $abs_dtrans
#@     set_user_attribute -quiet -class net $this_net_name abs_delta_attr $abs_delta
#@   }
#@ 
#@   set temp [filter_collection $nets "dtrans_min_attr != 9999" ]
#@   set no_crosstalk true
#@   if {[sizeof_collection $temp] != 0} {
#@     set temp_sort $temp
#@     if {$sort_type == "dtrans"} {
#@       set temp_sort [sort_collection -descending $temp {abs_dtrans_attr}]
#@     }
#@     if {$sort_type == "delta"} {
#@       set temp_sort [sort_collection -descending $temp {abs_delta_attr}]
#@     }
#@ 
#@     foreach_in_collection this_net_to_report $temp_sort {
#@       set dtrans_min [get_attribute -quiet $this_net_to_report dtrans_min_attr]
#@       set dtrans_max [get_attribute -quiet $this_net_to_report dtrans_max_attr]
#@       set delta_min  [get_attribute -quiet $this_net_to_report delta_min_attr]
#@       set delta_max  [get_attribute -quiet $this_net_to_report delta_max_attr]
#@       set abs_dtrans [get_attribute -quiet $this_net_to_report abs_dtrans_attr]
#@       set abs_delta  [get_attribute -quiet $this_net_to_report abs_delta_attr]
#@       set this_net_to_report_name [get_attribute -quiet $this_net_to_report full_name]
#@       set output [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"                       "$this_net_to_report_name" $abs_dtrans $dtrans_min $dtrans_max $abs_delta $delta_min $delta_max ]
#@       echo "$output"
#@     }
#@     set no_crosstalk false
#@   }
#@   if {$no_crosstalk == "true"} {
#@     echo "No crosstalk effects in this analysis."
#@   }
#@   echo "Analysis of [sizeof_collection $nets] net(s) complete."
#@ }
#@ 
#@ 
#@ define_proc_attributes P_report_xtalk_deltas     -info "reports delta delay and delta transition information for nets"     -define_args     {
#@       {-sort "dtrans to sort by absolute value of dtrans or delta to sort by absolute value of delta" "dtrans/delta" one_of_string {value_help {values {dtrans delta}} optional}}
#@       {-verbose "show all selected nets" "" boolean optional}
#@       {nets "nets to check" "nets" string optional}
#@     }
#@ 
#@ #######################################################################
#@ # Usage: P_restore_dmsa_session
#@ #
#@ # This procedure creates dmsa scenarios from a directory of saved sessions
#@ #######################################################################
#@ 
#@ proc P_restore_dmsa_session {args} {
#@   parse_proc_arguments -args $args results
#@ 
#@   if {[set dirs [glob -nocomplain -type f $results(dir_name)/*/*/lib_map]]
#@       eq {}} {
#@     echo "Error: no save_session directories found."
#@     return 0
#@   }
#@ 
#@   foreach dir $dirs {
#@     set dir [file dirname $dir]
#@     set name [file tail $dir]
#@     regsub "\/$name" $dir "" scenario
#@     regsub "..\/" $scenario "" scenario
#@     echo "Defining scenario ${scenario}."
#@ 
#@     create_scenario -name $scenario -image $dir
#@   }
#@ }
#@ 
#@ define_proc_attributes P_restore_dmsa_session     -info "Restores PrimeTime sessions in DMSA"     -define_args     {
#@       {dir_name "Dir name to restore from" "dir_name" string required}
#@     }
#@ 
#@ #######################################################################
#@ # Usage: P_report_qor
#@ #
#@ # This procedure to emulate DC's report_qor in PT
#@ #######################################################################
#@ 
#@ proc P_report_qor {args} {
#@ 
#@   global sh_product_version
#@   global sh_dev_null
#@   global report_default_significant_digits
#@   global synopsys_program_name
#@   global pt_shell_mode
#@ 
#@   set results(-help) "no help"
#@   set results(-significant_digits) "none"
#@   set results(-only_violated) "false"
#@   set results(-summary) "false"
#@ 
#@   parse_proc_arguments -args $args results
#@ 
#@   if {$results(-help)==""} {
#@     help -verbose report_qor
#@     return 1
#@   }
#@ 
#@   if {$results(-significant_digits)=="none"} {
#@     set significant_digits $report_default_significant_digits
#@   } else {
#@     if {$results(-significant_digits) < 0 || $results(-significant_digits) > 13} {
#@       echo "Error: value '$results(-significant_digits)' not in range (0 to 13). (CMD-019)"
#@       return 0
#@     } else {
#@       set significant_digits $results(-significant_digits)
#@     }
#@   }
#@ 
#@   proc P_count_levels {path} {
#@     set levels 0
#@     set endpoint [get_object_name [get_attribute -quiet $path endpoint]]
#@     foreach_in_collection point [get_attribute -quiet $path points] {
#@       set object [get_attribute -quiet $point object]
#@       if {[get_attribute -quiet $object object_class] == "pin"} {
#@         if {[get_attribute -quiet $object pin_direction] == "in"} {
#@           if {[get_attribute -quiet $object is_port] == "false"} {
#@             if {[get_attribute -quiet $object full_name] != $endpoint} {
#@               incr levels
#@             }
#@           }
#@         }
#@       }
#@     }
#@     return $levels
#@   }
#@ 
#@   proc P_display_path_group {levels arrival slack cost count significant_digits scenario} {
#@     echo "  ---------------------------------------------"
#@     echo [format "  Levels of Logic:%29d$scenario" $levels]
#@     echo [format "  Critical Path Length:%24.${significant_digits}f$scenario" $arrival]
#@     if {[regexp {[^a-zA-Z]} $slack full]} {
#@       echo [format "  Critical Path Slack:%25.${significant_digits}f$scenario" $slack]
#@     } else {
#@       echo [format "  Critical Path Slack:            unconstrained$scenario"]
#@     }
#@     echo [format "  Total Negative Slack:%24.${significant_digits}f" $cost]
#@     echo [format "  No. of Violating Paths:%22d" $count]
#@     echo "  ---------------------------------------------"
#@   }
#@ 
#@   proc P_display_cell_count_and_drcs {hier_cells_count nonhier_cells_count area hier_pins_count nonhier_pins_count cost count drc_list significant_digits scenario} {
#@     upvar $cost cost_local
#@     upvar $count count_local
#@     echo "\n\n  Cell Count"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Hierarchical Cell Count:%21d$scenario" $hier_cells_count]
#@     echo [format "  Hierarchical Port Count:%21d$scenario" $hier_pins_count]
#@     echo [format "  Leaf Cell Count:%29d$scenario" $nonhier_cells_count]
#@     echo "  ---------------------------------------------"
#@     echo "\n\n  Area"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Design Area:%33.6f$scenario" $area]
#@     if {[info exists cost_local(max_area)]} {
#@       echo [format "  Area Cost:%35.6f" $cost_local(max_area)]
#@     }
#@     echo "  ---------------------------------------------"
#@     echo "\n\n  Design Rule Violations"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Total No. of Pins in Design:%17d$scenario" $nonhier_pins_count]
#@     foreach i $drc_list {
#@       if {$count_local($i) != 0} {
#@         set len [expr 38 - [string length $i]]
#@         echo [format "  $i Count:%${len}d" $count_local($i)]
#@       }
#@     }
#@     set total_cost 0
#@     foreach i $drc_list {
#@       if {$cost_local($i) != 0} {
#@         set len [expr 39 - [string length $i]]
#@         set total_cost [expr $total_cost + $cost_local($i)]
#@         echo [format "  $i Cost:%${len}.${significant_digits}f" $cost_local($i)]
#@       }
#@     }
#@     echo [format "  Total DRC Cost:%30.${significant_digits}f" $total_cost]
#@     echo "  ---------------------------------------------\n"
#@   }
#@ 
#@   if {$synopsys_program_name != "pt_shell"} {
#@     echo "Error: This script only functions properly in PrimeTime."
#@     return 0
#@   }
#@ 
#@   set constraint_text ""
#@   set drc_list ""
#@   set group_list ""
#@ 
#@   if {$pt_shell_mode == "primetime" || $pt_shell_mode == "primetime_slave"} {
#@ 
#@     set cost(unconstrained) 0
#@     set count(unconstrained) 0
#@ 
#@     redirect $sh_dev_null {catch {set design [current_design]}}
#@ 
#@     if { $design == "" } {
#@       echo "Error: Current design is not defined. (DES-001)"
#@       return 0
#@     }
#@ 
#@     echo "\n****************************************"
#@     echo "Report : qor"
#@     echo "Design : [get_object_name $design]"
#@     echo "Version: $sh_product_version"
#@     echo "Date   : [date]"
#@     echo "****************************************\n"
#@ 
#@     redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}
#@ 
#@     foreach line [split $constraint_text "\n"] {
#@       switch -regexp $line {
#@         {^.* +([-\.0-9]+) +\(VIOLATED} {
#@           regexp {^.* +([-\.0-9]+) +\(VIOLATED} $line full slack
#@           set cost($group) [expr $cost($group) + $slack]
#@           incr count($group)
#@           continue
#@         }
#@         { *max_delay/setup.*'(.*)'} {
#@           regexp { *max_delay/setup.*'(.*)'} $line full group
#@           set cost($group) 0
#@           set count($group) 0
#@           continue
#@         }
#@         { *min_delay/hold.*'(.*)'} {
#@           regexp { *min_delay/hold.*'(.*)'} $line full group
#@           set group ${group}_min
#@           set cost($group) 0
#@           set count($group) 0
#@           continue
#@         }
#@         {^ *([a-zA-Z_]+) *$} {
#@           regexp {^ *([a-zA-Z_]+) *$} $line full group
#@           if {$group == "recovery" } {
#@             set group async_default
#@           }
#@           if {$group == "removal"} {
#@             set group async_default_min
#@           }
#@           if ![info exists cost($group)] {
#@             set cost($group) 0
#@             set count($group) 0
#@             if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
#@               lappend drc_list $group
#@             }
#@           }
#@           continue
#@         }
#@       }
#@     }
#@ 
#@     set WNS 0.0; set TNS 0.0; set NVP 0;
#@     set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;
#@ 
#@     foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group]] path_group] {
#@       set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost($path_group)]} {
#@         set cost($path_group) 0
#@         set count($path_group) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@ 
#@       if {$slack < $WNS} { set WNS $slack }
#@       set TNS [expr $TNS + $cost(${path_group})]
#@       set NVP [expr $NVP + $count(${path_group})]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits ""
#@     }
#@ 
#@     echo ""
#@ 
#@     foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group] -delay_type min] path_group] {
#@       redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost(${path_group}_min)]} {
#@         set cost(${path_group}_min) 0
#@         set count(${path_group}_min) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@ 
#@       if {$slack < $WNS_min} { set WNS_min $slack }
#@       set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
#@       set NVP_min [expr $NVP_min + $count(${path_group}_min)]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits ""
#@     }
#@ 
#@ 
#@     if {$results(-summary)} {
#@       puts "  Summary"
#@       puts "  ---------------------------------------------"
#@       puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
#@       puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
#@       puts "  ---------------------------------------------"
#@     }
#@ 
#@     set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"]
#@     set nonhier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == false"]
#@ 
#@     P_display_cell_count_and_drcs [sizeof_collection $hier_cells]         [sizeof_collection $nonhier_cells]         [get_attribute -quiet $design area]         [sizeof_collection [get_pins -quiet -of_objects $hier_cells]]         [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]]         cost         count         $drc_list         $significant_digits         ""
#@ 
#@   } elseif {$pt_shell_mode == "primetime_master"} {
#@ 
#@     global multi_scenario_message_verbosity_level
#@ 
#@     set old_verbosity_level $multi_scenario_message_verbosity_level
#@     set multi_scenario_message_verbosity_level low
#@ 
#@     if [info exists constraint_text] {
#@       unset constraint_text
#@     }
#@ 
#@     if {$sh_product_version=="Z-2007.06"||$sh_product_version=="Z-2007.06-SP1"||$sh_product_version=="Z-2007.06-SP2"||$sh_product_version=="Z-2007.06-SP2-1"} {
#@       echo "Error: Aborting script execution! Due to a DMSA bug in Z-2007.06 versions prior to Z-2007.06-SP3 (STAR 9000188708),"
#@       echo "       this script will produce inconsistent and incorrect results. The bug is fixed in Z-2007.06-SP3 PrimeTime."
#@       echo "       To use this script in DMSA mode, please use Z-2007.06-SP3 or later PrimeTime instead."
#@       return 0
#@     }
#@ 
#@     echo "\n****************************************"
#@     echo "Report : qor"
#@     echo "Design : multi-scenario design"
#@     echo "Version: $sh_product_version"
#@     echo "Date   : [date]"
#@     echo "****************************************\n"
#@ 
#@     get_distributed_variables -pre_commands         {redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}}         constraint_text
#@ 
#@     set max_paths [get_timing_paths -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]
#@     set min_paths [get_timing_paths -delay_type min -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]
#@ 
#@     set old_scenario_list [current_scenario]
#@ 
#@     foreach_in_collection scenario $old_scenario_list {
#@       set first_scenario_name [get_object_name $scenario]
#@       break
#@     }
#@ 
#@     current_scenario $first_scenario_name
#@ 
#@     get_distributed_variables -pre_commands         {set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"];              set nonhier_cells [get_cells -quiet -hieriarchical * -filter "is_hierarchical == false"];              set hier_cells_count [sizeof_collection $hier_cells];              set hier_pins_count [sizeof_collection [get_pins -quiet -of_objects $hier_cells]];              set nonhier_cells_count [sizeof_collection $nonhier_cells];              set nonhier_pins_count [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]];              set area [get_attribute -quiet [current_design] area];            } "hier_cells_count nonhier_cells_count hier_pins_count nonhier_pins_count area"
#@ 
#@     current_scenario $old_scenario_list
#@ 
#@     set multi_scenario_message_verbosity_level $old_verbosity_level
#@     set group ""
#@     foreach scenario [array names constraint_text] {
#@       foreach line [split $constraint_text($scenario) "\n"] {
#@         switch -regexp $line {
#@           {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} {
#@             regexp {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} $line full object slack
#@             set object [string trimright $object]
#@             if ![info exists slack_${group}($object)] {
#@               set slack_${group}($object) $slack
#@             } else {
#@               if [expr $slack < [set slack_${group}($object)]] {
#@                 set slack_${group}($object) $slack
#@               }
#@               continue
#@             }
#@           }
#@           { *max_delay/setup.*'(.*)'} {
#@             regexp { *max_delay/setup.*'(.*)'} $line full group
#@             if ![info exists slack_$group] {
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@               lappend group_list $group
#@             }
#@             continue
#@           }
#@           { *min_delay/hold.*'(.*)'} {
#@             regexp { *min_delay/hold.*'(.*)'} $line full group
#@             set group ${group}_min
#@             if ![info exists slack_$group] {
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@               lappend group_list $group
#@             }
#@             continue
#@           }
#@           {^ *([a-zA-Z_]+) *$} {
#@             regexp {^ *([a-zA-Z_]+) *$} $line full group
#@             if {$group == "recovery"} {
#@               set group async_default
#@               if ![info exists slack_async_default] {
#@                 lappend group_list async_default
#@               }
#@             }
#@             if {$group == "removal"} {
#@               set group async_default_min
#@               if ![info exists slack_async_default_min] {
#@                 lappend group_list async_default_min
#@               }
#@             }
#@             if ![info exists slack_$group] {
#@               if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
#@                 lappend drc_list $group
#@               }
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@             }
#@             continue
#@           }
#@         }
#@       }
#@     }
#@ 
#@     foreach group "$group_list $drc_list" {
#@       foreach object [array names slack_$group] {
#@         set cost($group) [expr $cost($group) + [set slack_${group}($object)]]
#@         incr count($group)
#@       }
#@     }
#@ 
#@     set WNS 0.0; set TNS 0.0; set NVP 0;
#@     set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;
#@ 
#@     foreach_in_collection path [sort_collection $max_paths path_group] {
#@       set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost($path_group)]} {
#@         set cost($path_group) 0
#@         set count($path_group) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@       set scenario_name [get_attribute $path scenario_name]
#@ 
#@       if {$slack < $WNS} { set WNS $slack }
#@       set TNS [expr $TNS + $cost(${path_group})]
#@       set NVP [expr $NVP + $count(${path_group})]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits " ($scenario_name)"
#@     }
#@ 
#@     echo ""
#@ 
#@     foreach_in_collection path [sort_collection $min_paths path_group] {
#@       redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost(${path_group}_min)]} {
#@         set cost(${path_group}_min) 0
#@         set count(${path_group}_min) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@       set scenario_name [get_attribute $path scenario_name]
#@ 
#@       if {$slack < $WNS_min} { set WNS_min $slack }
#@       set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
#@       set NVP_min [expr $NVP_min + $count(${path_group}_min)]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits " ($scenario_name)"
#@     }
#@ 
#@     if {$results(-summary)} {
#@       puts "  Summary"
#@       puts "  ---------------------------------------------"
#@       puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
#@       puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
#@       puts "  ---------------------------------------------"
#@     }
#@ 
#@     P_display_cell_count_and_drcs $hier_cells_count($first_scenario_name)         $nonhier_cells_count($first_scenario_name)         $area($first_scenario_name)         $hier_pins_count($first_scenario_name)         $nonhier_pins_count($first_scenario_name)         cost         count         $drc_list         $significant_digits         " ($first_scenario_name)"
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_report_qor     -info "Report QoR"     -define_args {                      {-physical "For compatibility with DC/ICC report_qor; ignored in PrimeTime" "" boolean optional}
#@       {-significant_digits "Precision level of report (range from 0 to 13)" "<digits>" int optional}
#@       {-only_violated "Show only violating path groups" "" boolean optional}
#@       {-summary "QoR Summary report" "" boolean optional}
#@     }
#@ 
#@ ###################################
#@ # Reports and Outputs Procedures
#@ ###################################
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_create_xyv_icc
#@ # Description : This proc is used to create top level block's XYV file for RV LTE analysis
#@ #               The xyv file contains rotation, flipping and coordinates information of top
#@ #               level block and all instances within top level block
#@ 
#@ proc P_create_xyv_icc {args } {
#@ 
#@   set topcell_name [get_attribute [current_design] name]
#@   if { $topcell_name == ""} {
#@     error "P_create_xyv_icc -ERROR- current design name for top level block is not defined\n"
#@   }
#@ 
#@   parse_proc_arguments -args $args flag
#@ 
#@   if {![info exists flag(-step)]} {
#@     error "P_create_xyv_icc -ERROR- Required APR step is not defined\n"
#@   } else {
#@     set step $flag(-step)
#@     set outputfile "outputs/${topcell_name}.${step}.xyv"}
#@   set fp [open $outputfile w]
#@ 
#@   global mw_attr_value_extra_braces
#@   set existing_value_of_extra_braces_var $mw_attr_value_extra_braces
#@   set mw_attr_value_extra_braces false
#@ 
#@   #############################################
#@   #xyv for top level block
#@   #############################################
#@ 
#@   set top_xy_coords ""
#@   set top_boundary [get_attribute [get_die_area] boundary]
#@   for {set tcount 0} {$tcount < [expr [llength $top_boundary] - 1]} {incr tcount} {
#@     set top_firstval [lindex $top_boundary $tcount]
#@     set top_xmin [lindex $top_firstval 0]
#@     set top_ymin [lindex $top_firstval 1]
#@     set top_xmin_nm [expr int($top_xmin*1000)]
#@     set top_ymin_nm [expr int($top_ymin*1000)]
#@     append top_xy_coords " $top_xmin_nm $top_ymin_nm"
#@   }
#@   puts $fp "$topcell_name $topcell_name 0 0 0 0 $top_xy_coords"
#@ 
#@   #############################################
#@   #xyv for all instances within top level block
#@   #############################################
#@ 
#@   foreach_in_collection cell [get_fp_cells -all] {
#@     set inst_name [get_attribute $cell full_name]
#@     set cell_name [get_attribute $cell ref_name]
#@     set inst_origin_x [lindex [get_attribute $cell origin] 0]
#@     set inst_origin_y [lindex [get_attribute $cell origin] 1]
#@     set orientation [get_attribute $cell orientation]
#@     if { $orientation eq "N"} {
#@       set inst_orient "0 0"
#@     } elseif {$orientation eq "FS"} {
#@       set inst_orient "1 0"
#@     } elseif {$orientation eq "FN"} {
#@       set inst_orient "2 0"
#@     } elseif {$orientation eq "S" } {
#@       set inst_orient "0 2"
#@     } else {
#@       puts "P_create_xyv_icc -ERROR- Invalid orientation is found for instance: $inst_name cell: $cell_name"
#@     }
#@     set inst_xy_coords ""
#@     set inst_boundary [get_attribute $cell boundary]
#@     for {set icount 0} {$icount < [expr [llength $inst_boundary] - 1]} {incr icount} {
#@       set inst_firstval [lindex $inst_boundary $icount]
#@       set inst_xmin [lindex $inst_firstval 0]
#@       set inst_ymin [lindex $inst_firstval 1]
#@       set inst_xmin_nm [expr int($inst_xmin*1000)]
#@       set inst_ymin_nm [expr int($inst_ymin*1000)]
#@       append inst_xy_coords " $inst_xmin_nm $inst_ymin_nm"
#@     }
#@     puts $fp "${topcell_name}/$inst_name $cell_name $inst_origin_x $inst_origin_y $inst_orient $inst_xy_coords"
#@   }
#@ 
#@   close $fp
#@ 
#@   set mw_attr_value_extra_braces $existing_value_of_extra_braces_var
#@ 
#@ }
#@ 
#@ define_proc_attributes P_create_xyv_icc      -info "Used to create top level block's XYV file for RV LTE analysis from ICC database"     -define_args {
#@       {-step "APR Step for which XYV file is created" string string required}
#@     }
#@ 
#@ #########################################################
#@ # Procedure: P_report_related_supply_net
#@ # Description: Report related supply nets for given ports.
#@ 
#@ proc P_report_related_supply_net { ports } {
#@   echo "\n****************************************"
#@   echo "Report : related_supply_net"
#@   echo "Design : [current_design_name]"
#@   echo "Version: $::sh_product_version"
#@   echo "Date   : [sh date]"
#@   echo "****************************************\n"
#@   array set miss_num {
#@     power  0
#@     ground 0
#@   }
#@   foreach_in_collection port [sort_collection -dictionary $ports full_name] {
#@     array unset rsn
#@     redirect $::sh_dev_null {
#@       set rsn(power) [get_related_supply_net $port]
#@       set rsn(ground) [get_related_supply_net -ground $port]
#@     }
#@     foreach net_type {power ground} {
#@       if { [sizeof_collection $rsn($net_type)] == 0 } {
#@         incr miss_num($net_type)
#@       }
#@     }
#@     echo "Port [get_object_name $port] ([get_attribute $port direction]) : power = [get_object_name $rsn(power)] , ground = [get_object_name $rsn(ground)]"
#@   }
#@   if { $miss_num(power) > 0 || $miss_num(ground) > 0 } {
#@     echo "\nERROR: $miss_num(power) of [sizeof_collection $ports] ports missing related power net & $miss_num(ground) of [sizeof_collection $ports] ports missing related ground net!\n"
#@     return 0
#@   } else {
#@     echo {}
#@     return 1
#@   }
#@ }
#@ 
#@ #########################################################
#@ # Procedure: P_reports
#@ # Description:  Writes out report files for SYN, APR, PV
#@ 
#@ proc P_reports {step} {
#@   set _start [clock seconds]
#@   global INTEL_DESIGN_NAME INTEL_UPF INTEL_REPORTS
#@   global INTEL_INSERT_SCAN INTEL_HARD_MACRO_NAME
#@   global INTEL_SLACK_LIMIT INTEL_MAX_PATHS INTEL_NWORST
#@   global synopsys_program_name
#@ 
#@   if {[info exists INTEL_MAX_PATHS($step)]} {
#@     set tmax_paths $INTEL_MAX_PATHS($step)
#@   } else {
#@     set tmax_paths 1000
#@   }
#@   if {[info exists INTEL_SLACK_LIMIT($step)]} {
#@     set tslack_limit $INTEL_SLACK_LIMIT($step)
#@   } else {
#@     set tslack_limit 9999
#@   }
#@   if {[info exists INTEL_NWORST($step)]} {
#@     set tnworst $INTEL_NWORST($step)
#@   } else {
#@     set tnworst 1
#@   }
#@ 
#@   set reports_path ./reports
#@   set report_timing_options "report_timing -nosplit -capacitance -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
#@   set check_timing_options "check_timing"
#@ 
#@ 
#@   set rpt_cmd ""
#@   if {$synopsys_program_name == "pt_shell"} {
#@     set report_timing_options "report_timing -nosplit -capacitance -crosstalk_delta -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
#@     set check_timing_options "check_timing -verbose"
#@   }
#@ 
#@   set act_scenarios ""
#@   if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
#@      set act_scenarios [all_active_scenarios]
#@   } 
#@ 
#@   if {[info exists INTEL_REPORTS($step)]} {
#@     foreach report $INTEL_REPORTS($step) {
#@       #         puts "==>INFORMATION: Generating $report report..."
#@       switch -exact -- $report {
#@         area {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set hard_macro_area 0.0
#@           set hard_macro_count 0
#@           if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@             foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@               foreach_in_collection inst_col [get_cells -hierarchical -filter ref_name==$hard_macro_name] {
#@                 set area [get_attribute $inst_col area]
#@                 set hard_macro_area [expr $hard_macro_area + $area]
#@                 incr hard_macro_count
#@               }
#@             }
#@           }
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
#@             report_area
#@             echo "HARD MACRO COUNT= $hard_macro_count"
#@             echo "HARD MACRO AREA = $hard_macro_area sq. microns"
#@             report_reference -hierarchy -nosplit
#@           }
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         qor {
#@           puts "==>INFORMATION: Generating $report report..."
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_report_qor}\n}\n"
#@           } else {
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_qor}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             if { $act_scenarios != "" } {
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt {report_qor -summary}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt reports/${INTEL_DESIGN_NAME}.${report}.summary.rpt
#@             }
#@           }
#@         }
#@         power {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_power -verbose -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               }
#@             } else {
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit }
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         congestion {
#@           if {[shell_is_in_topographical_mode] || [regexp {^icc} $synopsys_program_name]} {
#@             # reports estimated routing related congestion after topo mode synthesis.
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_congestion}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported in this mode."
#@           }
#@         }
#@         multi_vth {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         aocvm {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         high_fanout {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_net_fanout -high_fanout}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         logic_levels {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_get_logic_levels}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         max_delay {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.delay.rpt {report_constraint -all_violators -max_delay -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.delay.rpt reports/${INTEL_DESIGN_NAME}.delay.rpt
#@             }
#@           }
#@         }
#@         max_cap {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.cap.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.cap.rpt reports/${INTEL_DESIGN_NAME}.cap.rpt
#@             }
#@           }
#@         }
#@         max_tran {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt {report_constraint -all_violators -max_transition -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.tran.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tran.rpt reports/${INTEL_DESIGN_NAME}.tran.rpt
#@             }
#@           }
#@         }
#@         all_violators {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_constraint -all_violators -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         create_qor_snapshot {
#@           P_msg_info "Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "create_qor_snapshot -name $step -show_all -clock_tree"}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         timing_setup {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type max}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type max -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type max"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         timing_hold {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type min}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type min -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type min"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         timing_setup_zeroRC {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  set_zero_interconnect_delay_mode true\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay min}\n set_zero_interconnect_delay_mode false\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 set_zero_interconnect_delay_mode true
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@                 set_zero_interconnect_delay_mode false
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               set_zero_interconnect_delay_mode true
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               set_zero_interconnect_delay_mode false
#@             }
#@           }
#@         }
#@         timing_setup_groups {
#@           puts "==>INFORMATION: Generating $report report..."
#@           foreach_in_collection group [get_path_groups] {
#@             set group_name [get_object_name ${group}]
#@             regsub -all {\*} $group_name "" group_rpt_name
#@             regsub -all {\/} $group_rpt_name "-" group_rpt_name
#@             if {[regexp {^pt} $synopsys_program_name]} {
#@               set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {$report_timing_options -group $group_name}}\n"
#@             } else {
#@               if { $act_scenarios != "" } {
#@                 foreach scenario [all_active_scenarios] {
#@                   redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name -scenarios $scenario"}
#@                   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
#@                 }
#@               } else {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_setup_${group_rpt_name}.rpt
#@               }
#@             }
#@           }
#@         }
#@         timing_hold_groups {
#@           puts "==>INFORMATION: Generating $report report..."
#@           foreach_in_collection group [get_path_groups] {
#@             set group_name [get_object_name ${group}]
#@             regsub -all {\*} $group_name "" group_rpt_name
#@             regsub -all {\/} $group_rpt_name "-" group_rpt_name
#@             if {[regexp {^pt} $synopsys_program_name]} {
#@               set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {$report_timing_options -delay_type min -group $group_name}}\n"
#@             } else {
#@               if { $act_scenarios != "" } {
#@                 foreach scenario [all_active_scenarios] {
#@                   redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name -scenarios $scenario"}
#@                   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
#@                 }
#@               } else {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_hold_${group_rpt_name}.rpt
#@               }
#@             }
#@           }
#@         }
#@         timing_loops {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {$report_timing_options -loops}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {eval "$report_timing_options -loops"}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt reports/${INTEL_DESIGN_NAME}.max.timingloops.rpt
#@           }
#@         }
#@         timing_histogram {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -range_maximum 0}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_histogram.rpt {report_timing_histogram -bin_range 25 -scenarios $scenario}
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -bin_range 25}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt reports/${INTEL_DESIGN_NAME}.timing_histogram.rpt
#@             }
#@           }
#@         }
#@         clock {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock -skew -attributes -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         physical {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_design -physical}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         clock_tree {
#@           if { $act_scenarios != "" } {
#@             foreach scenario [all_active_scenarios] {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_tree -scenarios $scenario}
#@               redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup -scenarios $scenario}
#@               redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup -scenario $scenario }
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@             }
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_tree }
#@             redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup }
#@             redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup  }
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         clock_gating {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_gating -ungated -style}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_timing {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$check_timing_options}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval $check_timing_options}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         min_pulse_width {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_min_pulse_width -all_violators -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         check_zrt_routability {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_zrt_routability -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         drc {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_drc -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
#@           sh ln -fs ${INTEL_DESIGN_NAME}_${step}_${report}.err reports/${INTEL_DESIGN_NAME}_${report}.err
#@         }
#@         lvs {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_lvs -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err -max_error 200 -check_short_locator -check_open_locator}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_design {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_design}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         error_info {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}\n}\n"
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt  
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         saif {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_saif -hier -missing -annotated_flag -type gate}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_mv_design {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_mv_design -verbose}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         upf {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
#@               eval report_power_domain [get_power_domains -quiet -hierarchical *]
#@               eval report_supply_port [get_supply_ports -quiet -hierarchical *]
#@               eval report_supply_net -include_exception [get_supply_nets -quiet -hierarchical *]
#@               eval report_power_switch -verbose [get_power_switches -quiet -hierarchical *]
#@               # Somehow, ICC report_isolation_cell needs associate_mv_cells -isolation_cells.
#@               report_isolation_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               # Somehow, ICC report_level_shifter needs domain names instead of domain objects.
#@               if { $::synopsys_program_name == {icc_shell} } {
#@                 report_level_shifter -verbose -domain [get_object_name [get_power_domains -quiet -hierarchical *]]
#@               } else {
#@                 report_level_shifter -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               }
#@               report_retention_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               P_report_related_supply_net [get_ports *]
#@             }
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         check_legality {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_legality -verbose}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         threshold_voltage_group {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         vars {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {\n    echo \"##### Environment Variables #####\"\n     printenv\n   echo \" \"\n   echo \"##### Flow Related Variables #####\"\n    printvar\n}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {
#@               echo "##### Environment Variables #####"
#@               printenv
#@               echo " "
#@               echo "##### Flow Related Variables #####"
#@               printvar
#@             }
#@             ################
#@             # dump file paths of libraries and technology data.
#@             #   resulting file can be run through sha1sum for audit purposes.
#@             # libraries
#@             set libs [get_libs *]
#@             foreach_in_collection lib $libs {
#@               set file [get_attribute $lib extended_name]
#@               set l [split $file ":"]
#@               lappend names [lindex $l 0]
#@             }
#@             set names [lsort -unique $names]
#@             set f [open "$reports_path/${INTEL_DESIGN_NAME}.${step}.files" "w"]
#@             foreach n $names {
#@               puts $f $n
#@             }
#@             if {[regexp {icc} $synopsys_program_name] || ([regexp {dc} $synopsys_program_name] && [shell_is_in_topographical_mode])} {
#@               # tlu files
#@               redirect -variable tlu_files {report_tlu_plus_files}
#@               foreach line [split $tlu_files "\n"] {
#@                 regsub -all {\s+} $line {} line
#@                 if {[regexp {file:} $line]} {
#@                   puts $f [lindex [split $line ":"] 1]
#@                 }
#@               }
#@               # techfile - ??
#@             }
#@             close $f
#@           }
#@         }
#@         flow_vars {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {\n   echo \"#### INTEL_* flow varaibles #####\"\n   printvar INTEL_*\n}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {
#@               echo "#### INTEL_* flow varaibles #####"
#@               printvar INTEL_*
#@             }
#@           }
#@         }
#@         dft_drc {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {dft_drc -coverage_estimate}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         dft_signal {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_dft_signal}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         scanpath {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_scan_path}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         parasitic_not_annotated_check {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n   redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {report_annotated_parasitics -internal_nets -boundary_nets -list_not_annotated}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {
#@               report_annotated_parasitics                   -internal_nets                   -boundary_nets                   -list_not_annotated                 }
#@           }
#@         }
#@         pin_margin   {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_margin.pv.rpt
#@           redirect $output_file {echo [format "%-50s %-7s %-7s %-7s %-7s %-4s %-15s" #pin_name max_rise max_fall min_rise min_fall direction cell ]}
#@           redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection pin [get_pins -hierarchical * -filter "is_hierarchical == false && is_clock_pin == false"] {
#@             set temp [format "%-50s %7.2f %7.2f %7.2f %7.2f %-4s %-15s" [get_attribute -quiet -class pin $pin full_name]                           [get_attribute -quiet -class pin $pin max_rise_slack]                           [get_attribute -quiet -class pin $pin max_fall_slack]                           [get_attribute -quiet -class pin $pin min_rise_slack]                           [get_attribute -quiet -class pin $pin min_fall_slack]                           [get_attribute -quiet -class pin $pin direction]                           [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]
#@ 
#@             redirect -append $output_file { echo $temp}
#@           }
#@         }
#@         pin_attribute {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_pin_attribute.pv.rpt
#@           redirect $output_file {echo [format "%60s %14s" #RISE_TRAN FALL_TRAN]}
#@           redirect -append $output_file {echo [format "%-50s %-6s %-6s %-6s %-6s %-4s %-15s" #pin_name max  min  max  min  arr_window  cell]}
#@           redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection pin [get_pins -hierarchical * ] {
#@             set temp [format "%-50s %5.2f %5.2f %5.2f %5.2f %-50s %-15s" [get_attribute -quiet -class pin $pin full_name]                           [get_attribute -quiet -class pin $pin actual_rise_transition_max]                           [get_attribute -quiet -class pin $pin actual_rise_transition_min]                           [get_attribute -quiet -class pin $pin actual_fall_transition_max]                           [get_attribute -quiet -class pin $pin actual_fall_transition_min]                           [get_attribute -quiet -class pin $pin arrival_window]                           [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]
#@             redirect -append $output_file { echo $temp }
#@           }
#@         }
#@         net_attribute {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_net_attribute.pv.rpt
#@           redirect output_file {echo [format "%40s " #CAPACITANCE_MAX# ]}
#@           redirect -append $output_file {echo [format "%-20s %-7s %-7s %-7s %-7s %-4s %-15s" #net wire pin Total R_max lth_H  lth_V]}
#@           redirect -append $output_file {echo "#------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection hn [get_nets -hierarchical * ] {
#@             set tmp_val [get_attribute -quiet -class net $hn x_coordinate_max]
#@             if {[info exists tmp_val] && $tmp_val == ""} {
#@               set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-5s %-5s" [get_attribute -quiet -class net $hn full_name]                             [get_attribute -quiet -class net $hn wire_capacitance_max]                             [get_attribute -quiet -class net $hn pin_capacitance_max]                             [get_attribute -quiet -class net $hn total_capacitance_max]                             [get_attribute -quiet -class net $hn net_resistance_max]                             --- ---]
#@             } else {
#@               set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-9.2s %-9.2s" [get_attribute -quiet -class net $hn full_name]                             [get_attribute -quiet -class net $hn wire_capacitance_max]                             [get_attribute -quiet -class net $hn pin_capacitance_max]                             [get_attribute -quiet -class net $hn total_capacitance_max]                             [get_attribute -quiet -class net $hn net_resistance_max]                             [expr {[get_attribute -quiet -class net $hn x_coordinate_max] - [get_attribute -quiet -class net $hn x_coordinate_min]}]                             [expr {[get_attribute -quiet -class net $hn y_coordinate_max] - [get_attribute -quiet -class net $hn y_coordinate_min]}]]
#@             }
#@             redirect -append $output_file { echo $temp }
#@           }
#@         }
#@         noise_all_vio {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators -slack_type height -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators                                                                                    -verbose                                                                                    -slack_type height                                                                                    -nosplit }
#@           }
#@         }
#@         noise_below {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below                                                                                  -verbose                                                                                  -slack_type height                                                                                  -nworst 10000                                                                                  -nosplit }
#@           }
#@         }
#@         noise_above {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above                                                                                  -verbose                                                                                  -slack_type height                                                                                  -nworst 10000                                                                                  -nosplit }
#@           }
#@         }
#@         check_noise {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity} -beyond_rail -verbose}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity}                                                                                  -verbose }
#@           }
#@         }
#@         max_analysis_coverage {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage -status_details untested -check_type \"setup recovery clock_gating_setup out_setup\" -exclude_untested \"user_disabled false_paths constant_disabled\" -sort_by name -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage                                                                                            -status_details untested                                                                                            -check_type "setup recovery clock_gating_setup out_setup"                                                                                            -exclude_untested "user_disabled false_paths"                                                                                            -sort_by name                                                                                            -nosplit }
#@           }
#@         }
#@         switching_activity {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.switching_activity.rpt {report_switching_activity}\n}\n"
#@           }
#@         }
#@ 
#@         hier_switching_activity {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"  redirect $reports_path/${INTEL_DESIGN_NAME}.hier.switching_activity.rpt { report_switching_activity -hierarchy}\n}\n"
#@           }
#@         }
#@         missing_power_tables {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.no_power_table.rpt {check_power -verbose  -override_defaults missing_table }\n}\n"
#@           }
#@         }
#@         default {
#@           puts "==>WARNING: The defined report \"$report\" is not configured at $step in the default flow."
#@         }
#@       }
#@     }
#@   } else {
#@     puts "==>WARNING: No reports are defined at $step step in the default flow."
#@   }
#@ 
#@   if {[regexp {^pt} $synopsys_program_name]} {
#@     set rpt_cmd "parallel_execute -commands_only {\n $rpt_cmd }"
#@     echo $rpt_cmd
#@     eval $rpt_cmd
#@   }
#@   set _end [clock seconds]
#@   P_msg_info "Runtime for reports: [expr ($_end - $_start)/60.0] minutes"
#@ 
#@ }
#@ 
#@ ### procedure get_logic_levels takes in the output of "get_timing_path"
#@ proc P_get_logic_levels {args} {
#@   parse_proc_arguments -args $args results
#@   if {[info exists results(-paths)] && $results(-paths) != ""} {
#@     set paths $results(-paths)
#@   } elseif {[info exists results(-gtp_options)] && $results(-gtp_options) != ""} {
#@     set paths [eval get_timing_paths $results(-gtp_options)]
#@   } else {
#@     set paths [get_timing_paths -max_paths 25]
#@   }
#@   puts "\nPrining logic levels per start/end point\n"
#@   puts "Startpoint, Endpoint, # of logic cells, slack"
#@   puts "============================================="
#@   foreach_in_collection path $paths {
#@     set slack [get_attribute $path slack]
#@     set startpoint [get_object_name [get_attribute $path startpoint]]
#@     set endpoint [get_object_name [get_attribute $path endpoint]]
#@     set points [get_attribute $path points]
#@     set cells {}
#@     foreach_in_collection point $points {
#@       set obj [get_attribute $point object]
#@       set obj_class [get_attribute $obj object_class]
#@       set dir [get_attribute $obj direction]
#@       if {$dir == "in" && $obj_class == "pin" } {
#@         set cells [add_to_collection $cells [get_cells -of_objects $obj -filter "@is_combinational == true"]]
#@       }
#@     }
#@     puts "$startpoint, $endpoint, [sizeof_collection $cells], $slack"
#@   }
#@ }
#@ 
#@ define_proc_attributes P_get_logic_levels     -info "Prints logic levels in a start/end point pair"     -define_args {
#@       {-paths "output of get_timing_paths command" timing_paths string optional}
#@       {-gtp_options "options to be used by get_timing_paths command" get_timing_path_options string optional}
#@     }
#@ 
#@ ## procedure to create PG terminals on the entire strap of top metal layer to ensure correct FRAM creation
#@ proc P_create_pg_terminals {} {
#@   global INTEL_MAX_PG_LAYER
#@   global INTEL_TERM_LENGTH
#@ 
#@   set pports [get_ports -all -filter "port_type=~*Power* || port_type=~*Ground*"]
#@ 
#@   # Remove existing terminals
#@   set top_layer [string map {m ""} $INTEL_MAX_PG_LAYER]
#@   set filter_exp "layer!=tm1 && layer!=c4b"
#@   for {set i [expr $top_layer + 1]} {[expr $i <= 12]} {incr i} {
#@     set filter_exp "$filter_exp && layer!=m${i}"
#@   }
#@   remove_terminal [get_terminals -of_objects $pports -filter "$filter_exp"]
#@ 
#@   # Create new terminals
#@   set all_pg_nets [get_net_shapes -of_objects [get_nets -all -of_objects $pports] -filter "route_type==pg_strap"]
#@   set top_layer_nets [filter_collection $all_pg_nets "layer==$INTEL_MAX_PG_LAYER"]
#@   set other_nets [remove_from_collection $all_pg_nets $top_layer_nets]
#@ 
#@   # Terminals half DR in size
#@   foreach {metal stub} $INTEL_TERM_LENGTH {
#@     set stub_size($metal) [expr $stub / 2]
#@   }
#@ 
#@   # Get vertical/horizontal edges
#@   set boundary [get_attribute [get_die_area] boundary]
#@   set vert_edges ""
#@   set horz_edges ""
#@   set first 1
#@   foreach point $boundary {
#@     if {$first} {
#@       set first 0
#@     } else {
#@       #  puts "point:$point, prev:$prev"
#@       if {[lindex $point 0] == [lindex $prev 0]} {
#@         # X didn't change, vertical edge
#@         lappend vert_edges [format "%.3f" [lindex $point 0]]
#@       } else {
#@         lappend horz_edges [format "%.3f" [lindex $point 1]]
#@       }
#@     }
#@     set prev $point
#@   }
#@ 
#@   set first_layer 5
#@   for {set i 5} {[expr $i < [string map {m ""} $INTEL_MAX_PG_LAYER]]} {incr i} {
#@     # Create terminal stubs
#@     set layer "m${i}"
#@     P_msg_info "Creating terminals on layer $layer"
#@     foreach_in_collection net_shape [filter_collection $other_nets "layer==$layer"] {
#@       scan [get_attribute $net_shape bbox] "{%f %f} {%f %f}" llx lly urx ury
#@       if {[get_attribute [get_layer $layer] preferred_direction] == "horizontal"} {
#@         # L/R sides
#@         if {[lsearch $vert_edges [format "%.3f" $llx]] > -1} {
#@           set bbox1 [list $llx $lly [expr $llx + $stub_size($layer)] $ury]
#@           create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@         if {[lsearch $vert_edges [format "%.3f" $urx]] > -1} {
#@           set bbox2 [list [expr $urx - $stub_size($layer)] $lly $urx $ury]
#@           create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@       } else {
#@         # T/B sides
#@         if {[lsearch $horz_edges [format "%.3f" $lly]] > -1} {
#@           set bbox1 [list $llx $lly $urx [expr $lly + $stub_size($layer)]]
#@           create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@         if {[lsearch $horz_edges [format "%.3f" $ury]] > -1} {
#@           set bbox2 [list $llx [expr $ury - $stub_size($layer)] $urx $ury]
#@           create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@       }
#@       #      create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@       #      create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@     }
#@   }
#@ 
#@   # Terminals of top metal layers
#@   P_msg_info "Creating terminals on layer $INTEL_MAX_PG_LAYER"
#@   foreach_in_collection net_shape $top_layer_nets {
#@     create_terminal -bbox [get_attribute $net_shape bbox] -layer $INTEL_MAX_PG_LAYER -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@   }
#@ 
#@   proc P_poly2bbox {polygon} {
#@     return [join [list [lindex $polygon 0] [lindex $polygon 2]] " "]
#@   }
#@ 
#@   foreach_in_collection pin_shape [get_pin_shapes -of_objects [get_pins -all -of_objects [all_macro_cells ] -filter "pin_type=~*Power* || pin_type=~*Ground*" -quiet] -filter "layer==$INTEL_MAX_PG_LAYER" -quiet] {
#@     set port [get_ports -all -of_objects [get_nets -all [get_attribute [get_pins -all -of_objects $pin_shape -quiet] net_name -quiet] -quiet] -quiet]
#@     if {[sizeof_collection $port] > 0} {
#@       set points [get_attribute $pin_shape points]
#@       set plength [llength $points]
#@       if {[expr $plength % 5] == 0} {
#@         for {set pi 0} {[expr $pi < $plength]} {set pi [expr $pi + 5]} {
#@           set ppoints [lrange $points $pi [expr $pi + 4]]
#@           create_terminal -bbox [P_poly2bbox $ppoints] -layer $INTEL_MAX_PG_LAYER -port $port -no_snap
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ proc P_outputs_linkname {} {
#@   global synopsys_program_name
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
#@     set ::output_linkname syn
#@   } else {
#@     set ::output_linkname apr
#@   }
#@ }
#@ 
#@ proc P_outputs_verilog {step} {
#@   global INTEL_DESIGN_NAME
#@   global synopsys_program_name
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.vg
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
#@     write_file -format verilog -hierarchy -output $output_file
#@   } else {
#@     write_verilog -diode_ports -no_physical_only_cells -no_core_filler_cells -no_tap_cells -unconnected_ports $output_file
#@   }
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.vg outputs/${INTEL_DESIGN_NAME}.${output_linkname}.vg
#@ }
#@ 
#@ proc P_outputs_verilog_pg {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}_lvs.vg
#@   write_verilog -pg -diode_ports -unconnected_ports -output_net_name_for_tie $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}_lvs.vg outputs/${INTEL_DESIGN_NAME}.${output_linkname}_lvs.vg
#@ }
#@ 
#@ proc P_outputs_upf {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.upf
#@   save_upf $output_file
#@   P_msg_info "Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.upf outputs/${INTEL_DESIGN_NAME}.${output_linkname}.upf
#@ }
#@ 
#@ 
#@ proc P_outputs_spef {step} {
#@   global synopsys_program_name
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   if {($synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell")  && [shell_is_in_topographical_mode]} {
#@     write_parasitics -format distributed -output ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     if {[file exists ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz]} {
#@       sh rm ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz
#@     }
#@     sh gzip ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.gz
#@   } elseif {$synopsys_program_name != "dc_shell"} {
#@     global INTEL_DESIGN_NAME
#@     extract_rc -coupling_cap
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     write_parasitics -format SPEF -compress -output $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}.max.gz ${output_file}.min.gz"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.max.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.max.gz
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.min.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.min.gz
#@   }
#@ }
#@ 
#@ proc P_outputs_def {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   global synopsys_program_name
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
#@   if {($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode]) || $synopsys_program_name == "de_shell" } {
#@     write_def -output $output_file -placed
#@ 		sh ln -fs ${INTEL_DESIGN_NAME}.${step}.def outputs/${INTEL_DESIGN_NAME}.${output_linkname}.def
#@     puts "==>INFORMATION: Output file: ${INTEL_DESIGN_NAME}.${step}.def"
#@   } elseif {$synopsys_program_name == "icc_shell" } {
#@     write_def -compressed -output $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}.gz"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.def.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.def.gz
#@   }
#@ }
#@ 
#@ proc P_outputs_techlef {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tech.lef
#@   set libpath  [file dirname [ get_attribute [current_mw_lib] path]]
#@   set libname [get_attribute [current_mw_lib] name]
#@   set f_out [open write_lef.tcl "w"]
#@   puts $f_out "write_lef -output_version 5.5 -lib_name $libpath/$libname -ignore_tech_signal_em -ignore_tech_antenna_rule -ignore_cell_geom $output_file"
#@   puts $f_out "exit"
#@   close $f_out
#@   if {[catch {sh which Milkyway} id] } {
#@     puts "==>WARNING: Milkyway tool not set, techlef cannot be generated"
#@   } else {
#@     exec Milkyway -nullDisplay -nogui -tcl -file ./write_lef.tcl -logd logs/mw -cmdd logs/mw >& /dev/null
#@   } 
#@   sh rm ./write_lef.tcl
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tech.lef outputs/${INTEL_DESIGN_NAME}.${output_linkname}.tech.lef
#@ }
#@ 
#@ proc P_syn_output_def {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_SCRIPTS_SEARCH_PATH
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
#@   set file1 icc_dp.tcl
#@   if {[catch {sh which icc_shell} id] } {
#@     puts "ICC is not set , def file cannot be geneartaed"
#@   } else {
#@     set iccpath [sh which icc_shell]
#@     set_icc_dp_options -icc_executable $iccpath
#@     foreach search_dir $INTEL_SCRIPTS_SEARCH_PATH {
#@       if {[file exists [ file join $search_dir $file1]] } {
#@         set file_icc_dp [file join $search_dir $file1]
#@       }
#@     }
#@     start_icc_dp -f $file_icc_dp
#@     if { [file exists icc_dp_error] } {
#@       puts "WARNING: cannot write def file due to error in icc_dp"
#@     }
#@   }
#@ }
#@ 
#@ proc P_outputs_fp {step} {
#@   global INTEL_DESIGN_NAME
#@ 
#@   ### All floorplan contents
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tcl
#@   write_floorplan -all $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@ 
#@   ### Hard macro placements only
#@   if {[sizeof_collection [all_macro_cells]] != 0} {
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.macro_placement.tcl
#@     write_floorplan -placement { hard_macro }  -no_placement_blockage -no_bound         -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary         $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}"
#@   }
#@ 
#@   ### IO placements only
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.io_placement.tcl
#@   write_floorplan -placement { terminal }  -no_placement_blockage -no_bound       -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary       $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@ }
#@ 
#@ proc P_outputs_sdc {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   global synopsys_program_name
#@ 
#@   P_outputs_linkname
#@ 
#@   set act_scenarios ""
#@   if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
#@     set act_scenarios [all_active_scenarios]
#@   }
#@   if { $act_scenarios == ""} {
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.sdc.orig
#@     write_sdc -nosplit $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}"
#@     if { [file exists $output_file ] } {
#@       set org_sdc [ open $output_file ]
#@       set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.sdc w]
#@       while { [ gets $org_sdc line ] != -1 } {
#@         if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
#@           set new_line [concat #$line]
#@           puts $mod_sdc "$new_line"
#@         } else {
#@           puts $mod_sdc "$line"
#@         }
#@       }
#@       close $org_sdc
#@       close $mod_sdc
#@     }
#@     puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.sdc"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.sdc
#@ 
#@   } else {
#@     foreach scenario [all_active_scenarios] {
#@       set output_file outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc.orig
#@       write_sdc -nosplit $output_file
#@       puts "==>INFORMATION: Output file: ${output_file}"
#@ 
#@       #Modify SDC for PV usage
#@       if { [file exists $output_file ] } {
#@         set org_sdc [ open $output_file ]
#@         set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc w]
#@         while { [ gets $org_sdc line ] != -1 } {
#@           if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
#@             set new_line [concat #$line]
#@             puts $mod_sdc "$new_line"
#@           } else {
#@             puts $mod_sdc "$line"
#@           }
#@         }
#@         close $org_sdc
#@         close $mod_sdc
#@       }
#@       puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc"
#@       sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.${scenario}.sdc
#@     }
#@   }
#@ }
#@ 
#@ 
#@ proc P_outputs_saif {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_SAIF
#@   global synopsys_program_name
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell" } {
#@     saif_map -end
#@     saif_map -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap
#@     if {[info exists INTEL_SAIF] && $INTEL_SAIF == 1} {
#@       saif_map -type ptpx -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap.ptpx
#@ 
#@     }
#@     set_vsdc -off
#@   }
#@ }
#@ 
#@ proc P_outputs_scandef {step} {
#@   global INTEL_INSERT_SCAN
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   if {[info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN == 1} {
#@     puts "==>INFORMATION: writing a scandef since INTEL_INSERT_SCAN is set to $INTEL_INSERT_SCAN"
#@     write_scan_def -output ./outputs/${INTEL_DESIGN_NAME}.${step}.scandef
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.scandef outputs/${INTEL_DESIGN_NAME}.${output_linkname}.scandef
#@   }
#@ }
#@ 
#@ 
#@ proc P_outputs_oas {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@   P_outputs_linkname
#@   set_write_stream_options -reset
#@   set_write_stream_options       -map_fill_data       -output_first_same_name_cell       -skip_global_route_contact       -contact_prefix X       -child_depth 1000       -output_filling fill       -output_outdated_fill       -output_pin {text geometry}       -keep_data_type       -map_layer $INTEL_GDS_OUT_LAYER_MAP       -output_instance_name_as_property 112       -max_name_length 128       -output_net text
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
#@   write_stream -cells $INTEL_DESIGN_NAME -format oasis $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.oas outputs/${INTEL_DESIGN_NAME}.${output_linkname}.oas
#@ }
#@ 
#@ 
#@ #proc P_outputs_oas {step} {
#@ #   global INTEL_DESIGN_NAME
#@ #   global fdk_asic_flows_dir
#@ #
#@ #   if {$step == "fill"} {
#@ #      set output_file outputs/${INTEL_DESIGN_NAME}.apr.oas
#@ #      set gds_file outputs/${INTEL_DESIGN_NAME}.apr.gds.gz
#@ #      echo "Need GDS file to create OAS. Creating GDS..."
#@ #      P_outputs_gds apr
#@ #   } else {
#@ #      set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
#@ #      set gds_file outputs/${INTEL_DESIGN_NAME}.${step}.gds.gz
#@ #      echo "Need GDS file to create OAS. Creating GDS..."
#@ #      P_outputs_gds $step
#@ #   }
#@ #
#@ #   puts "==>INFORMATION: Generating OAS database using Calibre"
#@ #   set gds2oas_script $fdk_asic_flows_dir/apr/layout_merge_calibre.tcl
#@ #   set status [catch {sh calibredrv -64 $gds2oas_script convert $gds_file $output_file oas} msg]
#@ #   echo "$msg";
#@ #   puts "==>INFORMATION: Generated OAS database"
#@ #}
#@ 
#@ 
#@ proc P_outputs_gds {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@   P_outputs_linkname
#@   set_write_stream_options -reset
#@   set_write_stream_options       -map_fill_data       -child_depth 1000       -output_filling fill       -output_outdated_fill       -output_pin {text geometry}       -keep_data_type       -map_layer $INTEL_GDS_OUT_LAYER_MAP       -output_instance_name_as_property 112       -max_name_length 128       -output_net text       -compressed
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.gds.gz
#@   write_stream -cells $INTEL_DESIGN_NAME -format gds $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.gds.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.gds.gz
#@ }
#@ 
#@ proc P_outputs_fram {step} {
#@   global INTEL_MAX_PG_LAYER
#@   global INTEL_DESIGN_NAME
#@ 
#@   P_create_pg_terminals; #Creates PG terminals on the entire strap of top metal layer
#@ 
#@ 
#@   # Create macro fram work around give by SNPS:
#@   # 1. Create_macro_fram with default setting, so you will get the top metal layer blockages. Write out the top level blockages to a file.
#@   # 2. Create_macro_fram with no top layer blockage setting, so you can get all the VIAN-1 extracted. And then read the files contain the top level blockages to the FRAM and save the FRAM, by doing this, you get both VIAN-1 vias and the top level blockages in your FRAM view.
#@ 
#@ 
#@   # Open temp file to right fram info
#@   set fp [open "scripts/.fram.tcl" w+]
#@   set my_mw_cel [get_object_name [current_mw_cel]]
#@ 
#@ 
#@   if {$INTEL_MAX_PG_LAYER=="m12"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m14 -1.0 m15 -1.0} -extract_via_on_layer V12 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m12] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m12 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V12 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   }  elseif {$INTEL_MAX_PG_LAYER=="m11"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V11 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m11] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m11 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V11 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m10"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V10 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m10] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m10 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V10 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m9"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V9 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m9] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m9 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V9 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m8"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V8 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m8] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m8 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V8 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m7"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V7 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m7] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m7 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V7 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m6"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V6 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m6] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m6 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V6 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m5"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V5 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m5] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m5 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V5 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m4"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V4 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m4] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m4 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V4 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m3"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V3 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m3] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m3 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m4 -1.0 m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V3 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } else {
#@     P_msg_error "FRAM view is not properly created."
#@   }
#@ }
#@ 
#@ proc P_outputs_lteloc {step} {
#@   global INTEL_DESIGN_NAME
#@ 
#@   set output_file ./outputs/${INTEL_DESIGN_NAME}.${step}.xyv
#@   P_create_xyv_icc -step $step
#@   P_msg_info "Output file: ${output_file}"
#@ }
#@ 
#@ proc P_outputs {step} {
#@   global INTEL_DESIGN_NAME INTEL_UPF INTEL_SPG INTEL_INSERT_SCAN INTEL_SCAN_REPLACE_FLOPS
#@   global INTEL_OUTPUTS
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@ 
#@   if {[info exists INTEL_OUTPUTS($step)]} {
#@     set step_name $step
#@     foreach v $INTEL_OUTPUTS($step) {
#@       #         puts "==>INFORMATION: Writing an output $v"
#@       switch -exact -- $v {
#@         verilog {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_verilog $step_name
#@         }
#@         verilog_pg {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_verilog_pg $step_name
#@         }
#@         upf {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating output $v because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating output $v because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating an output $v"
#@             P_outputs_upf $step_name
#@           }
#@         }
#@         spef {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_spef $step_name
#@         }
#@         def {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_def $step_name
#@         }
#@         techlef {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_techlef $step_name
#@         }
#@         syn_def {
#@           if  { [shell_is_in_topographical_mode] && $INTEL_SPG == 1 } {
#@             puts "==>INFORMATION: Generating an output $v"
#@             P_syn_output_def $step_name
#@           } else {
#@             P_msg_warn "Skip generating def file as spg option is turned off"
#@           }
#@         }
#@         fp {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_fp $step_name
#@         }
#@         sdc {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_sdc $step_name
#@         }
#@         saif {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_saif $step_name
#@         }
#@         scandef {
#@           if {$INTEL_SCAN_REPLACE_FLOPS==1 && $INTEL_INSERT_SCAN==1} {
#@             puts "==>INFORMATION: Generating an output $v"
#@             P_outputs_scandef $step_name
#@           } else {
#@             puts "==>INFORMATION : either INTEL_INSERT_SCAN or INTEL_SCAN_REPLACE_FLOPS are turned off , No scnadef will be generated"
#@           }
#@         }
#@         oas {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_oas $step_name
#@         }
#@         gds {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_gds $step_name
#@         }
#@         lteloc {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_lteloc $step_name
#@         }
#@         fram {
#@           P_msg_info "Generating an output $v"
#@           P_outputs_fram $step_name
#@         }
#@ 
#@         default {
#@           puts "==>WARNING: The defined output is not configured at $step in the default flow"
#@         }
#@       }
#@     }
#@   } else {
#@     puts "==>WARNING: No outputs are defined at $step step in the default flow"
#@   }
#@ }
#@ 
#@ ##############################################################################
#@ ## Define procedure: P_check_place_overlap
#@ ## This proc checks for overlapped cells
#@ ## Usage: P_check_place_overlap
#@ ##############################################################################
#@ proc P_check_place_overlap {} {
#@   P_msg_info " Checking for cell overlap "
#@   set legalize_support_phys_only_cell true
#@   redirect -file ./temp_check_legality_v0.txt {check_legality -verbose}
#@   #takes care the CTS spacer cells
#@   sh grep -v "cts_fill" ./temp_check_legality_v0.txt 1> ./temp_check_legality.txt
#@ 
#@   #check if no cells overlap ( count the number of lines in the ./temp_overlap.txt )
#@   set fd [open "./temp_check_legality.txt" "r"]
#@   set count 0;
#@   set pattern "overlaps with cell"
#@   while {[gets $fd line] > -1 } {
#@     set isMatch [string match *$pattern* $line]
#@     if { $isMatch != 0 } {
#@       incr count 1
#@     }
#@   }
#@   close $fd
#@ 
#@   echo $count
#@ 
#@ 
#@   if { $count == 0 } {
#@     P_msg_info " There is no overlapped cells "
#@   } else {
#@     #there is some overlap cells, now post process that cells
#@     sh grep "overlaps with cell" ./temp_check_legality.txt 1> ./temp_overlap.txt
#@     #create awk script for log file post processing
#@     set fd [open "./temp_post_process.awk" "w"]
#@     puts $fd "{ if (NF == 9 || NF == 8)"
#@     puts $fd "   print \$3;"
#@     puts $fd " else if (NF == 10) "
#@     puts $fd "   print \$5;"
#@     puts $fd "}"
#@     close $fd
#@     #run awk script
#@     sh awk -f ./temp_post_process.awk ./temp_overlap.txt  > ./temp_overlap_cell.txt
#@     #post-process the overlapped cells
#@     set list_overlap {}
#@     set fd [open "./temp_overlap_cell.txt" "r"]
#@     while {[gets $fd line] > -1} {
#@       lappend list_overlap $line
#@     }
#@     close $fd
#@     #print cell_type and cell name of overlapped cells
#@     foreach cell_overlap $list_overlap {
#@       set cell_name [get_attribute $cell_overlap full_name]
#@       set cell_type [get_attribute $cell_overlap ref_name]
#@       P_msg_error "Overlap Cell in place: $cell_type : $cell_name"
#@     }
#@     #remove all temporary files
#@     sh rm ./temp_check_legality_v0.txt
#@     sh rm ./temp_check_legality.txt
#@     sh rm ./temp_overlap.txt
#@     sh rm ./temp_overlap_cell.txt
#@     sh rm ./temp_post_process.awk
#@   }
#@   P_msg_info " Done: Checking for cell overlap "
#@ }
#@ 
#@ ##################################################################
#@ # Procedure   : P_check_cells
#@ # Description : This proc checks if specified cells are used in the list of instances.
#@ #               when given a list of reference cell names and a list of instances,
#@ #               if the instance cell matches any cell in the reference cell list,
#@ #               it flags it as a warning or error depending on the flag.
#@ # Usage: P_check_cells <ref_list> <inst_list> <msg> <flag>
#@ # Example: P_check_cells $ref_list $inst_list $msg $flag
#@ # $ref_list : list of cells to check
#@ # $inst_list : collection of instance to check
#@ # $msg: message prefix
#@ # $flag: indicates to print as warning or error (P_msg_warn or P_msg_err)
#@ ###################################################################
#@ 
#@ proc P_check_cells {ref_list inst_list msg flag} {
#@   P_msg_info "Checking cells in the design..."
#@   #collection of instances to check
#@   set coll_of_insts $inst_list
#@   #flag message depending on the flag value: Error or Warning
#@   if { $flag == "err" } {
#@     set flag_local "P_msg_error"
#@   } elseif { $flag == "warn" } {
#@     set flag_local "P_msg_warn"
#@   } else {
#@     set flag_local "P_msg_info"
#@   }
#@   set dont_use_list [list]
#@ 
#@   foreach cell $ref_list {
#@     if {$cell ne ""} {
#@       set pattern "(ref_name=~[join $cell {) || (ref_name =~} ])"
#@       lappend dont_use_list $pattern
#@     }
#@   }
#@   set dont_use_expr [join $dont_use_list || ]
#@   set ic_cntr  0
#@   foreach_in_collection c [get_cells $inst_list -filter "is_hierarchical==false && $dont_use_expr"  -quiet] {
#@     set c_name [get_attribute $c full_name]
#@     $flag_local "$c_name is a $msg [get_attribute $c ref_name]"
#@     incr ic_cntr
#@   }
#@ 
#@   if {!$ic_cntr} {
#@     P_msg_info "No dont_use cells found in your design"
#@   } else {
#@     $flag_local "$ic_cntr dont_use cells found in your design"
#@   }
#@ 
#@   P_msg_info "Done: Checking cells in the design..."
#@ }
#@ 
#@ define_proc_attributes P_check_cells     -info "Procedure to check if ref cells are used in the list of instances"
#@ 
#@ 
#@ ###########################################################################################
#@ # check if there are any shorts or opens or floating on power/ground nets
#@ # The script parse the verify_lvs reports
#@ # if there are any shorts/opens/floatings on PG, this script will issue an error message
#@ # if user see error message, user may look more detail on the verify_lvs reports
#@ 
#@ ###########################################################################################
#@ 
#@ proc P_check_power_ground_nets {} {
#@   P_msg_info "Check if there are any shorts or opens on power/ground nets"
#@ 
#@   #set DEBUG 1
#@   set DEBUG 0
#@   global INTEL_MW_POWER_NET INTEL_MW_GROUND_NET
#@ 
#@   set icc_pg_nets "$INTEL_MW_POWER_NET $INTEL_MW_GROUND_NET"
#@   redirect -file ./temp_verify_lvs_pg.txt {verify_lvs  -nets $icc_pg_nets }
#@ 
#@   set fd [open "./temp_verify_lvs_pg.txt" "r"]
#@   set err_count 0; set war_count 0;
#@   set pattern1 "Total Floating Nets are 1"
#@   set pattern2 "Total Floating Nets are 2"
#@   set pattern3 "Total SHORT Nets are 1"
#@   set pattern4 "Total SHORT Nets are 2"
#@   set pattern5 "Total OPEN Nets are 1"
#@   set pattern6 "Total OPEN Nets are 2"
#@ 
#@   while {[gets $fd line] > -1} {
#@     set isMatch1 [string match *$pattern1* $line]
#@     set isMatch2 [string match *$pattern2* $line]
#@     set isMatch3 [string match *$pattern3* $line]
#@     set isMatch4 [string match *$pattern4* $line]
#@     set isMatch5 [string match *$pattern5* $line]
#@     set isMatch6 [string match *$pattern5* $line]
#@     set errMatch [expr $isMatch3 || $isMatch4 || $isMatch5 || $isMatch6]
#@     set warMatch [expr $isMatch1 || $isMatch2]
#@     if { $errMatch != 0 } {
#@       incr err_count 1;
#@     }
#@     if { $warMatch != 0 } {
#@       incr war_count 1;
#@     }
#@   }
#@   close $fd
#@ 
#@   if {$DEBUG} {puts $err_count}
#@ 
#@   if { $err_count > 0 } {
#@     P_msg_error " Power/Ground net has short/open\n                Please review the verify_lvs reports for more information"
#@   }
#@   if { $war_count > 0 } {
#@     P_msg_warn " Power/Ground net has floating\n                Please review the verify_lvs reports for more information"
#@   }
#@ 
#@   #unset temporary variables
#@   unset -nocomplain pattern1 pattern2 pattern3 pattern4 pattern5 pattern6 isMatch1 isMatch2 isMatch4 isMatch5 isMatch6 anyMatch count icc_pg_nets fd
#@   #remove all temporary files
#@   sh rm ./temp_verify_lvs_pg.txt
#@   P_msg_info "Done: Check if there are any shorts or opens on power/ground nets"
#@ 
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## End Of File
#@ ## -----------------------------------------------------------------------------
#@ 
#@ puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- Starting source /p/foundry/eda/em64t_SLES11/designcompiler/J-2014.09/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ # msgcat.tcl --
#@ #
#@ #	This file defines various procedures which implement a
#@ #	message catalog facility for Tcl programs.  It should be
#@ #	loaded with the command "package require msgcat".
#@ #
#@ # Copyright (c) 1998-2000 by Ajuba Solutions.
#@ # Copyright (c) 1998 by Mark Harrison.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ package require Tcl 8.5
#@ # When the version number changes, be sure to update the pkgIndex.tcl file,
#@ # and the installation directory in the Makefiles.
#@ package provide msgcat 1.4.5
#@ 
#@ namespace eval msgcat {
#@     namespace export mc mcload mclocale mcmax mcmset mcpreferences mcset 	    mcunknown
#@ 
#@     # Records the current locale as passed to mclocale
#@     variable Locale ""
#@ 
#@     # Records the list of locales to search
#@     variable Loclist {}
#@ 
#@     # Records the mapping between source strings and translated strings.  The
#@     # dict key is of the form "<locale> <namespace> <src>", where locale and
#@     # namespace should be themselves dict values and the value is
#@     # the translated string.
#@     variable Msgs [dict create]
#@ 
#@     # Map of language codes used in Windows registry to those of ISO-639
#@     if {[info sharedlibextension] eq ".dll"} {
#@ 	variable WinRegToISO639 [dict create  {*}{
#@ 	    01 ar 0401 ar_SA 0801 ar_IQ 0c01 ar_EG 1001 ar_LY 1401 ar_DZ
#@ 		  1801 ar_MA 1c01 ar_TN 2001 ar_OM 2401 ar_YE 2801 ar_SY
#@ 		  2c01 ar_JO 3001 ar_LB 3401 ar_KW 3801 ar_AE 3c01 ar_BH
#@ 		  4001 ar_QA
#@ 	    02 bg 0402 bg_BG
#@ 	    03 ca 0403 ca_ES
#@ 	    04 zh 0404 zh_TW 0804 zh_CN 0c04 zh_HK 1004 zh_SG 1404 zh_MO
#@ 	    05 cs 0405 cs_CZ
#@ 	    06 da 0406 da_DK
#@ 	    07 de 0407 de_DE 0807 de_CH 0c07 de_AT 1007 de_LU 1407 de_LI
#@ 	    08 el 0408 el_GR
#@ 	    09 en 0409 en_US 0809 en_GB 0c09 en_AU 1009 en_CA 1409 en_NZ
#@ 		  1809 en_IE 1c09 en_ZA 2009 en_JM 2409 en_GD 2809 en_BZ
#@ 		  2c09 en_TT 3009 en_ZW 3409 en_PH
#@ 	    0a es 040a es_ES 080a es_MX 0c0a es_ES@modern 100a es_GT 140a es_CR
#@ 		  180a es_PA 1c0a es_DO 200a es_VE 240a es_CO 280a es_PE
#@ 		  2c0a es_AR 300a es_EC 340a es_CL 380a es_UY 3c0a es_PY
#@ 		  400a es_BO 440a es_SV 480a es_HN 4c0a es_NI 500a es_PR
#@ 	    0b fi 040b fi_FI
#@ 	    0c fr 040c fr_FR 080c fr_BE 0c0c fr_CA 100c fr_CH 140c fr_LU
#@ 		  180c fr_MC
#@ 	    0d he 040d he_IL
#@ 	    0e hu 040e hu_HU
#@ 	    0f is 040f is_IS
#@ 	    10 it 0410 it_IT 0810 it_CH
#@ 	    11 ja 0411 ja_JP
#@ 	    12 ko 0412 ko_KR
#@ 	    13 nl 0413 nl_NL 0813 nl_BE
#@ 	    14 no 0414 no_NO 0814 nn_NO
#@ 	    15 pl 0415 pl_PL
#@ 	    16 pt 0416 pt_BR 0816 pt_PT
#@ 	    17 rm 0417 rm_CH
#@ 	    18 ro 0418 ro_RO 0818 ro_MO
#@ 	    19 ru 0819 ru_MO
#@ 	    1a hr 041a hr_HR 081a sr_YU 0c1a sr_YU@cyrillic
#@ 	    1b sk 041b sk_SK
#@ 	    1c sq 041c sq_AL
#@ 	    1d sv 041d sv_SE 081d sv_FI
#@ 	    1e th 041e th_TH
#@ 	    1f tr 041f tr_TR
#@ 	    20 ur 0420 ur_PK 0820 ur_IN
#@ 	    21 id 0421 id_ID
#@ 	    22 uk 0422 uk_UA
#@ 	    23 be 0423 be_BY
#@ 	    24 sl 0424 sl_SI
#@ 	    25 et 0425 et_EE
#@ 	    26 lv 0426 lv_LV
#@ 	    27 lt 0427 lt_LT
#@ 	    28 tg 0428 tg_TJ
#@ 	    29 fa 0429 fa_IR
#@ 	    2a vi 042a vi_VN
#@ 	    2b hy 042b hy_AM
#@ 	    2c az 042c az_AZ@latin 082c az_AZ@cyrillic
#@ 	    2d eu
#@ 	    2e wen 042e wen_DE
#@ 	    2f mk 042f mk_MK
#@ 	    30 bnt 0430 bnt_TZ
#@ 	    31 ts 0431 ts_ZA
#@ 	    32 tn
#@ 	    33 ven 0433 ven_ZA
#@ 	    34 xh 0434 xh_ZA
#@ 	    35 zu 0435 zu_ZA
#@ 	    36 af 0436 af_ZA
#@ 	    37 ka 0437 ka_GE
#@ 	    38 fo 0438 fo_FO
#@ 	    39 hi 0439 hi_IN
#@ 	    3a mt 043a mt_MT
#@ 	    3b se 043b se_NO
#@ 	    043c gd_UK 083c ga_IE
#@ 	    3d yi 043d yi_IL
#@ 	    3e ms 043e ms_MY 083e ms_BN
#@ 	    3f kk 043f kk_KZ
#@ 	    40 ky 0440 ky_KG
#@ 	    41 sw 0441 sw_KE
#@ 	    42 tk 0442 tk_TM
#@ 	    43 uz 0443 uz_UZ@latin 0843 uz_UZ@cyrillic
#@ 	    44 tt 0444 tt_RU
#@ 	    45 bn 0445 bn_IN
#@ 	    46 pa 0446 pa_IN
#@ 	    47 gu 0447 gu_IN
#@ 	    48 or 0448 or_IN
#@ 	    49 ta
#@ 	    4a te 044a te_IN
#@ 	    4b kn 044b kn_IN
#@ 	    4c ml 044c ml_IN
#@ 	    4d as 044d as_IN
#@ 	    4e mr 044e mr_IN
#@ 	    4f sa 044f sa_IN
#@ 	    50 mn
#@ 	    51 bo 0451 bo_CN
#@ 	    52 cy 0452 cy_GB
#@ 	    53 km 0453 km_KH
#@ 	    54 lo 0454 lo_LA
#@ 	    55 my 0455 my_MM
#@ 	    56 gl 0456 gl_ES
#@ 	    57 kok 0457 kok_IN
#@ 	    58 mni 0458 mni_IN
#@ 	    59 sd
#@ 	    5a syr 045a syr_TR
#@ 	    5b si 045b si_LK
#@ 	    5c chr 045c chr_US
#@ 	    5d iu 045d iu_CA
#@ 	    5e am 045e am_ET
#@ 	    5f ber 045f ber_MA
#@ 	    60 ks 0460 ks_PK 0860 ks_IN
#@ 	    61 ne 0461 ne_NP 0861 ne_IN
#@ 	    62 fy 0462 fy_NL
#@ 	    63 ps
#@ 	    64 tl 0464 tl_PH
#@ 	    65 div 0465 div_MV
#@ 	    66 bin 0466 bin_NG
#@ 	    67 ful 0467 ful_NG
#@ 	    68 ha 0468 ha_NG
#@ 	    69 nic 0469 nic_NG
#@ 	    6a yo 046a yo_NG
#@ 	    70 ibo 0470 ibo_NG
#@ 	    71 kau 0471 kau_NG
#@ 	    72 om 0472 om_ET
#@ 	    73 ti 0473 ti_ET
#@ 	    74 gn 0474 gn_PY
#@ 	    75 cpe 0475 cpe_US
#@ 	    76 la 0476 la_VA
#@ 	    77 so 0477 so_SO
#@ 	    78 sit 0478 sit_CN
#@ 	    79 pap 0479 pap_AN
#@ 	}]
#@     }
#@ }
#@ 
#@ # msgcat::mc --
#@ #
#@ #	Find the translation for the given string based on the current
#@ #	locale setting. Check the local namespace first, then look in each
#@ #	parent namespace until the source is found.  If additional args are
#@ #	specified, use the format command to work them into the traslated
#@ #	string.
#@ #
#@ # Arguments:
#@ #	src	The string to translate.
#@ #	args	Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated string.  Propagates errors thrown by the
#@ #	format command.
#@ 
#@ proc msgcat::mc {src args} {
#@     # Check for the src in each namespace starting from the local and
#@     # ending in the global.
#@ 
#@     variable Msgs
#@     variable Loclist
#@     variable Locale
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     while {$ns != ""} {
#@ 	foreach loc $Loclist {
#@ 	    if {[dict exists $Msgs $loc $ns $src]} {
#@ 		if {[llength $args] == 0} {
#@ 		    return [dict get $Msgs $loc $ns $src]
#@ 		} else {
#@ 		    return [format [dict get $Msgs $loc $ns $src] {*}$args]
#@ 		}
#@ 	    }
#@ 	}
#@ 	set ns [namespace parent $ns]
#@     }
#@     # we have not found the translation
#@     return [uplevel 1 [list [namespace origin mcunknown] 	    $Locale $src {*}$args]]
#@ }
#@ 
#@ # msgcat::mclocale --
#@ #
#@ #	Query or set the current locale.
#@ #
#@ # Arguments:
#@ #	newLocale	(Optional) The new locale string. Locale strings
#@ #			should be composed of one or more sublocale parts
#@ #			separated by underscores (e.g. en_US).
#@ #
#@ # Results:
#@ #	Returns the current locale.
#@ 
#@ proc msgcat::mclocale {args} {
#@     variable Loclist
#@     variable Locale
#@     set len [llength $args]
#@ 
#@     if {$len > 1} {
#@ 	return -code error "wrong # args: should be		\"[lindex [info level 0] 0] ?newLocale?\""
#@     }
#@ 
#@     if {$len == 1} {
#@ 	set newLocale [lindex $args 0]
#@ 	if {$newLocale ne [file tail $newLocale]} {
#@ 	    return -code error "invalid newLocale value \"$newLocale\":		    could be path to unsafe code."
#@ 	}
#@ 	set Locale [string tolower $newLocale]
#@ 	set Loclist {}
#@ 	set word ""
#@ 	foreach part [split $Locale _] {
#@ 	    set word [string trim "${word}_${part}" _]
#@ 	    if {$word ne [lindex $Loclist 0]} {
#@ 		set Loclist [linsert $Loclist 0 $word]
#@ 	    }
#@ 	}
#@ 	lappend Loclist {}
#@ 	set Locale [lindex $Loclist 0]
#@     }
#@     return $Locale
#@ }
#@ 
#@ # msgcat::mcpreferences --
#@ #
#@ #	Fetch the list of locales used to look up strings, ordered from
#@ #	most preferred to least preferred.
#@ #
#@ # Arguments:
#@ #	None.
#@ #
#@ # Results:
#@ #	Returns an ordered list of the locales preferred by the user.
#@ 
#@ proc msgcat::mcpreferences {} {
#@     variable Loclist
#@     return $Loclist
#@ }
#@ 
#@ # msgcat::mcload --
#@ #
#@ #	Attempt to load message catalogs for each locale in the
#@ #	preference list from the specified directory.
#@ #
#@ # Arguments:
#@ #	langdir		The directory to search.
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::mcload {langdir} {
#@     set x 0
#@     foreach p [mcpreferences] {
#@ 	if { $p eq {} } {
#@ 	    set p ROOT
#@ 	}
#@ 	set langfile [file join $langdir $p.msg]
#@ 	if {[file exists $langfile]} {
#@ 	    incr x
#@ 	    uplevel 1 [list ::source -encoding utf-8 $langfile]
#@ 	}
#@     }
#@     return $x
#@ }
#@ 
#@ # msgcat::mcset --
#@ #
#@ #	Set the translation for a given string in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	src		The source string.
#@ #	dest		(Optional) The translated string.  If omitted,
#@ #			the source string is used.
#@ #
#@ # Results:
#@ #	Returns the new locale.
#@ 
#@ proc msgcat::mcset {locale src {dest ""}} {
#@     variable Msgs
#@     if {[llength [info level 0]] == 3} { ;# dest not specified
#@ 	set dest $src
#@     }
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     set locale [string tolower $locale]
#@ 
#@     dict set Msgs $locale $ns $src $dest
#@     return $dest
#@ }
#@ 
#@ # msgcat::mcmset --
#@ #
#@ #	Set the translation for multiple strings in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	pairs		One or more src/dest pairs (must be even length)
#@ #
#@ # Results:
#@ #	Returns the number of pairs processed
#@ 
#@ proc msgcat::mcmset {locale pairs } {
#@     variable Msgs
#@ 
#@     set length [llength $pairs]
#@     if {$length % 2} {
#@ 	return -code error "bad translation list:		 should be \"[lindex [info level 0] 0] locale {src dest ...}\""
#@     }
#@ 
#@     set locale [string tolower $locale]
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     foreach {src dest} $pairs {
#@ 	dict set Msgs $locale $ns $src $dest
#@     }
#@ 
#@     return $length
#@ }
#@ 
#@ # msgcat::mcunknown --
#@ #
#@ #	This routine is called by msgcat::mc if a translation cannot
#@ #	be found for a string.  This routine is intended to be replaced
#@ #	by an application specific routine for error reporting
#@ #	purposes.  The default behavior is to return the source string.
#@ #	If additional args are specified, the format command will be used
#@ #	to work them into the traslated string.
#@ #
#@ # Arguments:
#@ #	locale		The current locale.
#@ #	src		The string to be translated.
#@ #	args		Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated value.
#@ 
#@ proc msgcat::mcunknown {locale src args} {
#@     if {[llength $args]} {
#@ 	return [format $src {*}$args]
#@     } else {
#@ 	return $src
#@     }
#@ }
#@ 
#@ # msgcat::mcmax --
#@ #
#@ #	Calculates the maximum length of the translated strings of the given
#@ #	list.
#@ #
#@ # Arguments:
#@ #	args	strings to translate.
#@ #
#@ # Results:
#@ #	Returns the length of the longest translated string.
#@ 
#@ proc msgcat::mcmax {args} {
#@     set max 0
#@     foreach string $args {
#@ 	set translated [uplevel 1 [list [namespace origin mc] $string]]
#@ 	set len [string length $translated]
#@ 	if {$len>$max} {
#@ 	    set max $len
#@ 	}
#@     }
#@     return $max
#@ }
#@ 
#@ # Convert the locale values stored in environment variables to a form
#@ # suitable for passing to [mclocale]
#@ proc msgcat::ConvertLocale {value} {
#@     # Assume $value is of form: $language[_$territory][.$codeset][@modifier]
#@     # Convert to form: $language[_$territory][_$modifier]
#@     #
#@     # Comment out expanded RE version -- bugs alleged
#@     # regexp -expanded {
#@     #	^		# Match all the way to the beginning
#@     #	([^_.@]*)	# Match "lanugage"; ends with _, ., or @
#@     #	(_([^.@]*))?	# Match (optional) "territory"; starts with _
#@     #	([.]([^@]*))?	# Match (optional) "codeset"; starts with .
#@     #	(@(.*))?	# Match (optional) "modifier"; starts with @
#@     #	$		# Match all the way to the end
#@     # } $value -> language _ territory _ codeset _ modifier
#@     if {![regexp {^([^_.@]+)(_([^.@]*))?([.]([^@]*))?(@(.*))?$} $value 	    -> language _ territory _ codeset _ modifier]} {
#@ 	return -code error "invalid locale '$value': empty language part"
#@     }
#@     set ret $language
#@     if {[string length $territory]} {
#@ 	append ret _$territory
#@     }
#@     if {[string length $modifier]} {
#@ 	append ret _$modifier
#@     }
#@     return $ret
#@ }
#@ 
#@ # Initialize the default locale
#@ proc msgcat::Init {} {
#@     global env
#@ 
#@     #
#@     # set default locale, try to get from environment
#@     #
#@     foreach varName {LC_ALL LC_MESSAGES LANG} {
#@ 	if {[info exists env($varName)] && ("" ne $env($varName))} {
#@ 	    if {![catch {
#@ 		mclocale [ConvertLocale $env($varName)]
#@ 	    }]} {
#@ 		return
#@ 	    }
#@ 	}
#@     }
#@     #
#@     # On Darwin, fallback to current CFLocale identifier if available.
#@     #
#@     if {[info exists ::tcl::mac::locale] && $::tcl::mac::locale ne ""} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $::tcl::mac::locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@     #
#@     # The rest of this routine is special processing for Windows or
#@     # Cygwin. All other platforms, get out now.
#@     #
#@     if {([info sharedlibextension] ne ".dll")
#@ 	    || [catch {package require registry}]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # On Windows or Cygwin, try to set locale depending on registry
#@     # settings, or fall back on locale of "C".
#@     #
#@ 
#@     # First check registry value LocalName present from Windows Vista
#@     # which contains the local string as RFC5646, composed of:
#@     # [a-z]{2,3} : language
#@     # -[a-z]{4}  : script (optional, translated by table Latn->latin)
#@     # -[a-z]{2}|[0-9]{3} : territory (optional, numerical region codes not used)
#@     # (-.*)* : variant, extension, private use (optional, not used)
#@     # Those are translated to local strings.
#@     # Examples: de-CH -> de_ch, sr-Latn-CS -> sr_cs@latin, es-419 -> es
#@     #
#@     set key {HKEY_CURRENT_USER\Control Panel\International}
#@     if {([registry values $key "LocaleName"] ne "")
#@ 	    && [regexp {^([a-z]{2,3})(?:-([a-z]{4}))?(?:-([a-z]{2}))?(?:-.+)?$}	    [string tolower [registry get $key "LocaleName"]] match locale	    script territory]} {
#@ 	if {"" ne $territory} {
#@ 	    append locale _ $territory
#@ 	}
#@ 	set modifierDict [dict create latn latin cyrl cyrillic]
#@ 	if {[dict exists $modifierDict $script]} {
#@ 	    append locale @ [dict get $modifierDict $script]
#@ 	}
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@ 
#@     # then check key locale which contains a numerical language ID
#@     if {[catch {
#@ 	set locale [registry get $key "locale"]
#@     }]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # Keep trying to match against smaller and smaller suffixes
#@     # of the registry value, since the latter hexadigits appear
#@     # to determine general language and earlier hexadigits determine
#@     # more precise information, such as territory.  For example,
#@     #     0409 - English - United States
#@     #     0809 - English - United Kingdom
#@     # Add more translations to the WinRegToISO639 array above.
#@     #
#@     variable WinRegToISO639
#@     set locale [string tolower $locale]
#@     while {[string length $locale]} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale [dict get $WinRegToISO639 $locale]]
#@ 	}]} {
#@ 	    return
#@ 	}
#@ 	set locale [string range $locale 1 end]
#@     }
#@     #
#@     # No translation known.  Fall back on "C" locale
#@     #
#@     mclocale C
#@ }
#@ msgcat::Init
#@ # -- End source /p/foundry/eda/em64t_SLES11/designcompiler/J-2014.09/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/common/procs.tcl

#@ 
#@ P_source_if_exists tooltype.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/tooltype.tcl

#@ ##############################################################################
#@ #
#@ # Procedures to  return 1/0 if running under certain tools.
#@ # Enable these for ALL tools so if/then logic can be used no matter where
#@ #
#@ 
#@ proc P_is_synopsys_tool { args } {
#@   parse_proc_arguments -args $args arg
#@ 
#@   global synopsys_program_name
#@   global sh_product_version
#@   global INTEL_SYNOPSYS_PROGRAM_SUITE
#@ 
#@   if {![info exists INTEL_SYNOPSYS_PROGRAM_SUITE]} {
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(DC)   {dc_shell design_vision design_analyzer de_shell}
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(PT)   {pt_shell primetime}
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(PSYN) {psyn_shell psyn_gui}
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(ICC)  {icc_shell}
#@   }
#@ 
#@   if {[info exists synopsys_program_name] && $synopsys_program_name != ""} {
#@     # Valid tool name?
#@     if {[lsearch -exact [array names INTEL_SYNOPSYS_PROGRAM_SUITE] $arg(tool)] == -1} {
#@       P_warning "Tool '$arg(tool)' not programmed in 'INTEL_SYNOPSYS_PROGRAM_SUITE'"
#@       return 0
#@     }
#@     # Does synopsys_program_name match the programmed strings?
#@     if {[lsearch -exact $INTEL_SYNOPSYS_PROGRAM_SUITE($arg(tool)) $synopsys_program_name] == -1} {
#@       return 0
#@     }
#@     # If the version is given, does it match current version?
#@     if {[info exists sh_product_version] &&             [info exists arg(version)]} {
#@       if {![string match $arg(version) $sh_product_version]} {
#@         return 0
#@       }
#@     }
#@     # All checks passed, return 1
#@     return 1
#@   } else {
#@     return 0
#@   }
#@   return 1
#@ }
#@ define_proc_attributes P_is_synopsys_tool     -info "Returns 1 if procedure was executed within the given Synopsys tool & version, 0 otherwise"     -define_args {
#@       {tool "Name of synopsys tool (as programmed in 'INTEL_SYNOPSYS_PROGRAM_SUITE')" toolname string required}
#@       {version "Version of synopsys tool"                                        version  string optional}
#@     }
#@ 
#@ 
#@ proc P_is_DC { args } {
#@ 
#@   set tool_name "DC"
#@   parse_proc_arguments -args $args arg
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_DC     -info "Returns 1 if current Synopsys tool is specified version (optional) of Design-Compiler/Design-Vision/Design-Analyzer, 0 otherwise"     -define_args {
#@       {version "Version of DC"                                                   version  string optional}
#@     }
#@ 
#@ 
#@ proc P_is_PT { args } {
#@   set tool_name "PT"
#@   parse_proc_arguments -args $args arg
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_PT     -info "Returns 1 if current Synopsys tool is specified version (optional) of PrimeTime, 0 otherwise"     -define_args {
#@       {version "Version of PT"                                                   version  string optional}
#@     }
#@ 
#@ 
#@ proc P_is_PSYN { args } {
#@   set tool_name "PSYN"
#@   parse_proc_arguments -args $args arg
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_PSYN     -info "Returns 1 if current Synopsys tool is specified version (optional) of Physical-Compiler, 0 otherwise"     -define_args {
#@       {version "Version of PSYN"                                                   version  string optional}
#@     }
#@ 
#@ proc P_is_PC { args } {
#@   return [P_is_PSYN $args]
#@ }
#@ 
#@ 
#@ # Command to check if you are in icc_shell
#@ proc P_is_ICC { args } {
#@   set tool_name "ICC"
#@   parse_proc_arguments -args $args arg
#@ 
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_ICC     -info "Returns 1 if current Synopsys tool is specified version (optional) of IC-Compiler, 0 otherwise"     -define_args {
#@       {version "Version of ICC"                                                   version  string optional}
#@     }
#@ 
#@ # some synopsys tool (don't care which)
#@ proc P_is_SNPS { } {
#@   global sh_product_version
#@   if {[info exists sh_product_version]} {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ 
#@ proc P_is_ENCOUNTER { } {
#@   global encounterVersion
#@   if {[info exists encounterVersion]} {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ proc P_is_FE { } {
#@   return [P_is_ENCOUNTER]
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/tooltype.tcl

#@ P_source_if_exists procs_common.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/procs_common.tcl

#@ ##############################################################################
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_run_CheckDiskSpace
#@ # Description : This script will check the use percentage and cautions the user
#@ 
#@ proc P_run_CheckDiskSpace { } {
#@ 
#@   #set threshold
#@   set lowLimit "95%"
#@ 
#@   set perc [exec df -k . | awk {{print $4}} | sed -n "2,14 p"]
#@ 
#@   #define condition
#@   if {$perc > $lowLimit} {
#@     echo "\n CAUTION: Available Disk Space is at $perc , Your disk space is approaching full and is less than the default low limits set. Please ensure sufficient diskspace to run complete APR flow on the design.\n"
#@   } else {
#@     echo "\n Available Disk Space is at $perc. Disk space is design dependant, continue to monitor the available space on your disk.\n"
#@   }
#@ 
#@ }
#@ 
#@ 
#@ ################################################################################
#@ 
#@ ############################################################
#@ # Procedure   : P_lsearch
#@ # Input(s)    : ?mode? ;# Optional, can be "-glob", "-regexp", "-exact"
#@ #                      ;# Default: -glob
#@ #                list  ;# List to search
#@ #                pattern ;# Search pattern
#@ # Output(s)   : list ;# List containing all elements matching the pattern
#@ # Help line   : Returns list containing all elements matching specified pattern
#@ # Description : This is a "modified" lsearch command.  lsearch only returns
#@ #               the index of the first element it finds in the list.  This
#@ #               procedure finds all the elements matching the pattern
#@ #               and returns all the elements as a list.
#@ #               Default "mode" is "-glob"
#@ #
#@ # Example(s)  : <set list1 "My1 My2 Your1 Your2 SoMe SOME"
#@ #               <T_lsearch $list1 "My1"
#@ #               >"My1"
#@ #
#@ #               <T_lsearch $list1 "My"
#@ #               >""
#@ #               Note that "My" does not match anything, however "My*"
#@ #               will match.
#@ #
#@ #               <T_lsearch $list1 "My*"
#@ #               >"My1 My2"
#@ #
#@ #               <T_lsearch $list1 "*2"
#@ #               >"My2 Your2"
#@ #
#@ #               <T_lsearch $list1 "Some"
#@ #               >"My2 Your2"
#@ #
#@ #               <T_lsearch -regexp $list1 "^(S)+(\[oO])+"
#@ #               >"SoMe SOME"
#@ #
#@ # Note(s)     :
#@ #
#@ proc P_lsearch { args } {
#@   set return_val ""
#@ 
#@   set convert ""
#@ 
#@   # Get all the arguments
#@   set mode ""
#@   set list ""
#@   set pattern ""
#@   if {[regexp "^(-)" $args] == 1} {
#@     set mode [lindex $args 0]
#@     set i 1
#@   } else {
#@     set mode "-glob"
#@     set i 0
#@   }
#@   set list [lindex $args $i]
#@   set pattern [lindex $args [incr i]]
#@ 
#@   # Build the list of elements that match the pattern
#@   # Have to do the following cause TCL will not accept "" as
#@   # the mode
#@   if {$convert != ""} {
#@     set index [lsearch $mode [string $convert $list] [string $convert $pattern]]
#@   } else {
#@     set index [lsearch $mode $list $pattern]
#@   }
#@   while {$index >= 0} {
#@     # Append the element found to the return list
#@     lappend return_val [lindex $list $index]
#@     # Remove the element from the original list
#@     set list [lrange $list [expr $index + 1] end]
#@     if {$convert != ""} {
#@       set index [lsearch $mode [string $convert $list] [string $convert $pattern]]
#@     } else {
#@       set index [lsearch $mode $list $pattern]
#@     }
#@   }
#@   return $return_val
#@ }
#@ 
#@ ############################################################
#@ # Procedure   : P_lminus
#@ # Input(s)    : list1  ;# First list
#@ #               list2  ;# Second list
#@ # Output(s)   : list
#@ # Help line   : Takes out list2 elements from list1, i.e. list1 - list2
#@ # Description : For each element in list2, this function finds
#@ #               exact matching element in list1 and removes it.
#@ #               It returns the new list1 with all list2 elements
#@ #               removed.
#@ # Example(s)  : <set list1 "a b c"
#@ #               <set list2 "d c"
#@ #               <T_lminus $list1 $list2
#@ #               >"a b"
#@ # Note(s)     :
#@ proc P_lminus { args } {
#@   set list1 [lindex $args 0]
#@   set list2 [lindex $args 1]
#@   set return_list $list1
#@   set found ""
#@   set element ""
#@   foreach element $list2 {
#@     set found [lsearch -exact $return_list $element]
#@     if {$found != -1} {
#@       set return_list [lreplace $return_list $found $found]
#@     }
#@   }
#@   return $return_list
#@ }
#@ 
#@ 
#@ ############################################################
#@ # Procedure   : P_lminus_r (REVERSE OF P_lminus)
#@ # Input(s)    : list1  ;# First list
#@ #               list2  ;# Second list
#@ # Output(s)   : list
#@ # Help line   : Takes out list2 elements from list1, i.e. list1 - list2 IN REVERSE
#@ # Description : For each element in list2, this function finds
#@ #               exact matching element in list1 and removes it.
#@ #               It returns the new list1 with all list2 elements
#@ #               removed.
#@ # Example(s)  : <set list1 "a b c"
#@ #               <set list2 "d c"
#@ #               <T_lminus $list1 $list2
#@ #               >"a b"
#@ # Note(s)     :
#@ proc P_lminus_r {args} {
#@ 
#@   set list1 [lindex $args 0]
#@   set list2 [lindex $args 1]
#@   set return_list $list1
#@   set found ""
#@   set element ""
#@   foreach element $list2 {
#@     set found [lindex [lsearch -all -exact $return_list $element] end]
#@     if {$found != -1} {
#@       set return_list [lreplace $return_list $found $found]
#@     }
#@   }
#@   return $return_list
#@ }
#@ 
#@ ############################################################
#@ # Procedure   : P_true
#@ # Input(s)    : value ;# Can be anything!
#@ # Output(s)   : 0 ;# when value = false or 0 or ""
#@ #               1 ;# when value = true or 1 or non-empty string
#@ #               $value ;# when value is numeric and non-zero
#@ # Help line   : Returns 0 or 1 or $value depeninding on contents of value
#@ # Description : Returns 0 when value is "false" or "0" or ""
#@ #               Returns 1 when value is "true" or non-empty string
#@ #               Returns $value when value is numeric and non-zero
#@ # Example(s)  : <set a 4
#@ #               <T_true $a
#@ #               >4
#@ #
#@ #               <set b ""
#@ #               <if {[P_true $b]} {
#@ #               <  puts "List not empty!"
#@ #               <} else {
#@ #               <  puts "nothing!"
#@ #               <}
#@ #               >nothing!
#@ #
#@ # Note(s)     :
#@ #
#@ proc P_true { args } {
#@ 
#@   set value [lindex $args 0]
#@ 
#@   # numeric
#@   if {[string match {[0-9]} $value]} {
#@     if {$value != 0} {
#@       return $value
#@     } else {
#@       return 0
#@     }
#@   } elseif {$value == "false" || $value == ""} {
#@     return 0
#@   } elseif {$value == "true" || $value != ""} {
#@     return 1
#@   }
#@ }
#@ 
#@ ############################################################
#@ # Procedure   : P_eval
#@ # Input(s)    : cmd
#@ # Output(s)   : none
#@ # Help line   : Returns 0/1 based on successful execution of the
#@ #               Tcl command "cmd".  Prints error msg to stderr if it fails.
#@ # Description : Executed the "cmd" if it is a valid tcl command.
#@ #               If an error is produced during execution,
#@ #               gives out the command at execution and the
#@ #               error message.
#@ # Example(s)  : <if {[P_eval {puts some}]} {
#@ #               < puts "ok!"
#@ #               <}
#@ #               >ok!
#@ #
#@ #               <if {[P_eval {puts some some}]} {
#@ #               < puts "ok!"
#@ #               <}
#@ #               >T_eval: Error executing: "puts some some"
#@ #               >can not find channel named "some"
#@ #
#@ # Note(s)     :
#@ #
#@ proc P_eval { args } {
#@ 
#@   set cmd [lindex $args 0]
#@   set success 1
#@   set error_msg ""
#@   set catch_val 0
#@ 
#@   if {[info complete $cmd]} {
#@     set catch_val [catch {eval $cmd} error_msg]
#@ 
#@     # puts "Executing $cmd"
#@     if {$catch_val == 1} {
#@       puts stderr "T_eval-ERROR: Error executing: \"$cmd\""
#@       puts stderr "T_eval-ERROR: $error_msg"
#@       set success 0
#@     }
#@   } else {
#@     puts stderr "T_eval-ERROR: \"$cmd\" is not a complete tcl command"
#@     set success 0
#@   }
#@ 
#@   return $success
#@ }
#@ 
#@ 
#@ 
#@ ############################################################
#@ # Procedure   : P_lcommon
#@ # Input(s)    : list1  ;# First list
#@ #               list2  ;# Second list
#@ # Output(s)   : list
#@ # Description : Returns a list of common elements in both lists
#@ #
#@ proc P_lcommon { args } {
#@   set list1 [lindex $args 0]
#@   set list2 [lindex $args 1]
#@ 
#@   set return_list ""
#@   if { [llength $list1] > [llength $list2] } {
#@     set nlist1 $list2
#@     set nlist2 $list1
#@   } else {
#@     set nlist1 $list1
#@     set nlist2 $list2
#@   }
#@   foreach element $nlist1 {
#@     set add [expr [lsearch -exact $nlist2 $element] != -1]
#@     set redundunt [expr [lsearch -exact $return_list $element] != -1]
#@     if {[expr $add && !$redundunt] } {
#@       lappend return_list $element
#@     }
#@   }
#@   return $return_list
#@ }
#@ 
#@ 
#@ ############################################################
#@ # Procedure   : P_sel2list
#@ # Input(s)    : selection ;# Any selection
#@ # Output(s)   : list ;# Selection contents in list form
#@ # Help line   : Converts PrimeTime/DesignCompiler TCL selection to list
#@ # Description : Converts PrimeTime/DesignCompiler TCL selection to list
#@ #               Looks at global variable synopsys_program_name to figure
#@ #               out which program is currently using this proc.
#@ #               Only accepts one selection!
#@ #
#@ # Example(s)  :  <set some [get_cell *]
#@ #                >CELL1 CELL1/CELL11
#@ #                <set some
#@ #                >_sel445
#@ #                <set lll [P_sel2list $some]
#@ #                <set lll
#@ #                >CELL1 CELL1/CELL11
#@ #
#@ # Note(s)     : - global variable synopsys_program_name has to exist and
#@ #                 has to be a non-empty string.
#@ #               - Only accepts one selection
#@ #
#@ proc P_sel2list { args } {
#@   global synopsys_program_name
#@ 
#@   set sel [lindex $args 0]
#@ 
#@   if {[info exists synopsys_program_name] &&           $synopsys_program_name != ""} {
#@ 
#@     if {[llength $sel] == 1} {
#@       if {[string match "_sel*" $sel] == 1} {
#@         # get_attribute works for a single object only in PT!!!
#@         #if {$synopsys_program_name == "pt_shell" ||                                                  #    $synopsys_program_name == "primetime"} {
#@         set return_val ""
#@         foreach_in_collection ss $sel {
#@           lappend return_val [get_object_name $ss]
#@         }
#@         #} else {
#@         # This is not working!  Maybe a Synopsys bug!
#@         #set return_val [get_attribute $sel full_name]
#@         #}
#@         return $return_val
#@       } else {
#@         return $sel
#@       }
#@     } else {
#@       return $sel
#@     }
#@   } else {
#@     P_msg_warn "This procedure will only work from within Synopsys tools"
#@     return $args
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/procs_common.tcl

#@ P_source_if_exists aliases.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/aliases.tcl

#@ ##############################################################################
#@ ### General Aliases
#@ alias runicc  runADF
#@ alias rundc   runADF
#@ alias runICC  runADF
#@ alias runDC   runADF
#@ alias so      source
#@ alias h       history
#@ alias cls     sh clear
#@ alias cdn     current_design
#@ alias pv      printvar
#@ alias source_if_exists P_source_if_exists
#@ alias PS      P_source_if_exists
#@ alias ps      P_source_if_exists
#@ 
#@ ### Aliases for read
#@ alias rdv     read_verilog
#@ alias rdb     read_db
#@ alias rdc     read_ddc
#@ 
#@ ### Aliases for reports
#@ alias rn      report_net -connections -verbose
#@ alias rc      report_cell -connections -verbose
#@ alias rtf     report_transitive_fanout
#@ alias rtt     report_transitive_fanin
#@ alias ra      report_attribute
#@ alias rt      report_timing -nets -capacitance -transition_time -input_pins -nosplit -significant_digits 1
#@ alias rt2     {rt -to}
#@ 
#@ ### Aliases for constraints
#@ alias sid     set_input_delay
#@ alias sod     set_output_delay
#@ alias set_mcp set_multicycle_path
#@ alias set_fp  set_false_path
#@ 
#@ ### Other aliases
#@ alias gp      get_pins
#@ alias ga      get_attribute
#@ alias gn      get_nets
#@ alias ac      all_connected
#@ alias rmd     remove_design
#@ alias ai      all_fanin -flat -to
#@ alias ao      all_fanout -flat -from
#@ alias afi     all_fanin -flat -start -to
#@ alias afo     all_fanout -flat -end -from
#@ alias cs      change_selection
#@ alias rmb     remove_placement_keepout
#@ alias gtp     get_timing_path
#@ 
#@ 
#@ if { [P_is_PSYN] || [P_is_ICC] } {
#@   ### Aliases for Physical compiler
#@   alias rn   report_net -connections -verbose -physical -nosplit
#@   alias rc   report_cell -connections -verbose -physical -nosplit
#@   alias rt   report_timing -transition_time -nets -capacitance -input_pins -nosplit -physical -significant_digits 3
#@   alias rtns report_timing -transition_time -nets -capacitance -input_pins -nosplit -physical -significant_digits 3
#@   alias rtm  report_timing -transition_time -nets -capacitance -input_pins -nosplit -delay_type min -significant_digits 3 -physical
#@   alias rtf  report_transitive_fanout -nosplit -from
#@   alias rtt  report_transitive_fanin -nosplit -to
#@   alias gs   get_selection
#@   alias rct  report_clock_timing -type latency -verbose -nosplit -physical -nets
#@   alias gc   get_cells
#@   alias gfc  get_flat_cells
#@   alias gfn  get_flat_nets
#@   alias gfp  get_flat_pins
#@ }
#@ 
#@ ### Aliases for PrimeTime
#@ if { [P_is_PT] } {
#@   alias rtM   report_timing -nosplit -nets -delay_type max -input_pins -significant_digits 0 -capacitance
#@   alias rt    report_timing -nosplit -nets -delay_type max -input_pins -significant_digits 0 -capacitance -transition_time
#@   alias rtm   report_timing -nosplit -nets -delay_type min -input_pins -significant_digits 0 -capacitance
#@   alias rtl   report_timing_location
#@   alias rnl   report_net_location
#@   alias rtMl  report_timing_location -delay_type max  -significant_digits 0 -pba path
#@   alias rtml  report_timing_location -delay_type min  -significant_digits 0 -pba path
#@   alias rtp   report_timing -nosplit -nets -delay_type min -input_pins -significant_digits 0 -path_type full_clock_expanded
#@   alias rtnM  report_timing -nosplit -nets -delay_type max -input_pins -significant_digits 0 -capacitance -crosstalk_delta
#@   alias rtnm  report_timing -nosplit -nets -delay_type min -input_pins -significant_digits 0 -capacitance -crosstalk_delta
#@   alias sc    sizeof_collection
#@   alias fc    filter_collection
#@   alias rfc   remove_from_collection
#@   alias rdc   report_delay_calculation -nosplit -cross
#@   alias rtf   report_transitive_fanout -nosplit -from
#@   alias rtt   report_transitive_fanin -nosplit -to
#@   alias gc    get_cells
#@   alias ga    get_attribute
#@   alias sad   set_annotated_delay
#@   alias ra    report_attribute -nosplit -application -class
#@   alias ai    all_fanin -flat -trace all -to
#@   alias ao    all_fanout -flat -trace all -from
#@   alias afia  all_fanin -flat -start -trace all -to
#@   alias afoa  all_fanout -flat -end -trace all -from
#@   alias get_flat_cells get_cells -hierarchical *
#@   alias gfc   get_flat_cells
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/aliases.tcl

#@ P_source_if_exists run_proc.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/run_proc.tcl

#@ ##############################################################################
#@ 
#@ 
#@ proc runADF {args} {
#@   global target_library link_library search_path mw_reference_library
#@   global INTEL_MW_LIB env
#@   global synopsys_program_name
#@   global suppress_errors
#@   global INTEL_SAVE_WD
#@   global INTEL_STEP_CURR
#@ 
#@   foreach glbl [info globals INTEL_*] {
#@     global $glbl
#@   }
#@ 
#@   if {[P_is_ICC]} {
#@     set INTEL_STEPS $INTEL_APR_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_APR_SUBSTEPS]
#@   } elseif {[P_is_DC]} {
#@     set INTEL_STEPS $INTEL_SYN_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_SYN_SUBSTEPS]
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@     return 0
#@   }
#@ 
#@   set pid [pid]
#@   set extension [P_save_extension]
#@ 
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@   parse_proc_arguments -args $args results
#@ 
#@   global sh_output_log_file
#@   global sh_command_log_file
#@ 
#@ 
#@   ## report status if enabled (design must be open)
#@   if { [info exists results(-status) ] } {
#@     if { [P_current_design_status] } {
#@       P_get_design_status
#@       return 1
#@     } else {
#@       P_msg_error "Unable to determine status."
#@       return 1
#@     }
#@   }
#@ 
#@   #########################################
#@   #  Setup
#@ 
#@   # Support tmp_proj run with sync to INTEL_SAVE_WD
#@   if { ![info exists INTEL_SAVE_WD] } {
#@     set INTEL_SAVE_WD [pwd]
#@   }
#@   # If syncing data to $INTEL_SAVE_WD, make sure scripts/inputs are linked and needed dirs are in $INTEL_SAVE_WD.
#@   if {$INTEL_SAVE_WD != [pwd]} {
#@     sh ln -sf $INTEL_SAVE_WD/scripts .
#@     sh ln -sf $INTEL_SAVE_WD/inputs .
#@     if { ![file isdirectory $INTEL_SAVE_WD/mwdb] } { file mkdir $INTEL_SAVE_WD/mwdb }
#@     if { ![file isdirectory $INTEL_SAVE_WD/$INTEL_MW_LIB] } { file mkdir $INTEL_SAVE_WD/$INTEL_MW_LIB }
#@     if { ![file isdirectory $INTEL_SAVE_WD/$INTEL_OUTPUTS_PATH] } { file mkdir $INTEL_SAVE_WD/$INTEL_OUTPUTS_PATH }
#@     if { ![file isdirectory $INTEL_SAVE_WD/$INTEL_REPORTS_PATH] } { file mkdir $INTEL_SAVE_WD/$INTEL_REPORTS_PATH }
#@     if { ![file isdirectory $INTEL_SAVE_WD/logs] } { file mkdir $INTEL_SAVE_WD/logs }
#@   }
#@   if { ![file isdirectory mwdb] } { file mkdir mwdb }
#@   if { ![file isdirectory $INTEL_MW_LIB] } { file mkdir $INTEL_MW_LIB }
#@   if { ![file isdirectory $INTEL_OUTPUTS_PATH] } { file mkdir outputs }
#@   if { ![file isdirectory $INTEL_REPORTS_PATH] } { file mkdir reports }
#@ 
#@   if { [P_current_design_status] && ![info exists results(-continue)]  } {
#@     P_msg_error "Please specify -continue"
#@     P_msg_error "    or   "
#@     P_msg_error "close_mw_lib and use -load "
#@     return 0
#@   }
#@ 
#@   #########################################
#@   #  -Load
#@   if { [info exists results(-load)]  && ![file isdirectory $results(-load)] && [P_is_ICC]} {
#@     P_msg_error "Invalid library specified . path to MWDB required e.g. ./${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_import_design${extension}"
#@     return 0
#@   }
#@   if { [info exists results(-load)]  && ![file exists $results(-load)] && [P_is_DC]} {
#@     P_msg_error "Invalid library specified . path to ddc required e.g. ./${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_import_design${extension}"
#@     return 0
#@   }
#@   if { [info exists results(-continue)] && [info exists results(-load)] } {
#@     P_msg_error "Invalid command line options! Cannot specify -load with -continue."
#@     return 0
#@   }
#@ 
#@   if { [info exists results(-load)] && [llength $args] == 2 } {
#@     P_open_design $results(-load)
#@     return 1
#@   }
#@ 
#@   if { [info exists results(-load)] } {
#@     set load_lib $results(-load)
#@   }
#@ 
#@ 
#@ 
#@   #########################################
#@   #  -Start
#@   # Define the name of the lib design will save to. $step_lib
#@   # Define lib to load and start from. $load_lib
#@   if { [info exists results(-start)] && ![info exists results(-load)] } {
#@     if {[lsearch -exact $INTEL_STEPS $results(-start)] > -1 } {
#@       set step_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_$results(-start)${extension}
#@       set load_step [lindex $INTEL_STEPS [expr [lsearch -exact $INTEL_STEPS $results(-start)] - 1]]
#@       if { $load_step eq "" } {
#@         # Starting from beginning. Don't define $load_step.
#@       } else {
#@         # If -start and user is still in tool, need to close current mw_lib and load saved one.
#@         redirect /dev/null {[close_mw_lib]}
#@         set load_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_${load_step}${extension}
#@       }
#@     } else {
#@       P_msg_error "Cannot find start point $results(-start) "
#@       P_msg_error " Needs to be one of $INTEL_STEPS "
#@       return 0
#@       # Dont know what to do or where to start
#@     }
#@   } elseif { [info exists results(-start)] && [info exists results(-load)] } {
#@     P_msg_error "Cannot specify both -start and -load!"
#@   }
#@ 
#@ 
#@   #########################################
#@   #  Open Design
#@   # Open the $load_lib
#@   if { ![info exists results(-continue)] } {
#@     if { [info exists load_lib] } {
#@       if { [file exists $load_lib] } {
#@         P_msg_info " Starting with lib $load_lib"
#@         P_open_design ${load_lib}
#@       } else {
#@         P_msg_error "Cannot find MWDB to load $load_lib"
#@         return 0
#@       }
#@     }
#@   }
#@ 
#@ 
#@   #########################################
#@   #  -Load
#@   # Set step_lib when using -load
#@   if { [info exists results(-load)] && ![info exists results(step)] } {
#@     set tmp_step [lindex [file split $results(-load)] end]
#@     if { [info exists tmp_step] } {
#@       regsub "${INTEL_DESIGN_NAME}_" $tmp_step "" tmp_step
#@       regsub "$extension" $tmp_step "" tmp_step
#@       if {  [lsearch -exact $INTEL_STEPS $tmp_step] > -1 } {
#@         set idx [expr [lsearch -exact $INTEL_STEPS $tmp_step ] + 1 ]
#@         set next_step [lindex $INTEL_STEPS $idx]
#@         set step_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_${next_step}${extension}
#@         puts " STEP : $step_lib"
#@       } else {
#@         P_msg_error "specified MW $tmp_step  is not part of standard substeps "
#@         P_msg_error "--Valid steps :  $INTEL_STEPS "
#@         return 0
#@       }
#@     } else {
#@       # Assuming first STEP of INTEL_STEPS
#@     }
#@   }
#@ 
#@ 
#@   #########################################
#@   #  STEP RUN
#@   # Run custom steps
#@   #    or
#@   # Run through $INTEL_STEPS in order
#@   if { [info exists results(step)] } {
#@     for {set i 0 } { $i < [llength $results(step)] } {incr i} {
#@       set step [lindex $results(step) $i]
#@       if { [info exists INTEL_SUBSTEPS($step) ] } {
#@         lappend steps_to_run $step
#@         P_msg_info " $step -- $INTEL_SUBSTEPS($step)"
#@       } else  {
#@         P_msg_error "No substeps specified for step $step"
#@         return 0
#@       }
#@     }
#@     P_msg_info "Executing Custom Specified step : $results(step) "
#@   } else {
#@     set steps_to_run $INTEL_STEPS
#@     set steps_done [get_completed_steps]
#@     set steps_to_run [P_lminus $steps_to_run $steps_done]
#@     P_msg_info "  Completed steps $steps_done"
#@ 
#@     if { [ info exists results(-stop)] && $results(-stop) != "" } {
#@       set step_stop $results(-stop)
#@       set substep_stop ""
#@       if { [string match "*:*" $results(-stop) ] } {
#@         set step_stop [lindex [split $results(-stop) ":" ] 0]
#@         set substep_stop [lindex [split $results(-stop) ":" ] 1]
#@       }
#@       if { [lsearch $steps_to_run $step_stop] > -1 } {
#@         if { $substep_stop != "" } {
#@           set completed_substeps [get_completed_substeps $step_stop]
#@           if { [lsearch $INTEL_SUBSTEPS($step_stop) $substep_stop] < 0 } {
#@             P_msg_error "Specified stop $results(-stop) needs to be one of  $INTEL_SUBSTEPS($step_stop) "
#@             return 0
#@           } elseif { [lsearch $completed_substeps $substep_stop] > -1 && [llength [lsearch -exact -all $INTEL_SUBSTEPS($step_stop) $substep_stop]] < 2} {
#@             # Check if step was already completed. But don't stop if there is more than one step in the step with the same name.
#@             P_msg_error " Specified stop $results(-stop) already executed!"
#@             P_msg_error "  Completed: $completed_substeps"
#@             P_msg_error "  Of:        $INTEL_SUBSTEPS($step_stop)"
#@             return 0
#@           }
#@         }
#@       } else {
#@         P_msg_error "Specified stop $results(-stop) maybe already done/ or specified incorrectly  "
#@         P_msg_error "Specified step Needs to be one of : $steps_to_run "
#@         return 0
#@       }
#@     }
#@   }
#@ 
#@   #########################################
#@   #  Start from beginning!
#@   #  Create mwdb
#@   if { ![info exists load_lib] && ![info exists results(-continue)] } {
#@     P_msg_info " Starting from first step:  [lindex $steps_to_run 0]"
#@     set step_lib ${INTEL_DESIGN_NAME}_${pid}${extension}
#@     set test_lib ""
#@     if { [P_current_design_status] && ![info exists results(-continue)]  } {
#@       set test_lib [get_object_name [current_mw_lib]]
#@     }
#@     if { [file exists $step_lib] && $step_lib == $test_lib && ![info exists results(-continue)]} {
#@       P_msg_error " MWDB exists Please delete MWDB $step_lib to restart "
#@       return 0
#@     }
#@     if { [file isdirectory ${step_lib}] } {
#@       P_msg_info " ${step_lib} already exists! "
#@       P_msg_info " Deleting local version $step_lib "
#@       catch {file delete -force  ${step_lib}} tmpvar
#@       if {$tmpvar != "" } {
#@         catch {sh mv ${step_lib} junk${extension}} movevar
#@       }
#@     }
#@     if {[P_is_ICC]} {
#@       create_mw_lib -technology $INTEL_MW_TECH_FILE -mw_reference_library $mw_reference_library -open $step_lib
#@     }
#@   }
#@ 
#@   #########################################
#@   # -continue
#@   # Continue on Existing Open MWDB
#@ 
#@   if { [info exists results(-continue) ] && [P_is_ICC]} {
#@     set step_lib [get_object_name [current_mw_lib]]
#@   }
#@ 
#@   #########################################
#@   #  MAIN LOOP
#@   #  For loop through steps.
#@   set in_step_loop 0
#@   set return_after_mark 0
#@   for {set ii 0 } {$ii < [llength $steps_to_run] } { incr ii } {
#@     set step [lindex $steps_to_run $ii]
#@     set INTEL_STEP_CURR $step
#@     set step_log_file ${INTEL_LOG_PATH}/${step}.log
#@     set step_command_log_file ${INTEL_LOG_PATH}/${step}.cmd_log
#@ 
#@     if { [file exists ${INTEL_LOG_PATH}/${step}.log] && ![info exists results(-continue)] } {
#@       file copy -force ${INTEL_LOG_PATH}/${step}.log ${INTEL_LOG_PATH}/${step}.log.bak
#@     }
#@     if { [file exists ${INTEL_LOG_PATH}/${step}.cmd_log] && ![info exists results(-continue)] } {
#@       file copy -force ${INTEL_LOG_PATH}/${step}.cmd_log ${INTEL_LOG_PATH}/${step}.cmd_log.bak
#@     }
#@     set sh_output_log_file $step_log_file
#@     set sh_command_log_file $step_command_log_file
#@     P_msg_info " Setting log file  : $step_log_file"
#@ 
#@     # INTEL_SKIP_SUBSTEPS: allow user to skip substeps in a STEP via INTEL_ var.
#@     if { [info exists INTEL_SKIP_STEP] && $INTEL_SKIP_SUBSTEPS != "" && [regexp "${step}( |$)" $INTEL_SKIP_SUBSTEPS match] } {
#@       P_msg_info "Skipping the following: ${step}"
#@       mark_step $step "Skipped"
#@       continue
#@     }
#@ 
#@     # copy over lib to load and work within for ICC only, otherwise just read_ddc in DC.
#@     if { [info exists load_lib]  && ![info exists results(-continue)] } {
#@       if {[P_is_ICC]} {
#@         redirect /dev/null {[close_mw_lib ${load_lib}]}
#@         set step_lib  ${INTEL_DESIGN_NAME}_${pid}${extension}
#@         P_msg_info "Loading $load_lib (moving to $step_lib first)"
#@         P_msg_info "rsync-ing $load_lib to $step_lib "
#@         P_rsync $load_lib $step_lib
#@         if { [file exists [file tail $load_lib]] } {
#@           redirect /dev/null {[close_mw_lib ${load_lib}]}
#@           P_msg_info " Removing work dir copy [file tail $load_lib]"
#@           #file delete -force [file tail $load_lib]
#@           catch {file delete -force [file tail $load_lib]} tmpvar
#@           if {$tmpvar != "" } {
#@             catch {sh mv [file tail $load_lib] junk${extension}} movevar
#@           }
#@         }
#@         P_open_design ${step_lib}
#@       } elseif {[P_is_DC]} {
#@         set step_lib $load_lib
#@       }
#@ 
#@     }
#@     set start_step_time [clock seconds]
#@ 
#@     # Define step specific active scenarios
#@     if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@       if { [all_scenarios] != "" } {
#@         set_active_scenarios [all_scenarios]
#@         if { [info exists INTEL_MCMM_SCENARIO_ACTIVE($step)] && $INTEL_MCMM_SCENARIO_ACTIVE($step) != "" } {
#@           P_msg_info "Setting the following as active scenarios in step $step :  $INTEL_MCMM_SCENARIO_ACTIVE($step)"
#@           set_active_scenarios $INTEL_MCMM_SCENARIO_ACTIVE($step)
#@         } else {
#@           P_msg_info "Current active scenarios : [all_active_scenarios]"
#@         }
#@         P_msg_info "Setting the following default active scenarios in step $step :  $INTEL_MCMM_SCENARIO_DEFAULT"
#@         current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@       }
#@     }
#@ 
#@     #
#@     # Manage substeps to be run
#@     # Trim substeps to be run only if -continue specified else run STEP from start.
#@     #
#@     set substeps_to_run  $INTEL_SUBSTEPS($step)
#@     set substeps_done ""
#@     if { [info exists results(-continue) ] } {
#@       set substeps_done [get_completed_substeps $step]
#@       set substeps_to_run [P_lminus $substeps_to_run $substeps_done]
#@     }
#@ 
#@     P_msg_info "  ALL $step substeps : $INTEL_SUBSTEPS($step)"
#@     if {[P_is_ICC]} {
#@       P_msg_info "  Current MW lib  : [get_object_name [current_mw_lib]]"
#@     }
#@     P_msg_info "  Completed substeps : $substeps_done"
#@     P_msg_info "  Remaining substeps : $substeps_to_run "
#@ 
#@     #########################################
#@     #  MAIN LOOP
#@     #  For loop through substeps.
#@     if { [llength $substeps_to_run]  > 0 } {
#@       for {set jj 0 } {$jj < [llength $substeps_to_run ] } { incr jj } {
#@         set substep [lindex $substeps_to_run $jj]
#@         # Skip STEP
#@         if { [info exists INTEL_SKIP_SUBSTEPS] && $INTEL_SKIP_SUBSTEPS != "" && [regexp "${step}:${substep}( |$)" $INTEL_SKIP_SUBSTEPS match] } {
#@           P_msg_info "Skipping the following: ${step}:${substep}"
#@           mark_substep $step $substep "Skipped"
#@           continue
#@         }
#@         P_msg_info "Executing substep $substep"
#@         set start_substep_time [clock seconds]
#@ 
#@         source_if_exists ${substep}.tcl
#@ 
#@         set duration [P_rdtConvertSeconds [expr ([clock seconds] - $start_substep_time)]]
#@         P_msg_info "Time to run substep $substep in (hh:mm:ss) : $duration hrs"
#@         mark_substep $step $substep "$duration"
#@         if { [info exists results(-stop)] && [string match $results(-stop) ${step}:${substep} ] > 0 } {
#@           if { [P_lminus $INTEL_SUBSTEPS($step) [get_completed_substeps $step]] == "" } {
#@             # Don't return yet, make sure you Mark the STEP as done and set time stamps
#@             set return_after_mark 1
#@           } else {
#@             P_msg_info "Stopping per users request: -stop ${step}:${substep}"
#@             return
#@           }
#@         }
#@       }
#@ 
#@       set duration [P_rdtConvertSeconds [expr ([clock seconds] - $start_step_time)]]
#@       P_msg_info "Time to run step $step in (hh:mm:ss) : $duration hrs"
#@       set mem_fp [expr [mem]/1024.0]
#@       if { $mem_fp > 1024.0 } {
#@         set mem_fp [format "%7.2f GB" [expr [mem]/(1024.0*1024)]]
#@       } else {
#@         set mem_fp [format "%7.2f MB" [expr [mem]/1024.0]]
#@       }
#@       mark_step $step "$duration  $mem_fp"
#@     } else {
#@       P_msg_info "Nothing to be done for Step. All substeps already completed "
#@     }
#@     set start_ro_time [clock seconds]
#@ 
#@     P_msg_info "Saving design ${INTEL_DESIGN_NAME} ..."
#@     P_save_design $step
#@ 
#@     if { [info exists INTEL_REPORTS($step) ] && $INTEL_REPORTS($step) != "" } {
#@       P_reports $step
#@     } else {
#@       P_msg_info " No report requirement specified INTEL_REPORTS($step) "
#@     }
#@     if { [info exists INTEL_OUTPUTS($step) ] && $INTEL_OUTPUTS($step) != "" } {
#@       P_outputs $step
#@     } else {
#@       P_msg_info " No report requirement specified INTEL_OUTPUTS($step) "
#@     }
#@ 
#@     if {[P_is_ICC]} {
#@       set save_lib  ${INTEL_DESIGN_NAME}_${step}${extension}
#@       P_msg_info "Saving/rsync-ing  $step_lib into ${INTEL_MW_LIB}/${save_lib}"
#@       P_rsync ${step_lib} "${INTEL_MW_LIB}/${save_lib}"
#@     }
#@ 
#@     #Rsync results back to INTEL_SAVE_WD
#@     if { $INTEL_SAVE_WD != [pwd] } {
#@       P_msg_info "Saving/rsync-ing ${step_lib} back to $INTEL_SAVE_WD"
#@       P_rsync  "${INTEL_MW_LIB}/${save_lib}" "${INTEL_SAVE_WD}/${INTEL_MW_LIB}/${save_lib}"
#@       sh rm -rf ${INTEL_SAVE_WD}/reports/${INTEL_DESIGN_NAME}.${step}.*
#@       sh rm -rf ${INTEL_SAVE_WD}/outputs/${INTEL_DESIGN_NAME}.${step}.*
#@       if { [glob -nocomplain reports/${INTEL_DESIGN_NAME}.${step}.*] != "" } {
#@         sh cp -pf reports/${INTEL_DESIGN_NAME}.${step}.* ${INTEL_SAVE_WD}/reports/
#@       }
#@       if { [glob -nocomplain outputs/${INTEL_DESIGN_NAME}.${step}.*] != "" } {
#@         sh cp -pf outputs/${INTEL_DESIGN_NAME}.${step}.* ${INTEL_SAVE_WD}/outputs/
#@       }
#@       sh cp -pf logs/${step}.* ${INTEL_SAVE_WD}/logs/
#@     }
#@     set duration [P_rdtConvertSeconds [expr ([clock seconds] - $start_ro_time)]]
#@     P_msg_info "Time to create reports and outputs for $step in (hh:mm:ss) : $duration hrs"
#@ 
#@     if {$return_after_mark == 1} {
#@       set return_after_mark 0
#@       P_msg_info "Stopping per users request: -stop ${step}:${substep}"
#@       return
#@     }
#@ 
#@     if { [info exists load_lib] } {
#@       unset load_lib
#@     }
#@     if { [info exists results(-continue)] } {
#@       unset results(-continue)
#@     }
#@     if { [info exists results(-stop)] && [string match $results(-stop) $step] > 0 } {
#@       P_msg_info " Stopping at $step as required by -stop $results(-stop)"
#@       return
#@     }
#@   }
#@ }
#@ 
#@ define_proc_attributes runADF     -info "ICF Flow Control"     -define_args {                        {step "Custom step/s to execute" step list optional }                        {-load "Load a mwdb" step string optional}                        {-start "Step start" step string optional}                        {-stop "Step stop" step string optional }                        {-continue "Continue with current mwdb in memory" "" boolean  optional }                        {-status "Report status" "" boolean optional }                      }
#@ 
#@ 
#@ proc P_get_design_status {args} {
#@   foreach glbl [info globals INTEL_*] {
#@     global $glbl
#@   }
#@   parse_proc_arguments -args $args results
#@ 
#@ 
#@   if { [P_current_design_status] } {
#@     # Cell open
#@   } else {
#@     P_msg_error "Unable to determine status. No MW cel open"
#@     return 0
#@   }
#@ 
#@   if {[P_is_ICC]} {
#@     set INTEL_STEPS $INTEL_APR_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_APR_SUBSTEPS]
#@   } elseif {[P_is_DC]} {
#@     set INTEL_STEPS $INTEL_SYN_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_SYN_SUBSTEPS]
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@     return 0
#@   }
#@ 
#@   redirect -variable aa {list_attributes -class [P_get_class]}
#@   set steps_run [get_completed_steps]
#@   #set custom_steps [P_lminus $steps_run $INTEL_STEPS]
#@   set steps_not_run [P_lminus $INTEL_STEPS $steps_run]
#@   P_msg_info " Steps run : $steps_run"
#@   if { ! [info exists results(-verbose)]  && ![info exists results(step)]} {
#@     puts "============================================================================================================="
#@     puts "      STEP  Name      :  Duration/Status "
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     for {set i 0 } { $i < [llength $steps_run] } { incr i} {
#@       set step [lindex $steps_run $i]
#@       puts " [format %30s $step ] : [get_attribute -quiet [P_get_current] step:${step}]"
#@     }
#@     for {set i 0 } { $i < [llength $steps_not_run] } { incr i} {
#@       set step [lindex $steps_not_run $i]
#@       puts " [format %30s $step ] : Not Run/Skipped"
#@     }
#@     return
#@   }
#@   if { ![info exists results(-verbose)] && [info exists results(step)] } {
#@     set step $results(step)
#@     set steps_run [P_lcommon [get_completed_steps] $results(step)]
#@     puts "============================================================================================================="
#@     puts "                  STEP  Name    :  [format %10s $step]  : [get_attribute -quiet [P_get_current] step:${step}]"
#@     puts "                          Step  :  Duration    :  Script Used "
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     for {set j 0 } {$j < [llength $INTEL_SUBSTEPS($step) ] } { incr j } {
#@       set step [lindex $INTEL_SUBSTEPS($step) $j]
#@       redirect -variable file {P_source_if_exists ${substep}.tcl -display}
#@       set substep_duration [get_attribute -quiet [P_get_current] step_${step}:${substep}]
#@       if {$substep_duration == ""} { set substep_duration "Skipped " }
#@       puts " [format %30s $step] :  $substep_duration  :$file "
#@     }
#@     return
#@ 
#@   }
#@   if { ![info exists results(step)] } {
#@     for {set i 0 } { $i < [llength $steps_run] } { incr i} {
#@       set step [lindex $steps_run $i ]
#@       puts "============================================================================================================="
#@       puts "                  Step  Name    :  [format %10s $step]  : [get_attribute -quiet [P_get_current] step:${step}]"
#@       puts "                       substep  :  Duration    :  Script Used "
#@       puts "-------------------------------------------------------------------------------------------------------------"
#@       for {set j 0 } {$j < [llength $INTEL_SUBSTEPS($step) ] } { incr j } {
#@         set substep [lindex $INTEL_SUBSTEPS($step) $j]
#@         redirect -variable file {P_source_if_exists ${substep}.tcl -display}
#@         set substep_duration [get_attribute -quiet [P_get_current] step_${step}:${substep}]
#@         if {$substep_duration == ""} { set substep_duration "Skipped " }
#@         puts " [format %30s $substep] :  $substep_duration  :$file "
#@       }
#@     }
#@   }
#@   for {set i 0 } { $i < [llength $steps_not_run] } { incr i} {
#@     set step [lindex $steps_not_run $i ]
#@     puts "============================================================================================================="
#@     puts "  Step  Name    :   $step "
#@     puts "    Status      :   Not Run / Skipped"
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     puts "                          Step  :  Duration  :  Script Used "
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     for {set j 0 } {$j < [llength $INTEL_SUBSTEPS($step) ] } { incr j } {
#@       set substep [lindex $INTEL_SUBSTEPS($step) $j]
#@       redirect -variable file {P_source_if_exists ${substep}.tcl -display}
#@       puts " [format %30s $substep] :  Not Run   :$file "
#@     }
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_get_design_status     -info "Get design status"     -define_args {                        {step "status of specific" step list optional }                        {-verbose  "detail status report" "" boolean optional }                      }
#@ 
#@ 
#@ proc P_rsync {from to} {
#@   catch {sh rsync --archive --verbose --delete --exclude="*@*" --exclude="*_INIT_RT_*" --exclude="*_fdksave_*" --exclude="*.lock"  ${from}/ $to } tmpvar
#@   puts $tmpvar
#@ }
#@ 
#@ proc P_open_design {arg} {
#@ 
#@   global INTEL_DESIGN_NAME mw_reference_library mw_design_library INTEL_MW_TECH_FILE INTEL_MAX_TLUPLUS_FILE INTEL_TLUPLUS_MAP_FILE
#@ 
#@   if {[P_is_ICC]} {
#@     open_mw_lib $arg
#@     open_mw_cel $INTEL_DESIGN_NAME
#@   } elseif {[P_is_DC]} {
#@     if { [shell_is_in_topographical_mode] } {
#@       redirect -variable aa {current_mw_lib}
#@       if { [string match "*No current milkyway library*" $aa] } {
#@         if {[file exists ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB]} {
#@           open_mw_lib mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@         } else {
#@           file delete -force -- ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@           set_app_var mw_design_library ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@           create_mw_lib -technology $INTEL_MW_TECH_FILE  -mw_reference_library $mw_reference_library $mw_design_library
#@           open_mw_lib $mw_design_library
#@         }
#@       }
#@       set_tlu_plus_files -max_tluplus $INTEL_MAX_TLUPLUS_FILE -min_tluplus $INTEL_MAX_TLUPLUS_FILE -tech2itf_map $INTEL_TLUPLUS_MAP_FILE
#@     }
#@     read_ddc $arg
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ 
#@ }
#@ 
#@ proc P_save_design {arg} {
#@ 
#@   global INTEL_DESIGN_NAME
#@   global INTEL_MCMM
#@   global INTEL_MW_LIB
#@   if {[P_is_ICC]} {
#@     if {$INTEL_MCMM == 1} {
#@       save_mw_cel -as ${INTEL_DESIGN_NAME} -scenarios [all_scenarios]
#@     } else {
#@       save_mw_cel -as ${INTEL_DESIGN_NAME}
#@     }
#@   } elseif {[P_is_DC]} {
#@     write_file -format ddc -hierarchy -output $INTEL_MW_LIB/${INTEL_DESIGN_NAME}_${arg}.ddc
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ 
#@ }
#@ 
#@ # Proc P_current_design_status
#@ # Returns 1 if the design is loaded.
#@ # Returns 0 if the design isn't loaded.
#@ proc P_current_design_status {} {
#@ 
#@   global INTEL_DESIGN_NAME
#@ 
#@   if {[P_is_ICC]} {
#@     redirect -variable aa {current_mw_lib}
#@     if { [string match "*No current milkyway library*" $aa] } {
#@       return 0
#@     } else {
#@       return 1
#@     }
#@   } elseif {[P_is_DC]} {
#@     redirect -variable aa {current_design}
#@     if { [string match "*Current design is not defined*" $aa] } {
#@       return 0
#@     } else {
#@       return 1
#@     }
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ 
#@ }
#@ 
#@ proc P_save_extension {} {
#@   if {[P_is_ICC]} {
#@     return "_LIB"
#@   } elseif {[P_is_DC]} {
#@     return ".ddc"
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ }
#@ 
#@ proc P_get_class {} {
#@   if {[P_is_ICC]} {
#@     return "mw_cel"
#@   } elseif {[P_is_DC]} {
#@     return "design"
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ }
#@ 
#@ proc P_get_current {} {
#@   set command "current_"
#@   append command [P_get_class]
#@   redirect /dev/null {set obj [eval $command]}
#@   return $obj
#@ }
#@ 
#@ 
#@ proc mark_step {step {comment ""}} {
#@   set done_steps ""
#@   if {$comment eq ""} { set comment "Marked/Skipped" }
#@   if { [P_current_design_status] } {
#@     set done_steps [get_attribute -quiet [P_get_current] completed_steps]
#@     lappend done_steps $step
#@     redirect /dev/null {define_user_attribute -class [P_get_class] -type string step:${step} -quiet }
#@     redirect /dev/null {set_attribute -quiet [P_get_current] step:$step $comment}
#@     redirect /dev/null {define_user_attribute -class [P_get_class] -type string  completed_steps -quiet}
#@     redirect /dev/null {set_attribute -quiet [P_get_current] completed_steps $done_steps}
#@   }
#@ }
#@ 
#@ 
#@ proc mark_substep {step substep {comment ""}} {
#@   global INTEL_SYN_SUBSTEPS INTEL_APR_SUBSTEPS
#@ 
#@   if {[P_is_ICC]} {
#@     array set INTEL_SUBSTEPS [array get INTEL_APR_SUBSTEPS]
#@   } elseif {[P_is_DC]} {
#@     array set INTEL_SUBSTEPS [array get INTEL_SYN_SUBSTEPS]
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@     return 0
#@   }
#@ 
#@   if {$comment eq ""} { set comment "Marked/Skipped" }
#@   redirect /dev/null {define_user_attribute -class [P_get_class] -type string  step:${step} -quiet }
#@   redirect /dev/null {define_user_attribute -class [P_get_class] -type string  completed_substeps:${step} -quiet}
#@   redirect /dev/null {define_user_attribute -class [P_get_class] -type string  step_${step}:${substep} -quiet}
#@   redirect -variable aa {list_attributes -class [P_get_class]}
#@   if { [P_current_design_status] } {
#@     set done_substeps [get_completed_substeps $step]
#@     foreach index [lsearch -all  $INTEL_SUBSTEPS($step) $substep] {
#@       if {[lindex $done_substeps $index] != $substep } {
#@         set done_substeps [linsert $done_substeps $index $substep]
#@         break
#@       }
#@     }
#@     redirect /dev/null {set_attribute [P_get_current] completed_substeps:${step} $done_substeps}
#@     redirect /dev/null {set_attribute [P_get_current] step_${step}:${substep} $comment}
#@   }
#@ 
#@ }
#@ 
#@ 
#@ proc unmark_step {step} {
#@   set done_steps ""
#@   if { [P_current_design_status] } {
#@     redirect /dev/null {redirect -variable aa {list_attributes -class [P_get_class]}}
#@     set done_steps [get_attribute [P_get_current] completed_steps]
#@     set done_steps [P_lminus $done_steps $step]
#@     redirect /dev/null {set_attribute [P_get_current] completed_steps $done_steps}
#@     foreach substep [get_completed_substeps $step] { unmark_substep $step $substep }
#@   }
#@ }
#@ 
#@ 
#@ proc unmark_substep {step substep} {
#@   redirect -variable aa {list_attributes -class [P_get_class]}
#@   set steps_run [P_lsearch $aa step*]
#@   set attr_to_remove [P_lsearch $steps_run step_${step}:$substep]
#@   foreach attr $attr_to_remove {
#@     redirect /dev/null {remove_attribute -quiet [P_get_current] $attr}
#@   }
#@   set done_substeps [get_attribute [P_get_current] completed_substeps:${step}]
#@   set updated_done_substeps [P_lminus_r $done_substeps $substep]
#@   redirect /dev/null {set_attribute [P_get_current] completed_substeps:${step} $updated_done_substeps}
#@   redirect /dev/null {redirect -variable aa {list_attributes -class [P_get_class]}}
#@   set done_steps [get_attribute [P_get_current] completed_steps]
#@   set done_steps [P_lminus $done_steps $step]
#@   redirect /dev/null {set_attribute [P_get_current] completed_steps $done_steps}
#@ }
#@ 
#@ 
#@ proc get_completed_steps {args} {
#@   parse_proc_arguments -args $args results
#@ 
#@   set done_steps ""
#@   if { [P_current_design_status] } {
#@     if { [info exists results(step)] } {
#@       redirect -variable aa {list_attributes -class [P_get_class]}
#@       set done_steps [ get_attribute [P_get_current] completed_steps]
#@       foreach done_step $done_steps {
#@         if {$done_step eq $results(step)} {
#@           return $done_step
#@         }
#@       }
#@     } else {
#@       redirect -variable aa {list_attributes -class [P_get_class]}
#@       set done_steps [ get_attribute [P_get_current] completed_steps]
#@       return $done_steps
#@     }
#@   } else {
#@     return $done_steps
#@   }
#@ }
#@ define_proc_attributes get_completed_steps     -info "Get a list of complted steps"     -define_args {                        {step "Return step if it had completed." step list optional }
#@     }
#@ 
#@ 
#@ proc get_completed_substeps {step} {
#@   set done_substeps ""
#@   if { [P_current_design_status] } {
#@     redirect -variable aa {list_attributes -class [P_get_class]}
#@     set done_substeps [ get_attribute [P_get_current] completed_substeps:${step} -quiet]
#@     return $done_substeps
#@   } else {
#@     return $done_substeps
#@   }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/run_proc.tcl

#@ 
#@ 
#@ ### project specific setting
#@ P_source_if_exists project_setup.tcl -require
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/project_setup.tcl

#@ ##############################################################################
#@ 
#@ ####################################
#@ # Flow Vars
#@ ####################################
#@ 
#@ # Synthesis flow vars
#@ # To add an extra step to the flow update the *_STEPS var to add the new step
#@ # Also define *_SUBSTEPS(<new step>) to include the tcl files that need to be sourced during that step
#@ 
#@ set INTEL_SYN_STEPS {read_design read_constraints compile insert_dft inc_compile}
#@ 
#@ set INTEL_SYN_SUBSTEPS(read_design)           { read_design }
#@ set INTEL_SYN_SUBSTEPS(read_constraints)      { read_constraints read_phys_constraints create_scenarios }
#@ set INTEL_SYN_SUBSTEPS(compile)               { compile_prep create_path_group compile }
#@ set INTEL_SYN_SUBSTEPS(insert_dft)            { insert_dft }
#@ set INTEL_SYN_SUBSTEPS(inc_compile)           { compile_prep inc_compile change_names }
#@ 
#@ # APR Flow vars
#@ 
#@ set INTEL_APR_STEPS {import_design floorplan place post_place cts route post_route adr fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(import_design)      { dont_use import_design read_constraints create_scenarios create_path_group derive_pg}
#@ 
#@ set INTEL_APR_SUBSTEPS(floorplan)          { dont_use tool_constraints init_floorplan set_wiretracks macro_placement halo_d04 derive_pg create_power_straps interface_metals isolated_pin_extension io_placement add_tap_cells insert_antenna_diodes_on_input pre_place_fiducial_d04 pre_place_bonus_fib_d04 create_check_grid check_floorplan derive_pg }
#@ 
#@ set INTEL_APR_SUBSTEPS(place)              { dont_use tool_constraints cmax_interpolate set_ideal_clock_network cell_spacing_d04 layer_promotion place_opt  check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(post_place)         { dont_use tool_constraints cmax_interpolate psynopt insert_spare_kit check_place derive_pg change_names}
#@ 
#@ set INTEL_APR_SUBSTEPS(cts)                { dont_use tool_constraints cmax_interpolate cts_ndr_rules cts_options create_route_guides remove_ideal_clock_network cts add_pg_hookup route_options_drc redundant_via_insertion clock_route create_clock_shield remove_pg_hookup freeze_clock_nets update_clocks check_cts derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(route)              { dont_use tool_constraints cmax_interpolate route_options route_options_drc report_pre_route route_trackassign add_pg_hookup initial_detailroute incr_create_clock_shield verify_zrt_route derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(post_route) { dont_use tool_constraints cmax_interpolate route_options  route_options_drc antenna_rules remove_pg_hookup incr_route_opt insert_antenna_diodes_on_input tie_high incr_eco_detail_route opportunistic_local_fiducial_place incr_create_clock_shield add_filler_cells_d04 derive_pg add_pg_hookup incr_detailroute verify_zrt_route derive_pg check_route change_names }
#@ 
#@ #set INTEL_APR_SUBSTEPS(focal_opt)          { dont_use tool_constraints cmax_interpolate route_options route_options_drc remove_pg_hookup focal_opt incr_create_clock_shield inc_add_filler_cells_d04 add_pg_hookup focal_opt_cleanup derive_pg check_route change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(adr)                { dont_use tool_constraints route_options route_options_drc adr derive_pg}
#@ 
#@ set INTEL_APR_SUBSTEPS(fill)               { dont_use check_fill_view metal_via_fill create_port_layer }
#@ 
#@ # TO run UPF flow uncomment the APR_STEPS line below
#@ #set INTEL_APR_STEPS {import_design upf_floorplan upf_place upf_post_place cts route upf_post_route adr fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_floorplan)      { dont_use tool_constraints init_floorplan set_wiretracks macro_placement halo_d04 halo_power_voltage_island derive_pg create_power_switch connect_power_switch derive_pg create_ls_bounds create_power_plan compile_power_plan connect_sec_pg_power_switch interface_metals isolated_pin_extension io_placement add_tap_cells insert_antenna_diodes_on_input pre_place_fiducial_d04 pre_place_bonus_fib_d04 create_check_grid check_floorplan derive_pg }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_place)              { dont_use tool_constraints cmax_interpolate set_ideal_clock_network upf_sec_pg_hookup magnet_placement cell_spacing_d04 layer_promotion place_opt  check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_post_place)          { dont_use tool_constraints cmax_interpolate psynopt insert_spare_kit upf_sec_pg_hookup route_upf_ao_pg check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_post_route)          { dont_use tool_constraints cmax_interpolate route_options route_options_drc antenna_rules remove_pg_hookup incr_route_opt insert_antenna_diodes_on_input tie_high incr_eco_detail_route opportunistic_local_fiducial_place add_filler_cells_d04 derive_pg upf_sec_pg_hookup route_upf_ao_pg add_pg_hookup incr_detailroute verify_zrt_route derive_pg check_route change_names }
#@ 
#@ # To Run ECO flow uncomment the INTEL_APR_STEPS line below
#@ #set INTEL_APR_STEPS {eco fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(eco)                { dont_use tool_constraints cmax_interpolate route_options route_options_drc eco_remove_filler remove_pg_hookup eco derive_pg eco_legalize_placement add_filler_cells_d04 route_eco add_pg_hookup incr_detailroute verify_zrt_route change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(metal_only_eco)     { dont_use tool_constraints cmax_interpolate route_options route_options_drc metal_only_eco verify_zrt_route change_names }
#@ 
#@ ####################################
#@ #Path Settings
#@ ####################################
#@ 
#@ set fdk_lib                     d04
#@ set fdk_stdcells_sp_dir         $env(INTEL_STDCELLS)
#@ set fdk_stdcells_misc_dir       $env(INTEL_STDCELLS_MISC)
#@ set fdk_asic_flows_dir          $env(INTEL_ASIC)/asicflows/synopsys
#@ set fdk_icv_fill_dir            $env(INTEL_PDK)/fill/icv
#@ set fdk_icv_adr_dir             $env(INTEL_PDK)/runsets/adr
#@ set fdk_star_ext_tech_dir       $env(INTEL_PDK)/extraction/starrc/cmdfiles
#@ set fdk_icc_ext_tech_dir        $env(INTEL_PDK)/extraction/icc/techfiles
#@ set fdk_icc_tech_dir            $env(INTEL_PDK)/apr/icc/
#@ 
#@ ######################################
#@ #Library Variables
#@ ######################################
#@ 
#@ # Variable used to set operating condition. Valid values are bc_wc, on_chip_variation.
#@ set INTEL_ANALYSIS_TYPE             "bc_wc"
#@ 
#@ # Max and Min operating condition used during set_operating_condition setting
#@ set INTEL_MAX_OPCON           slow_1.00
#@ if {$synopsys_program_name == "icc_shell" } {
#@   set INTEL_MIN_OPCON       fast_1.00
#@ } elseif {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell" } {
#@   set INTEL_MIN_OPCON       slow_1.00
#@ }
#@ 
#@ # Include the names of all memories, io's etc to be used in the block. An example is given below
#@ # set INTEL_HARD_MACRO_NAME         [list c69p0rgf1r1w4t128x34 c69p0ssa2048x52cm4]
#@ 
#@ 
#@ #######################################
#@ #Tech File Variables
#@ #######################################
#@ 
#@ set INTEL_GDS_OUT_LAYER_MAP       $fdk_icc_tech_dir/1273Milkyway2GdsLayerMap
#@ set INTEL_MW_TECH_FILE            $fdk_icc_tech_dir/${fdk_lib}/p1273.tf
#@ set INTEL_MAX_TLUPLUS_FILE        $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.tluplus
#@ set INTEL_MIN_TLUPLUS_FILE        $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.tluplus
#@ set INTEL_TLUPLUS_MAP_FILE        $fdk_star_ext_tech_dir/asic.starrc.map
#@ set INTEL_MAX_TLUPLUS_EMUL_FILE   $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.mfill.tluplus
#@ set INTEL_MIN_TLUPLUS_EMUL_FILE   $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.mfill.tluplus
#@ 
#@ ########################################
#@ #Design Variables:
#@ ########################################
#@ 
#@ ############SYN, APR and PV#############
#@ ########################################
#@ 
#@ # Top level block name for Physical Design
#@ set INTEL_DESIGN_NAME   ""
#@ 
#@ # Modular grid x and y
#@ set INTEL_MD_GRID_X                 1.680
#@ set INTEL_MD_GRID_Y                 1.596
#@ 
#@ # Max and min routing layers. These variables are used by set_ignored_layers icc command and various other tcl scripts.
#@ set INTEL_MAX_ROUTING_LAYER                  "m8"
#@ set INTEL_MIN_ROUTING_LAYER                  "m0"
#@ set INTEL_RC_IGNORE_LAYERS                   "m0 tm1"
#@ # Override the min routing layer contraint during placement only. Used in tool_constraints.tcl.
#@ # This has proven to improve post route QOR by reducing RC in placement.
#@ set INTEL_MIN_ROUTING_LAYER_OVERRIDE(place)           "m2"
#@ set INTEL_MIN_ROUTING_LAYER_OVERRIDE(post_place)      "m2"
#@ 
#@ # MW Power net Name
#@ set INTEL_MW_POWER_NET    vcc
#@ set INTEL_MW_GROUND_NET   vss
#@ 
#@ # Variable to enable the usage of SDC file. If set to 1, read ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc. If set to 0, read ./inputs/constraints/clocks.tcl and ./inputs/constraints/constraints.tcl
#@ set INTEL_SDC_FILE      0
#@ 
#@ 
#@ # Variable to use scan flops or not (if 1, compile -scan otherwise -scan is not used). If var set to 1 then, Synthesis will run compile -scan and compiled netlist will have scan flops.
#@ set INTEL_SCAN_REPLACE_FLOPS 1
#@ 
#@ #Variable to insert scan chain, if set to 1, DC will insert scan chain and  write out ./outputs/${INTEL_DESIGN_NAME}.scandef. APR will read in ./inputs/${INTEL_DESIGN_NAME}.scandef and run place_opt -optimize_dft
#@ set INTEL_INSERT_SCAN   0
#@ 
#@ # If set to 1, enables UPF flow for synthesis and APR.
#@ set INTEL_UPF     0
#@ 
#@ # Set RTL & post-synthesis UPF version, either 1.0 or 2.0.
#@ set INTEL_UPF_VERSION   1.0
#@ 
#@ # Set the list of nets incase of UPF design
#@ set INTEL_UPF_POWER_NETS {vss vcc}
#@ 
#@ # If set to 1, synthesis and APR flow will read ./inputs/constraints/${INTEL_DESIGN_NAME}.saif and optimizes dynamic power.
#@ set INTEL_SAIF      0
#@ 
#@ # Variable used to define the hierarchical instance (top/instA) for which switching activity is annotated. If not defined then top level design name will be assumed
#@ set INTEL_SAIF_INSTANCE   ""
#@ 
#@ # SPECIFY DEFAULT SWITCHING ACTIVITY for VECTOR-FREE power analysis and dynamic power optimization.
#@ # Use these variables to set switching activity for dynamic power optimization if not using SAIF.
#@ # Annotate a suitable default Toggle Rate value and Static Probability, for example, 0.2 to all the starting points.
#@ set INTEL_POWER_TR 0.2
#@ set INTEL_POWER_SP 0.3
#@ 
#@ ############SYN Specific################
#@ ########################################
#@ 
#@ # If set to 1 then DC will read the .def file for floorplan from ./inputs/floorplan/${INTEL_DESIGN_NAME}.def
#@ set INTEL_TOPO_DEF      0
#@ 
#@ # Variable to set insert_clock_gating (if 1 then insert_clock_gating and compile_ultra -clock_gate is used)
#@ set INTEL_INSERT_CLOCKGATES         1
#@ 
#@ # Set to 1, to invoke synopsys physical guidance to generate ddc/mwdb for seed placement to APR. DEF file must be provided and INTEL_TOPO_DEF set to 1.
#@ set INTEL_SPG                       0
#@ 
#@ # Set to 1, to enable congestion optimization
#@ set INTEL_CONGESTION_OPTIMIZE       0
#@ 
#@ # If set to 1 then ICC will read .ddc file from ./inputs/${INTEL_DESIGN_NAME}.syn.ddc
#@ set INTEL_DDC                       0
#@ 
#@ ###########APR Specific #################
#@ #####################################################################
#@ 
#@ #Input file name variables - Provide full paths to file names. Examples provided below.
#@ #Note - if variable not set, default path and filename (as shown in example below) will be assumed.
#@ 
#@ # set INTEL_INPUT_NETLIST ./inputs/<INTEL_DESIGN_NAME>.syn.vg
#@ # set INTEL_INPUT_SCANDEF ./inputs/<INTEL_DESIGN_NAME>.syn.scandef
#@ # set INTEL_INPUT_DEF ./inputs/floorplan/<INTEL_DESIGN_NAME>.floorplan.def
#@ # set INTEL_INPUT_UPF ./inputs/upf/<INTEL_DESIGN_NAME>.syn.upf
#@ # set INTEL_INPUT_SDC ./inputs/constraints/<INTEL_DESIGN_NAME>.sdc
#@ 
#@ ########## Main Command Variables ###################################
#@ # The following variables set the options to main APR commands like place_opt, psynopt, etc
#@ 
#@ # place_opt.tcl may append additional switches "-power", "-layer_optimization", "-optimize_dft" or "-spg" conditionally based on other INTEL_* conrol vars.
#@ set INTEL_PLACE_CMD "place_opt -congestion -effort medium"
#@ 
#@ # used in psynopt.tcl
#@ set INTEL_POST_PLACE_CMD "psynopt -area_recovery -power -congestion"
#@ 
#@ # used in cts.tcl
#@ set INTEL_CLK_OPT_CMD "clock_opt -only_cts -no_clock_route -power"
#@ set INTEL_POST_CTS_OPT_CMD "psynopt -only_hold_time"
#@ 
#@ # route_trackassign.tcl may append "-power" switch conditionally based on other INTEL_* conrol vars.
#@ set INTEL_ROUTE_TRACK_ASSIGN_CMD "route_opt -stage track -effort medium -xtalk_reduction"
#@ 
#@ # used in initial_detailroute.tcl
#@ set INTEL_INITIAL_DETAIL_ROUTE_CMD "route_opt  -initial_route_only -stage detail"
#@ 
#@ # used in incr_route_opt.tcl
#@ set INTEL_INCR_ROUTE_OPT_CMD "route_opt -incremental -xtalk_reduction -power"
#@ 
#@ # used in incr_eco_detail_route.tcl
#@ set INTEL_INCR_ECO_DETAIL_ROUTE_CMD "route_zrt_eco -open_net_driven true -reroute modified_nets_first_then_others; route_zrt_detail -incremental true"
#@ 
#@ # used in incr_detailroute.tcl
#@ set INTEL_INCR_DETAIL_ROUTE_OPT_CMD "route_zrt_detail -incremental true -max_number_iterations 45"
#@ 
#@ # if additional focal_opt fixing needs to be done please update variable and add necessary focal_opt commands
#@ #set INTEL_FOCAL_OPT_CMD "focal_opt -power; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_power"
#@ # for example if drc fixing needs to be done apart from power, variable can be udpated as below
#@ # set INTEL_FOCAL_OPT_CMD "focal_opt -drc_pins all; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_drc; focal_opt -power; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_power"
#@ 
#@ # Set this according to focal_opt being done, if just -power is used, incr route may not be needed. If using other modes you will need to do incr routing.  
#@ # used in focal_opt_cleanup.tcl
#@ #set INTEL_POST_FOCAL_OPT_ROUTE_CMD "verify_zrt_route"
#@ # Example showing incr routing done for non -power focal_opt modes.
#@ # set INTEL_POST_FOCAL_OPT_ROUTE_CMD "verify_zrt_route;route_zrt_detail -incremental true"
#@ 
#@ # Set to 1 to enable dynamic power optimization in ICC
#@ set INTEL_DYNAMIC_POWER 0
#@ 
#@ #############PG Hookup##################
#@ 
#@ ## Boundary net info file are used by the tcl/binary based pg hookup flow. Not needed by runset based flow.
#@ set INTEL_PWR_HOOKUP_ATTRIB [list $fdk_stdcells_sp_dir/utilities/d04_p1273.4_c.0_all_boundary_net_info.txt                                  $fdk_stdcells_misc_dir/utilities/d04_misc_p1273.4_c.0_all_boundary_net_info.txt]
#@ 
#@ ## Runset based needed variables.
#@ set INTEL_PWR_HOOKUP_GRID_COUNT              4
#@ set INTEL_PWR_HOOKUP_LAYERS                  "vcn tcn gcn m0 v0 m1 v1"
#@ set INTEL_PWR_HOOKUP_DH_BONUS_CELLS_LIST     {c04bfy??????? d04bfy???????}
#@ set INTEL_PWR_HOOKUP_CELLS_LIST              {*c04?????[^grx]???? *d04?????[^grx]????}
#@ set INTEL_PWR_HOOKUP_CELLS_LIST_XN           {*d04?????x????}
#@ set INTEL_PWR_HOOKUP_REMOVAL_COMPATIBILITY   1
#@ 
#@ set INTEL_PROCESS_NAME p1273
#@ set INTEL_STDCELL_TILE_HEIGHT 0.399
#@ set INTEL_FLIP_FIRST_ROW 0
#@ set INTEL_XN_LIBRARY 0
#@ 
#@ # The following variables are also used, but defined in other parts of project_setup.tcl, by the runset based pg hookup.
#@ # INTEL_UPF, INTEL_MW_POWER_NET, INTEL_MW_GROUND_NET, INTEL_STDCELL_TILE, INTEL_DFM_RELEASE_DIR
#@ 
#@ 
#@ #############Floorplan##################
#@ 
#@ set INTEL_FP_INPUT                 "" ; # DEF(import fp def)|FP_TCL(import fp tcl)|""
#@ set INTEL_DESIGN_WIDTH             "";  #must be set by user for each design
#@ set INTEL_DESIGN_HEIGHT            "";  #must be set by user for each design
#@ 
#@ # Example
#@ # set INTEL_FP_BOUNDARY             "{{0.000 0.000} {2138.112 0.000} {2138.112 1804.032} {409.248 1804.032} {409.248 651.456} {0.000 651.456} {0.000 0.000}}";
#@ 
#@ set INTEL_METAL_LAYERS {m2 m3 m4 m5 m6 m7 m8 m9}
#@ set INTEL_MAX_PG_LAYER "m9"
#@ 
#@ set INTEL_STDCELL_TILE                   "core"
#@ set INTEL_STDCELL_BONUS_GATEARRAY_TILE   "bonuscore"
#@ set INTEL_STDCELL_CORE2H_TILE            "core2h"
#@ 
#@ # List of halo cells to be used during halo insertion
#@ set INTEL_halo_b_horiz         "fdk73d84_asic_halo_hhb"
#@ set INTEL_halo_c_horiz         "fdk73d84_asic_halo_hhc"
#@ set INTEL_halo_b_corner        "fdk73d84_asic_halo_hcb"
#@ set INTEL_halo_c_corner        "fdk73d84_asic_halo_hcc"
#@ set INTEL_halo_b_inside_corner "fdk73d84_asic_halo_hib"
#@ set INTEL_halo_c_inside_corner "fdk73d84_asic_halo_hic"
#@ set INTEL_halo_side            "fdk73d84_asic_halo_hvn"
#@ set INTEL_halo_power_cell      "fdk73d84_asic_halo_hvniso"
#@ 
#@ # Tap cell to be used during tap cell insertion
#@ set INTEL_TAP_CELL                       "${fdk_lib}tap02ldz05"
#@ 
#@ # Sets the terminal length for each metal layer for use in P_create_pg_terminals procedure during FRAM generation.
#@ set INTEL_TERM_LENGTH "m1 0.070 m2 0.084 m3 0.084 m4 0.084 m5 0.084 m6 0.160 m7 0.204 m8 0.274 m9 0.540"
#@ 
#@ #Create route guides over specified macros
#@ #------------------------------------------
#@ #1. Route Guides will be created only on layers m0-m4 and layers containing macro pins.
#@ #2. Route guides should be provided in the format <layer_name> <x_bloat_val> <y_bloat_val>
#@ #3. Both x and y bloat values should be provided. Either both x and y bloat should be NA (or) both x and y bloat should be a double value.
#@ #4. If both x_bloat_val and y_bloat_val equal 0, RGs will be created the exact size of the macro
#@ #5. If both x_bloat_val and y_bloat_val equal NA, RGs will not be created for that layer
#@ #6. Use INTEL_MACRO_RG_LIST(DEFAULT) to specify the default bloat values to use for all macros
#@ #7. Use INTEL_MACRO_RG_LIST(<macro_ref_name>) to override the default bloat values for the specified <macro_ref_name>
#@ #8. Use INTEL_MACRO_EXCLUSION_LIST to specify macros which should be completely excluded from creating RGs.
#@ 
#@ #Note: (E2E Spacing) - (MinSpacing value of layer in techfile) = (Bloat Value of route guide outside macro boundary)
#@ #FYI: Pre-calculated Bloat values for all layers based on M*_41 (E2E spacing) and MinSpacing value in Techfile.
#@ #set INTEL_MACRO_RG_LIST(DEFAULT)  "m2  0.032  0      m3  0  0.032  \   
#@ #                                   m4  0.032  0      m5  0  0.032  #                                   m6  0.040  0      m7  0  0.034  #                                   m8  0.014  0      m9  NA NA"
#@ 
#@ set INTEL_MACRO_RG_LIST(DEFAULT) "m2  0.032 0      m3  0  0.032     m4  0.032 0                                   m5  0     0.032  m6  NA NA        m7  NA    NA                                   m8  NA    NA     m9  NA NA"
#@ 
#@ #The example below shows how to override default RG values for macro reference (iromu1r0w6144d16w1spu0p) for layers m4 and m5.
#@ #set INTEL_MACRO_RG_LIST(iromu1r0w6144d16w1spu0p) "m4 0.10 -0.10 m5 -0.210 -0.210"
#@ 
#@ #The example below shows how to completely exclude some macro references.
#@ #set INTEL_MACRO_EXCLUSION_LIST [list iromu1r0w6144d16w1spu0p iromu1r0w6144d16w1spu1p]
#@ 
#@ # Enable bonus gate array cel pre-placement
#@ set INTEL_INSERT_BONUS_GATE_ARRAY 1
#@ 
#@ # Set pre-placement bonus array cell
#@ set INTEL_PREPLACE_BONUSGATEARRAY_CELL "${fdk_lib}bar00nnz64"
#@ 
#@ #Update the list of ports where you don't need diode insertion
#@ set INTEL_NO_INPUT_DIODE_PORTS ""
#@ 
#@ ############### LOCAL FIDUCIALS ##########################
#@ # 2x fiducial cells are placed spaced apart in staggered  fashion, the follwing variables control the fiducial cell being placed.
#@ set INTEL_LOCAL_FIDUCIAL_PREPLACE_CELL "d04qfd02ndz00"
#@ 
#@ # These cells are placed opportunistically post-route
#@ set INTEL_LOCAL_FIDUCIAL_POSTROUTE_CELLS "d04qfd02nnz00 d04qfd01ndz00"
#@ 
#@ 
#@ ################# UPF Specific variables ############################
#@ 
#@ ####################################################################################
#@ # Sets up the UPF flow specific variables
#@ # These are only block independent vars. You may need to setup block specific vars
#@ # Example of a block specfic block_setup.tcl is provided with the DHM testcase.
#@ ####################################################################################
#@ 
#@ ###################################
#@ # Generic variables
#@ ###################################
#@ 
#@ # Select the UPF power plan to use if $INTEL_UPF == 1.
#@ set INTEL_POWER_PLAN mesh_upf_1aosv
#@ 
#@ # Sets default values for Power Switch. All the values provided below are the default values. User can override these variables locally in block_setup.tcl on a per domainn basis.
#@ 
#@ # Defines the power switch lib cell to use. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_POWER_SWITCH(default) d04pws00ld8b0
#@ 
#@ # Sets the x and y pitch of Power switch used for create_power_switch_array command. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_PS_X_PITCH(default) 13.44
#@ set INTEL_PS_Y_PITCH(default) 9.576
#@ 
#@ # Set the connect configuration for Power switch enables. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_PS_CONNECT_CONFIG(default) "daisy"
#@ set INTEL_PS_CONNECT_CORNER(default) "lower_left"
#@ 
#@ # The following variables(INTEL_PS_ALIGN_METAL_*) are used by the flow to calculate lower_left offset of power switches w.r.to the voltage area.
#@ # The values provided below are offset values of AON Power straps for the layer specified.
#@ # These values are used to align the Power Switch cells under m7 and m6.
#@ # Users are not needed to change these values unless the Power Strap offsets/pitch is updated (or) users want to align the power swtich cells differently and not under m6/m7 AON straps
#@ 
#@ # The offset value provides the offset values for AON power straps in the same order as the INTEL_UPF_POWER_NETS. The value also changes for singe supply vs dual supply grids. The variable is indexed accordingly
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_2aosv,m7) {0.896 1.344 2.464}
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_1aosv,m7) {0.896 2.464}
#@ 
#@ # The pitch value provides the pitch of AON power straps for which the offset is provided above.
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_2aosv,m7) 6.72
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_1aosv,m7) 6.72
#@ 
#@ # Values for m6 AON straps
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_2aosv,m6) {0.336 0.672 2.520}
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_1aosv,m6) {0.336 1.932}
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_2aosv,m6) 3.192
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_1aosv,m6) 3.192
#@ 
#@ # Values for power switch offset for top/right boundary. The left/bottom offset is calculated by flow based on INTEL_PS_ALIGN_METAL_* values provided above.
#@ # For a non-zero value, the insertion region for power switches is shrinked from the voltage area boundary by the offset value provided below.
#@ set INTEL_PS_RIGHT_OFFSET 0
#@ set INTEL_PS_TOP_OFFSET 0
#@ 
#@ # Users can create Level shifter bounds and assign level shifters cells to these bounds.
#@ # All Always-on straps are distributed over these bounds to enable seconday PG hookup for Level shifter cells.
#@ # Users need to set the variables following the constraints provided.
#@ 
#@ # NOTE: Side margins for VA bands start from lower left-most side of voltage area of $power_domain in clockwise order, and must be 0 or positive numbers on grids of horizontal placement width for vertical sides and double-row height for horizontal sides.
#@ # NOTE: Number of margins must match the sides of voltage area of $power_domain.
#@ # NOTE: VA band width should be at least widths of vertical halo cell + widest isolation or level-shifter cells used.
#@ # NOTE: VA band height should be at least 2 rows as the lwevel shifter cells are double height cells.
#@ 
#@ # NOTE: INTEL_LS_BOUND_CELLS($power_domain,<inner/outer>) must match cells of level shifter with parent/self location of $power_domain specified in UPF.
#@ 
#@ #set INTEL_LS_BOUND(pd_sleep1,inner) "0 0 $band_width 0"
#@ #set INTEL_LS_BOUND_CELLS(pd_sleep1,inner) u_dhm_unit_1/u_dhm_bypass/u_dhm_sleep_logic/*_UPF_LS
#@ 
#@ # Set name of templates to use from template file
#@ # The template name values provided below are for the default templates provided with the kit. Users are expected to update this list only if they change template names/add additional templates.
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,top) {common common_second_swap}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,always_on) {always_on_swap always_on always_on_second always_on_third}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,primary) {primary primary_second primary_third}
#@ 
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,top) {common common_second_swap}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,always_on) {always_on always_on_second_vss}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,primary) {primary primary_second primary_second_swap primary_second_power}
#@ 
#@ 
#@ ###############################################
#@ # Variables used for Secondary PG hookup
#@ ###############################################
#@ 
#@ #Note - Use 1aosv if $INTEL_POWER_PLAN is set to mesh_upf_1aosv. Use 2aosv if $INTEL_POWER_PLAN is set to mesh_upf_2aosv.
#@ #none implies default params applied across the entire design. Specify <va_name> to override params for a specific voltage area.
#@ 
#@ # INTEL_PWRGRID_PARAMS_PRIMARY(1aosv/2aosv, <va_name>/none) "<layer> <width> <pitch> <offset>"
#@ 
#@ set INTEL_PWRGRID_PARAMS_PRIMARY(1aosv,none)  "m4b 0.076 6.384 5.090                                                m4a 0.076 6.384 2.890                                                m4  0.084 6.384 0.798                                                m3  0.084 1.680 1.288"
#@ 
#@ set INTEL_PWRGRID_PARAMS_PRIMARY(2aosv,none)   "m4b 0.084 9.576 7.182                                                 m4a 0.084 9.576 3.990                                                 m4  0.084 9.576 0.798                                                 m3  0.084 1.680 1.288"
#@ 
#@ # INTEL_PWRGRID_PARAMS_PRIMARY(1aosv/2aosv, <index>, <va_name>/none) "<layer> <width> <pitch> <offset>"
#@ # index implies index value of the AON net in INTEL_UPF_POWER_NETS.
#@ # Eg. INTEL_UPF_POWER_NETS is [list vss vcc vccL]. To specify params for vcc AON, use index 1. To specify params for vccL AON, use index 2.
#@ 
#@ set INTEL_PWRGRID_PARAMS_AON(1aosv,1,none)    "m4b 0.076 6.384 6.082                                                m4a 0.084 6.384 3.990                                                m4  0.076 6.384 1.898                                                m3  0.084 1.680 1000000.0"
#@ set INTEL_PWRGRID_PARAMS_AON(2aosv,1,none)     "m4b 0.076 9.576 8.282                                                 m4a 0.076 9.576 5.090                                                 m4  0.076 9.576 1.898                                                 m3  0.084 1.680 1000000.0"
#@ set INTEL_PWRGRID_PARAMS_AON(2aosv,2,none)     "m4b 0.076 9.576 9.274                                                 m4a 0.076 9.576 6.082                                                 m4  0.076 9.576 2.890                                                 m3  0.084 1.680 1000000.0"
#@ 
#@ ################################################
#@ # Variables used for Frequency based Max-Cap LUT
#@ ################################################
#@ #Location of Max-Cap LUT CSV file
#@ set INTEL_CMAX_LUT $env(INTEL_STDCELLS)/erc/stdcell73_3x1r6u1_d04_rv_allfreq.csv
#@ 
#@ #Clock period to use if min clock period could not be determined
#@ set INTEL_CMAX_DEFAULT_PERIOD 1500.00
#@ 
#@ #############Placement##################
#@ 
#@ set INTEL_CRITICAL_RANGE           "2000";
#@ set INTEL_AREA_CRITICAL_RANGE      "not_set";
#@ set INTEL_POWER_CRITICAL_RANGE     "not_set";
#@ set INTEL_TIE_HIGH_CELL            "${fdk_lib}tih00wnz00"
#@ set INTEL_TIE_LOW_CELL             "${fdk_lib}til00wnz00"
#@ 
#@ set INTEL_INSERT_SPARE_KITS        "0"
#@ set INTEL_SPARE_CELLS              "${fdk_lib}nan02ln0b5 ${fdk_lib}nan02ln0c0 ${fdk_lib}nan02ln0d0 ${fdk_lib}non02ln0b5 ${fdk_lib}non02ln0c0 ${fdk_lib}non02ln0c5 ${fdk_lib}inn00ln0a5 ${fdk_lib}inn00ln0b5"
#@ set INTEL_DIST_BTW_SPARE_KITS      "30";
#@ 
#@ ## Set to 1 to enable Layer Promotion
#@ set INTEL_LAYER_PROMOTION           0
#@ 
#@ # Set to "magnet" for magnet placement, "port" for placing cells close to ports and "" to let place_opt place the iso cells.
#@ set INTEL_ISOCELL_PLACER            ""
#@ 
#@ ################CTS#####################
#@ 
#@ set INTEL_CTS_NETS                          ""
#@ set INTEL_CTS_MAX_ROUTING_LAYER(DEFAULT)    "m8"
#@ set INTEL_CTS_MIN_ROUTING_LAYER(DEFAULT)    "m6"
#@ set INTEL_CTS_LEAF_MIN_LAYER                "m6"
#@ set INTEL_CTS_LEAF_MAX_LAYER                "m7"
#@ set INTEL_ENABLE_CLOCK_SPACING              "1" ; #Enables/disables clock cell spacing for IR/EM
#@ set INTEL_CTS_MAX_FANOUT                    "24"
#@ set INTEL_CTS_ADVANCED_DRC_FIXING           "true"
#@ 
#@ ######################################
#@ # CTS NDR SETUP
#@ ######################################
#@ set INTEL_ENABLE_CLOCK_NDR "1"
#@ set INTEL_CTS_NDR_RULE(DEFAULT) "ndr_defaultW_3T_noSh_Lth"
#@ 
#@ ########################################################################
#@ # NDR definitions for each clock in the design
#@ #   Note - If INTEL_ENABLE_CLOCK_NDR is set to '0', then default routing
#@ #          rules are used for clocks
#@ ########################################################################
#@ #set INTEL_CTS_NDR_RULE(clk) "2xSpacing"
#@ #set INTEL_CTS_MAX_ROUTING_LAYER(clk) "m8"
#@ #set INTEL_CTS_MIN_ROUTING_LAYER(clk) "m7"
#@ 
#@ set INTEL_CTS_CELLS_DEFAULT "${fdk_lib}gbf00nd0* ${fdk_lib}gin00nd*"
#@ set INTEL_CTS_CELLS_SIZE "${fdk_lib}gbf00nd0* ${fdk_lib}gin00nd* ${fdk_lib}cgc01nd* ${fdk_lib}cgc03nd*                           ${fdk_lib}cgc00nd* ${fdk_lib}cgc02nd* ${fdk_lib}cgm22nd*                           ${fdk_lib}gan10nd* ${fdk_lib}gan20nd*                           ${fdk_lib}gan30nd* ${fdk_lib}gan40nd*                           ${fdk_lib}gmx22nd* ${fdk_lib}gna00nd*                           ${fdk_lib}gna02nd* ${fdk_lib}gno00nd*                           ${fdk_lib}gno02nd* ${fdk_lib}gor00nd*"
#@ set INTEL_CTS_CELLS_DELAY_INSERT "${fdk_lib}gbf10nd* ${fdk_lib}gbf20nd* ${fdk_lib}gbf30nd* ${fdk_lib}gin20nd*"
#@ set INTEL_CTS_CELL_BOUNDARY "${fdk_lib}gbf00nd0h0"
#@ 
#@ ##############Routing###################
#@ 
#@ set INTEL_ZROUTE_FIX_ANTENNA       1
#@ set INTEL_ZROUTE_VIA_DBL           "1"     ;# Redundant via insertion
#@ set INTEL_ANTENNA_DIODE            "${fdk_lib}gnc01lnz00"
#@ set INTEL_DELAY_CELL_LIST          "${fdk_lib}bfn11wn* ${fdk_lib}bfn12wn* ${fdk_lib}bfn13wn*"
#@ 
#@ #############Filler cells###############
#@ 
#@ set INTEL_BONUS_GATEARRAY_CELLS    "${fdk_lib}bar00nnz64 ${fdk_lib}bar00nnz32 ${fdk_lib}bar01nnz16 ${fdk_lib}bar01nnz08 ${fdk_lib}bar01nnz04"
#@ set INTEL_STDCELL_FILLER_CELLS     "${fdk_lib}spc00nnz03 ${fdk_lib}spc00nnz02 ${fdk_lib}spc00nnz01"
#@ set INTEL_DECAP_CELLS              "${fdk_lib}dcp00wnz08 ${fdk_lib}dcp00wnz04"
#@ set INTEL_2X_DECAP_CELLS           "${fdk_lib}dcp00wdz64"
#@ 
#@ # Set this switch to pick type of fillers, valid options are default & decap. Please refer add_filler_cells.tcl for more details
#@ set INTEL_STDCELL_FILLER_MODE decap
#@ 
#@ ############Metal/via fill##############
#@ 
#@ set INTEL_DFM_RELEASE_DIR   $fdk_icv_fill_dir
#@ set INTEL_DFM_UIN_DIR       $INTEL_DFM_RELEASE_DIR/uin/${fdk_lib}
#@ set INTEL_DFM_WRITE_MW_OUTPUT true
#@ set INTEL_DFM_ZONE_VIA_FILL true
#@ set INTEL_DFM_MAX_FILL_LAYER "m9"
#@ 
#@ ################ ADR ###################
#@ 
#@ set INTEL_ADR_RELEASEPATH $fdk_icv_adr_dir
#@ set INTEL_ADR_RUNSET_FILE "$INTEL_ADR_RELEASEPATH/adr.rs"
#@ # Sets pointer to configuration file that defines DRCs to target
#@ set INTEL_ADR_CONFIG_FILE "$INTEL_ADR_RELEASEPATH/adr.cfg"
#@ set INTEL_ADR_USER_DEF_OPT "-I . -I [pwd]/adr_work/adr_control/ -I $INTEL_ADR_RELEASEPATH/ -I $INTEL_DFM_UIN_DIR/"
#@ # Specifies the number of ADR iterations
#@ set INTEL_ADR_LOOPS 5
#@ 
#@ ############# ECO Flow Specific Variables #######
#@ # NOTE: In Normal Operation INTEL_ECO_TYPE is set 0; In ECO mode INTEL_ECO_TYPE can be set to 1, 2 or 3 based on the type of ECO that you are performing
#@ # When INTEL_ECO_TYPE set to 1, ECO is based on a TCL script where all your ECO's are defined.
#@ # When INTEL_ECO_TYPE set to 2, ECO is based on a verilog netlist. It is a unfreeze approach.  A verilog netlist w/ minor deltas is used.
#@ # For freeze silicon verilog approach, refer to place_freeze_silicon command in ICC for more details.
#@ set INTEL_ECO_TYPE 0
#@ #set INTEL_ECO_TCL inputs/eco1.tcl
#@ #set INTEL_ECO_NETLIST dhm.eco2.vg
#@ 
#@ ############# MCMM Flow Specific Variables ################
#@ # Comments on MCMM Flow:
#@ # The prerequisite for running the MCMM flow is:
#@ #   1) The library.tcl is updated to include PVTs referenced here by set_operating_conditions. Macros PVT must match the PVT of the stdcell libraries for the tools to link to them correctly.
#@ #   2) The variable below be set for each scenario created.
#@ #
#@ # All MCMM related setup is now done through create_scenarios.tcl. If something custom is required, please copy the file over locally an modify as needed.
#@ 
#@ # When using MCMM (set INTEL_MCMM 1), it is set to 0 by default
#@ # Also need to set all the MCMM variables below (example provided below)
#@ set INTEL_MCMM 0
#@ 
#@ ### Specify the name of each scenario.
#@ ### By default, all scenarios are active.
#@ ##set INTEL_MCMM_SCENARIOS         "max_corner_1 max_corner_2 min_corner_1"
#@ ##
#@ ### Specify the active scenarios by step. (OPTIONAL)
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(place)      "max_corner_1"
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(post_place) "max_corner_1 max_corner_2"
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(cts)        "max_corner_1 min_corner_1"
#@ ##
#@ ### Specify the default 'current_scenario'
#@ ##set INTEL_MCMM_SCENARIO_DEFAULT  "max_corner_1"
#@ ##
#@ ### Foreach scenario, define the operating condition for that scenario.
#@ ##set INTEL_MCMM_OPCON(max_corner_1) "set_operating_conditions -analysis_type on_chip_variation -max slow_1.00 -max_library d04_nn_p1273_6x1r2_psss_0.75v_125c_ccst"
#@ ##set INTEL_MCMM_OPCON(max_corner_2) "set_operating_conditions -analysis_type on_chip_variation -max slow_1.00 -max_library d04_nn_p1273_6x1r2_psss_0.98v_125c_ccst"
#@ ##set INTEL_MCMM_OPCON(min_corner_2) "set_operating_conditions -analysis_type on_chip_variation -max fast_1.00 -max_library d04_nn_p1273_6x1r2_pfff_0.98v_-40c_ccst"
#@ ##
#@ ### Foreach scenario, define the min and max tlu+ file
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(max_corner_1) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(max_corner_2) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(min_corner_1) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(max_corner_1) $INTEL_MIN_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(max_corner_2) $INTEL_MIN_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(min_corner_1) $INTEL_MIN_TLUPLUS_FILE
#@ ##
#@ ### Foreach scenario, define the min and max emulated tlu+ file (OPTIONAL)
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(max_corner_1) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(max_corner_2) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(min_corner_1) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(max_corner_1) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(max_corner_2) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(min_corner_1) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ 
#@ ### For scenario options, please provide just true or false for setup, hold, leakage_power, and cts_mode.
#@ ### The values for cts_corner can be max, min, min_max or none.
#@ ### Please refer to the set_scenario_options man page for further information.
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(max_corner_1)   "set_scenario_options -setup true  -hold true  -leakage_power true  -cts_mode true -cts_corner max"
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(max_corner_2)   "set_scenario_options -setup true  -hold true  -leakage_power true  -cts_mode true -cts_corner max"
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(min_corner_2)   "set_scenario_options -setup false -hold true  -leakage_power false -cts_mode false"
#@ 
#@ # The MCMM flow will either read all SDC files or all tcl files (but not both) for each scenario.
#@ # This is controlled via the $INTEL_SDC_FILE
#@ #        if {$INTEL_SDC_FILE == 1} {foreach $INTEL_MCMM_CONS_SDC($scenario) { read_sdc $sdc }}
#@ #   elseif ($INTEL_SDC_FILE == 0} {foreach $INTEL_MCMM_CONS_TCL($scenario) { source $tcl }}
#@ set INTEL_SDC_FILE 0
#@ ##set INTEL_MCMM_CONS_SDC(max_corner_1) "./inputs/constraints/max_corner_1.clocks.sdc ./inputs/constraints/max_corner_1.io.sdc"
#@ ##set INTEL_MCMM_CONS_SDC(max_corner_2) "./inputs/constraints/max_corner_2.clocks.sdc ./inputs/constraints/max_corner_2.io.sdc"
#@ ##set INTEL_MCMM_CONS_SDC(min_corner_1) "./inputs/constraints/min_corner_1.clocks.sdc ./inputs/constraints/min_corner_1.io.sdc"
#@ ### OR
#@ ##set INTEL_MCMM_CONS_TCL(max_corner_1) "./inputs/constraints/max_corner_1.clocks.tcl ./inputs/constraints/max_corner_1.io.tcl"
#@ ##set INTEL_MCMM_CONS_TCL(max_corner_2) "./inputs/constraints/max_corner_2.clocks.tcl ./inputs/constraints/max_corner_2.io.tcl"
#@ ##set INTEL_MCMM_CONS_TCL(min_corner_2) "./inputs/constraints/min_corner_1.clocks.tcl ./inputs/constraints/min_corner_1.io.tcl"
#@ 
#@ # In the case where two scenarios are defined to have similar PVT, the tool can have difficulty distinguishing which library to associate for that scenario.
#@ # For this case, there is an optional setting INTEL_MCMM_LINK_LIBRARY_SUBSET which will use the tool command link_library_subset to specify which libraries should be used for the given scenario.
#@ #set INTEL_MCMM_LINK_LIBRARY_SUBSET(max_corner_1) [list d04_ln_p1273_6x1r2_psss_0.75v_-40c_nldm.ldb]
#@ #set INTEL_MCMM_LINK_LIBRARY_SUBSET(max_corner_2) [list d04_ln_p1273_6x1r2_pfff_0.75v_-40c_nldm.ldb]
#@ 
#@ ###########STA Specific##################
#@ ########################################
#@ 
#@ ###########Setup Variables##############
#@ 
#@ if {[regexp {^pt_shell} $synopsys_program_name]} {
#@   # Variable used to set operating condition. Valid values are bc_wc, on_chip_variation.
#@   set INTEL_ANALYSIS_TYPE             "on_chip_variation"
#@ }
#@ 
#@ # Include List of all lib pair (max corner used for link lib during PV). The min lib will be used for setting the set_min_library which will provide the min lib corresponding to all max lib.
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(max)   "${fdk_lib}_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_nn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_ln_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_wn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_yn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(min)   "${fdk_lib}_nn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_nn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_ln_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_ln_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_wn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_wn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_yn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_yn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(power) "${fdk_lib}_nn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_nn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_ln_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_ln_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_wn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_wn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_yn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_yn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_nn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_ln_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_wn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_yn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(noise) "${fdk_lib}_nn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_nn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_ln_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_ln_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_wn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_wn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_yn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_yn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm"
#@ 
#@ # Specify the valid run_type and stage. User can configure custom run type and stages in the following vars.
#@ set INTEL_RUN_TYPES                  [list max min noise power]
#@ set INTEL_RUN_STAGES                 [list prelayout prects postlayout]
#@ 
#@ # Set the extraction file (SPEF) for the design.
#@ 
#@ set INTEL_SPEF_FILE(max)           ""
#@ set INTEL_SPEF_FILE(min)     ""
#@ set INTEL_SPEF_FILE(noise)     ""
#@ set INTEL_SPEF_FILE(power)     ""
#@ 
#@ # Set the SDC File for the design.
#@ set INTEL_PV_SDC(max)                   ""
#@ set INTEL_PV_SDC(min)                   ""
#@ set INTEL_PV_SDC(power)                 ""
#@ set INTEL_PV_SDC(noise)                 ""
#@ 
#@ # Set the Max-Min Operating conditions for the design.
#@ set INTEL_PV_MAX_OPCON(max)             "slow_1.00"
#@ set INTEL_PV_MAX_OPCON(min)             "fast_1.00"
#@ set INTEL_PV_MAX_OPCON(power)           "typical_1.00"
#@ set INTEL_PV_MAX_OPCON(noise)           "fast_1.00"
#@ 
#@ set INTEL_PV_MIN_OPCON(max)             "slow_1.00"
#@ set INTEL_PV_MIN_OPCON(min)             "fast_1.00"
#@ set INTEL_PV_MIN_OPCON(power)           "typical_1.00"
#@ set INTEL_PV_MIN_OPCON(noise)           "fast_1.00"
#@ 
#@ # Configure the number of cores on the local machine to use during the run.
#@ set_host_options -max_cores 4
#@ 
#@ # Variable used to setup AOCVM based runs.
#@ set INTEL_ENABLE_AOCVM     0
#@ 
#@ # Variables used to define early and late AOCVM tables. Populate the list with entire path of the table.
#@ set INTEL_AOCVM_TABLE(max)   [list ]
#@ set INTEL_AOCVM_TABLE(min)   [list ]
#@ 
#@ 
#@ 
#@ # Variable used to enable ILM generation for design.
#@ set INTEL_GENERATE_ILM               0
#@ 
#@ # Variable used to set absolute and percentage comparison limit for ILM model validation.
#@ set INTEL_ILM_ABS_TOL                200
#@ set INTEL_ILM_PER_TOL                5
#@ 
#@ #Variable to invoke PV Fast Analysis
#@ set INTEL_PV_FAST_ANALYSIS           0
#@ 
#@ ###########DMSA Variables (Variables not yet in use!!)##############
#@ 
#@ # Define DMSA corners: <mode> <run-type> <slew> <voltage> <temperature>
#@ # Syntax: <func|scan_shift|scan_capture> <max|min|power|noise> <psss|tttt|pfff> <lib voltage as in library name> <lib temp as in library name>
#@ set INTEL_DMSA_VARS               "func max psss 0.9v 125.00c                                scan_shift max psss 0.9v 125.00c                                scan_capture max psss 0.9v 125.00c                                func min pfff 1.025v 0.00c                                scan_shift min pfff 1.025v 0.00c                                scan_capture min pfff 1.025v 0.00c                                func power pfff 1.025v 0.00c                                func power psss 1.025v 105.00c"
#@ 
#@ # Specify all Vt variants present in netlist
#@ set INTEL_DMSA_VT                  [list ln nn wn]
#@ 
#@ # Scenarios to analyze currently. Can contain wildcard characters"
#@ set INTEL_DMSA_CURRENT_SCENARIOS   ""
#@ 
#@ # SPEF files for all corners. Create similar variables for extra temperatures than provided above.
#@ set INTEL_DMSA_SPEF(0.00)          ""
#@ set INTEL_DMSA_SPEF(125.00)        ""
#@ 
#@ # Clocks for all runs
#@ set INTEL_DMSA_CLOCKS              ""
#@ 
#@ # Constraint file for all run types
#@ set INTEL_DMSA_CONSTRAINTS(max)    ""
#@ set INTEL_DMSA_CONSTRAINTS(min)    ""
#@ set INTEL_DMSA_CONSTRAINTS(power)  ""
#@ set INTEL_DMSA_CONSTRAINTS(noise)  ""
#@ 
#@ # SDC files for all run types
#@ set INTEL_DMSA_SDC(max)           ""
#@ set INTEL_DMSA_SDC(min)           ""
#@ set INTEL_DMSA_SDC(power)         ""
#@ set INTEL_DMSA_SDC(noise)         ""
#@ 
#@ ############Power variables#############
#@ 
#@ # Variable is used to enable VCD/SAIF file read for PTPX Power Calculation ./inputs/${INTEL_DESIGN_NAME}.vcd/.fsdb/.saif. Specify the full path of the activity file name.
#@ set INTEL_ACTIVITY_FILE    ""
#@ 
#@ # Specifies a path prefix that is to be stripped from all the object names read from the VCD file. This option is applied to strip the testbench/instance path from the VCD file.
#@ set INTEL_STRIP_PATH         ""
#@ 
#@ # Variables used to specify the map file while using VCD from RTL. Give full path of the file. Map file will make sure that RTL names in the VCD match with those in the gate-level netlist.
#@ set INTEL_RTL_VCD_MAP_FILE     ""
#@ 
#@ # Variable used to set average or peak power_analysis type. Valid values are avg, peak.
#@ set INTEL_POWER_ANALYSIS     "avg"
#@ 
#@ ########################################
#@ #Outputs and Reports Variables
#@ ########################################
#@ 
#@ #############Synthesis##################
#@ ########################################
#@ 
#@ # Setting the reports var. All the reports listed are in common/scripts/procs_reference.tcl
#@ set INTEL_REPORTS(inc_compile) "qor area clock clock_gating max_delay max_cap                                 max_tran all_violators saif power check_timing                                 check_design high_fanout timing_setup timing_setup_groups                                 timing_loops congestion dft_drc dft_signal scanpath vars check_mv_design"
#@ 
#@ # Variable used to control report_timing parameters
#@ foreach step $INTEL_SYN_STEPS {
#@   set INTEL_MAX_PATHS($step)   1000
#@   set INTEL_SLACK_LIMIT($step) 9999
#@   set INTEL_NWORST($step)      1
#@ }
#@ 
#@ set INTEL_OUTPUTS(compile)     "verilog upf"
#@ set INTEL_OUTPUTS(insert_dft)  "verilog upf"
#@ if { $::sh_product_version < {I-2013.12} } {
#@   set INTEL_OUTPUTS(inc_compile) "verilog upf sdc saif spef scandef syn_def"
#@ } else {
#@   set INTEL_OUTPUTS(inc_compile) "verilog upf sdc saif spef scandef def"
#@ }
#@ 
#@ ################ APR ################################################
#@ #####################################################################
#@ 
#@ # Available report types:
#@ # NOTE: check_mv_design & upf will only be reported if $INTEL_UPF == 1.
#@ # Design checks:   check_design check_mv_design check_timing check_legality check_zrt_routability
#@ # Design reports:  area threshold_voltage_group high_fanout physical
#@ # UPF reports:     upf
#@ # Timing reports:  qor all_violators timing_setup timing_hold timing_setup_zeroRC timing_setup_groups timing_loops
#@ # Clock reports:   clock_tree clock_gating
#@ # Power reports:   saif power
#@ # Route reports:   verify_zrt_route lvs
#@ # Other reports:   logic_levels vars
#@ 
#@ set INTEL_REPORTS(import_design)    "timing_setup_zeroRC flow_vars"
#@ 
#@ set INTEL_REPORTS(floorplan)        ""
#@ set INTEL_REPORTS(upf_floorplan)    "$INTEL_REPORTS(floorplan) check_mv_design upf"
#@ 
#@ set INTEL_REPORTS(place)            "qor physical"
#@ set INTEL_REPORTS(upf_place)        $INTEL_REPORTS(place)
#@ set INTEL_REPORTS(post_place)       $INTEL_REPORTS(place)
#@ set INTEL_REPORTS(upf_post_place)   "$INTEL_REPORTS(post_place) check_mv_design upf"
#@ 
#@ set INTEL_REPORTS(cts)              "clock_tree qor physical"
#@ 
#@ set INTEL_REPORTS(route)            "all_violators timing_setup timing_hold qor power                                      threshold_voltage_group logic_levels vars physical lvs"
#@ set INTEL_REPORTS(post_route)       $INTEL_REPORTS(route)
#@ set INTEL_REPORTS(upf_post_route)   "$INTEL_REPORTS(post_route) check_mv_design upf"
#@ 
#@ #set INTEL_REPORTS(focal_opt)         $INTEL_REPORTS(post_route)
#@ set INTEL_REPORTS(fill)             "$INTEL_REPORTS(post_route) timing_setup_groups"
#@ 
#@ foreach step $INTEL_APR_STEPS {
#@   set INTEL_MAX_PATHS($step)   1000
#@   set INTEL_SLACK_LIMIT($step) 9999
#@   set INTEL_NWORST($step)      1
#@ }
#@ 
#@ # Available output types: verilog verilog_pg spef def fp sdc oas gds
#@ # NOTE: check_mv_design & upf will only be reported if $INTEL_UPF == 1.
#@ 
#@ set INTEL_OUTPUTS(import_design)   ""
#@ set INTEL_OUTPUTS(floorplan)       ""
#@ set INTEL_OUTPUTS(upf_floorplan)   $INTEL_OUTPUTS(floorplan)
#@ set INTEL_OUTPUTS(place)           ""
#@ set INTEL_OUTPUTS(upf_place)       $INTEL_OUTPUTS(place)
#@ set INTEL_OUTPUTS(post_place)      $INTEL_OUTPUTS(place)
#@ set INTEL_OUTPUTS(upf_post_place)  $INTEL_OUTPUTS(post_place)
#@ set INTEL_OUTPUTS(cts)             ""
#@ set INTEL_OUTPUTS(route)           "verilog_pg oas"
#@ set INTEL_OUTPUTS(post_route)      $INTEL_OUTPUTS(route)
#@ set INTEL_OUTPUTS(upf_post_route)  $INTEL_OUTPUTS(post_route)
#@ #set INTEL_OUTPUTS(focal_opt)       $INTEL_OUTPUTS(route)
#@ set INTEL_OUTPUTS(adr)             "$INTEL_OUTPUTS(route) def"
#@ set INTEL_OUTPUTS(fill)            "verilog verilog_pg upf sdc def spef oas lteloc techlef"
#@ set INTEL_OUTPUTS(eco)             "verilog verilog_pg upf sdc def spef oas"
#@ 
#@ ################PV######################
#@ 
#@ # Variable used to set generate reports for different runs
#@ 
#@ set INTEL_REPORTS(max)             [list timing_setup all_violators clock check_timing timing_setup_groups pin_margin net_attribute pin_attribute parasitic_not_annotated_check vars max_cap max_tran max_delay error_info aocvm qor min_pulse_width]
#@ set INTEL_REPORTS(min)             [list timing_hold  all_violators clock check_timing timing_hold_groups  pin_margin net_attribute pin_attribute parasitic_not_annotated_check vars error_info aocvm qor min_pulse_width]
#@ set INTEL_REPORTS(noise)           [list noise_all_vio noise_below noise_above check_noise parasitic_not_annotated_check max_analysis_coverage vars error_info qor]
#@ set INTEL_REPORTS(power)           [list power switching_activity missing_power_tables parasitic_not_annotated_check vars error_info qor]
#@ 
#@ # Variable used to control report_timing parameters
#@ set INTEL_MAX_PATHS(max)            1000
#@ set INTEL_SLACK_LIMIT(max)          9999
#@ set INTEL_NWORST(max)               1
#@ 
#@ set INTEL_MAX_PATHS(min)            1000
#@ set INTEL_SLACK_LIMIT(min)          9999
#@ set INTEL_NWORST(min)               1
#@ 
#@ set INTEL_MAX_PATHS(power)            1000
#@ set INTEL_SLACK_LIMIT(power)          9999
#@ set INTEL_NWORST(power)               1
#@ 
#@ set INTEL_MAX_PATHS(noise)            1000
#@ set INTEL_SLACK_LIMIT(noise)          9999
#@ set INTEL_NWORST(noise)               1
#@ 
#@ # ERC checks variables and reporting
#@ # Variable to enable ERC checks
#@ set INTEL_PT_ERC_CHECK_ENABLE 0
#@ 
#@ 
#@ 
#@ 
#@ ################PV-DMSA (Variables not yet in use!!)######################
#@ 
#@ set INTEL_REPORTS(dmsa)              [list timing_setup timing_hold all_violators vars max_cap max_tran max_delay max_analysis_coverage clock_summary]
#@ set INTEL_MAX_PATHS(dmsa)            1000
#@ set INTEL_SLACK_LIMIT(dmsa)          9999
#@ set INTEL_NWORST(dmsa)               1
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/project_setup.tcl

#@ 
#@ ### design specific setting
#@ P_source_if_exists block_setup.tcl -require
#@ # -- Starting source ./scripts/block_setup.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ ############
#@ #Common vars
#@ ############
#@ 
#@ # Top level block name for Physical Design
#@ set INTEL_DESIGN_NAME 		fdkex
#@ 
#@ ##############
#@ #Syn vars
#@ ##############
#@ 
#@ # For setting up synthesis with scan, set G_INSERT_SCAN to 1, else set it to 0.
#@ set INTEL_INSERT_SCAN                      1
#@ 
#@ 
#@ 
#@ 
#@ 
#@ # -- End source ./scripts/block_setup.tcl

#@ 
#@ 
#@ P_source_if_exists library.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dot3/d04/library.tcl

#@ ##############################################################################
#@ 
#@ ##############################################################
#@ # The list of procs used by this script:
#@ # 1. P_msg_info
#@ #
#@ ###############################################################
#@ 
#@ ###########################################
#@ # Variables for CCST Timing Model
#@ ###########################################
#@ 
#@ # NOTE : Set the variables to basic for NLDM Timing Model if required.
#@ 
#@ P_msg_info "==>INFORMATION: Setting variables to support CCS Timing Models"
#@ set_app_var rc_driver_model_mode advanced
#@ set_app_var rc_receiver_model_mode advanced
#@ 
#@ ###########################################################################
#@ # Description: This file sets up libraries for the entire design
#@ ###########################################################################
#@ 
#@ # NOTE: This is a reference of what could be done. You can use hard paths here.
#@ 
#@ set tmp_search_path [list                          $env(INTEL_STDCELLS)/lib/ln                          $env(INTEL_STDCELLS)/lib/nn                          $env(INTEL_STDCELLS)/lib/wn                          $env(INTEL_STDCELLS)/lib/yn                          $env(INTEL_STDCELLS)/ccs/ln                          $env(INTEL_STDCELLS)/ccs/nn                          $env(INTEL_STDCELLS)/ccs/wn                          $env(INTEL_STDCELLS)/ccs/yn                     ]
#@ set_app_var search_path [concat $search_path [lsort -unique $tmp_search_path]]
#@ 
#@ P_msg_info "==>INFORMATION: search_path is set to $search_path"
#@ 
#@ 
#@ set_app_var target_library [list                                 d04_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                                 d04_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                                 d04_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                                 d04_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                                 ]
#@ 
#@ puts "==>INFORMATION: target_library is set to $target_library"
#@ 
#@ 
#@ set_app_var link_library [list *]
#@ set_app_var link_library [concat $link_library $target_library]
#@ set_app_var link_library [concat $link_library dw_foundation.sldb]
#@ 
#@ P_msg_info "==>INFORMATION: link_library is set to $link_library"
#@ 
#@ set mw_reference_library [list                               $env(INTEL_STDCELLS)/fram/ln/d04_ln                               $env(INTEL_STDCELLS)/fram/nn/d04_nn                               $env(INTEL_STDCELLS)/fram/wn/d04_wn                               $env(INTEL_STDCELLS)/fram/yn/d04_yn ]
#@ 
#@ P_msg_info "==>INFORMATION: mw_reference_library is set to $mw_reference_library"
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dot3/d04/library.tcl

#@ P_source_if_exists dc_var_setup.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dc_var_setup.tcl

#@ ##############################################################################
#@ 
#@ set start_time [clock seconds]
#@ #puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ ################################################################################
#@ # Description: This file sets up DC specific default variables used in the flow.
#@ ################################################################################
#@ 
#@ ####################
#@ # General Settings
#@ ####################
#@ set_app_var sh_continue_on_error false
#@ set_app_var enable_page_mode false
#@ 
#@ ########################
#@ ## UPF Specific settings
#@ ########################
#@ if {($synopsys_program_name == "dc_shell") && [info exists INTEL_UPF] && $INTEL_UPF } {
#@   if { [info exists INTEL_UPF_VERSION] && $INTEL_UPF_VERSION >= 2.0 } {
#@     set_app_var upf_create_implicit_supply_sets true
#@   } else {
#@     set_app_var upf_create_implicit_supply_sets false
#@   }
#@   set_app_var enable_ao_synthesis true
#@   set_app_var mv_insert_level_shifters_on_ideal_nets all
#@   set_app_var auto_insert_level_shifters_on_clocks all
#@   #set_app_var mv_no_main_power_violations false
#@ }
#@ 
#@ ##########################################
#@ # LIMIT WARNINGS and INFORMATION Messages
#@ ########################################
#@ # Warning: Design rule attributes from the driving cell will be set on the port. (UID-401)
#@ set_message_info -id UID-401 -limit 5
#@ 
#@ # Limit the message showing info about defining new variable
#@ # Information: Defining new variable 'INTEL_INSERT_SCAN'. (CMD-041)
#@ set_message_info -id CMD-041 -limit 5
#@ 
#@ ##################################
#@ # DC Explorer Variable
#@ ###############################
#@ if {[shell_is_in_exploration_mode]} {
#@   set enable_presynthesis_floorplanning true
#@ }
#@ 
#@ ######################################
#@ # Final output/verilog output settings
#@ ########################################
#@ set_app_var report_default_significant_digits 3
#@ 
#@ #set_app_var high_fanout_net_threshold 25
#@ #set_app_var high_fanout_net_pin_capacitance 4
#@ 
#@ set_app_var write_name_nets_same_as_ports true
#@ 
#@ set_app_var uniquify_naming_style %s_%d
#@ # Following variables are needed for correct verilog out
#@ set_app_var verilogout_no_tri true
#@ set_app_var verilogout_single_bit false
#@ set_app_var verilogout_show_unconnected_pins true
#@ set_app_var verilogout_higher_designs_first false
#@ 
#@ ######################################
#@ #Variable for Timing
#@ #####################################
#@ # Reset needs to be fixed for timing
#@ set_app_var enable_recovery_removal_arcs true
#@ set_app_var timing_enable_multiple_clocks_per_reg true
#@ # Enable dynamic max_cap tables based upon pin frequency
#@ # set_app_var compile_enable_dyn_max_cap true
#@ 
#@ ######################################
#@ # read/write cache from local run dir
#@ #####################################
#@ if {![file exists ./synopsys_cache]} {file mkdir ./synopsys_cache}
#@ set_app_var cache_write ./synopsys_cache
#@ set_app_var cache_read ./synopsys_cache
#@ set_app_var cache_file_chmod_octal 777
#@ set_app_var cache_dir_chmod_octal 777
#@ 
#@ ########################################
#@ # Settings for compile
#@ #######################################
#@ # Setting variable to show following info during compile
#@ if {![shell_is_in_exploration_mode]} {
#@   set_app_var compile_log_format "  %elap_time %trials %area %wns %tns %drc %group_path %endpoint"
#@   set_app_var power_preserve_rtl_hier_names true
#@ }
#@ set compile_timing_high_effort true
#@ 
#@ #set_app_var power_preserve_rtl_hier_names true
#@ 
#@ ####################################
#@ # Read design RTL settings
#@ ###################################
#@ define_design_lib WORK -path ./WORK
#@ 
#@ set_app_var hdlin_preserve_sequential all
#@ set_app_var link_force_case case_insensitive
#@ set_app_var uniquify_keep_original_design true
#@ set_app_var allow_newer_db_files true
#@ set_app_var change_names_dont_change_bus_members false
#@ set_app_var vhdlout_single_bit VECTOR
#@ set_app_var vhdlout_follow_vector_direction TRUE
#@ set_app_var vhdlout_dont_write_types true
#@ set_app_var vhdlout_package_naming_style CONV_PACK
#@ 
#@ 
#@ set_app_var mw_logic1_net $INTEL_MW_POWER_NET
#@ set_app_var mw_logic0_net $INTEL_MW_GROUND_NET
#@ 
#@ ## Disable command and argument abbreviation.
#@ #set_app_var sh_command_abbrev_mode none
#@ #set_app_var sh_command_abbrev_options false
#@ 
#@ #puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dc_var_setup.tcl

#@ P_source_if_exists dont_use.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ 
#@ 
#@ ### Check Disk Space
#@ P_run_CheckDiskSpace
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/syn/dot3/d04/run.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/read_design.tcl

#@ ##############################################################################
#@ 
#@ ####################################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ # 2. P_msg_fatal
#@ #######################################################
#@ 
#@ ######################################
#@ #INPUT SETUP CHECKS
#@ ######################################
#@ 
#@ puts "==>INFORMATION: Executing input file setup checks...."
#@ 
#@ #Checking for UPF files
#@ if { $synopsys_program_name == "dc_shell"} {
#@   if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@     P_msg_info "Checking for UPF files..."
#@     if {![file readable ./inputs/upf/${INTEL_DESIGN_NAME}.upf]} {
#@       P_msg_fatal "INTEL_UPF is set to $INTEL_UPF. Expecting ${INTEL_DESIGN_NAME}.upf file in ./inputs/upf/. Exiting..."
#@     } else {
#@       P_msg_info "UPF file existence: ${INTEL_DESIGN_NAME}.upf file exists"
#@     }
#@   }
#@ }
#@ 
#@ #Checking for Constraints
#@ puts "==>INFORMATION: Checking for existence of constraint files...."
#@ if {(![info exists INTEL_MCMM] || $INTEL_MCMM==0)} {
#@   if {[info exists INTEL_SDC_FILE] && $INTEL_SDC_FILE == 1} {
#@     if {![file exists ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc]} {
#@       puts "==>FATAL: INTEL_SDC_FILE is set to 1. Expecting but ${INTEL_DESIGN_NAME}.sdc file in ./inputs/constraints/. Exiting..."
#@       return 0
#@     } else {
#@       puts "==>INFORMATION: Constraint file existence: ${INTEL_DESIGN_NAME}.sdc file exists"
#@     }
#@   } elseif {![file exists ./inputs/constraints/${INTEL_DESIGN_NAME}.clocks.tcl] || ![file exists ./inputs/constraints/${INTEL_DESIGN_NAME}.constraints.tcl]} {
#@     puts "==>FATAL: Expecting ${INTEL_DESIGN_NAME}.clocks.tcl and ${INTEL_DESIGN_NAME}.constraints.tcl file in ./inputs/constraints/. Exiting..."
#@     return 0
#@   } else {
#@     puts "==>INFORMATION: Constraint file existence: ${INTEL_DESIGN_NAME}.clocks.tcl and ${INTEL_DESIGN_NAME}.constraints.tcl file exist. Will be using them."
#@   }
#@ }
#@ 
#@ if {[shell_is_in_topographical_mode]} {
#@   if {[info exists INTEL_TOPO_DEF ] && $INTEL_TOPO_DEF == 1} {
#@     puts "==>INFORMATION: Checking for DEF file..."
#@     if {![file exists ./inputs/floorplan/${INTEL_DESIGN_NAME}.def]} {
#@       puts "==>FATAL: INTEL_TOPO_DEF has been set to 1. Expecting ${INTEL_DESIGN_NAME}.def in ./inputs/floorplan/. Exiting..."
#@       return 0
#@     } else {
#@       puts "==>INFORMATION: DEF file existence: ${INTEL_DESIGN_NAME}.def exists. Will use this file."
#@     }
#@   }
#@ } else {
#@   puts "==>INFORMATION: DEF file not provided. Default floorplan will be assumed"
#@ }
#@ 
#@ 
#@ # Checking for scan input files
#@ puts "==>INFORMATION: Checking for scan input file...."
#@ if { $synopsys_program_name == "dc_shell" } {
#@   if {[info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN ==1} {
#@     if {![file exists ./scripts/scan_stitch_template.tcl]} {
#@       puts "==>FATAL: INTEL_INSERT_SCAN set to 1. Expecting scan_stitch_template.tcl in ./scripts/. Exiting..."
#@       return 0
#@     } else {
#@       puts "==>INFORMATION: Scan input existence: Scan stitch template exists"
#@     }
#@   } else {
#@     puts "==>INFORMATION: Scan input existence: Scan not enabled. Hence scan_stitch_template.tcl not necessary."
#@   }
#@ }
#@ 
#@ ####################
#@ #SAIF file setup
#@ ####################
#@ if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@   if {![file exists ./inputs/constraints/${INTEL_DESIGN_NAME}.saif]} {
#@     puts "==>FATAL: INTEL_SAIF var is set to 1. Expecting ${INTEL_DESIGN_NAME}.saif file in ./inputs/constraints/... Exiting..."
#@     return 0
#@   }
#@ }
#@ 
#@ if {$synopsys_program_name == "dc_shell"} {
#@   saif_map -start
#@   set_vsdc ./outputs/${INTEL_DESIGN_NAME}.syn.vsdc
#@ }
#@ 
#@ #####################
#@ #Creating MW library
#@ #####################
#@ 
#@ if { [shell_is_in_topographical_mode] } {
#@   file delete -force -- ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@   set_app_var mw_design_library ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@   create_mw_lib -technology $INTEL_MW_TECH_FILE  -mw_reference_library $mw_reference_library $mw_design_library
#@   open_mw_lib $mw_design_library
#@ 
#@   #Set & Check TLUplus file
#@   #-------------------------
#@   if {(![info exists INTEL_MCMM] || $INTEL_MCMM==0)} {
#@     if {[info exists INTEL_MAX_TLUPLUS_EMUL_FILE] && $INTEL_MAX_TLUPLUS_EMUL_FILE != "" && [info exists INTEL_MIN_TLUPLUS_EMUL_FILE] && $INTEL_MIN_TLUPLUS_EMUL_FILE != ""} {
#@       set_tlu_plus_files -max_tluplus $INTEL_MAX_TLUPLUS_FILE -min_tluplus $INTEL_MAX_TLUPLUS_FILE -tech2itf_map $INTEL_TLUPLUS_MAP_FILE -max_emulation_tluplus $INTEL_MAX_TLUPLUS_EMUL_FILE -min_emulation_tluplus $INTEL_MIN_TLUPLUS_EMUL_FILE
#@     } else {
#@       set_tlu_plus_files -max_tluplus $INTEL_MAX_TLUPLUS_FILE -min_tluplus $INTEL_MAX_TLUPLUS_FILE -tech2itf_map $INTEL_TLUPLUS_MAP_FILE
#@     }
#@     check_tlu_plus_files
#@   }
#@ }
#@ 
#@ 
#@ 
#@ ############################
#@ #Read RTL, Elaborate & Link
#@ ############################
#@ 
#@ if {[file exists ./inputs/rtl/${INTEL_DESIGN_NAME}.rtl_list.tcl]} {
#@   source ./inputs/rtl/${INTEL_DESIGN_NAME}.rtl_list.tcl
#@ } else {
#@   puts "==>FATAL: ${INTEL_DESIGN_NAME}.rtl_list.tcl file does not exist in ./inputs/rtl area... Exiting..."
#@   return 0
#@ }
#@ # -- Starting source ./inputs/rtl/fdkex.rtl_list.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ ## Analyze verilog and SV files first
#@ 
#@ analyze -format sverilog ./inputs/rtl/alu_core.vs
#@ analyze -format sverilog ./inputs/rtl/check_ecc_alu.vs
#@ analyze -format sverilog ./inputs/rtl/check_ecc_in.vs
#@ analyze -format sverilog ./inputs/rtl/fdkex.vs
#@ analyze -format sverilog ./inputs/rtl/fifo.vs
#@ analyze -format sverilog ./inputs/rtl/gen_ecc_alu.vs
#@ analyze -format sverilog ./inputs/rtl/gen_ecc_in.vs
#@ analyze -format sverilog ./inputs/rtl/init_mask_alu.vs
#@ analyze -format sverilog ./inputs/rtl/init_mask_in.vs
#@ analyze -format sverilog ./inputs/rtl/secded_alu.vs
#@ analyze -format sverilog ./inputs/rtl/secded_in.vs
#@ # -- End source ./inputs/rtl/fdkex.rtl_list.tcl

#@ 
#@ elaborate ${INTEL_DESIGN_NAME}
#@ current_design ${INTEL_DESIGN_NAME}
#@ 
#@ 
#@ if {![eval {link}]} {
#@   puts "==>FATAL: Design Link Failed... Exiting..."
#@   return 0
#@ } else {
#@   link > ./reports/${INTEL_DESIGN_NAME}.syn.link.rpt
#@ }
#@ 
#@ 
#@ ##############################
#@ #Read UPF
#@ ##############################
#@ if { $synopsys_program_name == "dc_shell"} {
#@   if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@     load_upf ./inputs/upf/${INTEL_DESIGN_NAME}.upf
#@     propagate_constraints -power_supply_data
#@ 
#@     save_upf ./outputs/${INTEL_DESIGN_NAME}.syn.premapped.upf
#@     redirect ./reports/${INTEL_DESIGN_NAME}.syn.premapped.report_power_domain.rpt {eval report_power_domain [get_power_domains -quiet -hierarchical *]}
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/read_design.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/read_constraints.tcl

#@ ##############################################################################
#@ 
#@ #############################
#@ # List of procs used in this script
#@ # None
#@ ############################
#@ 
#@ ##########################
#@ #Set Operating Condition
#@ ##########################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1} {
#@ } else {
#@   #Setting Operating Condition of best_case_worst_case analysis
#@   set cmd "set_operating_conditions -analysis_type bc_wc"
#@   if {[info exists INTEL_MIN_OPCON]} {set cmd [concat $cmd "-min $INTEL_MIN_OPCON"]}
#@   if {[info exists INTEL_MAX_OPCON]} {set cmd [concat $cmd "-max $INTEL_MAX_OPCON"]}
#@   if  {![eval $cmd] } {
#@     puts "==>FATAL: Setting Operating Conditions failed... Exiting..."
#@     exit
#@   } else {
#@     puts "==>INFORMATION: Setting default Operating Conditions\n$cmd "
#@   }
#@ }
#@ 
#@ ########################
#@ # Design Constraints
#@ ########################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1} {
#@ } else {
#@   if {[info exists INTEL_SDC_FILE] && $INTEL_SDC_FILE==1} {
#@     if {[info exists INTEL_INPUT_SDC] && $INTEL_INPUT_SDC != ""} {
#@       read_sdc $INTEL_INPUT_SDC
#@     } elseif {[file exists ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc]} {
#@       read_sdc ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc
#@     } else {
#@       puts "==>FATAL: $INTEL_DESIGN_NAME.sdc does not exists in ./inputs/constraints... Exiting..."
#@       exit
#@     }
#@   } else {
#@ 
#@     #CLOCKS
#@     #-------
#@     if {[file exists  ./inputs/constraints/${INTEL_DESIGN_NAME}.clocks.tcl]} {
#@       puts "==>INFORMATION: Sourcing the ${INTEL_DESIGN_NAME}.clocks.tcl file"
#@       source -echo -verbose ./inputs/constraints/${INTEL_DESIGN_NAME}.clocks.tcl
#@     } else {
#@       puts "==>FATAL: Your $INTEL_DESIGN_NAME.clocks.tcl file does not exists in ./inputs/constraints/ dir... Exiting..."
#@       exit
#@     }
#@ 
#@     #IO, Loading Constraints, Timing Exception File
#@     #------------------------------------------------
#@     if {[file exists  ./inputs/constraints/${INTEL_DESIGN_NAME}.constraints.tcl]} {
#@       puts "==>INFORMATION: Sourcing the design constraints file"
#@       source -echo -verbose ./inputs/constraints/${INTEL_DESIGN_NAME}.constraints.tcl
#@     } else {
#@       puts "==>FATAL: DESIGN CONSTRAINTS file does not exists... Exiting..."
#@       exit
#@     }
#@   }
#@ }
#@ # -- Starting source ./inputs/constraints/fdkex.clocks.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ 
#@ # This is a TEMPLATE file for CLOCK CONSTRAINTS FILE
#@ # create_clock -name pxclk -period 6666.67 -waveform {0 3333.33} [get_ports {pxclk}]
#@ # set_input_transition 150 -max [ get_ports pxclk ]
#@ # set_input_transition 75 -min [ get_ports pxclk ]
#@ 
#@ 
#@ # create_clock -name xtclk_13p5 -period 73337 -waveform {0 36668.5} [get_ports {xtclk_13p5}]
#@ # set_input_transition 150 -max [ get_ports xtclk_13p5 ]
#@ # set_input_transition 75 -min [ get_ports xtclk_13p5 ]
#@ 
#@ # Make sure all combinations are here
#@ # for n clocks, there should be n^2 max clock uncertainty lines and n^2 min clock uncertainty
#@ # set_clock_uncertainty -hold 300 -from pxclk -to pxclk
#@ # set_clock_uncertainty -hold 300 -from pxclk -to xtclk_13p5
#@ # set_clock_uncertainty -hold 300 -from xtclk_13p5 -to pxclk
#@ # set_clock_uncertainty -hold 300 -from xtclk_13p5 -to xtclk_13p5
#@ 
#@ # set_clock_uncertainty -setup 235 -from pxclk -to pxclk
#@ # set_clock_uncertainty -setup 235 -from pxclk -to xtclk_13p5
#@ # set_clock_uncertainty -setup 235 -from xtclk_13p5 -to pxclk
#@ # set_clock_uncertainty -setup 235 -from xtclk_13p5 -to xtclk_13p5
#@ 
#@ # clock insertion delay
#@ # This is the same as specified for CTS in APR
#@ # set_clock_latency <number> [get_clocks {pxclk}]
#@ # set_clock_latency <number> [get_clocks {xtclk_13p5}]
#@ 
#@ #GENERATED CLOCKS
#@ #create_generated_clock -name GEN_CLK -source [get_pins clk_div2_ckcorediv2/clockdivff_cknameout/ffout_reg/ck] -divide_by 2 [get_pins clk_div2_ckcorediv2/clockdivff_cknameout/ffout_reg/o]
#@ 
#@ #VIRTUAL CLOCKS
#@ #create_clock -name  VIRTUAL_CLK   -period  1088   -waveform {0.000 0544}
#@ 
#@ 
#@ create_clock -name clk -period 500 -waveform {0 250} [get_ports {clk}]
#@ set_clock_uncertainty -setup 50 [get_clocks clk]
#@ set_clock_uncertainty -hold  50 [get_clocks clk]
#@ # -- End source ./inputs/constraints/fdkex.clocks.tcl

#@ # -- Starting source ./inputs/constraints/fdkex.constraints.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ 
#@ ###############################
#@ # Default Loading Constraints
#@ ###############################
#@ #User should copy this file in ./inputs/constraints/${G_DESIGN_NAME}.constraints.tcl and overwrite the actual value
#@ 
#@ #Default setting input_delay & output_delay of 2/3rd  of fastest clock
#@ #-----------------------------------------------------------------------
#@ set delay_value [expr [lindex [lsort -real -decreasing [get_attribute [get_clocks ] period]] end] * 2/3]
#@ 
#@ set clock_name [get_clocks clk]
#@ set_input_delay  -clock $clock_name $delay_value [remove_from_collection [all_inputs] [get_ports clk]]
#@ set_output_delay -clock $clock_name $delay_value [all_outputs]
#@ 
#@ 
#@ #Default input transition or loading cons
#@ #-----------------------------------------
#@ 
#@ set my_driving_cell d04bfn00ln0b0
#@ if {[get_lib_cells */$my_driving_cell -quiet] != ""} {
#@    set_driving_cell -lib_cell $my_driving_cell [all_inputs]
#@    puts "==>INFORMATION: Setting driving cell to $my_driving_cell"
#@ } else {
#@    set_input_transition 50 [all_inputs]
#@    puts "==>INFORMATION: Specified driving cell $my_driving_cell was not found. Setting default input transition as 50"
#@ }
#@ 
#@ 
#@ set_load 10 [all_outputs]
#@ set_max_transition 350 *
#@ set_max_fanout 30 [get_designs *]
#@ set_max_area 0
#@ 
#@ 
#@ # -- End source ./inputs/constraints/fdkex.constraints.tcl

#@ 
#@ ##  ########################################################
#@ # Set voltages for supply nets when running in UPF mode
#@ ########################################################
#@ 
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   if {$synopsys_program_name == "de_shell"}  {
#@     puts "==>INFORMATION: UPF flow is not supported in Design Explorer"
#@   } else {
#@     source -echo -verbose ./inputs/upf/${INTEL_DESIGN_NAME}.set_voltage.tcl
#@   }
#@ }
#@ 
#@ ################
#@ #Read SAIF file
#@ ################
#@ 
#@ if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@   if {![info exists INTEL_SAIF_INSTANCE] || $INTEL_SAIF_INSTANCE == ""} {
#@     set INTEL_SAIF_INSTANCE ${INTEL_DESIGN_NAME}
#@     puts "==>INFORMATION: setting INTEL_SAIF_INSTANCE to ${INTEL_DESIGN_NAME} since user hasn't set INTEL_SAIF_INSTANCE varible"
#@   } else {
#@     puts "==>INFORMATION: INTEL_SAIF_INSTANCE has been set to $INTEL_SAIF_INSTANCE by the user"
#@   }
#@   set saif_file ./inputs/constraints/${INTEL_DESIGN_NAME}.saif
#@   read_saif -auto_map_names -input $saif_file -instance $INTEL_SAIF_INSTANCE -verbose
#@   puts "==>INFORMATION: read_saif -auto_map_names -input ${INTEL_DESIGN_NAME}.saif -instance $INTEL_SAIF_INSTANCE -verbose"
#@   redirect ./reports/${INTEL_DESIGN_NAME}.rtl_saif.rpt { report_saif -hier -missing -annotated_flag -type rtl }
#@ }
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/read_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/read_phys_constraints.tcl

#@ ##############################################################################
#@ 
#@ ################################
#@ # List of procs used by this script
#@ # None
#@ #################################
#@ 
#@ ############################
#@ #Physical Constraints/def file
#@ ##############################
#@ if {[info exists INTEL_TOPO_DEF] && $INTEL_TOPO_DEF==1} {
#@   if {[shell_is_in_topographical_mode] && [file exists ./inputs/floorplan/${INTEL_DESIGN_NAME}.def]} {
#@     puts "==>INFORMATION: Sourcing the DEF file for Physical Constraints"
#@     set find_ignore_case true
#@     extract_physical_constraints ./inputs/floorplan/${INTEL_DESIGN_NAME}.def
#@     set find_ignore_case false
#@     if {[info exists INTEL_UPF] && $INTEL_UPF == 1 } {
#@       if {[file exists ./scripts/${INTEL_DESIGN_NAME}.voltage_area.tcl]} {
#@         puts "==>INFORMATION : sourcing ${INTEL_DESIGN_NAME}.voltage_area.tcl to create voltage area"
#@         source ./scripts/${INTEL_DESIGN_NAME}.voltage_area.tcl
#@       } else {
#@         puts "==>INFORMATION : ${INTEL_DESIGN_NAME}.voltage_area.tcl does not exist to create the voltage area."
#@       }
#@     }
#@ 
#@   } else {
#@     puts "==>FATAL: Cant read DEF file, either file not found in ./inputs/constraints/ or shell is not in TOPO mode... Exiting..."
#@     return 0
#@   }
#@ } elseif {[info exists INTEL_DESIGN_HEIGHT] && $INTEL_DESIGN_HEIGHT > 0 && [info exists INTEL_DESIGN_WIDTH] && $INTEL_DESIGN_WIDTH > 0} {
#@   ## check lego
#@   set INTEL_DESIGN_WIDTH [expr ceil($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X ) * $INTEL_MD_GRID_X]
#@   set INTEL_DESIGN_HEIGHT [expr ceil($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y ) * $INTEL_MD_GRID_Y]
#@   puts "==>INFORMATION: Floorplan area set to \"$INTEL_DESIGN_WIDTH x $INTEL_DESIGN_HEIGHT\""
#@   set_placement_area -fixed -coordinate "0 0 $INTEL_DESIGN_WIDTH $INTEL_DESIGN_HEIGHT"
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/read_phys_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_scenarios.tcl

#@ ##############################################################################
#@ 
#@ #Requirements:
#@ # 1: Update library.tcl to include libraries needed for each scenario.
#@ # 2: Update project_setup.tcl/block_setup.tcl $INTEL_MCMM_* to create and setup scenarios.
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM} {
#@ 
#@   ##Cleanup before creating scenarios
#@   remove_scenario -all
#@ 
#@   foreach scenario $INTEL_MCMM_SCENARIOS {
#@     P_msg_info "Creating scenario $scenario."
#@     create_scenario $scenario
#@ 
#@     ####
#@     #  Set scenario specific link_libraries (OPTIONAL).
#@     #  Only required if tool has difficulty determining which PVT is needed for the given scenario.
#@     if {[info exists INTEL_MCMM_LINK_LIBRARY_SUBSET($scenario)] && $INTEL_MCMM_LINK_LIBRARY_SUBSET($scenario) != ""} {
#@       set_link_library_subset $INTEL_MCMM_LINK_LIBRARY_SUBSET($scenario) -top
#@     }
#@ 
#@     ####
#@     #Set scenario options
#@     P_msg_info "Setting scenario $scenario options to $INTEL_MCMM_SCENARIO_OPTIONS($scenario)"
#@     eval $INTEL_MCMM_SCENARIO_OPTIONS($scenario)
#@ 
#@     ####
#@     # Report scenario options
#@     P_msg_info "Scenario $scenario is created."
#@     report_scenario_options
#@ 
#@     ####
#@     # Setting TLU+
#@     P_msg_info "Setting tlu+ model for scenario ${scenario}..."
#@     if {[file exists $INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE($scenario)]} {
#@       set_tlu_plus_files           -tech2itf_map $INTEL_TLUPLUS_MAP_FILE           -max_tluplus $INTEL_MCMM_MAX_TLUPLUS_FILE($scenario)           -min_tluplus $INTEL_MCMM_MIN_TLUPLUS_FILE($scenario)           -max_emulation_tluplus $INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE($scenario)           -min_emulation_tluplus $INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE($scenario)
#@     } else {
#@       set_tlu_plus_files           -tech2itf_map $INTEL_TLUPLUS_MAP_FILE           -max_tluplus $INTEL_MCMM_MAX_TLUPLUS_FILE($scenario)           -min_tluplus $INTEL_MCMM_MIN_TLUPLUS_FILE($scenario)
#@     }
#@     check_tlu_plus_files
#@ 
#@     ####
#@     # Setting Operating Conditions
#@     eval $INTEL_MCMM_OPCON($scenario)
#@ 
#@     ####
#@     # If INTEL_SDC_FILE, read SDC files, otherwise source tcl files
#@     if {[info exists INTEL_SDC_FILE] && $INTEL_SDC_FILE==1} {
#@       foreach sdc_file $INTEL_MCMM_CONS_SDC($scenario) {
#@         P_msg_info "Loading sdc file $sdc_file for scenario $scenario"
#@         set auto_link_disable true
#@         read_sdc $sdc_file
#@         set auto_link_disable false
#@       }
#@     } else {
#@       foreach tcl_file $INTEL_MCMM_CONS_TCL($scenario) {
#@         P_msg_info "Loading constraints tcl files $tcl_file for scenario $scenario"
#@         set auto_link_disable true
#@         source $tcl_file
#@         set auto_link_disable false
#@       }
#@     }
#@ 
#@     ####
#@     # In UPF mode, load scenario specific set_volatage files.
#@     if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@       source -echo -verbose $INTEL_MCMM_UPF_SET_VOLTAGE($scenario)
#@     }
#@ 
#@   }
#@ 
#@   ####
#@   # Enable default scenario
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ 
#@   # Flow assumes that all created scenarios are active.
#@   set_active_scenarios [all_scenarios]
#@   report_scenarios
#@ 
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_scenarios.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dot3/d04/compile_prep.tcl

#@ ##############################################################################
#@ 
#@ ############################################
#@ ## List of procs used by this script
#@ ## 1. P_msg_warn
#@ #############################################
#@ 
#@ 
#@ #####################
#@ #Insert Clock Gating
#@ #####################
#@ 
#@ if {[info exists INTEL_INSERT_CLOCKGATES] && $INTEL_INSERT_CLOCKGATES==1} {
#@   set_clock_gating_style  -positive_edge_logic integrated       -max_fanout 16       -minimum_bitwidth 8       -control_point before       -no_sharing       -control_signal test_mode
#@ 
#@   set_app_var compile_clock_gating_through_hierarchy true
#@ 
#@   #Exclude negative edge FF
#@   #------------------------
#@   set neg_edge_ff [ get_cells -hierarchical -filter  "@ff_edge_sense==0" * ]
#@   if { [sizeof_collection $neg_edge_ff ] > 0} {
#@     set_clock_gating_objects -exclude $neg_edge_ff
#@   }
#@   #insert_clock_gating
#@ }
#@ 
#@ #--------------------
#@ #Set Routing layers
#@ #--------------------
#@ if {[shell_is_in_topographical_mode]} {
#@ 
#@   # Suppress the following message:
#@   # Information: No preferred routing direction is found for design layer metal1. Automatically deriving direction V. (DCT-035)
#@   # This message is issued in Design Compiler versions 2009 and beyond, when the automatically derived DC preferred routing directions are overriden in the flow. This is for informational purposes only and can be suppressed.
#@ 
#@   suppress_message DCT-035
#@ 
#@   set_preferred_routing_direction -layers {m0 m2 m4 m6 m8}   -direction horizontal
#@   set_preferred_routing_direction -layers {m1 m3 m5 m7 m9}   -direction vertical
#@   set_ignored_layers -min_routing_layer $INTEL_MIN_ROUTING_LAYER -max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ 
#@ 
#@ #--------------------------------------------
#@ #Uniquify the design to make it APR friendly
#@ #--------------------------------------------
#@ uniquify
#@ 
#@ #------------------------
#@ # set compile variables.
#@ #------------------------
#@ if {[shell_is_in_topographical_mode]} {
#@   set_app_var placer_max_cell_density_threshold 0.7
#@ }
#@ 
#@ set_max_time_borrow 0 [all_registers]
#@ set_register_merging $INTEL_DESIGN_NAME false
#@ set_critical_range 2000 [get_designs]
#@ set_app_var timing_enable_multiple_clocks_per_reg true
#@ # Dont Allow synopsys to invert registers
#@ set_app_var compile_seqmap_enable_output_inversion false
#@ # Disable register merging during compile. This causes FV issues
#@ set_app_var compile_enable_register_merging false
#@ # Disable identification of shift registers. This will allow compile to swap all flops to scan flops
#@ set_app_var compile_seqmap_identify_shift_registers false
#@ set_app_var compile_seqmap_propagate_constants true
#@ set_app_var compile_delete_unloaded_sequential_cells false
#@ set_app_var compile_preserve_subdesign_interfaces true
#@ 
#@ if {$synopsys_program_name == "dc_shell"} {
#@   set_app_var compile_seqmap_propagate_high_effort false
#@ 
#@   #Setting for AHFS synthesis in TOPO
#@   #-------------------------------------
#@   if {[shell_is_in_topographical_mode]} {
#@     set_fix_multiple_port_nets -all -buffer_constants
#@     set_ahfs_options -default
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dot3/d04/compile_prep.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_path_group.tcl

#@ ##############################################################################
#@ 
#@ ###################################
#@ # List of procs used in this script
#@ # None
#@ ###############################
#@ 
#@ #------------------------
#@ #Create Paths groups
#@ #-----------------------
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1 && $synopsys_program_name != "pt_shell"} {
#@   set_active_scenarios [all_scenarios]
#@   foreach scenario $INTEL_MCMM_SCENARIOS {
#@     current_scenario $scenario
#@     puts "==> For scenario $scenario..."
#@ 
#@     set nonclockports [all_inputs]
#@     foreach_in_collection ck [all_clocks] {
#@       redirect /dev/null { set nonclockports [remove_from_collection $nonclockports [ get_ports [ get_object_name $ck ]]] }
#@     }
#@     redirect  /dev/null {group_path -name INPUTS -from $nonclockports}
#@ 
#@     group_path -name OUTPUTS -to [all_outputs]
#@     group_path -name COMB -from [all_inputs] -to [all_outputs]
#@ 
#@     if {[sizeof_collection [all_registers]] !=0} {
#@       group_path -name REG2REG -from [all_registers -clock_pins] -to [all_registers -data_pins]
#@     }
#@ 
#@     if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@       set hard_macro_cells ""
#@       set mc_pin  ""
#@       foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@         set hard_macro_cells [get_attribute  [get_cells -hierarchical -quiet -filter ref_name==$hard_macro_name] full_name]
#@         foreach hard_macro_cell $hard_macro_cells {
#@           set mc_pin [add_to_collection $mc_pin [get_pins -quiet ${hard_macro_cell}/* ]]
#@         }
#@       }
#@       group_path -name MACRO -from $mc_pin -to  [all_registers -data_pins]
#@       group_path -name MACRO -from  [all_registers -clock_pins]  -to $mc_pin
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ 
#@ } else {
#@ 
#@   set nonclockports [all_inputs]
#@   foreach_in_collection ck [all_clocks] {
#@     redirect /dev/null { set nonclockports [remove_from_collection $nonclockports [ get_ports [ get_object_name $ck ]]] }
#@   }
#@   redirect  /dev/null {group_path -name INPUTS -from $nonclockports}
#@ 
#@   group_path -name OUTPUTS -to [all_outputs]
#@   group_path -name COMB -from [all_inputs] -to [all_outputs]
#@ 
#@   if {[sizeof_collection [all_registers]] !=0} {
#@     group_path -name REG2REG -from [all_registers -clock_pins] -to [all_registers -data_pins]
#@   }
#@ 
#@   if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@     set hard_macro_cells ""
#@     set mc_pin  ""
#@     foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@       set hard_macro_cells [get_attribute  [get_cells -hierarchical -quiet -filter ref_name==$hard_macro_name] full_name]
#@       foreach hard_macro_cell $hard_macro_cells {
#@         set mc_pin [add_to_collection $mc_pin [get_pins -quiet ${hard_macro_cell}/* ]]
#@       }
#@     }
#@     group_path -name MACRO -from $mc_pin -to  [all_registers -data_pins]
#@     group_path -name MACRO -from  [all_registers -clock_pins]  -to $mc_pin
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_path_group.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/compile.tcl

#@ ##############################################################################
#@ 
#@ ####################################
#@ # List of procs used by this script
#@ # None
#@ ####################################
#@ 
#@ #########
#@ #Compile
#@ #########
#@ if {[shell_is_in_exploration_mode] } {
#@   set cmd "compile_exploration"
#@ } else {
#@   set cmd "compile_ultra  -timing_high_effort_script"
#@ }
#@ if  { [info exists INTEL_INSERT_CLOCKGATES] && $INTEL_INSERT_CLOCKGATES ==1} {
#@   set cmd "$cmd -gate_clock"
#@ }
#@ 
#@ if { [info exists INTEL_SCAN_REPLACE_FLOPS] && $INTEL_SCAN_REPLACE_FLOPS==1} {
#@   set cmd "$cmd -scan"
#@ }
#@ 
#@ if {[shell_is_in_topographical_mode]} {
#@   if { ![shell_is_in_exploration_mode]} {
#@     if {[info exists INTEL_CONGESTION_OPTIMIZE] && $INTEL_CONGESTION_OPTIMIZE ==1} {
#@       set cmd "$cmd -congestion"
#@     }
#@ 
#@     if {[info exists INTEL_SPG] && $INTEL_SPG ==1} {
#@       if {[info exists INTEL_TOPO_DEF] && $INTEL_TOPO_DEF ==1} {
#@         set cmd "$cmd -spg"
#@       } else {
#@         puts "==>WARNING: DEF input has not been provided. Hence Compile Ultra will not run with SPG"
#@       }
#@     }
#@   }
#@   # Using the "-check_only" option of "compile_ultra" to verify that the libraries and design are complete
#@   # and optimization will not fail in topographical mode
#@ 
#@   set check_only  "$cmd -check_only"
#@   eval $check_only
#@ }
#@ 
#@ puts "==>INFORMATION: Performing initial compile using\n '$cmd'"
#@ eval $cmd
#@ 
#@ 
#@ #################################
#@ #Flatten clock gate hierarchies
#@ #################################
#@ set_app_var power_cg_flatten true
#@ 
#@ set icg_coll [get_cells * -hierarchical -filter "@ref_name =~ *SNPS_CLOCK_GATE*"]
#@ if { [sizeof_collection $icg_coll] > 0 } {
#@   ungroup -flatten $icg_coll
#@ }
#@ remove_attribute [filter_collection [get_cells -hierarchical *] "@is_hierarchical==true"] dont_touch
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/compile.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/insert_dft.tcl

#@ ##############################################################################
#@ 
#@ ######################################
#@ # List of procs used by this script
#@ # None
#@ #
#@ ######################################
#@ ##############################################################################
#@ # DFT Insertion
#@ #
#@ # Copy scan_stitch_template file from $env(INTEL_ASIC)/kit/asicflow/synopsys/syn/scripts into
#@ # local ./scripts directory and modify as needed
#@ ##############################################################################
#@ 
#@ if {[shell_is_in_exploration_mode]} {
#@   echo "INFO: DFT not supported in exploration mode"
#@ } else {
#@   if {[info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN==1} {
#@     set_scan_state test_ready
#@ 
#@     if {![file readable ./scripts/scan_stitch_template.tcl]} {
#@       P_msg_fatal "==>FATAL: Can't read ./scripts/scan_stitch_template.tcl file. Exiting..."
#@     } else {
#@       puts "==>INFORMATION: Found ./scripts/scan_stitch_template.tcl file"
#@       source ./scripts/scan_stitch_template.tcl
#@     }
#@ 
#@     #Test Clocks
#@     if {$INTEL_SCAN_CLOCKS == "" || $INTEL_SCAN_CLOCKS == "none"} {
#@       P_msg_fatal "==>FATAL: Atleast one test clock must be defined for DFT insertion. Exiting..."
#@     } else {
#@       foreach clk_fields $INTEL_SCAN_CLOCKS {
#@         foreach clock_element $clk_fields {
#@           set split_clock_name [split $clock_element "/"]
#@           set_dft_signal -view existing_dft -type ScanClock -timing [list 45 55] -port [lindex $split_clock_name 0]
#@           puts "==>INFORMATION: Defining test clock(s):  set_dft_signal -view existing_dft -type ScanClock -timing [list 45 55] -port [lindex $split_clock_name 0]"
#@         }
#@       }
#@     }
#@     set first_testclk [lindex $INTEL_SCAN_CLOCKS 0]
#@     set split_first_testclk [split $first_testclk "/"]
#@     set first_testclk_name [lindex $split_first_testclk 0]
#@     #set testclk_period to 100ns default; using ps to match with library units
#@     set testclk_period 100000
#@ 
#@     puts "==>INFORMATION: first_testclk_name: $first_testclk_name"
#@     puts "==>INFORMATION: testclk_period: $testclk_period"
#@ 
#@     #Test Resets
#@     if {$INTEL_SCAN_RESETS == "" || $INTEL_SCAN_RESETS == "none"} {
#@       puts "==>WARNING: Test reset(s) NOT defined or set to 'none'; Proceeding without test resets"
#@     } else {
#@       set split_resets [split $INTEL_SCAN_RESETS ","]
#@       foreach reset_fields $split_resets {
#@         foreach reset_element $reset_fields {
#@           set split_reset_active_value [split $reset_element "/"]
#@           if {[lindex $split_reset_active_value 1] == "high" } {
#@             set active_reset_value "0"
#@           } else {
#@             set active_reset_value "1"
#@           }
#@           puts "==>INFORMATION: Defining test reset(s): set_dft_signal -view existing_dft -port [lindex $split_reset_active_value 0] -type Reset -active_state $active_reset_value"
#@           set_dft_signal -view existing_dft -port [lindex $split_reset_active_value 0] -type Reset -active_state $active_reset_value
#@         }
#@       }
#@     }
#@ 
#@     #Test Constraints
#@     if {$INTEL_SCAN_CONSTRAINTS == "" || $INTEL_SCAN_CONSTRAINTS == "none"} {
#@       puts "==>INFORMATION: Test constraints NOT defined or set to 'none'; Proceeding without test mode constraints"
#@     } else {
#@       foreach constraint_fields $INTEL_SCAN_CONSTRAINTS {
#@         foreach constraint_element $constraint_fields {
#@           set split_test_constraint_value [split $constraint_element "/"]
#@           set_dft_signal -view existing_dft -type Constant -active_state [lindex $split_test_constraint_value 1] -port [lindex $split_test_constraint_value 0]
#@           puts "==>INFORMATION: Defining test constraints:  set_dft_signal -view existing_dft -type Constant -active_state [lindex $split_test_constraint_value 1] -port [lindex $split_test_constraint_value 0]"
#@         }
#@       }
#@     }
#@ 
#@     #Scan_enable
#@     if {$INTEL_SCAN_ENABLE == "" || $INTEL_SCAN_ENABLE == "default"} {
#@       puts "==>INFORMATION: Scan_enable port NOT defined or set to 'default'; Creating default scan_enable (test_se, active_high)"
#@       create_port -direction in test_se
#@       set_switching_activity -toggle_rate 0 test_se
#@       set scanen_port test_se
#@     } else {
#@       set split_scanen_field [split $INTEL_SCAN_ENABLE "/"]
#@       if {[lindex $split_scanen_field 1] == "high" } {
#@         set scanen_active_value "1"
#@       } else {
#@         set scanen_active_value "0"
#@       }
#@       redirect -var scan_en_port {get_ports [lindex $split_scanen_field 0]}
#@       if {[lindex $scan_en_port 0] == "Warning:"} {
#@         puts "==>INFORMATION: Port [lindex $split_scanen_field 0] doesn't exist"
#@         puts "==>INFORMATION: Creating new port [lindex $split_scanen_field 0] for scan_enable"
#@         create_port -direction in [lindex $split_scanen_field 0]
#@         set_dft_signal -view spec -port [lindex $split_scanen_field 0] -type ScanEnable -active_state $scanen_active_value
#@       } else {
#@         redirect -var scan_en_port_direction_out {get_ports [lindex $split_scanen_field 0] -filter {@port_direction == out}}
#@         if {[lindex $scan_en_port_direction_out 0] == "[lindex $split_scanen_field 0]"} {
#@           P_msg_fatal "==>FATAL: Output port [lindex $scan_en_port_direction_out 0] already exists. Cannot create input port with the same name. Exiting..."
#@         } else {
#@           redirect -var scan_en_port_direction_in {get_ports [lindex $split_scanen_field 0] -filter {@port_direction == in}}
#@           if {[lindex $scan_en_port_direction_in 0] == "[lindex $split_scanen_field 0]"} {
#@             puts "==>INFORMATION: Input port [lindex $scan_en_port_direction_in 0] already exists"
#@             puts "==>INFORMATION: Defining existing port [lindex $split_scanen_field 0] as scan_enable"
#@             set_dft_signal -view existing -port [lindex $split_scanen_field 0] -type ScanEnable -active_state $scanen_active_value
#@           }
#@         }
#@       }
#@       set_switching_activity -toggle_rate 0 [lindex $split_scanen_field 0]
#@       set scanen_port [lindex $split_scanen_field 0]
#@     }
#@     puts "==>INFORMATION: Scan_enable port is $scanen_port"
#@ 
#@     #Clock_gating enable
#@     if {$INTEL_SCAN_CLOCK_UNGATE == "" || $INTEL_SCAN_CLOCK_UNGATE == "default"} {
#@       puts "==>INFORMATION: Clock_gating_enable NOT defined or set to 'default'; Creating a default port test_tm to control clock_gating in scan mode"
#@       create_port -direction in test_tm
#@       set_dft_signal -port test_tm -view spec -type TestMode -usage clock_gating
#@       set_switching_activity -toggle_rate 0 test_tm
#@       set_case_analysis 1 test_tm
#@       set clock_gating_en_port test_tm
#@     } else {
#@       set split_clock_ungate_field [split $INTEL_SCAN_CLOCK_UNGATE "/"]
#@       redirect -var clkgating_en_port {get_ports [lindex $split_clock_ungate_field 0]}
#@       if {[lindex $clkgating_en_port 0] == "Warning:"} {
#@         puts "==>INFORMATION: Port [lindex $split_clock_ungate_field 0] doesn't exist"
#@         puts "==>INFORMATION: Defining new port {[lindex $split_clock_ungate_field 0]} as clock_gating_enable"
#@         create_port -direction in [lindex $split_clock_ungate_field 0]
#@         set_dft_signal -port [lindex $split_clock_ungate_field 0] -view spec -type TestMode -usage clock_gating
#@       } else {
#@         redirect -var clkgating_en_port_direction_out {get_ports [lindex $split_clock_ungate_field 0] -filter {@port_direction == out}}
#@         if {[lindex $clkgating_en_port_direction_out 0] == "[lindex $split_clock_ungate_field 0]"} {
#@           P_msg_fatal "==>FATAL: Output port [lindex $clkgating_en_port_direction_out 0] already exists. Cannot create input port with the same name. Exiting..."
#@         } else {
#@           redirect -var clkgating_en_port_direction_in {get_ports [lindex $split_clock_ungate_field 0] -filter {@port_direction == in}}
#@           if {[lindex $clkgating_en_port_direction_in 0] == "[lindex $split_clock_ungate_field 0]"} {
#@             puts "==>INFORMATION: Port [lindex $clkgating_en_port_direction_in 0] already exists"
#@             puts "==>INFORMATION: Defining existing port {[lindex $split_clock_ungate_field 0]} as clock_gating_enable"
#@             set_dft_signal -port $INTEL_SCAN_CLOCK_UNGATE -view existing -type TestMode
#@           }
#@         }
#@       }
#@       set_switching_activity -toggle_rate 0 [lindex $split_clock_ungate_field 0]
#@       set_case_analysis 1 [lindex $split_clock_ungate_field 0]
#@       set clock_gating_en_port [lindex $split_clock_ungate_field 0]
#@     }
#@     puts "==>INFORMATION: Clock_gating_en port is $clock_gating_en_port"
#@ 
#@     #Scan_chain_length check
#@     if {$INTEL_SCAN_COMPRESSION == "enable" || $INTEL_SCAN_COMPRESSION == "yes"} {
#@       #scan_chain length in compression_mode
#@       if {$INTEL_SCAN_CHAIN_LENGTH == "" || $INTEL_SCAN_COMPRESSED_CHAIN_LENGTH == ""} {
#@         P_msg_fatal "==>FATAL: INTEL_SCAN_CHAIN_LENGTH and INTEL_SCAN_COMPRESSED_CHAIN_LENGTH must be specified for scan_compression. Exiting..."
#@       }
#@     } else {
#@       #scan_chain length in simple scan mode
#@       if {$INTEL_SCAN_CHAIN_LENGTH == ""} {
#@         P_msg_fatal "==>FATAL: INTEL_SCAN_CHAIN_LENGTH must be specified for simple scan mode. Exiting..."
#@       }
#@     }
#@ 
#@     #Chain_length setup
#@     if {$INTEL_SCAN_COMPRESSION == "enable" || $INTEL_SCAN_COMPRESSION == "yes"} {
#@       puts "==>INFORMATION: INTEL_SCAN_COMPRESSION enabled"
#@       set_dft_configuration -scan_compression enable
#@       #scan_chain length in compression_mode
#@       if {$INTEL_SCAN_CHAIN_LENGTH == "default"} {
#@         puts "==>WARNING: INTEL_SCAN_CHAIN_LENGTH set to default. Chain_length for external chains will be set to 750"
#@         puts "==>INFORMATION: Using scan_chain_length of $INTEL_SCAN_COMPRESSED_CHAIN_LENGTH for internal chains in compression_mode"
#@         set_scan_configuration -exact_length 750
#@         set_scan_compression_configuration -xtolerance high -max_length $INTEL_SCAN_COMPRESSED_CHAIN_LENGTH -min_power true
#@       } else {
#@         puts "==>INFORMATION: Using scan_chain_length of $INTEL_SCAN_CHAIN_LENGTH for external chains in compression_mode"
#@         puts "==>INFORMATION: and using $INTEL_SCAN_COMPRESSED_CHAIN_LENGTH for internal chains in compression_mode"
#@         set_scan_configuration -exact_length $INTEL_SCAN_CHAIN_LENGTH
#@         set_scan_compression_configuration -xtolerance high -max_length $INTEL_SCAN_COMPRESSED_CHAIN_LENGTH -min_power true
#@       }
#@     } else {
#@       puts "==>INFORMATION: Scan_compression NOT enabled. Proceeding with simple scan configuration."
#@       #scan_chain length in NON_compression_mode
#@       if {$INTEL_SCAN_CHAIN_LENGTH == "" || $INTEL_SCAN_CHAIN_LENGTH == "default"} {
#@         puts "==>INFORMATION: INTEL_SCAN_CHAIN_LENGTH not specified or set to 'default'; Max_chain_length will be set to 750"
#@         set_scan_configuration -exact_length 750
#@       } else {
#@         puts "==>INFORMATION: Using scan_chain_length of $INTEL_SCAN_CHAIN_LENGTH"
#@         set_scan_configuration -exact_length $INTEL_SCAN_CHAIN_LENGTH
#@       }
#@     }
#@ 
#@     #Scan_ins, scan_outs
#@     if {$INTEL_SCAN_IN_SCAN_OUT == "" || $INTEL_SCAN_IN_SCAN_OUT == "none" || $INTEL_SCAN_IN_SCAN_OUT == "default"} {
#@       puts "==>INFORMATION: Scan_in/scan_out NOT defined or set to 'none' or 'default'; Creating scan chain(s) with default test_si*/test_so* port name(s)"
#@     } else {
#@       set count 1
#@       set split_chains [split $INTEL_SCAN_IN_SCAN_OUT ","]
#@       foreach chain $split_chains {
#@         set split_chains_in_out [split $chain "/"]
#@         set_dft_signal -view existing_dft -type ScanDataIn   -port *[lindex $split_chains_in_out 0]
#@         set_dft_signal -view existing_dft -type ScanDataOut  -port *[lindex $split_chains_in_out 1]
#@         set ports [get_ports [lindex $split_chains_in_out 0]]
#@         if { [sizeof_collection $ports] == 1 } {
#@           set_scan_path chain$count -view existing_dft -scan_data_in [lindex $split_chains_in_out 0] -scan_data_out [lindex $split_chains_in_out 1]
#@         }
#@         incr count
#@       }
#@     }
#@ 
#@     #OCC
#@     if [info exists INTEL_SCAN_ATSPEED_CLK_CTRL] {
#@       if {$INTEL_SCAN_ATSPEED_CLK_CTRL == "" || $INTEL_SCAN_ATSPEED_CLK_CTRL == "none"} {
#@         puts "==>INFORMATION: At_speed clock_controller variable INTEL_SCAN_ATSPEED_CLK_CTRL set to 'none'; Proceeding without at_speed clock controller"
#@         } else {
#@           set atspeed_clk_ctrl_fields [split $INTEL_SCAN_ATSPEED_CLK_CTRL ","]
#@           puts "==>INFORMATION: Defining OCC with [lindex $atspeed_clk_ctrl_fields 0] as pll clock, [lindex $atspeed_clk_ctrl_fields 1] as ref_clk and [lindex $atspeed_clk_ctrl_fields 2] as ATEclk"
#@ 
#@           #Enable OCC insertion
#@           set_dft_configuration -clock_controller enable
#@           set_dft_signal -view existing_dft -type refclock -port [lindex $atspeed_clk_ctrl_fields 1] -period 10 -timing [list 3 8]
#@ 
#@           #Define shift clock coming from ATE
#@           set_dft_signal -type ScanClock -view existing_dft -port [lindex $atspeed_clk_ctrl_fields 2] -timing [list 45 55]
#@           set_dft_signal -type Oscillator -view existing_dft -port [lindex $atspeed_clk_ctrl_fields 2]
#@ 
#@           #Define PLL output pin, this is where we insert OCC
#@           set_dft_signal -type Oscillator -view existing_dft -hookup_pin  [get_pins [lindex $atspeed_clk_ctrl_fields 0]]
#@ 
#@           #Define global signals needed for OCC: pll_reset, occ_testmode, pll_bypass
#@           set_dft_signal -type pll_reset  -port pll_reset -view spec
#@           set_dft_signal -type TestMode   -port occ_testmode -view spec
#@           set_dft_signal -type pll_bypass -port pll_bypass -view spec
#@ 
#@           #Define OCC clock controller
#@           set_dft_clock_controller               -cell_name OCC1               -test_mode_port occ_testmode               -design_name snps_clk_mux               -pllclocks [lindex $atspeed_clk_ctrl_fields 0]               -ateclocks  [lindex $atspeed_clk_ctrl_fields 2]               -cycles_per_clock 4 -chain_count 1
#@ 
#@           #Use integrated clock_gating cells for gating, instead of AND/OR based clock selection
#@           set_app_var test_occ_insert_clock_gating_cells true
#@ 
#@           #Use a dedicated OCC clock_chain clock connection 
#@           set_app_var test_dedicated_clock_chain_clock true
#@         }
#@     } else {
#@       puts "INTEL_SCAN_ATSPEED_CLK_CTRL variable not defined in ./scripts/scan_stitch_template.tcl; Proceeding without OCC"
#@     }
#@ 
#@     #DFT Configuration
#@     puts "==>INFORMATION: Setting up DFT configuration"
#@     set_dft_insertion_configuration -preserve_design_name true
#@     set_dft_insertion_configuration -synthesis_optimization none
#@ 
#@     set_scan_configuration -clock_mixing mix_clocks
#@     set_scan_configuration -insert_terminal_lockup true -add_lockup true
#@ 
#@     #Non_scan designs
#@     if {[file exists ./scripts/list_of_non_scan_designs] } {
#@       set file [open "./scripts/list_of_non_scan_designs" r]
#@       set non_scan_design [read $file]
#@       foreach nonscan_element $non_scan_design {
#@         puts "==>INFORMATION: set_scan_element false [get_attribute [get_designs -quiet $nonscan_element] name]"
#@         set_scan_element false [get_designs -quiet $nonscan_element]
#@       }
#@     }
#@ 
#@     puts "==>INFORMATION: Creating test protocol"
#@     redirect ./reports/${INTEL_DESIGN_NAME}.create_test_protocol.rpt { create_test_protocol }
#@ 
#@     #Pre_DFT reports
#@     redirect ./reports/${INTEL_DESIGN_NAME}.syn.pre_dft_drc.rpt { dft_drc }
#@     redirect ./reports/${INTEL_DESIGN_NAME}.syn.pre_dft_drc_verbose.rpt { dft_drc -verbose }
#@     redirect ./reports/${INTEL_DESIGN_NAME}.syn.scan_config.rpt { report_scan_configuration }
#@ 
#@     if [info exists INTEL_SCAN_ATSPEED_CLK_CTRL] {
#@       if {$INTEL_SCAN_ATSPEED_CLK_CTRL == "" || $INTEL_SCAN_ATSPEED_CLK_CTRL == "none"} {
#@       } else {
#@         redirect ./reports/${INTEL_DESIGN_NAME}.syn.clock_controller.rpt { report_dft_clock_controller -view spec }
#@       }
#@     } else {
#@     }
#@ 
#@     redirect ./reports/${INTEL_DESIGN_NAME}.syn.preview_dft.rpt { preview_dft -show all}
#@ 
#@     #List of pre_scan pins
#@     set input_ports_pre_scan [get_ports [all_inputs]]
#@     set output_ports_pre_scan [get_ports [all_outputs]]
#@ 
#@     puts "==>INFORMATION: Performing DFT insertion"
#@     redirect ./reports/${INTEL_DESIGN_NAME}.insert_dft.rpt { insert_dft }
#@ 
#@     #post_DFT reports
#@     if [info exists INTEL_SCAN_ATSPEED_CLK_CTRL] {
#@       if {$INTEL_SCAN_ATSPEED_CLK_CTRL == "" || $INTEL_SCAN_ATSPEED_CLK_CTRL == "none"} {
#@         redirect ./reports/${INTEL_DESIGN_NAME}.syn.post_dft_drc.rpt { dft_drc }
#@       } else {
#@         set_dft_drc_configuration -pll_bypass enable
#@         redirect ./reports/${INTEL_DESIGN_NAME}.syn.post_dft_drc_pll_bypass.rpt { dft_drc }
#@       }
#@     } else {
#@     } 
#@       redirect ./reports/${INTEL_DESIGN_NAME}.syn.scan_path.rpt { report_scan_path -test_mode all }
#@ 
#@     #Test protocol files
#@     if {$INTEL_SCAN_COMPRESSION == "enable" || $INTEL_SCAN_COMPRESSION == "yes"} {
#@       puts "==>INFORMATION: Saving test protocol in compression_mode"
#@       write_test_protocol -out ./outputs/${INTEL_DESIGN_NAME}.syn.scan_internal.spf -test_mode Internal_scan
#@       write_test_protocol -out ./outputs/${INTEL_DESIGN_NAME}.syn.scan_compress.spf -test_mode ScanCompression_mode
#@     } else {
#@       puts "==>INFORMATION: Saving simple scan test protocol"
#@       write_test_protocol -output ./outputs/${INTEL_DESIGN_NAME}.syn.spf
#@     }
#@ 
#@     #False_path to new scan control signals
#@     puts "==>INFORMATION: set_false_path -through $scanen_port"
#@     set_false_path -through $scanen_port
#@ 
#@     puts "==>INFORMATION: set_false_path -through $clock_gating_en_port"
#@     set_false_path -through $clock_gating_en_port
#@ 
#@     if {$INTEL_SCAN_COMPRESSION == "enable" || $INTEL_SCAN_COMPRESSION == "yes"} {
#@       puts "==>INFORMATION: set_false_path -through test_mode"
#@       set_false_path -through test_mode
#@     }
#@ 
#@     if [info exists INTEL_SCAN_ATSPEED_CLK_CTRL] {
#@       if {$INTEL_SCAN_ATSPEED_CLK_CTRL == "" || $INTEL_SCAN_ATSPEED_CLK_CTRL == "none"} {
#@       } else {
#@         puts "==>INFORMATION: set_false_path -through ooc related signals: occ_testmode and pll_bypass"
#@         set_false_path -through occ_testmode
#@         set_false_path -through pll_bypass
#@       }
#@     } else {
#@     }
#@ 
#@     #Setting 100ps nominal input_delay on scan inputs
#@     set input_ports_post_scan [get_ports [all_inputs]]
#@     set new_input_ports_post_scan [remove_from_collection $input_ports_post_scan $input_ports_pre_scan]
#@ 
#@     foreach_in_collection inputs_post_scan $new_input_ports_post_scan {
#@       echo "==>INFORMATION: set_input_delay -clock $first_testclk_name 100 [get_object_name $inputs_post_scan]"
#@       set_input_delay -clock $first_testclk_name 100 [get_object_name $inputs_post_scan]
#@     }
#@ 
#@     #Setting 100ps nominal output_delay on scan outputs
#@     set output_ports_post_scan [get_ports [all_outputs]]
#@     set new_output_ports_post_scan [remove_from_collection $output_ports_post_scan $output_ports_pre_scan]
#@ 
#@     foreach_in_collection outputs_post_scan $new_output_ports_post_scan {
#@       echo "==>INFORMATION: set_output_delay -clock $first_testclk_name 100 [get_object_name $outputs_post_scan]"
#@       set_output_delay -clock $first_testclk_name 100 [get_object_name $outputs_post_scan]
#@     }
#@   } else {
#@     puts "==>WARNING: INTEL_INSERT_SCAN not defined or set to 0. DFT will not be inserted"
#@   }
#@ }
#@ # -- Starting source ./scripts/scan_stitch_template.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ ######################################
#@ ## List of procs used by this script
#@ ## None
#@ ##
#@ #######################################
#@ 
#@ # This file is used for scan architecture definition
#@ # Copy $env(INTEL_ASIC)/kit/asicflows/<EDA_VENDOR>/syn/scan_stitch_template.tcl into
#@ # local ./scripts directory and modify the default settings as necessary
#@ # All variables must be defined
#@ 
#@ #1. Test clocks: Specify test_clock name, period in ps, the domain it belongs to
#@ #2. Test resets: Specify reset name, it's value during scan_shift; Set to {none} if no test resets
#@ #3. Set INTEL_SCAN_ENABLE {name_of_scanen_port/value_during_shift} to define an existing or a new port as scan_enable
#@ #4. Set INTEL_SCAN_CLOCK_UNGATE {name_of_clock_gating_enable} to define an existing or a new port as clock_gating_enable 
#@ #5. Test mode constraints: Specify ATPG mode configuration settings like (scan_mode1/1 scan_mode2/0); Set to {none} if no test constants
#@ #6. Scan_in, Scan_out: Specify existing ports, like (scan_in0/scan_out0, scan_in1/scan_out1). If 'none', default ports (test_si*/test_so*) will be created
#@ #7. Scan_chain length: {default} length is 750; Specify a # to set different scan chain length
#@ #8. Scan_compression information: Set to {enable} for compression, and specify compression chain length  
#@ #   INTEL_SCAN_EDT_CHANNELS: variable ONLY needed for Mentor DFT flow
#@ #9. INTEL_SCAN_ATSPEED_CLK_CTRL: variable currently not used
#@ 
#@ 
#@ # 1. Test clocks
#@ set INTEL_SCAN_CLOCKS                     {clk/100000/domain1}
#@ 
#@ # 2. Test resets
#@ set INTEL_SCAN_RESETS                     {rstb/high}
#@ 
#@ # 3. Scan_enable
#@ set INTEL_SCAN_ENABLE                     {scan_enable/high}
#@ 
#@ # 4. Clock_gating enable
#@ set INTEL_SCAN_CLOCK_UNGATE               {test_tm}
#@ 
#@ # 5. Test mode constraints
#@ set INTEL_SCAN_CONSTRAINTS                {none}
#@ 
#@ # 6. Scan_in, scan_out
#@ set INTEL_SCAN_IN_SCAN_OUT                {none}
#@ 
#@ # 7. Scan_chain length
#@ set INTEL_SCAN_CHAIN_LENGTH               {default}
#@ 
#@ # 8. Scan_compression
#@ set INTEL_SCAN_COMPRESSION                {disable}
#@ set INTEL_SCAN_COMPRESSED_CHAIN_LENGTH    100
#@ 
#@ #The following variable needed for Mentor DFT flow ONLY
#@ set INTEL_SCAN_EDT_CHANNELS               2
#@ 
#@ #Variable currently not used
#@ # 9. INTEL_SCAN_ATSPEED_CLK_CTRL          {disable}
#@ 
#@ # -- End source ./scripts/scan_stitch_template.tcl

#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/insert_dft.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dot3/d04/compile_prep.tcl

#@ ##############################################################################
#@ 
#@ ############################################
#@ ## List of procs used by this script
#@ ## 1. P_msg_warn
#@ #############################################
#@ 
#@ 
#@ #####################
#@ #Insert Clock Gating
#@ #####################
#@ 
#@ if {[info exists INTEL_INSERT_CLOCKGATES] && $INTEL_INSERT_CLOCKGATES==1} {
#@   set_clock_gating_style  -positive_edge_logic integrated       -max_fanout 16       -minimum_bitwidth 8       -control_point before       -no_sharing       -control_signal test_mode
#@ 
#@   set_app_var compile_clock_gating_through_hierarchy true
#@ 
#@   #Exclude negative edge FF
#@   #------------------------
#@   set neg_edge_ff [ get_cells -hierarchical -filter  "@ff_edge_sense==0" * ]
#@   if { [sizeof_collection $neg_edge_ff ] > 0} {
#@     set_clock_gating_objects -exclude $neg_edge_ff
#@   }
#@   #insert_clock_gating
#@ }
#@ 
#@ #--------------------
#@ #Set Routing layers
#@ #--------------------
#@ if {[shell_is_in_topographical_mode]} {
#@ 
#@   # Suppress the following message:
#@   # Information: No preferred routing direction is found for design layer metal1. Automatically deriving direction V. (DCT-035)
#@   # This message is issued in Design Compiler versions 2009 and beyond, when the automatically derived DC preferred routing directions are overriden in the flow. This is for informational purposes only and can be suppressed.
#@ 
#@   suppress_message DCT-035
#@ 
#@   set_preferred_routing_direction -layers {m0 m2 m4 m6 m8}   -direction horizontal
#@   set_preferred_routing_direction -layers {m1 m3 m5 m7 m9}   -direction vertical
#@   set_ignored_layers -min_routing_layer $INTEL_MIN_ROUTING_LAYER -max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ 
#@ 
#@ #--------------------------------------------
#@ #Uniquify the design to make it APR friendly
#@ #--------------------------------------------
#@ uniquify
#@ 
#@ #------------------------
#@ # set compile variables.
#@ #------------------------
#@ if {[shell_is_in_topographical_mode]} {
#@   set_app_var placer_max_cell_density_threshold 0.7
#@ }
#@ 
#@ set_max_time_borrow 0 [all_registers]
#@ set_register_merging $INTEL_DESIGN_NAME false
#@ set_critical_range 2000 [get_designs]
#@ set_app_var timing_enable_multiple_clocks_per_reg true
#@ # Dont Allow synopsys to invert registers
#@ set_app_var compile_seqmap_enable_output_inversion false
#@ # Disable register merging during compile. This causes FV issues
#@ set_app_var compile_enable_register_merging false
#@ # Disable identification of shift registers. This will allow compile to swap all flops to scan flops
#@ set_app_var compile_seqmap_identify_shift_registers false
#@ set_app_var compile_seqmap_propagate_constants true
#@ set_app_var compile_delete_unloaded_sequential_cells false
#@ set_app_var compile_preserve_subdesign_interfaces true
#@ 
#@ if {$synopsys_program_name == "dc_shell"} {
#@   set_app_var compile_seqmap_propagate_high_effort false
#@ 
#@   #Setting for AHFS synthesis in TOPO
#@   #-------------------------------------
#@   if {[shell_is_in_topographical_mode]} {
#@     set_fix_multiple_port_nets -all -buffer_constants
#@     set_ahfs_options -default
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/dot3/d04/compile_prep.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/inc_compile.tcl

#@ ##############################################################################
#@ 
#@ ####################################
#@ # List of procs used by this script
#@ # None
#@ ####################################
#@ 
#@ 
#@ #################
#@ #Incremental Compile
#@ #####################
#@ if {![shell_is_in_exploration_mode]} {
#@   set cmd "compile_ultra -incremental"
#@ 
#@   if  { [info exists INTEL_INSERT_CLOCKGATES] && $INTEL_INSERT_CLOCKGATES ==1} {
#@     set cmd "$cmd -gate_clock"
#@   }
#@ 
#@   if { [info exists INTEL_SCAN_REPLACE_FLOPS] && $INTEL_SCAN_REPLACE_FLOPS==1} {
#@     set cmd "$cmd -scan"
#@   }
#@ 
#@ 
#@   if {[shell_is_in_topographical_mode]} {
#@ 
#@     if {[info exists INTEL_CONGESTION_OPTIMIZE] && $INTEL_CONGESTION_OPTIMIZE ==1} {
#@       set cmd "$cmd -congestion"
#@     }
#@ 
#@     if {[info exists INTEL_SPG] && $INTEL_SPG ==1 && [info exists INTEL_TOPO_DEF] && $INTEL_TOPO_DEF ==1 } {
#@       set cmd "$cmd -spg"
#@     }
#@   }
#@ 
#@ 
#@   puts "==>INFORMATION: Performing incremental compile using\n '$cmd'"
#@   eval $cmd
#@ 
#@ 
#@ 
#@   #Doing this again following a bug in DC where hier reappear for clock_gate
#@   #if only -gate_clock is used but not using it with -scan option
#@   #################################
#@   #Flatten clock gate hierarchies
#@   #################################
#@   set_app_var power_cg_flatten true
#@ 
#@   set icg_coll [get_cells * -hierarchical -filter "@ref_name =~ *SNPS_CLOCK_GATE*"]
#@   if { [sizeof_collection $icg_coll] > 0 } {
#@     ungroup -flatten $icg_coll
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/syn/inc_compile.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ ##############################################################################
#@ 
#@ #####################################
#@ # List of procs used in script
#@ # None
#@ ################################
#@ 
#@ 
#@ ## making the net names case insensitive to avoid false violation from LVS
#@ define_name_rules standard_netnames -case_insensitive -type net
#@ 
#@ if {$synopsys_program_name == "icc_shell" && $INTEL_ECO_TYPE != 0 } {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ } else {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ }
#@ 
#@ 
#@ puts "==>INFORMATION: Running default verilog rule , check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules verilog >> $change_name_log_file
#@ 
#@ puts "==>INFORMATION: Running name rule 'standard_netnames_verilog', check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules standard_netnames >> $change_name_log_file
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

