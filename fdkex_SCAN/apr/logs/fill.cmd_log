#@ # 
#@ # Running icc_shell Version J-2014.09-SP1 for suse64 -- Oct 14, 2014
#@ # Date:   Tue Mar 31 00:56:17 2015
#@ # Run by: spalutla@chlr16420
#@ 

source -echo -verbose /nfs/ch/disks/icf_fdk_regression001/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/runs/d04/fdkex_SCAN/apr/./icc_batch.tcl
#@ # -- Starting source /nfs/ch/disks/icf_fdk_regression001/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/runs/d04/fdkex_SCAN/apr/./icc_batch.tcl

#@ source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/apr/dot3/d04/run.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/apr/dot3/d04/run.tcl

#@ ##############################################################################
#@ 
#@ #######################################################################
#@ # SUMMARY: run.tcl to drive netlist2gds flow in ICC
#@ ######################################################################
#@ set echo_include_commands false
#@ set echo_include_commands FALSE
#@ 
#@ 
#@ set timestamp [sh date '+%m_%d_%H_%M']
#@ 
#@ puts "\n######## Synopsys Build Information ########"
#@ puts "Product Version:  $::sh_product_version"
#@ puts "Build Date:       $::product_build_date"
#@ puts "############################################\n"
#@ 
#@ #########################################
#@ # General/Project SPECIFIC CONFIGURATION
#@ #########################################
#@ 
#@ if { ![info exists env(INTEL_ASIC)] } {
#@   error "Required environment variable 'INTEL_ASIC' not set."
#@ } else {
#@   set INTEL_ASIC $env(INTEL_ASIC)
#@   puts "-I- Setting INTEL ASIC to $INTEL_ASIC"
#@ }
#@ 
#@ #setup all local paths
#@ set INTEL_LOG_PATH      ./logs
#@ set INTEL_SCRIPTS_PATH  ./scripts
#@ set INTEL_INPUTS_PATH   ./inputs
#@ set INTEL_MW_LIB        ./mwdb
#@ set INTEL_REPORTS_PATH  ./reports
#@ set INTEL_OUTPUTS_PATH  ./outputs
#@ 
#@ if { ![file isdirectory $INTEL_MW_LIB] } { file mkdir $INTEL_MW_LIB }
#@ if { ![file isdirectory $INTEL_LOG_PATH] } { file mkdir $INTEL_LOG_PATH }
#@ if { ![file isdirectory $INTEL_OUTPUTS_PATH] } { file mkdir $INTEL_OUTPUTS_PATH }
#@ if { ![file isdirectory $INTEL_REPORTS_PATH] } { file mkdir $INTEL_REPORTS_PATH }
#@ 
#@ set_app_var sh_command_log_file ./logs/cmd.log
#@ set_app_var sh_output_log_file  ./logs/icc.log
#@ 
#@ ### INTEL_SCRIPTS_SEARCH_PATH order as: highest to lowest
#@ set INTEL_SCRIPTS_SEARCH_PATH "./scripts"
#@ set INTEL_SCRIPTS_SEARCH_PATH "$INTEL_SCRIPTS_SEARCH_PATH                              $env(INTEL_ASIC)/asicflows/synopsys/apr/dot3/d04                              $env(INTEL_ASIC)/asicflows/synopsys/apr                              $env(INTEL_ASIC)/asicflows/synopsys/common/dot3/d04                              $env(INTEL_ASIC)/asicflows/synopsys/common"
#@ 
#@ 
#@ set COMMON_SCRIPTS $env(INTEL_ASIC)/asicflows/synopsys/common/
#@ set APR_SCRIPTS $env(INTEL_ASIC)/asicflows/synopsys/apr/
#@ 
#@ puts "-I- scripts search path variable INTEL_SCRIPTS_SEARCH_PATH is set to: $INTEL_SCRIPTS_SEARCH_PATH"
#@ set search_path [concat $INTEL_SCRIPTS_SEARCH_PATH $search_path]
#@ 
#@ 
#@ source $env(INTEL_ASIC)/asicflows/synopsys/common/procs.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/common/procs.tcl

#@ ##############################################################################
#@ # This file sets up procedures used by the synthesis, APR & STA flows        #
#@ # This file is sectioned according to steps and tcl files which use them     #
#@ ##############################################################################
#@ 
#@ ##########################################
#@ # Common Procedures - Used by DC/ICC/STA
#@ ##########################################
#@ # P_source_if_exists: Used by all flows to source scripts from a provided INTEL_SCRIPTS_SEARCH_PATH
#@ # P_rdtConvertSeconds: Used by P_source_if_exists to convert time in a specific reporting format
#@ # P_get_scr_proc_name: Used by all flows to provide additional stack info when erroring out
#@ # P_msg_info: Used by all flows to provide info messages
#@ # P_msg_warn: Used by all flows to provide warning messages
#@ # P_msg_error: Used by all flows to provide error messages
#@ # P_msg_fatal: Used by all flows to provide fatal error messages
#@ # P_find_common_collection: Utility which can be used to find overlap/common elements between two collections
#@ 
#@ #################################################
#@ # Synthesis Procedures - Used by Synthesis flow
#@ #################################################
#@ # P_smash_design: Used by the synthesis flow  for smashing hierarchies
#@ # P_smash_design_recursive: Used by P_smash_design for smashing design to the lowest hierarchy
#@ # P_remove_donttouch_on_hier_cells: Used by P_smash_design for removing dont_touch on hierachical instances.
#@ 
#@ #######################################################
#@ # Floorplan Procedures - Used by floorplan step of APR
#@ #######################################################
#@ # P_add_bonuscore_core2h_rows: Used by init_floorplan.tcl to create site rows for different core tiles
#@ # P_get_techfile_info: Used by P_add_bonuscore_core2h_rows and stdcell PG hookup to get techfile related
#@ # P_set_repeating_custom_tracks: Used by set_wiretracks.tcl to create custom tracks based on track settings
#@ # P_check_boundary_contact: Used by halo.tcl to determine if the Core Boundary contacts with any cell
#@ # P_get_abut_chain: Used by halo.tcl to get list of macros abutting each other
#@ # P_get_abutted_cells: Used by halo.tcl to get macro ells which are abutting
#@ # P_get_boundary_polygon: Used by halo.tcl to calculate boundary polygon for halo insertion
#@ # P_lcount: Used by halo.tcl to get repeated element
#@ # P_place_halo: Used by halo.tcl to place a halo at a particular location
#@ # P_find_direction: Used by halo.tcl and halo_power_voltage_island.tcl to place correct ver/horiz halo cells according to direction
#@ # P_ret_intersect_list: Used by halo_power_voltage_island.tcl to get voltage areas abutting with boundary/macro/non-va-halo
#@ # P_check_exclusion: Used by halo_power_voltage_island.tcl to get intersection points of boundary/macro/non-va-halo
#@ # P_macro_route_guide_cmd: Used by create_power_straps.tcl to create correct PG pullback from macro boundaries
#@ # P_strap_cmd: Used by create_power_strpas.tcl to create power straps
#@ # P_check_partition_dimension: Used by check_floorplan.tcl to check if the partition dimensions are a multiple of the modular grid
#@ # P_adv_polygon_size: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_adv_polygon_check: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_adv_polygon_logic: Used by pre_place_bonus_array.tcl to do polygon operations for insertion of bonus cells
#@ # P_create_diffcheck_grid: Used by create_check_grid.tcl to create diffcheckgrid over the partition
#@ # P_create_polycheck_grid: Used by create_check_grid.tcl to create polycheckgrid over the partition
#@ # P_placement_blockage_move_or_unmove: Used by pre_place_fiducial.tcl and add_filler_cells.tcl to move placement blockages
#@ # P_insert_pre_place_cells_blockage: Used by pre_place_fib_bonus.tcl to insert placement blockages at pre_place cells location or reverse locations
#@ # P_compare: Used by P_insert_pre_place_cells_blockage to do list comparison of blockages
#@ # P_adv_polygon_get: Used by P_insert_pre_place_cells_blockage to do polygon computations
#@ 
#@ ################################################################
#@ # Place-UPF Procedures - Used by UPF flow in Place step of APR
#@ ################################################################
#@ # P_parse_pwrgrid_params: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stages
#@ # P_ret_aon_net: Used by route_upf_ao_pg.tcl to do Secondary PG Hookup in Place and Route stage
#@ # P_check_sec_pg_overlap: Used by P_add_sec_pg_hookup defined within upf_sec_pg_hookup.tcl to determine if a secondary PG staple overlaps with another staple.
#@ 
#@ ###########################################################
#@ # CTS-UPF Procedures - Used by UPF flow in CTS step of APR
#@ ###########################################################
#@ # P_query_voltage_pgnet: Used by stdcell PG hookup procedure to find out primary pg net for each voltage area
#@ 
#@ ################################################
#@ # Route Procedures - Used by route step of APR
#@ ################################################
#@ # P_bonus_array_blockage: Used by add_filler_cells.tcl to create blockages for bonus array addition before decap insertion
#@ 
#@ ########################################################
#@ # Focal opt Procedures - Used by Focal opt step of APR
#@ ########################################################
#@ # P_fix_min_cap args: Used by focal_opt.tcl for fixing min-cap violations on design
#@ 
#@ ##################
#@ # STA Procedures
#@ ##################
#@ # P_report_xtalk_deltas: Used by STA flow to report xtalk delta delays
#@ # P_restore_dmsa_session: Used by DMSA flows of STA to restore dmsa sessions
#@ # P_report_qor: Used by STA flow to report QoR data in a format similar to DC/ICC
#@ 
#@ #################################
#@ # Reports and Outputs Procedures
#@ #################################
#@ # P_create_xyv_icc: Used by P_outputs_xyv procedure to dump out xyv file fo use by RV tools
#@ # P_report_related_supply_net: Used by P_reports to get related supply nets for generate reportsin UPF flow
#@ # P_reports: Used by Syn, APR & STA flows to generate design reports controlled by INTEL_REPORTS variable
#@ # P_get_logic_levels: Used by P_reports procedure to get logic levels during reporting
#@ # P_create_pg_terminals: Used by P_outputs_fram
#@ # P_outputs_linkname: Used by P_outputs_* procedures to get file name used to create link
#@ # P_outputs_verilog: Used by P_outputs to write a verilog output
#@ # P_outputs_verilog_pg: Used by P_outputs to write a verilog output with PG pin and physical-only cells
#@ # P_outputs_upf: Used by P_outputs to write a upf file
#@ # P_outputs_spef: Used by P_outputs to write output spef file
#@ # P_outputs_def: Used by P_outputs to write output def file
#@ # P_syn_output_def: Used by synthesis to write output def file
#@ # P_outputs_fp: Used by P_outputs to write floorplan outputs
#@ # P_outputs_sdc: Used by P_outputs to write sdc output
#@ # P_outputs_saif: Used by P_outputs to write saif output
#@ # P_outputs_scandef: Used by P_outputs at the end of syn flow to write scandef output
#@ # P_outputs_oas: Used by P_outputs to write oas output
#@ # P_outputs_gds: Used by P_outputs to write gds output
#@ # P_outputs_fram: Used by P_outputs to write fram output
#@ # P_outputs_lteloc: Used by P_outputs to create an output xyv file used for RV flow
#@ # P_outputs: Main Output procedure used by Synthesis and APR flow to write out outputs. It is controlled by INTEL_OUTPUTS variable
#@ # P_check_place_overlap: Used by Check_* scripts in APR for checking cell overlaps
#@ # P_check_cells: Used by Check_* scripts in APR for checking if dont use cells are used in design
#@ # P_check_power_ground_nets: Used by check_route.tcl to verify shorts/opens/floating metals in design
#@ 
#@ set start_time [clock seconds]
#@ puts "==>SOURCING: [info script] START TIME: [date]"
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## These procedures/variables are not uniformly available
#@ ## for all tools used in the flow. This section of code creates
#@ ## the procedures/variables if they are not available.
#@ ## -----------------------------------------------------------------------------
#@ 
#@ if { ![info exists synopsys_root] } {
#@   set synopsys_root "synopsys_root"
#@ }
#@ 
#@ if { ![info exists synopsys_program_name] } {
#@   set synopsys_program_name "tcl"
#@ }
#@ 
#@ if { $synopsys_program_name == "tcl" } {
#@   set sh_product_version [info patchlevel]
#@ }
#@ 
#@ if { [info command parse_proc_arguments] != "parse_proc_arguments" } {
#@   proc parse_proc_arguments { cmdSwitch procArgs optsRef } {
#@     upvar $optsRef opts
#@     if { $cmdSwitch == "-args" } {
#@       foreach arg $procArgs {
#@         if { [string index $arg 0] == "-" } {
#@           set curArg $arg
#@           set opts($curArg) 1
#@         } else {
#@           if { [info exists curArg] } {
#@             set opts($curArg) $arg
#@             unset curArg
#@           } else {
#@             puts "SNPS_ERROR: Found invalid argument: '$arg', with no preceding switch."
#@             puts "SNPS_ERROR: Called from procedure: [lindex [info level -1] 0]"
#@           }
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ if { [info command define_proc_attributes] != "define_proc_attributes" } {
#@   proc define_proc_attributes args {}
#@ }
#@ 
#@ if { [info command date] != "date" } {
#@   proc date {} {
#@     return [clock format [clock seconds] -format {%a %b %e %H:%M:%S %Y}]
#@   }
#@ }
#@ 
#@ ########################
#@ # Common Procedures
#@ ########################
#@ 
#@ ################################################################################
#@ # Procedure   : P_source_if_exists
#@ # Description : This sources the specified script.  It searches through directories
#@ #               in the following order:
#@ #                Local script
#@ #                ==> Project flow path flow specific (syn, apr, ..) script
#@ #                ==> Project flow path common script
#@ #                ==> Flow default flow specific (syn, apr, ..) script
#@ #                ==> Flow default common script
#@ #               When it finds the specified script in one of the above directoreis,
#@ #               it sources the script, and stops searching for the script in the
#@ #               next directory.
#@ #               If "-inclusive" option is specified, it sources the script inclusively
#@ #               in the following order:
#@ #                Flow default common script
#@ #                ==> Flow default flow specific (syn, apr, ..) script
#@ #                ==> Project flow path common script
#@ #                ==> Project flow path flow specific (syn, apr, ..) script
#@ #                ==> Local script
#@ #               If the specified script does not exists, it prints out a warning
#@ #               message.
#@ 
#@ 
#@ proc P_source_if_exists {args} {
#@   global INTEL_SCRIPTS_SEARCH_PATH
#@   global INTEL_SOURCE_OPTIONS
#@ 
#@   #parse_proc_arguments -args $args flag
#@ 
#@   foreach arg $args {
#@     if {$arg == "-require"} {
#@       set require 1
#@     } elseif {$arg == "-inclusive"} {
#@       set inclusive 1
#@     } elseif {$arg == "-display"} {
#@       set display 1
#@     } else {
#@       set filename $arg
#@     }
#@   }
#@   if {![info exists require]} {set require 0}
#@   if {![info exists inclusive]} {set inclusive 0}
#@   if {![info exists display]} {set display 0}
#@   #  set filename $flag(filename)
#@   #  if { [info exists flag(-require) ] } {
#@   #    set require 1
#@   #  } else {
#@   #    set require 0
#@   #  }
#@   #  if {[info exists flag(-inclusive)]} {
#@   #    set inclusive 1
#@   #  } else {
#@   #    set inclusive 0
#@   #  }
#@ 
#@   set prereq_list {}
#@   # Look for the file in the search_path, if file not yet determined
#@   if {[info exists INTEL_SCRIPTS_SEARCH_PATH]} {
#@     foreach search_dir $INTEL_SCRIPTS_SEARCH_PATH {
#@       set prereq [file join $search_dir $filename]
#@       if {[file exists $prereq]} {
#@         set prereq_list [linsert $prereq_list 0 $prereq]
#@         if {! $inclusive} {
#@           break ;# Found the file, so stop looking
#@         }
#@       }
#@     }
#@   }
#@ 
#@   if {$display} {
#@     foreach prereq $prereq_list {
#@       puts $prereq
#@     }
#@     return
#@   }
#@ 
#@   if {[llength $prereq_list] == 0} {
#@     if { $require == 1 } {
#@       P_msg_error "Required file not found: $filename."
#@     } else {
#@       puts "==>WARNING: File $filename does not exist."
#@       return 0
#@     }
#@   }
#@ 
#@   foreach prereq $prereq_list {
#@     # Now that the prereq has been determined, source it.
#@     set start_time [clock seconds]
#@     set cpu_start [cputime]
#@     set dates [exec date]
#@     puts "==>INFORMATION: P_source_if_exists: Sourcing $prereq : START $dates"
#@     # Source the file in the global scope
#@     if {[info exists INTEL_SOURCE_OPTIONS] && $INTEL_SOURCE_OPTIONS != ""} {
#@       set catch_return [catch {uplevel \#0 eval source $INTEL_SOURCE_OPTIONS $prereq} catch_result]
#@     } else {
#@       set catch_return [catch {uplevel \#0 source $prereq} catch_result]
#@     }
#@     # Check to see if an error occurred in the script
#@     if {$catch_return != 0} {
#@       puts "Error: Problem with sourced file \"$prereq\". See errorInfo below"
#@       error $catch_result
#@     }
#@     set end_time [clock seconds]
#@     set cpu_end [cputime]
#@     set dates [exec date]
#@     regexp {.*\/(\S+)} $prereq t localFile
#@     #    set elapsed_time [format "%6.4f" [expr ($end_time - $start_time) / 60.0 / 60.0]]
#@     set elapsed_time [P_rdtConvertSeconds [expr ($end_time - $start_time)]]
#@     set elapsed_cpu [P_rdtConvertSeconds [expr ($cpu_end - $cpu_start)]]
#@     puts "==>INFORMATION: P_source_if_exists: $localFile : END $dates : WALLCLOCK RUNTIME in (hh:mm:ss) : $elapsed_time hrs : CPU RUNTIME in (hh:mm:ss) : $elapsed_cpu hrs : MEMORY : [mem] KB"
#@   }
#@   return 1
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_source_if_exists       -info "source script, if it exists"       -define_args {                          {filename "file name to be sourced" filename string required}                          {-require "require file" "" boolean optional}                          {-display "Shows which file will be sourced without sourcing it" "" boolean optional}                          {-inclusive "Source all files found in all paths in the order of priority. Default is to source only the first found file" "" boolean optional}                        }
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_rdtConvertSeconds #{{{
#@ # Description : This is a time conversion utility
#@ 
#@ proc P_rdtConvertSeconds {secs} {
#@ 
#@   set h [expr {$secs/3600}]
#@   incr secs [expr {$h*-3600}]
#@   set m [expr {$secs/60}]
#@   set s [expr {$secs%60}]
#@   format "%02.2d:%02.2d:%02.2d" $h $m $s
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_get_scr_proc_name #{{{
#@ # Description : This gets the name of procedures, and returns names of all procedures
#@ #               on the stack.
#@ 
#@ proc P_get_scr_proc_name { args } {
#@ 
#@   set all [string match "*-all*" $args]
#@ 
#@   # Start with the current script
#@   set proc_list "[file tail [info script]]"
#@ 
#@   set start 1
#@   set end [info level]
#@ 
#@   # Special cases
#@   if {$end == 1} {
#@     # Called from script?
#@     if {$proc_list != ""} {
#@       return "$proc_list"
#@ 
#@       # Interactive call
#@     } else {
#@       return "<interactive>"
#@     }
#@   } elseif {$end >= 2} {
#@     # Don't consider the last procedure (which is P_get_scr_proc_name)
#@     incr end -1
#@   }
#@ 
#@   for {set i $start} {$i <= $end} {incr i} {
#@     set proc_name [lindex [info level $i] 0]
#@     lappend proc_list $proc_name
#@   }
#@ 
#@   # Return all if all was specified
#@   set len_proc_list [llength $proc_list]
#@   if {!$all && $len_proc_list > 2} {
#@     # Get the name of the last two procedures
#@     # or script & procedure
#@     # or script only
#@     # or procedure only
#@ 
#@     set proc_list [lrange $proc_list [expr {$len_proc_list - 2}] end]
#@   }
#@ 
#@   # Return values joined by ":" to make it one string
#@   return [join $proc_list ":"]
#@ 
#@ }; # P_get_scr_proc_name
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   create_command_group {flow_procs}
#@ }
#@ 
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_get_scr_proc_name       -command_group "flow_procs"       -info "Procedure to get caller and callee script and procedure names \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {-all "name of all the procedures on the stack is returned" "" boolean optional}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_info #{{{
#@ # Description : This prints information messages.
#@ 
#@ proc P_msg_info { args } {
#@   set prefix "#INFO-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_info       -command_group "flow_procs"       -info "Procedure to print info messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "info message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_warn #{{{
#@ # Description : This prints warning messages.
#@ 
#@ proc P_msg_warn { args } {
#@   set prefix "#WARNING-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_warn       -command_group "flow_procs"       -info "Procedure to print warning messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "warning message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_error #{{{
#@ # Description : This prints error messages.  The flow goes through, and does not stop.
#@ 
#@ proc P_msg_error { args } {
#@   set prefix "#ERROR-MSG==> "
#@   puts "$prefix [join [concat $args] { }]"
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_error       -command_group "flow_procs"       -info "Procedure to print error messages \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {args "error message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_msg_fatal #{{{
#@ # Description : This prints messages about fatal errors, and exits from the shell.
#@ 
#@ proc P_msg_fatal { args } {
#@   set prefix "\n#INFO-STACK==> [uplevel 1 {P_get_scr_proc_name -all}] \n#FATALERROR-MSG==> "
#@   puts stderr "$prefix [join [concat $args] { }]"
#@   exit 1
#@ }
#@ 
#@ if {[info exists synopsys_program_name]} {
#@   define_proc_attributes P_msg_fatal       -command_group "flow_procs"       -info "Procedure to print fatal messages and exit the tool \n\t\t\tdefined in script: [info script]\n"       -define_args {
#@         {target "file to create before exiting" target.db string required}
#@         {args "fatal message" message string required}
#@       }
#@ }
#@ #}}}
#@ 
#@ proc P_find_common_collection {a b} {
#@   set in_a_but_notin_b [remove_from_collection $a $b]
#@   set in_b_but_notin_a [remove_from_collection $b $a]
#@   set common_a_b [remove_from_collection $a $in_a_but_notin_b]
#@   if { [sizeof_collection $b] == 0 } {
#@     return $a
#@   } else {
#@     return $common_a_b
#@   }
#@ }
#@ 
#@ define_proc_attributes P_find_common_collection     -info "Returns common elements between 2 collections"     -define_args {
#@       {a "First Coll" "First Coll" string required}
#@       {b "Second Coll" "Second Coll" string required}
#@     }
#@ 
#@ ########################
#@ # Synthesis Procedures
#@ ########################
#@ 
#@ ##############################################################################
#@ # Procedure   : P_smash_design
#@ # Description : This proc smashes the design but presevers the hierarchies listed in the argument.
#@ #               It also takes the numbers of level below which the smashing has to happen.
#@ #   If 2 is given, the it descends to 2 levels of hierarchy below the top and smashes thoses levels.
#@ #               But regardless of levels specified, the list specified in \$preserve_hier_instance_list will be honored.
#@ #   If levels is less than 0, then no smashing is done
#@ 
#@ proc P_smash_design {{preserve_hier_instance_list {}} {levels 0}} {
#@   if {$levels < 0} {return 0}
#@   global smashed_designs_hash
#@   set start_time [clock seconds]
#@   set cur_design [get_attribute [current_design] name]
#@   set hiers_level_list {}
#@   foreach preserve_hier_instance $preserve_hier_instance_list {
#@     if {[get_attribute [get_cells $preserve_hier_instance] is_hierarchical] == "true"} {
#@       set hiers [split $preserve_hier_instance "/"]
#@       set mid_index [expr [llength $hiers] - 2]
#@       set end_index [expr [llength $hiers] - 1]
#@       set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
#@       set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
#@       while {([get_cells -quiet $parent_hier] == "") && ($mid_index >= 0)} {
#@         incr mid_index -1
#@         set parent_hier [join [lrange $hiers 0 $mid_index] "/"]
#@         set child_inst [join [lrange $hiers [expr $mid_index + 1] $end_index] "/"]
#@       }
#@       if {$parent_hier == ""} {
#@         set parent_hier_ref $cur_design
#@       } else {
#@         set parent_hier_ref [get_attribute [get_cells $parent_hier] ref_name]
#@       }
#@       set hier_hash($preserve_hier_instance) [list $parent_hier_ref $child_inst]
#@       lappend hiers_level_list [list $preserve_hier_instance [llength $hiers] $parent_hier_ref $child_inst]
#@     }
#@   }
#@   current_design $cur_design
#@   foreach hiers_level_pair [lsort -decreasing -index 1 $hiers_level_list] {
#@     set parent_hier_ref [lindex $hiers_level_pair 2]
#@     set child_inst [lindex $hiers_level_pair 3]
#@     set preserve_hier_instance [lindex $hiers_level_pair 0]
#@     set child_hier_level [lindex $hiers_level_pair 1]
#@     if {$child_hier_level > $levels} {
#@       set preserve_hier_ref [get_attribute [get_cells $preserve_hier_instance] ref_name]
#@       current_design $preserve_hier_ref
#@       set smashed_designs_hash($preserve_hier_ref) 1
#@       ungroup -all -flatten
#@       current_design $parent_hier_ref
#@       set_dont_touch $child_inst
#@       current_design $cur_design
#@     }
#@   }
#@   current_design $cur_design
#@ 
#@   P_smash_design_recursive $levels
#@   P_remove_donttouch_on_hier_cells
#@   array unset smashed_designs_hash
#@   set end_time [clock seconds]
#@   set elapsed_time [expr ($end_time - $start_time) / 60.0 / 60.0]
#@   #echo "Runtime to smash the design = $elapsed_time hrs"
#@ }
#@ 
#@ #################################################################
#@ # Procedure   : P_smash_design_recursive
#@ # Description : This proc starts at the current design and descends into the lowest hierarchy and smashes from that level upwards.
#@ #   This proc is called from proc:P_smash_design
#@ 
#@ proc P_smash_design_recursive {levels} {
#@   global smashed_designs_hash
#@   set cur_design [current_design]
#@   set cur_design_name [get_attribute $cur_design name]
#@   if {[info exists smashed_designs_hash($cur_design_name)]} {
#@     return 0
#@   }
#@   if {$levels <= 0} {
#@     ungroup -all -flatten
#@     set smashed_designs_hash($cur_design_name) 1
#@   } else {
#@     set ref_designs {}
#@     set insts_col [get_cells -filter is_hierarchical==true]
#@     set insts_count [sizeof_collection $insts_col]
#@     foreach_in_collection inst_col $insts_col {
#@       lappend ref_designs [get_attribute $inst_col ref_name]
#@     }
#@     foreach ref_design $ref_designs {
#@       if {![info exists smashed_designs_hash($ref_design)]} {
#@         current_design $ref_design
#@         P_smash_design_recursive [expr $levels - 1]
#@       }
#@     }
#@     current_design $cur_design
#@   }
#@ }
#@ 
#@ ##################################################################
#@ # Procedure   : P_remove_donttouch_on_hier_cells
#@ # Description : This proc recursively traverses the hierarchies in the design.
#@ #   If a hiararchical instance as a dont touch on it remove that dont touch attribute
#@ 
#@ proc P_remove_donttouch_on_hier_cells {} {
#@   set cur_design [current_design]
#@   set ref_designs {}
#@   set insts_col [get_cells -filter is_hierarchical==true]
#@   foreach_in_collection inst_col $insts_col {
#@     lappend ref_designs [get_attribute $inst_col ref_name]
#@     remove_attribute $inst_col dont_touch -quiet
#@   }
#@   foreach ref_design $ref_designs {
#@     current_design $ref_design
#@     P_remove_donttouch_on_hier_cells
#@   }
#@   current_design $cur_design
#@ }
#@ 
#@ ########################
#@ # Floorplan Procedures
#@ ########################
#@ 
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_add_bonuscore_core2h_rows
#@ # __description:  add bonuscore & core2h site_rows to an existing FP
#@ # __proc returns: 0 = successful
#@ #                 1 = error
#@ # __required_args:  -unit_tile    = name of base unit tile
#@ # __optional_args:  -bonus_tile   = name of bonus tile
#@ #                   -unit_2h_tile = name of double height tile
#@ # __end
#@ #-------------------------------------------------------------------
#@ #
#@ proc P_add_bonuscore_core2h_rows { args } {
#@   parse_proc_arguments -args $args flag
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   # set up error outputs
#@   set puts "puts"
#@   set puts_nnl "puts -nonewline"
#@   set info_stack "\n#INFO-STACK==> $func_name"
#@   set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
#@   set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
#@   if { [llength [info commands da_error]] > 0 } { set da_error da_error
#@   } else { set da_error [eval $fmte ERROR] }
#@   if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
#@   } else { set da_warn [eval $fmt WARNING] }
#@   if { [llength [info commands da_info]] > 0 } { set da_info da_info
#@   } else { set da_info [eval $fmt INFO] }
#@ 
#@   ###########################################################################
#@   # procedure P_add_bonuscore_core2h_rows
#@   # the function assumes that only single tile pattern exists in the design
#@   # assumes that rows alternate between N & S with no gaps in site_rows.
#@   # bonuscore rows are the same height & orientation as existing core tile
#@   # core2h rows are the same width as existing core tile, and require N-S pair
#@   ###########################################################################
#@ 
#@ 
#@   # get techfile info
#@   set tech_info [P_get_techfile_info]
#@   if { [llength $tech_info] == 0 } {
#@     eval $da_error "\"No MW library open or insufficient disk space\""
#@     return 1
#@   }
#@   # look up info for tiles
#@   set all_tiles {}
#@   set all_tile_names {}
#@   foreach tech_item $tech_info {
#@     if { ! [string equal "Tile" [lindex $tech_item 0]] } {
#@       continue
#@     }
#@     unset -nocomplain tech_tile_name tech_tile_width tech_tile_length
#@     set tech_tile_name [lindex $tech_item 1]
#@     foreach sub_item [lrange $tech_item 2 end] {
#@       if { [string equal -nocase "width" [lindex $sub_item 0]] } {
#@         set tech_tile_width [lindex $sub_item 1]
#@       } elseif { [string equal -nocase "height" [lindex $sub_item 0]] } {
#@         set tech_tile_height [lindex $sub_item 1]
#@       }
#@     }
#@     if { (! [info exists tech_tile_width]) || (! [info exists tech_tile_height]) } {
#@       continue
#@     }
#@     set new_tile [list $tech_tile_name $tech_tile_width $tech_tile_height]
#@     lappend all_tiles $new_tile
#@     lappend all_tile_names $tech_tile_name
#@   }
#@ 
#@ 
#@ 
#@   # ensure that a design is open and has core_area
#@   redirect /dev/null {catch {set core_area [get_core_area]}}
#@   if { (! [info exists core_area]) || ([llength $core_area] == 0) } {
#@     # no design is open or core_area isn't defined
#@     eval $da_error "\"No design open or undefined core_area\""
#@     return 1
#@   }
#@ 
#@ 
#@   # get min resolution (the round about method for icc)
#@   redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
#@   regexp -line {^length.*} $unit_vars length_units
#@   set resolution [expr 1.0 / ([lindex $length_units 2] + 0.0)]
#@ 
#@ 
#@   # check that each tile specified exists
#@   set error 0
#@   set core_step 1.0
#@   set core2h_width 1.0
#@   set core2h_height 1.0
#@   set bonus_width  1.0
#@   set bonuscore_mult 1
#@   if { [info exists flag(-unit_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-unit_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"unit_tile '$flag(-unit_tile)' doesn't exist\""
#@     } else {
#@       set core_tile $flag(-unit_tile)
#@       set core_item [lindex $all_tiles $tile_number]
#@       set tile_width  [lindex $core_item 1]
#@       set tile_height [lindex $core_item 2]
#@       set core_step [expr int(round($tile_width / $resolution))]
#@     }
#@   }
#@   if { [info exists flag(-bonus_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-bonus_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"bonus_tile '$flag(-bonus_tile)' doesn't exist\""
#@     } else {
#@       set bonuscore_tile $flag(-bonus_tile)
#@       set bonus_item [lindex $all_tiles $tile_number]
#@       set bonus_width  [lindex $bonus_item 1]
#@       set bonuscore_step [expr int(round($bonus_width / $resolution))]
#@       set bonuscore_mult [expr int(round($bonuscore_step / $core_step))]
#@     }
#@   }
#@   if { [info exists flag(-unit_2h_tile)] } {
#@     set tile_number [lsearch -exact $all_tile_names $flag(-unit_2h_tile)]
#@     if { $tile_number == -1 } {
#@       set error 1
#@       eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' doesn't exist\""
#@     } else {
#@       set core2h_tile $flag(-unit_2h_tile)
#@       set core2h_item [lindex $all_tiles $tile_number]
#@       set core2h_width  [lindex $core2h_item 1]
#@       set core2h_height  [lindex $core2h_item 2]
#@       set core2h_step [expr int(round($core2h_width / $resolution))]
#@       set core2h_mult [expr int(round($core2h_step / $core_step))]
#@       if { (int(round($tile_height/$resolution)) * 2) != int(round($core2h_height/$resolution)) } {
#@         set error 1
#@         eval $da_warn "\"unit_2h_tile '$flag(-unit_2h_tile)' is not double the height of the unit_tile\""
#@       }
#@       set tile_height [lindex $core_item 2]
#@     }
#@   }
#@ 
#@ 
#@   # exit if error
#@   if { $error } {
#@     eval $da_error "\"Problem specified tiles don't exist\""
#@     return 1
#@   }
#@ 
#@ 
#@ 
#@   # get information on existing site_rows
#@   # use win_select_objects (rather than get_site_rows)
#@   # -- this is due to an early bug where get_site_rows didn't get unnamed rows
#@   set design_bbox [get_attribute -quiet [get_die_area] bbox]
#@   if { [llength $design_bbox] == 1 } { set design_bbox [lindex $design_bbox 0] }
#@   set design_bbox [join $design_bbox]
#@   change_selection -remove [get_selection]
#@   win_set_select_class {site_row}
#@   win_set_filter -class site -filter {site_row}
#@   win_select_objects -within $design_bbox -slct_targets global -slct_targets_operation clear -intersect
#@   set site_rows [sort_collection [sort_collection [filter_collection [get_selection] "object_class==\"site_row\""] bbox_llx] bbox_lly]
#@   change_selection $site_rows
#@   if { [sizeof_collection $site_rows] == 0 } {
#@     eval $da_warn "\"no site_row in design\""
#@     return 1
#@   }
#@ 
#@   # record existing site_row information
#@   set existing_rows {}
#@   set existing_names {}
#@   set core2h_N_rows {}
#@   set core2h_S_rows {}
#@   set core_sites {}
#@   set bonuscore_sites {}
#@   set core2h_sites {}
#@   unset -nocomplain min_y
#@   foreach_in_collection site_row $site_rows {
#@     set site_space  [get_attribute -quiet $site_row site_space]
#@     set site_count  [get_attribute -quiet $site_row site_count]
#@     set site_type   [get_attribute -quiet $site_row site_type]
#@     if { ! [string equal $core_tile $site_type] } { continue }
#@     set origin      [get_attribute -quiet $site_row origin]
#@     if { [llength $origin] == 1 } { set origin [lindex $origin 0] }
#@     foreach { x y } $origin { break }
#@     if { (! [info exists min_y]) || ($y < $min_y) } {
#@       set min_y $y
#@     }
#@     set orientation [get_attribute -quiet $site_row orientation]
#@     set direction   [get_attribute -quiet $site_row direction]
#@     set name        [get_attribute -quiet $site_row name]
#@     switch -glob $orientation {
#@       *N { set flip_orient "FS" }
#@       *S { set flip_orient "N" }
#@       default { set flip_orient $orientation }
#@     }
#@     set add_row [list $site_space $site_count $site_type $origin $orientation $direction $name $flip_orient]
#@     lappend existing_rows $add_row
#@     lappend existing_names $name
#@ 
#@     # core sites
#@     lappend core_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation $site_count]
#@ 
#@     # bonuscore sites are original core sites with site_count divided by 4
#@     set x_length [expr $site_count * $tile_width]
#@     lappend bonuscore_sites [list [expr int(round($x/$resolution))] [expr int(round($y/$resolution))] $orientation [expr int(floor(($x_length/$bonus_width) + $resolution))]]
#@ 
#@     #
#@     # compute rows for core2h
#@     # use polygon operation, build bbox for each site_row
#@     #   BUT ... stretch N rows up by tile_height, S rows down by tile_height
#@     #   core2h site_rows described by the intersection of N & S polygons
#@     #
#@     switch -glob $orientation {
#@       *N { set yll $y
#@         set yur [expr $y + $tile_height]
#@         set north 1
#@       }
#@       *S { set yll [expr $y - $tile_height]
#@         set yur $y
#@         set north 0
#@       }
#@       default { set yll 0.0
#@         set yur 0.0
#@         set north -1
#@       }
#@     }
#@     set xll $x
#@     set xur [expr $x + ($site_space * $site_count)]
#@     set bbox [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     if { $north == 1 } {
#@       lappend core2h_N_rows $bbox
#@     } elseif { $north == 0 } {
#@       lappend core2h_S_rows $bbox
#@     }
#@   }
#@   if { [llength $core_sites] == 0 } {
#@     eval $da_error "\"No $core_tile site_rows found in design\""
#@     return 1
#@   }
#@   remove_site_row [get_selection]
#@   change_selection -remove [get_selection]
#@ 
#@   # make a list of core2h sites from the intersection of N & S polygons
#@   foreach row2h [compute_polygons -boolean and $core2h_N_rows $core2h_S_rows] {
#@     # get the bounds of each polygon to figure out core2h sites
#@     set xll [lindex [lindex [lsort -real -index 0 -increasing $row2h] 0] 0]
#@     set yll [lindex [lindex [lsort -real -index 1 -increasing $row2h] 0] 1]
#@     set xur [lindex [lindex [lsort -real -index 0 -decreasing $row2h] 0] 0]
#@     if { int(round(($yll - $min_y)/$core2h_height)) % 2 } {
#@       set core_orient "N"
#@     } else {
#@       set core_orient "FS"
#@     }
#@     lappend core2h_sites [list [expr int(round($xll/$resolution))] [expr int(round($yll/$resolution))] $core_orient [expr int(floor((($xur-$xll)/$core2h_width) + $resolution))]]
#@ 
#@   }
#@ 
#@   # create DEF file
#@   write_def -rows_tracks_gcells -output core_[pid].def
#@   set f1 [open core_[pid].def  ]
#@   redirect -variable file_dump {set tmp [read $f1]}
#@   close $f1
#@ 
#@   set f2 [open core_[pid].def   w]
#@   regsub -all "ROW STD_ROW_\[\^\n\]*\n" $tmp "" tmpnew1
#@   regsub -all "DIEAREA " $tmpnew1 "\#DIEAREA" tmpnew2
#@   regsub -all "END DESIGN.*" $tmpnew2 "" tmpnew
#@   puts $f2 "[string trimright $tmpnew]\n"
#@   # add core
#@   # DEF line looks like;
#@   #  ROW STD_ROW_1 core 0 2784 N DO 7080 BY 1 STEP 116 0 ;
#@   if { ! [info exists core_tile] } {
#@     set core_sites {}
#@   }
#@   set i 1
#@   foreach site_row [lsort -index 0 [lsort -index 1 $core_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_$i $core_tile $x $y $orient DO $step BY 1 STEP $core_step 0 ;"
#@     incr i
#@   }
#@   # add bonuscore
#@   # DEF line looks like;
#@   #  ROW STD_ROW_BONUSCORE_1 bonuscore 0 2784 N DO 7080 BY 1 STEP 464 0 ;
#@   if { ! [info exists bonuscore_tile] } {
#@     set bonuscore_sites {}
#@   }
#@   foreach site_row [lsort -index 0 [lsort -index 1 $bonuscore_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_BONUSCORE_$i $bonuscore_tile $x $y $orient DO $step BY 1 STEP $bonuscore_step 0 ;"
#@     incr i
#@   }
#@   # add core2h (if available)
#@   # DEF line looks like;
#@   #  ROW STD_ROW_CORE2H_1 core2h 0 2784 N DO 7080 BY 1 STEP 116 0 ;
#@   if { ! [info exists core2h_tile] } {
#@     set core2h_sites {}
#@   }
#@   foreach site_row [lsort -index 0 [lsort -index 1 $core2h_sites]] {
#@     foreach { x y orient step }  $site_row { break }
#@     puts $f2 "ROW STD_ROW_CORE2H_$i $core2h_tile $x $y $orient DO $step BY 1 STEP $core2h_step 0 ;"
#@     incr i
#@   }
#@   close $f2
#@ 
#@   # load def
#@   read_def core_[pid].def
#@   file delete -force "core_[pid].def"
#@ 
#@ 
#@   return 0
#@ 
#@ }
#@ 
#@ define_proc_attributes P_add_bonuscore_core2h_rows     -info "Create site_rows for core2h and bonuscore"     -define_args {
#@       {-unit_tile "name of unit tile" unit_tile string required}
#@       {-bonus_tile "name of bonus tile" bonus_tile string optional}
#@       {-unit_2h_tile "name of 2x height tile" unit_2h_tile string optional}
#@     }
#@ 
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_get_techfile_info
#@ # __description:  dump & read in contents of techfile for current_mw_lib
#@ #                 ignores comment fields
#@ # __proc returns:  a list of lists of technology information
#@ #                  i.e.
#@ #                  {{Technology {name "name-string"} {date "date-string"}
#@ #                               {dielectric 3.45e-5} ...}
#@ #                   {Color 19 {{name 19} {rgbDefined 1} ...}}
#@ #                   {Stipple patternM1 {{width 8} {height 8}
#@ #                                       {pattern {0 0 0 1 0 0 ...}  ...}}
#@ #                   {Tile unit {{width 0.xx} {height x.xx}}}
#@ #                   {Tile core {{width 0.xx} {height x.xx}}}
#@ #                   {Layer poly {{layerNumber #} {maskName poly} {visible 1} ...}}
#@ #                   {ContactCode via1 {{contactCodeNumber #} {cutLayer via1} ...}}
#@ #                   .....}
#@ # __required_args:  none
#@ # __optional_args:
#@ # __end
#@ #-------------------------------------------------------------------
#@ #
#@ proc P_get_techfile_info {} {
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   # set up error outputs
#@   set puts "puts"
#@   set puts_nnl "puts -nonewline"
#@   set info_stack "\n#INFO-STACK==> $func_name"
#@   set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
#@   set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
#@   if { [llength [info commands da_error]] > 0 } { set da_error da_error
#@   } else { set da_error [eval $fmte ERROR] }
#@   if { [llength [info commands da_warn]] > 0 } { set da_warn da_warn
#@   } else { set da_warn [eval $fmt WARNING] }
#@   if { [llength [info commands da_info]] > 0 } { set da_info da_info
#@   } else { set da_info [eval $fmt INFO] }
#@ 
#@   redirect /dev/null {catch {set mw_lib [current_mw_lib]}}
#@   if { (! [info exists mw_lib]) || ([llength $mw_lib] == 0) } {
#@     # no library is open
#@     return {}
#@   }
#@   write_mw_lib_files -technology -output tech_[pid].tf [current_mw_lib]
#@ 
#@   set tfh [open tech_[pid].tf r]
#@   set tech_lines {}
#@   set start_comment -1
#@   while { ! [eof $tfh] } {
#@     gets $tfh line
#@     set new_line ""
#@     while { [string length $line] > 0 } {
#@       if { $start_comment >= 0 } {
#@         set stop_comment [string first "*/" $line $start_comment]
#@         if { $stop_comment < 0 } {
#@           set line ""
#@           set start_comment 0
#@           break
#@         } else {
#@           set line [string range $line [expr $stop_comment + 2] end]
#@           set start_comment -1
#@         }
#@       } else {
#@         set start_comment [string first "/*" $line]
#@         if { $start_comment > 0 } {
#@           append new_line [string range $line 0 [expr $start_comment - 1]]
#@           set line [string range $line [expr $start_comment + 2] end]
#@           set start_comment 0
#@         } elseif { $start_comment < 0 } {
#@           append new_line $line
#@           set line ""
#@         }
#@       }
#@       set new_line [string trim $new_line]
#@       if { [string length $new_line] > 0 } {
#@         lappend tech_lines $new_line
#@       }
#@     }
#@   }
#@   close $tfh
#@ 
#@   set tech_info {}
#@   set in_section 0
#@   set line ""
#@   # have a techfile with all comments stripped
#@   foreach read_line $tech_lines {
#@     append line " $read_line"
#@     if { ! $in_section } {
#@       unset -nocomplain field type new_list end
#@       if { [regexp {^\s*(\S+)\s+"(\S+)"\s+\{\s*(\}?)$} $line all field type end] } {
#@         set new_list [list $field $type]
#@       } elseif { [regexp {^\s*(\S+)\s+(\d+)\s+\{\s*(\}?)$} $line all field type end] } {
#@         set new_list [list $field $type]
#@       } elseif { [regexp {^\s*(\S+)\s+\{\s*(\}?)$} $line all field end] } {
#@         set new_list [list $field]
#@       } else {
#@         continue
#@       }
#@       set in_section 1
#@     } else {
#@       if { [regexp {^\s*(\S+)\s*=\s*"([^\"]+)"\s*(\}?)$} $line all item value end] } {
#@         lappend new_list [list $item $value]
#@       } elseif { [regexp {^\s*(\S+)\s*=\s*\(([^\)]+)\)\s*(\}?)$} $line all item value_list end] } {
#@         set value [regsub -all {[\s,]+} [string trim $value_list] { }]
#@         lappend new_list [list $item $value]
#@       } elseif { [regexp {^\s*(\S+)\s*=\s*([^\s\(]+)\s*(\}?)$} $line all item value end] } {
#@         lappend new_list [list $item $value]
#@       } elseif { ! [regexp {^\s*(\})$} $line all end] } {
#@         continue
#@       }
#@     }
#@     if { [info exists end] && [string equal "\}" $end] } {
#@       lappend tech_info $new_list
#@       set in_section 0
#@     }
#@     set line ""
#@ 
#@   }
#@ 
#@   # remove the temporary techfile
#@   file delete -force "tech_[pid].tf"
#@ 
#@   return $tech_info
#@ 
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_set_repeating_custom_tracks
#@ # Input(s)    : -track_settings {list}
#@ # Output(s)   : none
#@ # Help line   : sets custom tracks based on track_settings
#@ #                  list that describes track settings
#@ # Description : set preferred directions, preferred
#@ #               and non-preferred routing tracks.
#@ #               The procedure will set tracks across the
#@ #               entire floorplan and allows a either a
#@ #               single repeating track or set of
#@ #               (non-uniform) repeating tracks.
#@ #               Non-preferred tracks can be explicitly set
#@ #               or if not set then are derived from preferred
#@ #               tracks above & below the current layer.
#@ #               Tracks are built to avoid wires
#@ #               that won't be contained in the floorplan area.
#@ #
#@ #               {list} format for -track_settings:
#@ #                  => per layer list specifying:
#@ #                   layer                string(layer_name)
#@ #                   preferred-direction  string(horizontal or vertical)
#@ #                   preferred-tracks     list(offsets,repeat)
#@ #                   non-preferred-tracks list(offsets,repeat)
#@ #                   {offsets} - (list of) number(s)
#@ #                   {repeat}  - number (step value for tracks)
#@ #
#@ # Example(s)  : Suppose you are running script called "check_hier.tcl"
#@ #               set my_tracks {
#@ #                   { { layer metal1 }
#@ #                          { preferred-direction vertical }
#@ #                          { preferred-tracks { offsets 0 }
#@ #                                             { repeat 0.116 } } }
#@ #                      { { layer metal2 }
#@ #                          { preferred-direction horizontal }
#@ #                          { preferred-tracks { offsets { 0.029 0.145 0.464 0.580
#@ #                                                         0.696 0.812 0.928
#@ #                                                         1.247 1.363 1.479 } }
#@ #                                             { repeat  1.566 } } }
#@ #                      { { layer metal3 }
#@ #                          { preferred-direction vertical }
#@ #                          { preferred-tracks { offsets 0.116 }
#@ #                                             { repeat 0.116 } } }
#@ #                      { { layer metal4 }
#@ #                          { preferred-direction horizontal } }
#@ #                   }
#@ #               P_set_repeating_custom_tracks -track_settings $my_tracks
#@ #
#@ # Notes(s)    :
#@ #      1) arguments are given as lists (lists of lists with keyword directives)
#@ #      2) it is not necessary to specify preferred-direction, values set
#@ #             up in the design are used by default
#@ #      3) offsets should be given from the bottom & left
#@ #      4) tracks are only added if the entire metal width fits in the fub
#@ #      5) non-preferred tracks by default will be derived from the
#@ #           preferred tracks of the layers above & below the current layer
#@ #      6) non-preferred tracks can be forced if needed using the
#@ #           non-preferred-tracks directive
#@ #      7) if two different sets of repeats are required for a particular
#@ #           track setup, then they need to be given as 2 separate layer sets
#@ #           i.e. (this example pushes preferred tracks from
#@ #                         metal2 & metal4 to metal3 non-preferred tracks)
#@ #
#@ #               set my_tracks {
#@ #                      { { layer metal3 }
#@ #                          { non-preferred-tracks { offsets
#@ #                                                    { 0.029 0.145 0.464 0.580
#@ #                                                      0.696 0.812 0.928
#@ #                                                      1.247 1.363 1.479 } }
#@ #                                             { repeat  1.566 } } }
#@ #                      { { layer metal3 }
#@ #                          { non-preferred-tracks { offsets 0.087 }
#@ #                                                 { repeat 0.174 } } }
#@ #                   }
#@ #               P_set_repeating_custom_tracks -track_settings $my_tracks
#@ #
#@ # -----------------------------------------------------------------------------
#@ #
#@ 
#@ 
#@ proc P_set_repeating_custom_tracks {args } {
#@   parse_proc_arguments -args $args flag
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   if { [info exists flag(-track_settings)] } {
#@     if { $flag(-track_settings) == "help" } {
#@       puts "need help"
#@       puts "Usage: $func_name # set custom tracks"
#@       puts "        -track_settings TrackInfoList"
#@       puts "   (TrackInfoList of type list)"
#@       puts "   TrackInfoList format:"
#@       puts "      {"
#@       puts "         { {layer LAYER_1}"
#@       puts "              {preferred-direction HORIZONTAL|VERTICAL}"
#@       puts "              {preferred-tracks"
#@       puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
#@       puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
#@       puts "              }"
#@       puts "              {non-preferred-tracks"
#@       puts "                 {offsets {OFFSET1 OFFSET2 ...}}"
#@       puts "                 {repeat  REPEAT_FOR_OFFSET_PATTERN}"
#@       puts "              }"
#@       puts "         }"
#@       puts "         { {layer LAYER_N}"
#@       puts "           {preferred-direction HORIZONTAL|VERTICAL}"
#@       puts "         }"
#@       puts "      }"
#@       puts "   - - - - - - - -"
#@       puts "   (optional) non-preferred-tracks"
#@       puts "        - if not given, then derived from preferred-tracks above/below"
#@       puts ""
#@       return
#@     }
#@     set track_settings $flag(-track_settings)
#@   }
#@ 
#@   # set default offset reference to the lowerLeft unless 'origin' is specified
#@   set reference_origin 0
#@   if { [info exists flag(-offset_reference)] } {
#@     if { [string equal "origin" $flag(-offset_reference)] } {
#@       set reference_origin 1
#@     }
#@   }
#@ 
#@   # record if tracks can land on the boundary
#@   set no_sharing_boundary [info exists flag(-no_tracks_on_boundary)]
#@ 
#@   # All track settings are done HERE with track_settings
#@ 
#@   # get length precision (the round about method for icc)
#@   redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
#@   regexp -line {^length.*} $unit_vars length_units
#@   set lengthPrecision [expr [lindex $length_units 2] + 0.0]
#@   # hard code length precision - not easily available in tcl
#@   # set lengthPrecision 1000.0
#@ 
#@   # base on bounds of the block to set range of wiretracks
#@   set bound_llx [expr [get_attribute [current_design] die_area_llx]                      / $lengthPrecision]
#@   set bound_lly [expr [get_attribute [current_design] die_area_lly]                      / $lengthPrecision]
#@   set bound_urx [expr [get_attribute [current_design] die_area_urx]                      / $lengthPrecision]
#@   set bound_ury [expr [get_attribute [current_design] die_area_ury]                      / $lengthPrecision]
#@ 
#@   # find metal routing layers
#@   set layer_pairs {}
#@   foreach_in_collection layer [get_layers] {
#@     set layer_name [get_attribute $layer name]
#@     if { [string match [get_layer_attribute -layer $layer_name isDefaultLayer] 0] } {
#@       continue
#@     }
#@     if { [string match metal*               [get_layer_attribute -layer $layer_name mask_name]] } {
#@       lappend layer_pairs [list [get_layer_attribute -layer $layer_name mask_name] $layer_name]
#@     }
#@   }
#@   set layer_pairs [lsort -index 0 -dictionary $layer_pairs]
#@   set layers {}
#@   foreach item $layer_pairs {
#@     lappend layers [lindex $item 1]
#@   }
#@   unset layer_pairs
#@ 
#@   # get existing preferred directions
#@   set preferred_dir_list {}
#@   redirect -variable dump_preferred_dir { report_preferred_routing_direction }
#@   set next_match 0
#@   if { [regexp -start $next_match -indices -lineanchor             "Layer Name  \[^\n]*"             $dump_preferred_dir dump_indices] } {
#@     set new_str [string range $dump_preferred_dir [lindex $dump_indices 0]                      [lindex $dump_indices 1]]
#@     set next_match [expr [lindex $dump_indices 1] + 2]
#@     regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_fields
#@     # find fields for layer_name & design
#@     set layer_index [lsearch [string tolower $dump_fields] layer_name]
#@     set design_index [lsearch [string tolower $dump_fields] design]
#@     set num_fields [llength $dump_fields]
#@ 
#@     # now search for fields
#@     while { [regexp -start $next_match -indices -lineanchor                  "\[^\n]*"                  $dump_preferred_dir dump_indices] } {
#@       if { $layer_index < 0 || $design_index < 0 } {
#@         break
#@       }
#@       set new_str [string range $dump_preferred_dir                        [lindex $dump_indices 0]                        [lindex $dump_indices 1]]
#@       set next_match [expr [lindex $dump_indices 1] + 2]
#@       regsub -all {([^ ]) ([^ ])} $new_str {\1_\2} dump_string
#@       if { [llength $dump_string] < $num_fields } {
#@         unset dump_string new_str
#@         break
#@       }
#@       set prefer_layer [lindex $dump_string $layer_index]
#@       set prefer_dir   [string tolower [lindex $dump_string $design_index]]
#@       lappend preferred_dir_list [list $prefer_layer $prefer_dir]
#@       unset prefer_layer prefer_dir dump_string new_str
#@     }
#@     unset layer_index design_index num_fields
#@   }
#@   unset dump_preferred_dir next_match
#@   set preferred_dir_list [lsort -index 0 -dictionary $preferred_dir_list]
#@ 
#@ 
#@   # begin processing track settings for layer
#@   set error 0
#@   set tracks_actually_set {}
#@   set nprfr_adds {}
#@   set dir_updates {}
#@   foreach track_set $track_settings {
#@     unset -nocomplain layer_name preferred_dir         PT NPT unknown_opt comment_field err_type
#@     foreach item $track_set {
#@       if { $error } {
#@         break
#@       }
#@       if { [llength $item] < 2 } {
#@         continue
#@       }
#@       set chk_field [string tolower [lindex $item 0]]
#@       switch -- ${chk_field} {
#@         layer                { if { [info exists layer_name] } {
#@           set err_type layer
#@         } else {
#@           set layer_name [lindex $item 1]
#@         }
#@         }
#@         preferred-direction  { if { [info exists preferred_dir] } {
#@           set err_type preferred-direction
#@         } else {
#@           set preferred_dir [lindex $item 1]
#@         }
#@         }
#@         non-preferred-tracks { if { [info exists NPT] } {
#@           set err_type non-preferred-tracks
#@         } else {
#@           set NPT [lrange $item 1 end]
#@         }
#@         }
#@         preferred-tracks     { if { [info exists PT] } {
#@           set err_type preferred-tracks
#@         } else {
#@           set PT [lrange $item 1 end]
#@         }
#@         }
#@         comment              { set comment_field 1 }
#@         default        { set unknown_opt $item }
#@       }
#@       if { [info exists err_type] } {
#@         puts "ERROR - duplicate option for \"$err_type\" in 'track_settings' for \{ $track_set \}"
#@         set error 1
#@         break
#@       }
#@       if { [info exists comment_field] } {
#@         unset comment_field
#@         continue
#@       }
#@       if { [info exists unknown_opt] } {
#@         break
#@       }
#@     }
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists unknown_opt] } {
#@       puts "WARNING - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $track_set \}"
#@       continue
#@     }
#@     if { ! [info exists layer_name] } {
#@       puts "ERROR - Required 'layer' option missing in 'track_settings' for \{ $track_set \}"
#@       set error 1
#@       break
#@     }
#@     if { [lsearch -exact $layers $layer_name] < 0 } {
#@       puts "ERROR - Unknown 'layer' \"$layer_name\" specified in 'track_settings' for \{ $track_set \}"
#@       puts "      - layer must be one of: $layers"
#@       set error 1
#@       break
#@     }
#@     if { [info exists preferred_dir] } {
#@       switch -- [string tolower ${preferred_dir}] {
#@         vertical    { set new_dir vertical }
#@         horizontal  { set new_dir horizontal }
#@         default     { set unknown_opt $item }
#@       }
#@       if { [info exists unknown_opt] } {
#@         puts "ERROR - bad preferred-direction \"$preferred_dir\" defined for layer \"$layer_name\" "
#@         set error 1
#@         break
#@       }
#@       if { [info exists ${layer_name}(dir)] && (! [string match $new_dir [expr $${layer_name}(dir)]]) } {
#@         puts "ERROR - preferred-direction defined as both horizontal & vertical for layer \"$layer_name\" "
#@         set error 1
#@         break
#@       }
#@       set ${layer_name}(dir) $new_dir
#@     }
#@ 
#@     set track_items {}
#@     if { [info exists PT] } {
#@       lappend track_items [list PT $PT]
#@     }
#@     if { [info exists NPT] } {
#@       lappend track_items [list NPT $NPT]
#@     }
#@     unset -nocomplain comment_field PT_track_offsets PT_track_repeats NPT_track_offsets NPT_track_repeats
#@     foreach N_item $track_items {
#@       set N_dir [string toupper [lindex $N_item 0]]
#@       foreach item [lindex $N_item 1] {
#@         set chk_field [string tolower [lindex $item 0]]
#@         switch -- ${N_dir}_${chk_field} {
#@           NPT_offsets { if { [info exists NPT_track_offsets] } {
#@             set err_type "non-preferred-tracks offsets"
#@           } else {
#@             set NPT_track_offsets [lindex $item 1]
#@           }
#@           }
#@           NPT_repeat  { if { [info exists NPT_track_repeats ] } {
#@             set err_type "non-preferred-tracks repeat"
#@           } else {
#@             set NPT_track_repeats [lindex $item 1]
#@           }
#@           }
#@           NPT_comment { set comment_field 1 }
#@           PT_offsets  { if { [info exists PT_track_offsets] } {
#@             set err_type "preferred-tracks offsets"
#@           } else {
#@             set PT_track_offsets [lindex $item 1]
#@           }
#@           }
#@           PT_repeat   { if { [info exists PT_track_repeats ] } {
#@             set err_type "preferred-tracks repeat"
#@           } else {
#@             set PT_track_repeats [lindex $item 1]
#@           }
#@           }
#@           PT_comment  { set comment_field 1 }
#@           default     { set unknown_opt $item }
#@         }
#@         if { [info exists comment_field] } {
#@           unset comment_field
#@           continue
#@         }
#@         if { [info exists unknown_opt] } {
#@           break
#@         }
#@         if { [info exists err_type] } {
#@           if { ($N_dir == "PT") } {
#@             set type "preferred-tracks"
#@           } else {
#@             set type "non-preferred-tracks"
#@           }
#@           puts "ERROR - duplicate option for \"$err_type\" in $layer_name '${type}' for \{ $item \}"
#@           set error 1
#@           break
#@         }
#@       }
#@       if { [info exists unknown_opt] } {
#@         break
#@       }
#@     }
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists unknown_opt] } {
#@       if { ($N_dir == "PT") } {
#@         set type "preferred-tracks"
#@       } else {
#@         set type "non-preferred-tracks"
#@       }
#@       puts "ERROR - Unknown 'track_settings' option \"[lindex $item 0]\" for \{ $layer_name $N_dir \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists PT_track_offsets] } {
#@       foreach t_item $PT_track_offsets {
#@         if { ! [string is double $t_item] } {
#@           set error 1
#@           break
#@         }
#@       }
#@       if { $error } {
#@         puts "ERROR - illegal \"preferred-tracks offsets\". Value must be real on $layer_name for $PT \}"
#@         break
#@       }
#@     }
#@     if { [info exists PT_track_repeats] && ((! [string is double $PT_track_repeats]) || ($PT_track_repeats < (1.0 / $lengthPrecision))) } {
#@       puts "ERROR - illegal \"preferred-tracks repeat\". Value must be positive real on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_offsets] } {
#@       foreach t_item $NPT_track_offsets {
#@         if { ! [string is double $t_item] } {
#@           set error 1
#@           break
#@         }
#@       }
#@       if { $error } {
#@         puts "ERROR - illegal \"non-preferred-tracks offsets\". Value must be real on $layer_name for $NPT \}"
#@         break
#@       }
#@     }
#@     if { [info exists NPT_track_repeats] && ((! [string is double $NPT_track_repeats]) || ($NPT_track_repeats < (1.0 / $lengthPrecision))) } {
#@       puts "ERROR - illegal \"non-preferred-tracks repeat\". Value must be positive real on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@ 
#@     if { [info exists PT_track_offsets] && (! [info exists PT_track_repeats]) } {
#@       puts "ERROR - \"preferred-tracks\" missing \"repeat\" on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists PT_track_repeats] && (! [info exists PT_track_offsets]) } {
#@       puts "ERROR - \"preferred-tracks\" missing \"offsets\" on $layer_name for $PT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_offsets] && (! [info exists NPT_track_repeats]) } {
#@       puts "ERROR - \"non-preferred-tracks\" missing \"repeat\" on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@     if { [info exists NPT_track_repeats] && (! [info exists NPT_track_offsets]) } {
#@       puts "ERROR - \"non-preferred-tracks\" missing \"offsets\" on $layer_name for $NPT \}"
#@       set error 1
#@       break
#@     }
#@ 
#@     if { [info exists PT_track_repeats] } {
#@       if { ! [info exists ${layer_name}(PT)] } {
#@         set ${layer_name}(PT) {}
#@       }
#@       lappend ${layer_name}(PT) [list $PT_track_repeats $PT_track_offsets]
#@     }
#@     if { [info exists NPT_track_repeats] } {
#@       if { ! [info exists ${layer_name}(NPT)] } {
#@         set ${layer_name}(NPT) {}
#@       }
#@       lappend ${layer_name}(NPT) [list $NPT_track_repeats $NPT_track_offsets]
#@     }
#@ 
#@   }
#@ 
#@   foreach layer_name $layers {
#@     if { $error } {
#@       break
#@     }
#@     if { [info exists ${layer_name}(dir)] } {
#@       set preferred_dir [expr $${layer_name}(dir)]
#@     } elseif { ! ([info exists ${layer_name}(PT)] || [info exists ${layer_name}(PT)]) } {
#@       # no tracks or preferred_dir defined for the layer
#@       continue
#@     }
#@     unset -nocomplain act_dir
#@     set dir_index [lsearch -glob $preferred_dir_list "$layer_name *"]
#@     if { $dir_index >= 0 } {
#@       set act_dir [lindex [lindex $preferred_dir_list $dir_index] 1]
#@     }
#@     if { [info exists preferred_dir] } {
#@       # see if preferred_dir needs to be changed
#@       if { [info exists act_dir] } {
#@         if { ! [string match -nocase $act_dir $preferred_dir] } {
#@           # mismatched preferred direction
#@           puts "INFO - Changing $layer_name preferred direction to \"${preferred_dir}\""
#@           unset_preferred_routing_direction -layer $layer_name
#@           set_preferred_routing_direction -layers $layer_name -direction $preferred_dir
#@           set act_dir $preferred_dir
#@           set preferred_dir_list               [lreplace $preferred_dir_list $dir_index $dir_index                    [list $layer_name $preferred_dir]]
#@           lappend dir_updates [list $layer_name $preferred_dir]
#@         }
#@       } else {
#@         puts "ERROR - $layer_name has no preferred direction"
#@         set error 1
#@         continue
#@       }
#@     } else {
#@       if { [info exists act_dir] &&                ( [string match horizontal $act_dir] ||                      [string match vertical $act_dir] ) } {
#@         puts "INFO - $layer_name using $act_dir preferred direction"
#@         set preferred_dir $act_dir
#@       } else {
#@         puts "WARNING - $layer_name has no preferred direction"
#@         continue
#@       }
#@     }
#@   }
#@ 
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { ! [info exists ${layer_name}(PT) ] } {
#@       # no defined preferred tracks to add
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     # set layer_index [lsearch -exact $layers $layer_name]
#@ 
#@     unset -nocomplain tracks_actually_set
#@     set tracks_actually_set {}
#@ 
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 1
#@       set XY Y
#@       set bound_ll $bound_lly
#@       set bound_ur $bound_ury
#@     } else {
#@       set horizontal 0
#@       set XY X
#@       set bound_ll $bound_llx
#@       set bound_ur $bound_urx
#@     }
#@ 
#@     # find start track (based on reference_origin) relative to lower-left
#@     if { $reference_origin } {
#@       # reference for offset is origin
#@       set start_ref 0
#@     } else {
#@       # reference for offset is lower-left
#@       set start_ref $bound_ll
#@     }
#@ 
#@     set PT_list [expr $${layer_name}(PT)]
#@ 
#@     # get default layer width
#@     set width [get_layer_attribute -layer $layer_name defaultWidth]
#@     # if no_sharing_boundary use width, else treat as if width=0
#@     #   (since only the track not the metal must fall within/touching boundary)
#@     if { ! $no_sharing_boundary } {
#@       set width 0
#@     }
#@     set removed_track 0
#@ 
#@     foreach PT $PT_list {
#@       set PT_track_repeats [lindex $PT 0]
#@       set PT_track_offsets [lindex $PT 1]
#@ 
#@ 
#@       # figure out offsets and repeats for actual tracks
#@       set item_list {}
#@       foreach PT_offset $PT_track_offsets  {
#@         # find start track based on start_ref (wire width must fit in bounds)
#@         set offset_adjust [expr $PT_offset                                - ($PT_track_repeats *floor($PT_offset / $PT_track_repeats))]
#@         set PT_start [expr $start_ref + $offset_adjust                           + (($offset_adjust < (0.5 * $width))? $PT_track_repeats : 0)]
#@         set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $PT_start)                                          / $PT_track_repeats)) ]
#@         if { $tcnt > 0 } {
#@           set new_item [list $PT_start $tcnt]
#@           if { [lsearch -exact $item_list $new_item] < 0 } {
#@             lappend item_list $new_item
#@           }
#@         }
#@       }
#@       if { (! $removed_track) && ([llength $item_list] > 0) } {
#@         puts "INFO: Forcing preferred track to defined values on -layer $layer_name"
#@         remove_track -layer $layer_name -dir $XY
#@         set removed_track 1
#@       }
#@       foreach new_item $item_list  {
#@         set PT_start [lindex $new_item 0]
#@         set tcnt [lindex $new_item 1]
#@         set new_track "create_track -layer $layer_name -dir $XY -coord $PT_start                       -space $PT_track_repeats -count $tcnt"
#@         eval $new_track
#@         lappend tracks_actually_set $new_track
#@       }
#@     }
#@     if { [llength $tracks_actually_set] > 0 } {
#@       set ${layer_name}(tracks) $tracks_actually_set
#@     }
#@   }
#@ 
#@   # loop to add defined non-preferred tracks
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { ! [info exists ${layer_name}(NPT)] } {
#@       # no defined non-preferred tracks to add
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     set layer_index [lsearch -exact $layers $layer_name]
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 0
#@       set XY X
#@       set bound_ur $bound_urx
#@     } else {
#@       set horizontal 1
#@       set XY Y
#@       set bound_ur $bound_ury
#@     }
#@ 
#@     set NPT_list [expr $${layer_name}(NPT)]
#@ 
#@     # get default layer width
#@     set width [get_layer_attribute -layer $layer_name defaultWidth]
#@     # if no_sharing_boundary use width, else treat as if width=0
#@     #   (since only the track not the metal must fall within/touching boundary)
#@     if { ! $no_sharing_boundary } {
#@       set width 0
#@     }
#@     set removed_track 0
#@ 
#@     foreach NPT $NPT_list {
#@       set NPT_track_repeats [lindex $NPT 0]
#@       set NPT_track_offsets [lindex $NPT 1]
#@ 
#@       # figure out offsets and repeats for actual tracks
#@       set item_list {}
#@       foreach NPT_offset $NPT_track_offsets  {
#@         # find start track based on start_ref (wire width must fit in bounds)
#@         set offset_adjust [expr $NPT_offset                                - ($NPT_track_repeats                                       * floor($NPT_offset / $NPT_track_repeats))]
#@         set NPT_start [expr $start_ref + $offset_adjust                            + (($offset_adjust < (0.5 * $width))? $NPT_track_repeats : 0)]
#@         set tcnt [expr 1 + int(floor(($bound_ur - (0.5 * $width) - $NPT_start)                                          / $NPT_track_repeats)) ]
#@         if { $tcnt > 0 } {
#@           set new_item [list $NPT_start $tcnt]
#@           if { [lsearch -exact $item_list $new_item] < 0 } {
#@             lappend item_list $new_item
#@           }
#@         }
#@       }
#@       if { (! $removed_track) && ([llength $item_list] > 0) } {
#@         puts "INFO: Forcing non-preferred track to defined values on -layer $layer_name"
#@         remove_track -layer $layer_name -dir $XY
#@         set removed_track 1
#@       }
#@       foreach new_item $item_list  {
#@         set NPT_start [lindex $new_item 0]
#@         set tcnt [lindex $new_item 1]
#@         set new_track "create_track -layer $layer_name -dir $XY -coord $NPT_start                       -space $NPT_track_repeats -count $tcnt"
#@         eval $new_track
#@       }
#@     }
#@   }
#@ 
#@   # loop to check if default non-preferred tracks are needed
#@   foreach layer_dir $preferred_dir_list {
#@     if { $error } {
#@       break
#@     }
#@     set layer_name [lindex $layer_dir 0]
#@     if { [info exists ${layer_name}(NPT)] } {
#@       # already added non-preferred tracks
#@       continue
#@     }
#@     set preferred_dir [lindex $layer_dir 1]
#@     set layer_index [lsearch -exact $layers $layer_name]
#@     if { $layer_index > 0 } {
#@       set lower_layer [lindex $layers [expr $layer_index - 1]]
#@     } else {
#@       set lower_layer ""
#@     }
#@     if { $layer_index < ([llength $layers] - 1) } {
#@       set upper_layer [lindex $layers [expr $layer_index + 1]]
#@     } else {
#@       set upper_layer ""
#@     }
#@ 
#@     if { ! ([info exists ${upper_layer}(tracks)] || [info exists ${lower_layer}(tracks)]) } {
#@       # no preferred tracks defined on adjacent tracks
#@       continue
#@     }
#@ 
#@     if { [string match horizontal $preferred_dir] } {
#@       set horizontal 0
#@       set XY X
#@     } else {
#@       set horizontal 1
#@       set XY Y
#@     }
#@ 
#@     set np_list {}
#@     if { [llength $lower_layer] } {
#@       unset -nocomplain lower_tracks
#@       redirect -variable lower_tracks { report_track -layer $lower_layer -dir $XY }
#@       set next_match 0
#@       while { [regexp -start $next_match -indices                    "$lower_layer \[^\n]*"                    $lower_tracks np_indices] } {
#@         lappend np_list             [lreplace [lrange [string range $lower_tracks                                    [lindex $np_indices 0]                                    [lindex $np_indices 1]]                            0 4] 0 0 $layer_name]
#@         set next_match [expr [lindex $np_indices 1] + 1]
#@       }
#@       unset -nocomplain lower_tracks np_indices next_match
#@     }
#@     if { [llength $upper_layer] } {
#@       unset -nocomplain upper_tracks
#@       redirect -variable upper_tracks { report_track -layer $upper_layer -dir $XY }
#@       set next_match 0
#@       while { [regexp -start $next_match -indices                    "$upper_layer \[^\n]*"                    $upper_tracks np_indices] } {
#@         lappend np_list             [lreplace [lrange [string range $upper_tracks                                    [lindex $np_indices 0]                                    [lindex $np_indices 1]]                            0 4] 0 0 $layer_name]
#@         set next_match [expr [lindex $np_indices 1] + 1]
#@       }
#@       unset -nocomplain upper_tracks np_indices next_match
#@     }
#@     set np_list [lsort -unique $np_list]
#@ 
#@     if { [llength $np_list] > 0 } {
#@       puts "INFO: Resetting non-preferred track to adjacent layer preferred tracks settings on -layer $layer_name"
#@       remove_track -layer $layer_name -dir $XY
#@     }
#@     foreach np_track $np_list {
#@       if { [llength $np_track] < 5 } {
#@         continue
#@       }
#@       set new_track "create_track -layer $layer_name -dir $XY -coord [lindex $np_track 2]                         -space [lindex $np_track 4] -count [lindex $np_track 3]"
#@       eval $new_track
#@     }
#@ 
#@   }
#@ 
#@   if { $error } {
#@     puts "ERROR - $func_name stopped due to errors"
#@   }
#@ 
#@ }
#@ define_proc_attributes P_set_repeating_custom_tracks -info "set custom tracks"     -define_args {{-track_settings "provide list or use '-track_settings help' for TrackInfoList format" TrackInfoList list required }                       {-offset_reference "reference for track offsets {default=lowerLeft}" offset_reference one_of_string { optional value_help {values {lowerLeft origin}}}}                       {-no_tracks_on_boundary "require tracks produce wires fully in the boundary" "" boolean optional} }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_check_boundary_contact
#@ # Description : The procedure to determine if the Core Boundary contacts with any cell
#@ #               which has start point coordinates as cell_llx, cell_lly
#@ #               Used in halo insertion
#@ 
#@ proc P_check_boundary_contact {cell_llx cell_lly} {
#@ 
#@   set bbox [get_attribute [get_core_area] bbox]
#@   set bbox_x1 [lindex [lindex $bbox 0] 0]
#@   set bbox_y1 [lindex [lindex $bbox 0] 1]
#@   set bbox_x2 [lindex [lindex $bbox 1] 0]
#@   set bbox_y2 [lindex [lindex $bbox 1] 1]
#@ 
#@   global diehalo_width
#@   global diehalo_height
#@ 
#@   set flag 0
#@   set prs_flag 0
#@ 
#@   # Checking if the cell that gets placed will be within the die boundary.
#@   # Uncomment line from 78-83 and comment line 85-90 if die-edge halo is considered within Core
#@   #  if {($cell_llx <= [expr $bbox_x1 + 0.54 - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + 1.68 - 0.001]) || ($cell_llx >= [expr $bbox_x2 - 0.54 - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - 1.68 - 0.001] )} {
#@   # set flag 1
#@   #   } else {
#@   #       set flag 0
#@   #   }
#@   #   return $flag
#@ 
#@   if {($cell_llx <= [expr $bbox_x1 + $diehalo_width - 0.001] ) || ($cell_lly <= [expr $bbox_y1 + $diehalo_height - 0.001]) || ($cell_llx >= [expr $bbox_x2 - $diehalo_width - 0.001] ) || ($cell_lly >= [expr $bbox_y2 - $diehalo_height - 0.001] )} {
#@     set flag 1
#@   } else {
#@     set flag 0
#@   }
#@   return $flag
#@ }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_get_abut_chain
#@ # Description : This proc is used to get list of macros which are abutting each other
#@ #               Used in halo insertion
#@ 
#@ proc P_get_abut_chain {abut_master} {
#@   global cellabutlist
#@   set cellabutlist [add_to_collection $cellabutlist $abut_master]
#@   set macro_bbox [list [get_attribute $abut_master boundary]]
#@   set overlapcells [remove_from_collection [get_cells -all -intersect $macro_bbox] $cellabutlist]
#@   foreach_in_collection ovcell $overlapcells {
#@     P_get_abut_chain $ovcell
#@   }
#@   return $cellabutlist
#@ }
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_get_abutted_cells
#@ # Description : This proc is used to get macro cells which are abutting
#@ #               Used in halo insertion
#@ 
#@ proc P_get_abutted_cells {input_master} {
#@   set macro_groups ""
#@   set fullabutlist ""
#@   global cellabutlist
#@   foreach_in_collection macrolist $input_master {
#@     if {[sizeof_collection [remove_from_collection $fullabutlist $macrolist -intersect]] == 0} {
#@       set cellabutlist ""
#@       set out_list [P_get_abut_chain $macrolist]
#@       set fullabutlist [add_to_collection $fullabutlist $out_list]
#@       lappend macro_groups [lsort -unique [get_object_name $out_list]]
#@     }
#@   }
#@ 
#@   return $macro_groups
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_get_boundary_polygon
#@ # Description : This proc is used boundary polygon computation for halo insertion
#@ 
#@ proc P_get_boundary_polygon {list_macros} {
#@   set result_polygon [list]
#@   while {[llength $list_macros] > 0} {
#@     set copy_macros $list_macros
#@     for { set i 0 } { $i < [llength $copy_macros] } { incr i } {
#@       if {[llength $result_polygon] > 0 } {
#@         set polygon [compute_polygons -boolean or "$result_polygon" [get_attribute [get_cells -all [lindex $copy_macros $i]] boundary]]
#@         if {[llength $polygon] == 1} {
#@           set result_polygon $polygon
#@           set list_macros [lsearch -inline -all -not -exact $list_macros [lindex $copy_macros $i]]
#@         }
#@       } else {
#@         set first_macro [lindex $copy_macros 0]
#@         set list_macros [lsearch -inline -all -not -exact $list_macros $first_macro]
#@         set result_polygon [get_attribute [get_cells -all $first_macro] boundary]
#@       }
#@     }
#@   }
#@ 
#@   if {[llength $result_polygon] != 1} {
#@     set result_polygon [list $result_polygon];
#@   }
#@ 
#@   return $result_polygon
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_lcount
#@ # Description : This proc is used to get repeated elements from a list
#@ 
#@ proc P_lcount list {
#@   foreach x $list {lappend arr($x) {}}
#@   set res {}
#@   foreach name [array names arr] {
#@     if { [llength $arr($name)] == 2 } {
#@       set res $name
#@     }
#@   }
#@   return $res
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_place_halo
#@ # creates and places a HALO cell at a specific location
#@ # to improve run time, save orientation in list and run at the end
#@ #
#@ proc P_place_halo {cell inst x y orientation} {
#@   global halo_counter
#@   global halo_orient_N halo_orient_FN halo_orient_S halo_orient_FS
#@   create_cell $inst $cell > /dev/null
#@   set_cell_location $inst -coordinates "$x $y" -ignore_fixed
#@   #rotate_objects $inst -to $orientation -ignore_fixed > /dev/null
#@   #this command is slow, so create a list of cell first, then run at once
#@   if {$orientation == "N"} {
#@     lappend halo_orient_N "$inst"
#@   } elseif {$orientation == "FN"} {
#@     lappend halo_orient_FN "$inst"
#@   } elseif {$orientation == "S"} {
#@     lappend halo_orient_S "$inst"
#@   } elseif {$orientation == "FS"} {
#@     lappend halo_orient_FS "$inst"
#@   } else {
#@     P_msg_error "set orientation error"
#@   }
#@   incr halo_counter
#@   #puts "==>INFORMATION: Placed $cell $inst $x $y $orientation"
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_find_direction
#@ # This procedure just finds the direction of the boundary edge
#@ # by looking at the coordinate of start point and end point
#@ # returns "up", "down", "left", "right"
#@ #
#@ proc P_find_direction {start end} {
#@   set startx [lindex $start 0]
#@   set starty [lindex $start 1]
#@   set endx [lindex $end 0]
#@   set endy [lindex $end 1]
#@   if {$startx == $endx && $starty==$endy} {
#@     return "nochange"
#@   } elseif {$startx<$endx && $starty==$endy} {
#@     return "right"
#@   } elseif {$startx==$endx && $starty<$endy} {
#@     return "up"
#@   } elseif {$startx>$endx && $starty==$endy} {
#@     return "left"
#@   } elseif {$startx==$endx && $starty>$endy} {
#@     return "down"
#@   } else {
#@     P_msg_error "Cannot determine direction"
#@   }
#@ }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_ret_intersect_list
#@ # Description : This proc returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo 
#@ #               Used during halo insertion around voltage areas
#@ 
#@ proc P_ret_intersect_list {args} {
#@   parse_proc_arguments -args $args inputs
#@   set vboundary $inputs(-input_boundary)
#@   set input_va_name $inputs(-input_va)
#@ 
#@   set check_boundary_list [list ]
#@   set volt_boundary [lsort -unique -dict -increasing $vboundary]
#@ 
#@   set die_boundary [lsort -unique -dict -increasing [get_attribute [get_die_area] boundary]]
#@   lappend check_boundary_list $die_boundary
#@   
#@   set intersect_macros [get_cells -all -intersect $vboundary -quiet -filter "name !~ *halo_va*"]
#@   foreach_in_collection  macro $intersect_macros {
#@     lappend check_boundary_list [lsort -unique -incr -dict [get_attribute $macro boundary]]
#@   }
#@   
#@   set ret_list ""
#@   set volt_count -1
#@ 
#@   foreach volt_point $volt_boundary {
#@     incr volt_count
#@     foreach volt_x_val [lindex $volt_point 0] {
#@       foreach check_bound $check_boundary_list {
#@         set ch_count -1
#@         set x_val ""
#@         foreach check_point $check_bound {
#@           incr ch_count
#@           foreach check_x_val [lindex $check_point 0] {
#@             if {[lsearch $x_val $volt_x_val] > -1} {continue}
#@             if {$check_x_val == $volt_x_val} {
#@               lappend x_val $check_x_val
#@               set check_curr_y_val [lindex $check_point 1]
#@               set check_next_y_val [lindex [lindex $check_bound [expr $ch_count + 1]] 1]
#@               set volt_curr_y_val [lindex $volt_point 1]
#@               set volt_next_y_val [lindex [lindex $volt_boundary [expr $volt_count + 1]] 1]
#@               
#@               if {($check_curr_y_val <= $volt_curr_y_val) && ($check_next_y_val > $volt_curr_y_val)} {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$volt_curr_y_val y2_$check_next_y_val"
#@               } elseif {($check_curr_y_val < $volt_next_y_val) && ($check_next_y_val >= $volt_next_y_val)} {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$volt_next_y_val"
#@               } elseif {($check_curr_y_val > $volt_curr_y_val) && ($check_next_y_val < $volt_next_y_val)}  {
#@                 set ret_list "$ret_list x_$volt_x_val y1_$check_curr_y_val y2_$check_next_y_val"
#@               }
#@             }
#@           }
#@         }
#@       }
#@     }
#@   }
#@ 
#@   return $ret_list
#@ }
#@ 
#@ define_proc_attributes P_ret_intersect_list     -info "Returns the x/y coordinates of voltage area which intersect with boundary/macro/non-va-halo"     -define_args {
#@       {"-input_boundary" "Voltage area boundary" "" list required}
#@       {"-input_va" "Voltage area name" "" string required}
#@     }
#@ 
#@ #######################################################################################################
#@ # Procedure   : P_check_exclusion
#@ # Description : This proc returns the returns y1 y2 intersect points of boundary/macro/non-va-halo
#@ #               Used during halo insertion around voltage areas
#@ 
#@ proc P_check_exclusion {args} {
#@   parse_proc_arguments -args $args inputs
#@   set x $inputs(-x)
#@   set y $inputs(-y)
#@   set ret 1
#@ 
#@   foreach in_list $inputs(-list) {
#@     set match_index [lsearch -all $in_list x_$x]
#@     foreach x_index $match_index {
#@       if {$x_index > -1} {
#@         set y1 [lindex [split [lindex $in_list [expr $x_index + 1]] "_"] 1]
#@         set y2 [lindex [split [lindex $in_list [expr $x_index + 2]] "_"] 1]
#@         if {[expr $y >= $y1] && [expr $y < $y2]} {
#@           set ret 0
#@           return $ret
#@         }
#@       }
#@     }
#@   }
#@ 
#@   return $ret
#@ 
#@ }
#@ 
#@ define_proc_attributes P_check_exclusion     -info "Returns y1 y2 intersect points"     -define_args {
#@       {"-list" "input list" "" string required}
#@       {"-x" "x coordinate to check" "" string required}
#@       {"-y" "y coordinate to check" "" string required}
#@     }
#@ 
#@ ####################################################################################################
#@ # Procedure   : P_macro_route_guide_cmd
#@ # Description : This proc is a PG pullback solution.
#@ #               It creates route-guides for all IPs for all specified layers and pulls back the PG when power straps are created.
#@ #               The route guide is removed when the proc is executed again for the next metal layer.
#@ 
#@ proc P_macro_route_guide_cmd {layer} {
#@   global INTEL_MACRO_EXCLUSION_LIST
#@   global INTEL_MACRO_RG_LIST
#@   remove_route_guide macroblkg*
#@ 
#@   foreach_in_collection macro [all_macro_cells] {
#@     set macro_ref_name [get_attribute $macro ref_name]
#@     set macro_index ""
#@     set default_index ""
#@     set exclusion_list -1
#@ 
#@     #Sets up exclusion list for macro references which should not have RGs for any layer
#@     #------------------------------------------------------------------------------------
#@     if {[info exists INTEL_MACRO_EXCLUSION_LIST] && $INTEL_MACRO_EXCLUSION_LIST != ""} {
#@       set exclusion_list [lsearch $INTEL_MACRO_EXCLUSION_LIST $macro_ref_name]
#@     }
#@ 
#@     if {$exclusion_list >= 0} {
#@       P_msg_info "Route Guides not created for macro:$macro_ref_name as it is part of exclusion list..."
#@     } else {
#@ 
#@       #Overrides default bloat values of current layer for specified macros
#@       #---------------------------------------------------------------------------------
#@       if {[info exists INTEL_MACRO_RG_LIST($macro_ref_name)]} {
#@         set macro_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST($macro_ref_name)] $layer]
#@         if {$macro_index != -1} {
#@           set x_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 1]]
#@           set y_bloat [lindex $INTEL_MACRO_RG_LIST($macro_ref_name) [expr $macro_index + 2]]
#@         }
#@       }
#@ 
#@       #Defaults bloat values for current layer if not overriden for a macro
#@       #-------------------------------------------------------------------------
#@ 
#@       if {![info exists INTEL_MACRO_RG_LIST($macro_ref_name)] || $macro_index == -1} {
#@         if {[info exists INTEL_MACRO_RG_LIST(DEFAULT)]} {
#@           set default_index [lsearch [regexp -inline -all -- {\S+} $INTEL_MACRO_RG_LIST(DEFAULT)] $layer]
#@           if {$default_index != -1} {
#@             set x_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 1]]
#@             set y_bloat [lindex $INTEL_MACRO_RG_LIST(DEFAULT) [expr $default_index + 2]]
#@           }
#@         }
#@       }
#@ 
#@       #No route guides will be created for current layer, if bloat values were neither provided in default or override list
#@       #----------------------------------------------------------------------------------------------------------------------
#@ 
#@       if {![info exists INTEL_MACRO_RG_LIST(DEFAULT)] || $default_index == -1} {
#@         puts "==>ERROR: Neither \$INTEL_MACRO_RG_LIST($macro_ref_name) nor \$INTEL_MACRO_RG_LIST(DEFAULT) have been defined for layer $layer. Route Guides will not be created..."
#@         return
#@       }
#@ 
#@       #Check to ensure that both bloats should either be NA or should be a double value.
#@       #----------------------------------------------------------------------------
#@       if {!(($x_bloat eq "NA") && ($y_bloat eq "NA")) && !([string is double $x_bloat] && [string is double $y_bloat])} {
#@         puts "==>ERROR: Bloat values specified incorrectly for $macro_ref_name. Either x_bloat and y_bloat should both be NA (or) a double value. Route Guides will not be created..."
#@         return
#@       }
#@ 
#@ 
#@       #Route Guides will not be created if both x and y bloats equal NA
#@       #-------------------------------------------------------------------
#@       if {($x_bloat eq "NA") && ($y_bloat eq "NA")} {
#@         return
#@       }
#@ 
#@ 
#@       #Route Guides will be created around macros on layers m0-m4 + layers containing macro pins.
#@       #-------------------------------------------------------------------------------------------
#@ 
#@       set macro_name [get_attribute $macro full_name]
#@       set macro_bound [get_attribute $macro boundary]
#@       set rect_box [convert_from_polygon -format rectangle $macro_bound]
#@       set i 0
#@       foreach rect $rect_box {
#@         scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@         set macrobbox_bloat "[expr $b_llx - $x_bloat] [expr $b_lly - $y_bloat] [expr $b_urx + $x_bloat] [expr $b_ury + $y_bloat]"
#@ 
#@         set pin_names [get_pins -all -quiet -filter "layer=~*$layer*" -of_objects $macro ]
#@         if {[sizeof_collection $pin_names] > 0 || [regexp {m[0-5]$} $layer]} {
#@           create_route_guide -no_preroute_layers $layer               -name macroblkg_${macro_name}_${layer}_${i}               -coordinate $macrobbox_bloat
#@           incr i
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ #########################################################################################################
#@ # Procedure   : P_strap_cmd
#@ # Common procedure to create power straps
#@ # step_at: the offset from which the start the first strap
#@ # step: pitch
#@ # pullback: distance to pull the end of strap away from bondary to isolate from neighbor partition
#@ 
#@ proc P_strap_cmd {layer direction net width start_at step pullback} {
#@   global bound_llx bound_lly bound_urx bound_ury
#@   set cmd "create_power_straps -layer $layer -nets $net -width $width                                  -start_at $start_at -step $step                                  -configure step_and_stop                                  -clip_at_top_cell_boundaries                                  -advanced_via_rules                                  -keep_floating_wire_pieces"
#@   if {$direction == "horizontal"} {
#@     set high_ends [expr $bound_urx - $pullback]
#@     set low_ends [expr $bound_llx + $pullback]
#@     set cmd "$cmd -direction horizontal                       -start_high_ends coordinate -start_high_ends_coordinate [expr $bound_urx - $pullback]                       -start_low_ends coordinate -start_low_ends_coordinate [expr $bound_llx + $pullback]                       -stop $bound_ury"
#@   } else {
#@     set high_ends [expr $bound_ury - $pullback]
#@     set low_ends [expr $bound_lly + $pullback]
#@     set cmd "$cmd -direction vertical                       -start_high_ends coordinate -start_high_ends_coordinate $high_ends                       -start_low_ends coordinate -start_low_ends_coordinate $low_ends                       -stop $bound_urx"
#@   }
#@   if {$pullback == 0} {
#@     set cmd "$cmd -extend_low_ends to_boundary_and_generate_pins                       -extend_high_ends to_boundary_and_generate_pins"
#@   }
#@   set cmd [regsub -all {\s+} $cmd " "]; #clean up extra spaces
#@   puts "==>INFORMATION: Running \"$cmd\""
#@   eval $cmd
#@ }
#@ 
#@ #########################################################################################################
#@ # Procedure   : P_check_partition_dimension
#@ # Check if the partition dimension is modular-grid multiple
#@ 
#@ proc P_check_partition_dimension {} {
#@ 
#@   global INTEL_DESIGN_WIDTH INTEL_DESIGN_HEIGHT INTEL_FP_BOUNDARY
#@   global INTEL_FP_INPUT
#@   global INTEL_MD_GRID_X INTEL_MD_GRID_Y
#@ 
#@   if {[info exists INTEL_DESIGN_WIDTH] && $INTEL_DESIGN_WIDTH != "" && [info exists INTEL_DESIGN_HEIGHT] && $INTEL_DESIGN_HEIGHT != ""} {
#@     P_msg_info "Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
#@     if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X) - round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X))]] != 0.0 } {
#@       P_msg_error "Block width is NOT n * $INTEL_MD_GRID_X, please adjust the design width setting INTEL_DESIGN_WIDTH."
#@       P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_X is [expr round($INTEL_DESIGN_WIDTH / $INTEL_MD_GRID_X)]"
#@     }
#@     if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y) - round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@       P_msg_error "Block height is NOT n * $INTEL_MD_GRID_Y, please adjust the design height setting INTEL_DESIGN_HEIGHT."
#@       P_msg_error "The nearest integer multiple of $INTEL_MD_GRID_Y is [expr round($INTEL_DESIGN_HEIGHT / $INTEL_MD_GRID_Y)]"
#@     }
#@     P_msg_info "Done: Checking if INTEL_DESIGN_WIDTH and INTEL_DESIGN_HEIGHT are integer multiples of the modular grid."
#@   } elseif {[info exists INTEL_FP_BOUNDARY] && $INTEL_FP_BOUNDARY != ""} {
#@     P_msg_info "Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
#@     redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $INTEL_FP_BOUNDARY $INTEL_FP_BOUNDARY]}}
#@     if { ! [info exists _bndry] } {
#@       P_msg_error "INTEL_FP_BOUNDARY is not valid.  May require additional set of {} braces"
#@     } elseif { $_bndry == 0 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified is not a valid polygon"
#@     } elseif { [llength $_bndry] == 0 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified has no defined area"
#@     } elseif { [llength $_bndry] != 1 } {
#@       P_msg_error "INTEL_FP_BOUNDARY specified is not a single polygon shape"
#@     } else {
#@       set _bndry [lindex $_bndry 0]
#@     }
#@     foreach xy $INTEL_FP_BOUNDARY {
#@       set x [lindex $xy 0]
#@       set y [lindex $xy 1]
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
#@         P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
#@       }
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
#@         P_msg_error "Please adjust the boundary INTEL_FP_BOUNDARY."
#@       }
#@     }
#@     P_msg_info "Done: Checking if coordinates of INTEL_FP_BOUNDARY are integer multiples of the modular grid."
#@   } elseif { ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "DEF") || ([info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT == "FP_TCL") } {
#@     set fp_boundary [get_attribute [get_die_area] boundary]
#@     P_msg_info "Checking if coordinates of the die area are integer multiples of the modular grid."
#@     redirect -file /dev/null {catch {set _bndry [compute_polygons -boolean or $fp_boundary $fp_boundary]}}
#@     if { ! [info exists _bndry] } {
#@       P_msg_error "The die area is not valid.  May require additional set of {} braces"
#@     } elseif { $_bndry == 0 } {
#@       P_msg_error "The die area specified is not a valid polygon"
#@     } elseif { [llength $_bndry] == 0 } {
#@       P_msg_error "The die area specified has no defined area"
#@     } elseif { [llength $_bndry] != 1 } {
#@       P_msg_error "The die area specified is not a single polygon shape"
#@     } else {
#@       set _bndry [lindex $_bndry 0]
#@     }
#@     foreach xy $fp_boundary {
#@       set x [lindex $xy 0]
#@       set y [lindex $xy 1]
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_X * (($x / $INTEL_MD_GRID_X) - round($x / $INTEL_MD_GRID_X))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $x of ($x, $y) is NOT n * $INTEL_MD_GRID_X."
#@         P_msg_error "Please adjust the die area."
#@       }
#@       if { [format "%.4f" [expr $INTEL_MD_GRID_Y * (($y / $INTEL_MD_GRID_Y) - round($y / $INTEL_MD_GRID_Y))]] != 0.0 } {
#@         P_msg_error "Block boundary coordinate $y of ($x, $y) is NOT n * $INTEL_MD_GRID_Y."
#@         P_msg_error "Please adjust the die area."
#@       }
#@     }
#@     P_msg_info "Done: Checking if coordinates of the die area are integer multiples of the modular grid."
#@   } else {
#@     P_msg_error "None of the following is set: INTEL_DESIGN_WIDTH/INTEL_DESIGN_HEIGHT, INTEL_FP_BOUNDARY, INTEL_FP_DEF or INTEL_FP_TCL"
#@   }
#@ }
#@ 
#@ proc P_adv_polygon_size { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon)]) || [info exists inputs(-list)]]
#@ 
#@   # get size argument, see if valid
#@   set size $inputs(size)
#@ 
#@   # allow for separate x,y size
#@   # if only a single value, then x,y default to that value
#@   set xsize [lindex $size 0]
#@   set ysize [lindex $size end]
#@   if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@     error "$func_name: size value \"$size\" is not a float or pair of floats."
#@     unset size xsize ysize
#@   }
#@ 
#@   set no_sizing 0
#@   set single_resize 1
#@   set directional_resize 0
#@   if { $xsize == $ysize } {
#@     set simple_size 1
#@     set size $xsize
#@     if { $xsize == 0 } {
#@       set no_sizing 1
#@     } else {
#@       redirect -variable resize_help {resize_polygon -help}
#@       set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     }
#@   } else {
#@     set simple_size 0
#@     redirect -variable resize_help {resize_polygon -help}
#@     set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     set directional_resize [regexp -- {-size_left} $resize_help]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     error "'${func_name}': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # suppress message MWUI-087 when downsizing removes a polygon
#@   set no_MWUI_087_suppress 0
#@   if { (! $single_resize) && (($xsize < 0) || ($ysize < 0)) } {
#@     redirect -variable suppress_chk_str {print_suppressed_messages}
#@     if { [lsearch -exact [split [regsub -all {[\{\},\s]+} $suppress_chk_str { }]] {MWUI-087}] == -1 } {
#@       set no_MWUI_087_suppress 1
#@       suppress_message {MWUI-087}
#@     }
#@   }
#@ 
#@   # go through sizing scenarios
#@   if { $no_sizing || ([llength $polygon] < 1) } {
#@     # no sizing or no polygon - nothing to do
#@     set final $polygon
#@   } elseif { $simple_size && $single_resize } {
#@     # use simple sizing function
#@     set final {}
#@     foreach shape $polygon {
#@       foreach sized_poly [resize_polygon -size $size $shape] {
#@         # ensure a valid polygon was returned
#@         # - some Synopsys versions return '0' rather than {} if empty
#@         if { [llength $sized_poly] > 3 } {
#@           lappend final $sized_poly
#@         }
#@       }
#@     }
#@   } elseif { $simple_size } {
#@     set final [resize_polygon -size $size $polygon]
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } elseif { $directional_resize } {
#@     if { (($xsize < 0) && ($ysize < 0)) || (($xsize > 0) && ($ysize > 0)) } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize -size_top $ysize -size_bottom $ysize $polygon]
#@     } elseif { $ysize < 0 } {
#@       set pre_final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $xsize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_left $xsize -size_right $xsize $pre_final]
#@       }
#@     } elseif { $xsize < 0 } {
#@       set pre_final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $ysize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_top $ysize -size_bottom $ysize $pre_final]
#@       }
#@     } elseif { $ysize == 0 } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@     } elseif { $xsize == 0 } {
#@       set final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@     } else {
#@       set final $polygon
#@     }
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } else {
#@     # first perform any necessary shrink
#@     if { ($xsize < 0) || ($ysize < 0) } {
#@       # to avoid issues with breaking apart during shrink,
#@       # the shrink is done as an inverse image using a grow
#@       #   expand_bound = (expand BOUND(polygon) by size)
#@       #   shrink_poly = expand_bound NOT
#@       #         (expand (poly_to_rects(expand_bound NOT polygon)) by shrink)
#@       set shrunk_poly {}
#@ 
#@       # expand by 0.1 more than smallest negative value
#@       set ovrsize [expr ($xsize < $ysize) ? (0.1 - $xsize) : (0.1 - $ysize)]
#@       set rect_shrink_factor_x [expr ($xsize<0) ?  abs($xsize) : 0]
#@       set rect_shrink_factor_y [expr ($ysize<0) ?  abs($ysize) : 0]
#@ 
#@       foreach shape $polygon {
#@         # get x extents using a list sort
#@         set x_sort [lsort -index 0 -increasing -real $shape]
#@         set xll [expr [lindex [lindex $x_sort 0] 0] - $ovrsize]
#@         set xur [expr [lindex [lindex $x_sort end] 0] + $ovrsize]
#@ 
#@         # get y extents using a list sort
#@         set y_sort [lsort -index 1 -increasing -real $shape]
#@         set yll [expr [lindex [lindex $y_sort 0] 1] - $ovrsize]
#@         set yur [expr [lindex [lindex $y_sort end] 1] + $ovrsize]
#@ 
#@         set expand_bound [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         set inv_polygon [compute_polygons -boolean not $expand_bound $shape]
#@ 
#@         # create inverse sized polygon
#@         set inv_sized_polygon {}
#@         foreach inv_shape $inv_polygon {
#@           foreach rect [convert_from_polygon -format polygon $inv_shape] {
#@             # get x extents using a list sort
#@             set x_sort [lsort -index 0 -increasing -real $rect]
#@             set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_shrink_factor_x]
#@             set xur [expr [lindex [lindex $x_sort end] 0] + $rect_shrink_factor_x]
#@ 
#@             # get y extents using a list sort
#@             set y_sort [lsort -index 1 -increasing -real $rect]
#@             set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_shrink_factor_y]
#@             set yur [expr [lindex [lindex $y_sort end] 1] + $rect_shrink_factor_y]
#@ 
#@             lappend inv_sized_polygon [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@           }
#@         }
#@ 
#@         # merge inverse sized polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain merge_polygon
#@         redirect /dev/null {
#@           catch {set merge_polygon [compute_polygons -boolean or $inv_sized_polygon [lindex $inv_sized_polygon 0]]}
#@         }
#@         if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set inv_sized_polygon $merge_polygon
#@           unset -nocomplain merge_polygon
#@         } else {
#@           for { set i 0 } { $i < [llength $inv_sized_polygon] } {incr i} {
#@             for { set j [expr $i + 1] } { $j < [llength $inv_sized_polygon] } {incr j} {
#@               set new [compute_polygons -boolean or [lindex $inv_sized_polygon $i] [lindex $inv_sized_polygon $j]]
#@               if { [llength $new] > 1 } {
#@                 continue
#@               }
#@               set inv_sized_polygon [lreplace [lreplace $inv_sized_polygon $i $i [lindex $new 0]] $j $j]
#@               incr i -1
#@               break
#@             }
#@           }
#@         }
#@ 
#@         # re-invert the polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain re_inv_polygon
#@         redirect /dev/null {
#@           catch {set re_inv_polygon [compute_polygons -boolean not [list $expand_bound] $inv_sized_polygon]}
#@         }
#@         if { [info exists re_inv_polygon] && (! [string equal $re_inv_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         } else {
#@           set re_inv_polygon [list $expand_bound]
#@           foreach inv_shape $inv_sized_polygon {
#@             set new_shrink {}
#@             foreach re_shape $re_inv_polygon {
#@               foreach poly_not [compute_polygons -boolean not $re_shape $inv_shape] {
#@                 lappend new_shrink $poly_not
#@               }
#@             }
#@             set re_inv_polygon $new_shrink
#@           }
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         }
#@       }
#@     } else {
#@       set shrunk_poly $polygon
#@     }
#@ 
#@     # then perform any necessary grow
#@     set final {}
#@     if { ($xsize > 0) || ($ysize > 0) } {
#@       # the grow is a directional grow on the rectangles of the polygon
#@       set rect_grow_factor_x [expr ($xsize>0) ?  $xsize : 0]
#@       set rect_grow_factor_y [expr ($ysize>0) ?  $ysize : 0]
#@ 
#@       foreach shape $shrunk_poly {
#@         foreach rect [convert_from_polygon -format polygon $shape] {
#@           # get x extents using a list sort
#@           set x_sort [lsort -index 0 -increasing -real $rect]
#@           set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_grow_factor_x]
#@           set xur [expr [lindex [lindex $x_sort end] 0] + $rect_grow_factor_x]
#@ 
#@           # get y extents using a list sort
#@           set y_sort [lsort -index 1 -increasing -real $rect]
#@           set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_grow_factor_y]
#@           set yur [expr [lindex [lindex $y_sort end] 1] + $rect_grow_factor_y]
#@ 
#@           lappend final [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         }
#@       }
#@     } else {
#@       set final $shrunk_poly
#@     }
#@   }
#@ 
#@   if { $no_MWUI_087_suppress } {
#@     set no_MWUI_087_suppress 0
#@     unsuppress_message {MWUI-087}
#@   }
#@ 
#@   # merge final polygons
#@   if { (! $no_sizing) && $single_resize } {
#@     # first see if compute_polygons works for lists of polygons
#@     unset -nocomplain merge_polygon
#@     redirect /dev/null {
#@       catch {set merge_polygon [compute_polygons -boolean or $final [lindex $final 0]]}
#@     }
#@     if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@       # compute_polygons took the list of polygons
#@       set final $merge_polygon
#@       unset -nocomplain merge_polygon
#@     } else {
#@       # compute_polygons didn't take the list of polygons
#@       for { set i 0 } { $i < [llength $final] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $final] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $final $i] [lindex $final $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set final [lreplace [lreplace $final $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # return result or assign to polygon_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon) $final
#@     return {}
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_adv_polygon_size     -info "grow/shrink polygon"     -define_args {
#@       {polygon "polygon" polygon string required}
#@       {"size" "size {+grow / -shrink} float or list {x y} of float" "" string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ 
#@ 
#@ 
#@ proc P_adv_polygon_check { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set poly_args {}
#@   set poly_cnt 1
#@ 
#@   if { [string equal $option "identical"] } {
#@     if { [info exists inputs(other_polygon)] } {
#@       incr poly_cnt
#@     }
#@   } elseif { [string equal $option "polygon"] } {
#@     if { [info exists inputs(other_polygon)] &&  [string equal -nocase "$inputs(other_polygon)" "-list"]} {
#@       set option "return_expression"
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   # store as list for each polygon { name_or_NULL is_simple_polygon
#@   #                                  is_polygon is_rect_array
#@   #                                  is_compressed_set complex_polygon_list }
#@   #    where name_or_NULL = name of defined polygon set if valid, else {}
#@   #          is_simple_polygon    = 1 if a simple polygon, else 0
#@   #          is_polygon           = 1 if a polygon, else 0
#@   #          is_rect_array        = 1 if paired coordinates for rect, else 0
#@   #          is_compressed_set    = 1 if a compressed polygon set, else 0
#@   #          complex_polygon_list = polygon value as a complex polygon list
#@   set polygon_info {}
#@   for { set i 1 } { $i <= $poly_cnt } { incr i } {
#@     if { $i == 1 } {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(polygon)
#@       set item $inputs(polygon)
#@     } else {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(other_polygon)
#@       set item $inputs(other_polygon)
#@     }
#@     # check if the polygon is defined in a polygon set
#@     if { [info exists $source_polygon] } {
#@       set polygon_set [expr $$source_polygon]
#@       lappend polygon_info [list $item 0 1 0 0 $polygon_set]
#@       continue
#@     }
#@ 
#@     # check to see if the cell is either a simple/complex polygon or rectArray
#@     #    or a compressed polygon set
#@ 
#@     # First ensure that coordinates if paired are at consistent level
#@     # - first ensure that a double coordinate value is in the expected levels
#@     # - max levels to first double = 3
#@     # -    complex_polygon = { simple_polygon_1 ... simple_polygon_n }
#@     # -    simple_polygon  = { list_of_coordinates }
#@     # -    coordinate      = { x y }
#@     if { ! [string is double -strict [lindex [lindex [lindex $item 0] 0] 0]] } {
#@       # may be that this is an empty list
#@       if { [llength $item] == 0 } {
#@         lappend polygon_info [list {} 1 1 1 1 {}]
#@       } else {
#@         lappend polygon_info [list {} 0 0 0 0 {}]
#@       }
#@       continue
#@     }
#@ 
#@     # while the length of list is one, strip the nesting level
#@     while { [llength $item] == 1 } {
#@       set item [lindex $item 0]
#@     }
#@ 
#@     # - find up one level from the first double coordinate x or y value
#@     # - ensure that the level is always consistent
#@     set paired 1
#@     if { [string is double -strict [lindex $item 0]] } {
#@       # only a single level - this can only be a rectArray or compressedSet
#@       set is_simple_polygon 0
#@       set is_rectArray 1
#@       set is_compressedSet 1
#@       set is_polygon 0
#@       # all items can only be double floats and must be paired set of coords
#@       # this means the length must be a multiple of 4
#@       if { ([llength $item] % 4) == 0 } {
#@         # run a quick check to see if all numbers are double
#@         if { [catch { lsort -real $item } catch_result] != 0 } {
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         set paired 0
#@       }
#@     } else {
#@       if { [string is double -strict [lindex [lindex $item 0] 0]] } {
#@         # this can only be a list of coordinate pairs
#@         # which can be either a compressedSet, rectArray, or simple polygon
#@         set is_simple_polygon 1
#@         set is_compressedSet 1
#@         set is_polygon 1
#@         # for rectArray, must have an even number of points
#@         set is_rectArray [expr ([llength $item] % 2) == 0]
#@ 
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         if { ([lsearch -glob $item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         } elseif { [llength $item] > 4 } {
#@           # for this one case see if same start+end and common x or y
#@           # in this case then an empty set (must be at least 5 pairs)
#@           foreach {x1 y1} [lindex $item 0] { break }
#@           foreach {x2 y2} [lindex $item end] { break }
#@           if { ($x1 == $x2) && ($y1 == $y2) } {
#@             if { [llength [lsort -real -unique -index 0 $item]] eq 1 } {
#@               # fixed x, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             } elseif { [llength [lsort -real -unique -index 1 $item]] eq 1 } {
#@               # fixed y, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             }
#@           }
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         # with the levels involved this can only be a complex polygon
#@         set is_simple_polygon 0
#@         set is_compressedSet 0
#@         set is_polygon 1
#@         set is_rectArray 0
#@         # check that all coordinates are paired sets of real/double
#@         # discard trivial shapes of <3 coordinates
#@         set polygon {}
#@         foreach shape $item {
#@           if { [llength $shape] < 3 } {
#@             # ignore trivial shapes
#@             continue
#@           }
#@           lappend polygon $shape
#@         }
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of joined item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         set joined_item [join $item]
#@         if { ([lsearch -glob $joined_item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $joined_item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $joined_item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         unset -nocomplain joined_item
#@       }
#@ 
#@     }
#@     if { ! $paired } {
#@       # bad pairing of coordinates found, this is a bad polygon
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@       continue
#@     }
#@ 
#@ 
#@     # step through the actual shapes and check to see if a valid polygon
#@     set rectArray {}
#@     if { $is_rectArray } {
#@       foreach {xl yl xu yu} [join [join [join $polygon]]] {
#@         if { ($xl<$xu) && ($yl<$yu) } {
#@           lappend rectArray [list [list $xl $yl] [list $xl $yu] [list $xu $yu] [list $xu $yl] [list $xl $yl]]
#@         } else {
#@           set is_rectArray 0
#@           break
#@         }
#@       }
#@     }
#@ 
#@     if { $is_compressedSet } {
#@       set compressedSet {}
#@       set partialSet {}
#@       # can only be a length of 1
#@       set joined_polygon [join [join [join $polygon]]]
#@       set shifted_polygon [join [list [lrange $joined_polygon 2 end] 0 0]]
#@       unset -nocomplain x0 y0
#@       foreach {x1 y1} $joined_polygon {x2 y2} $shifted_polygon {
#@         lappend partialSet [list $x1 $y1]
#@         if { [info exists x0] } {
#@           if { ($x0==$x1) && ($y0==$y1) } {
#@             # shape valid if both x & y have more than one value (there is size to the shape)
#@             if { ([llength [lsort -unique -real -index 0 $partialSet]] > 1) && ([llength [lsort -unique -real -index 1 $partialSet]] > 1) } {
#@               lappend compressedSet $partialSet
#@             }
#@             set partialSet {}
#@             unset -nocomplain x0 y0
#@             continue
#@           }
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         } else {
#@           if { ($x1==$x2) && ($y1==$y2) } {
#@             continue
#@           }
#@           if { ($x1==$x2) || ($y1==$y2) } {
#@             set x0 $x1
#@             set y0 $y1
#@           } else {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@       }
#@       if { [info exists x0] } {
#@         # didn't complete the final polygon shape
#@         set is_simple_polygon 0
#@         set is_polygon 0
#@         set is_compressedSet 0
#@       }
#@     } elseif { $is_polygon } {
#@       set new_polygon {}
#@       foreach shape $polygon {
#@         # check that first/last coordinate match
#@         foreach {x0 y0} [join [lindex $shape 0]] { break }
#@         foreach {xend yend} [join [lindex $shape end]] { break }
#@         if { ($x0!= $xend) || ($y0 != $yend) } {
#@           set is_simple_polygon 0
#@           set is_polygon 0
#@           break
#@         }
#@         set joined_shape [join [join $shape]]
#@         set joined_shape1 [lrange $joined_shape 0 end-2]
#@         set joined_shape2 [lrange $joined_shape 2 end]
#@         foreach {x1 y1} $joined_shape1 {x2 y2} $joined_shape2 {
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@         if { ! $is_polygon } {
#@           break
#@         }
#@         # shape is valid if both x & y have more than one value (there is size to the shape)
#@         if { ([llength [lsort -unique -real -index 0 $shape]] > 1) && ([llength [lsort -unique -real -index 1 $shape]] > 1) } {
#@           lappend new_polygon $shape
#@         }
#@       }
#@       set polygon $new_polygon
#@     }
#@ 
#@     if { $is_rectArray } {
#@       lappend polygon_info [list {} 0 0 1 0 $rectArray]
#@     } elseif { $is_polygon && (! $is_compressedSet) } {
#@       lappend polygon_info [list {} $is_simple_polygon 1 0 0 $polygon]
#@     } elseif { $is_compressedSet } {
#@       set is_simple_polygon [expr [llength $compressedSet] < 2]
#@       lappend polygon_info [list {} $is_simple_polygon $is_simple_polygon 0 [expr ! $is_simple_polygon] $compressedSet]
#@     } else {
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@     }
#@   }
#@ 
#@   set is_polygon [expr [lindex [lindex $polygon_info 0] 2] ||                       [lindex [lindex $polygon_info 0] 3] ||                       [lindex [lindex $polygon_info 0] 4] ||                       ([llength [lindex [lindex $polygon_info 0] 0]] > 0)]
#@   switch -exact -- $option {
#@     simple      {
#@       set is_simple           [expr [lindex [lindex $polygon_info 0] 1]  && ([llength [lindex                                                                        [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_simple
#@     }
#@     complex     {
#@       set is_complex           [expr (! [lindex [lindex $polygon_info 0] 1]) && ([llength [lindex                                                                           [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_complex
#@     }
#@     defined_set {
#@       return [expr [llength [lindex [lindex $polygon_info 0] 0]] > 0]
#@     }
#@     rectArray   {
#@       return [expr [lindex [lindex $polygon_info 0] 3] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     compressed  {
#@       return [expr [lindex [lindex $polygon_info 0] 4] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     polygon     {
#@       return $is_polygon
#@     }
#@     default     {
#@       if { ! $is_polygon } {
#@         error "'${func_name} $option': polygon \"$inputs(polygon)\" is not a valid polygon."
#@         return
#@       }
#@       set is_polygon [expr                           [lindex [lindex $polygon_info end] 2] || [lindex [lindex $polygon_info end] 3] ||                           [lindex [lindex $polygon_info end] 4] || ([llength [lindex [lindex $polygon_info end] 0]] > 0)]
#@       if { (! $is_polygon) && [string equal $option "identical"] && ([llength $polygon_info] > 1) } {
#@         error "'${func_name} $option': other_polygon \"$inputs(other_polygon)\" is not a valid polygon."
#@         return
#@       }
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (if so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_help]
#@ 
#@   # simplify polygon structure
#@   set check_empty [string equal $option "empty"]
#@   if { [llength [lindex [lindex $polygon_info 0] 0]] == 0 } {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@ 
#@     # merge polygon
#@     # (see if compute_polygons works for lists of polygons - avail in icc)
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $polygon [lindex $polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set polygon {}
#@       } else {
#@         set polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $polygon $i] [lindex $polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set polygon [lreplace [lreplace $polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@   }
#@ 
#@   if { $check_empty } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $polygon] < 1]
#@   }
#@ 
#@   if { [string equal $option "return_expression"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $polygon
#@   }
#@ 
#@ 
#@   # determine if the polygon is now only a single rectangle
#@   if { [string equal $option "rectangle"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr ([llength $polygon]==1) && ([llength [lindex $polygon 0]]==5)]
#@   }
#@ 
#@   # ONLY CHECK remaining is "identical"
#@ 
#@   # simplify other_polygon structure for performing "identical" check
#@   if { [llength [lindex [lindex $polygon_info end] 0]] == 0 } {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@ 
#@     # merge other_polygon
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $other_polygon [lindex $other_polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set other_polygon {}
#@       } else {
#@         set other_polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $other_polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $other_polygon $i] [lindex $other_polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set other_polygon [lreplace [lreplace $other_polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@   }
#@ 
#@   # simple check is if one empty, then they both must be empty
#@   if { ([llength $polygon] == 0) && ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 1
#@   } elseif { ([llength $polygon] == 0) || ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 0
#@   }
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   if { ! $simple_polygons } {
#@     # compute_polygons takes a list of polygons
#@     unset -nocomplain xor_polygon
#@     redirect /dev/null {
#@       catch {set xor_polygon [compute_polygons -boolean xor $polygon $other_polygon]}
#@     }
#@     if { $xor_polygon == "0" } {
#@       set xor_polygon {}
#@     }
#@ 
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $xor_polygon] == 0]
#@   }
#@ 
#@   # otherwise to be identical,
#@   # each piece of polygon must have a corresponding piece of other_polygon
#@   foreach shape $polygon {
#@     set poly_and {}
#@     set poly_xor $polygon
#@     for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@       set other_shape [lindex $other_polygon $i]
#@       set poly_and [compute_polygons -boolean and $shape $other_shape]
#@       if { [llength $poly_and] != 0 } {
#@         set poly_xor [compute_polygons -boolean xor $shape $other_shape]
#@         break
#@       }
#@     }
#@     if { [llength $poly_xor] != 0 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return 0
#@     }
#@     set other_polygon [lreplace $other_polygon $i $i]
#@   }
#@ 
#@   # polygon is identical if no remaining portions of other_polygon to match
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return [expr [llength $other_polygon] == 0]
#@ 
#@ }
#@ 
#@ define_proc_attributes P_adv_polygon_check     -info "check condition 'option' on polygon"     -define_args {
#@       {option "check option" option one_of_string { required value_help {values { simple complex defined_set rectArray compressed polygon empty rectangle identical }}}}
#@       {polygon "polygon" polygon string required}
#@       {other_polygon "second polygon -> only used for identical check" other_polygon string optional}}
#@ #}}}
#@ 
#@ 
#@ 
#@ proc P_adv_polygon_logic { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set operation $inputs(operation)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set copy_set   [string equal $operation "copy"]
#@   set or_set     [string equal $operation "or"]
#@   set and_set    [string equal $operation "and"]
#@   set not_set    [string equal $operation "not"]
#@   set xor_set    [string equal $operation "xor"]
#@   set select_set [string equal $operation "select"]
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon_a)])]
#@   if { $copy_set && $return_expression } {
#@     error "'$func_name copy': polygon \"$inputs(polygon_a)\" is not a defined_set."
#@   } else {
#@     set return_expression [expr $return_expression || [info exists inputs(-list)]]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_a) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_a)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_a)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_a)"
#@     }
#@     error "'${func_name} $operation': polygon_a \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon_b) -list} other_polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_b)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_b)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_b)"
#@     }
#@     error "'${func_name} $operation': polygon_b \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # return if copy
#@   if { $copy_set } {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $other_polygon
#@     return {}
#@   }
#@ 
#@   # do simple cases where either polygon is empty
#@   unset -nocomplain final_polygon
#@   if { [llength $polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon {}
#@     } elseif { $xor_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   } elseif { [llength $other_polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon $polygon
#@     } elseif { $xor_set } {
#@       set final_polygon $polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   }
#@   if { [info exists final_polygon] } {
#@     if { $return_expression } {
#@       return $final_polygon
#@     } else {
#@       set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@       return {}
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_polygons_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_polygons_help]
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   # can do all operations except select which requires 2 steps
#@   unset -nocomplain final_polygon
#@   if { $select_set } { set op "and" } else { set op $operation }
#@   unset -nocomplain or_polygon
#@ 
#@   if { ! $simple_polygons } {
#@     redirect /dev/null {
#@       catch {set final_polygon [compute_polygons -boolean $op $polygon $other_polygon]}
#@     }
#@     if { (! [info exists final_polygon]) || [string equal $final_polygon "0"] } {
#@       # compute_polygons didn't take the list of polygons
#@       set final_polygon {}
#@     } elseif { $select_set } {
#@       if { [llength $final_polygon] < [llength $other_polygon] } {
#@         set other_polygon $final_polygon
#@       }
#@       unset -nocomplain final_polygon
#@     }
#@   }
#@ 
#@   # perform OR operation if needed ("or" & "xor")
#@   set or_polygon {}
#@   if { [info exists final_polygon] } {
#@     set or_polygon $final_polygon
#@   } elseif { $or_set || $xor_set } {
#@     set or_polygon [concat $polygon $other_polygon]
#@     # merge or_polygon
#@     for { set i 0 } { $i < [llength $or_polygon] } {incr i} {
#@       for { set j [expr $i + 1] } { $j < [llength $or_polygon] } {incr j} {
#@         set new [compute_polygons -boolean or [lindex $or_polygon $i] [lindex $or_polygon $j]]
#@         if { [llength $new] > 1 } {
#@           continue
#@         }
#@         set or_polygon [lreplace [lreplace $or_polygon $i $i [lindex $new 0]] $j $j]
#@         incr i -1
#@         break
#@       }
#@     }
#@   }
#@ 
#@   # perform AND operation if needed ("and" "not" "xor" "select")
#@   set and_polygon {}
#@   set select_polygon {}
#@   if { [info exists final_polygon] } {
#@     set and_polygon $final_polygon
#@   } elseif { $select_set && (! $simple_polygons) } {
#@     if { [llength $other_polygon] != 0 } {
#@       # evaluating select in subsets of from 20-50 tend to give best runtimes
#@       set incr_value 30
#@       for { set i 0 } { $i < [llength $polygon] } { incr i $incr_value } {
#@         set sub_range [lrange $polygon $i [expr $i + $incr_value]]
#@         set sub_range_and [compute_polygons -boolean and $sub_range $other_polygon]
#@         if { ($sub_range_and == "0") || ([llength $sub_range_and] == 0) } {
#@           # no intersection, skip this subset of polygons
#@           continue
#@         } elseif { [llength $sub_range] == 1 } {
#@           lappend select_polygon [lindex $sub_range 0]
#@           continue
#@         } elseif { [llength $sub_range_and] > [llength $other_polygon] } {
#@           # try to minimize the number of shapes being worked with
#@           set sub_range_and $other_polygon
#@         }
#@         foreach shape $sub_range {
#@           set shape_and [compute_polygons -boolean and $shape $sub_range_and]
#@           if { ($shape_and != "0") && ([llength $shape_and] != 0) } {
#@             lappend select_polygon $shape
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $and_set || $not_set || $xor_set || $select_set } {
#@     foreach shape $polygon {
#@       set poly_and {}
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         set other_shape [lindex $other_polygon $i]
#@         set poly_and [compute_polygons -boolean and $shape $other_shape]
#@         if { [llength $poly_and] != 0 } {
#@           if { $select_set } {
#@             lappend select_polygon $shape
#@             break
#@           } else {
#@             foreach and_item $poly_and {
#@               lappend and_polygon $and_item
#@             }
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $or_set } {
#@     set and_polygon $or_polygon
#@   }
#@ 
#@   # perform NOT operation if needed ("not" "xor")
#@   if { (! [info exists final_polygon]) && ($not_set || $xor_set) } {
#@     if { $not_set } {
#@       set final_polygon $polygon
#@       set not_polygon   $other_polygon
#@     } else {
#@       set final_polygon $or_polygon
#@       set not_polygon   $and_polygon
#@     }
#@     foreach other_shape $not_polygon {
#@       set new_final_polygon {}
#@       foreach shape $final_polygon {
#@         foreach not_poly [compute_polygons -boolean not $shape $other_shape] {
#@           lappend new_final_polygon $not_poly
#@         }
#@       }
#@       set final_polygon $new_final_polygon
#@     }
#@   } elseif { $or_set } {
#@     set final_polygon $or_polygon
#@   } elseif { $select_set } {
#@     set final_polygon $select_polygon
#@   } elseif { $and_set } {
#@     set final_polygon $and_polygon
#@   } elseif { ! [info exists final_polygon] } {
#@     set final_polygon {}
#@   }
#@ 
#@   # return polygon or set value in defined_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final_polygon
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@     return {}
#@   }
#@ 
#@ }
#@ 
#@ 
#@ define_proc_attributes P_adv_polygon_logic     -info "perform logic 'operation' between polygons"     -define_args {
#@       {operation "logic operation" operation one_of_string { required value_help {values { copy or and not xor select }}}}
#@       {polygon_a "polygon_a" polygon_a string required}
#@       {polygon_b "polygon_b" polygon_b string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ # Proc: P_create_diffcheck_grid
#@ # Description: Draws diffcheck grid over design that will show up as DRC violations
#@ # if the diffusion layer is misaligned in any areas. The diffcheck is removed over macros/DICs
#@ proc P_create_diffcheck_grid {layer start width step stop {hard_macro_refs ""}} {
#@ 
#@   set _bndry [get_attribute -quiet [get_die_area] boundary]
#@   set layer $layer
#@   remove_user_shape  [get_user_shapes -quiet -filter layer_name==$layer]
#@ 
#@   set rect_box [convert_from_polygon  -format rectangle $_bndry]
#@   foreach rect $rect_box {
#@     scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@     set y [expr $start + $b_lly]
#@     while { $y < [expr $b_ury - $stop]} {
#@       create_user_shape -layer $layer  -datatype 24 -bbox [list $b_llx $y $b_urx [expr $y + $width]]
#@       set y [expr $y + $step + $width]
#@     }
#@   }
#@ 
#@   # Remove user shapes over HIP/DIC
#@   set hard_macro_cells ""
#@   if {$hard_macro_refs == "" } {
#@     set hard_macro_cells  [all_macro_cells]
#@   } else {
#@     foreach cell $hard_macro_refs {
#@       set hard_macro_cells [add_to_collection $hard_macro_cells [get_cells -quiet -hierarchical -all -filter ref_name==$cell]]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $hard_macro_cells]>0} {
#@     cut_objects  -by $hard_macro_cells [get_user_shapes -quiet -filter layer_name==$layer]
#@   }
#@ 
#@ }
#@ define_proc_attributes P_create_diffcheck_grid     -info "Creates diffcheck grid over design"     -define_args {                        {layer "diffcheck grid layer name" layer string required}                        {start "Offset to start grid relative to boundary" start string required}                        {width "Path to overlay cell gds file" width string required}                        {step "Pitch between shapes" step string required}                        {stop "Offset to stop grid relative to boundary" stop string required}                        {hard_macro_refs "Macro reference names. If blank, then grid removed over all_macro_cells" hard_macro_refs list required}                      }
#@ 
#@ # Proc: P_create_polycheck_grid
#@ # Description: Draws polycheck grid over design that will show up as DRC violations
#@ # if the poly layer is misaligned in any areas. The polycheck is removed over macros/DICs
#@ 
#@ proc P_create_polycheck_grid { layer start width step stop {hard_macro_refs ""}} {
#@ 
#@   set _bndry [get_attribute -quiet [get_die_area] boundary]
#@   set layer $layer
#@   remove_user_shape  [get_user_shapes -quiet -filter layer_name==$layer]
#@ 
#@   set rect_box [convert_from_polygon  -format rectangle $_bndry]
#@   foreach rect $rect_box {
#@     scan $rect "{%f %f} {%f %f}" b_llx b_lly b_urx b_ury
#@     set x [expr $start + $b_llx]
#@     while { $x < [expr $b_urx - $stop]} {
#@       create_user_shape -layer $layer -bbox [list $x $b_lly [expr $x + $width] $b_ury]
#@       set x [expr $x + $step + $width]
#@     }
#@   }
#@ 
#@   # Remove user shapes over HIP/DIC
#@   set hard_macro_cells ""
#@   if {$hard_macro_refs == "" } {
#@     set hard_macro_cells  [all_macro_cells]
#@   } else {
#@     foreach cell $hard_macro_refs {
#@       set hard_macro_cells [add_to_collection $hard_macro_cells [get_cells -quiet -hierarchical -all -filter ref_name==$cell]]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $hard_macro_cells]>0} {
#@     cut_objects -by $hard_macro_cells [get_user_shapes -quiet -filter layer_name==$layer]
#@   }
#@ 
#@ }
#@ define_proc_attributes P_create_polycheck_grid     -info "Creates polycheck grid over design"     -define_args {                        {layer "Polycheck layer name" layer string required}                        {start "Offset to start grid relative to boundary" start string required}                        {width "Path to overlay cell gds file" width string required}                        {step "Pitch between shapes" step string required}                        {stop "Offset to stop grid relative to boundary" stop string required}                        {hard_macro_refs "Macro reference names. If blank, then grid removed over all_macro_cells" hard_macro_refs list required}                      }
#@ 
#@ proc P_placement_blockage_move_or_unmove { {mode report_usage} } {
#@   ###  move placement blockage out of bounds Or back  ###
#@   if {$mode=="report_usage"} {
#@     puts "  usage1 ->  set blockage_bbox_pairs \[P_placement_blockage_move_or_unmove move\]; ## to move blockage out of bounds ##";
#@     puts "  usage2 ->  P_placement_blockage_move_or_unmove \$blockage_bbox_pairs;           ## to restore blockage ##";
#@     return;
#@   }
#@   ###  mode=move - moves blockage and returns blockage_bbox_pairs variable | mode=$blockage_bbox_pairs - restores blockage  ###
#@   set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
#@   if {"$mode"=="move"} {
#@     set boundary [get_attribute -quiet [get_core_area] boundary]
#@     set boundary_llx [lindex [lindex [lsort -index 0 -real -increasing $boundary] 0] 0]
#@     set boundary_lly [lindex [lindex [lsort -index 1 -real -increasing $boundary] 0] 1]
#@     set hard_pb_llx [expr $boundary_llx - .01]; set hard_pb_lly [expr $boundary_lly - .01]
#@     set hard_placement_box [list [list $hard_pb_llx  $hard_pb_lly]  [list $boundary_llx $boundary_lly]]
#@     set blockage_bbox_pairs {}
#@     foreach_in_collection blkg_obj [remove_from_collection [get_placement_blockages -quiet] [get_placement_blockages -quiet halo_adjacent_placement_blk_*]] {
#@       lappend blockage_bbox_pairs  [list $blkg_obj [get_attribute -quiet $blkg_obj bbox]]
#@       set_attribute -quiet $blkg_obj bbox $hard_placement_box
#@     }
#@     return $blockage_bbox_pairs;
#@   } else {
#@     foreach blkg_pair $mode {
#@       foreach {blkg_obj blkg_bbox} $blkg_pair { break }
#@       set_attribute -quiet $blkg_obj bbox $blkg_bbox
#@     }
#@   }
#@   set_object_snap_type -enabled $oldSnapState; set flag 1;
#@ }
#@ 
#@ ##########################################################################
#@ # Procedure   : P_insert_pre_place_cells_blockage
#@ #
#@ # Description : To insert the placement blockage at the intended pre-place cells
#@ #               locations if option -as_blockage useage.
#@ #               Otherwise, To insert the placement blockage everywhere except
#@ #               pre-place cells locations
#@ #
#@ # Inputs      :
#@ #
#@ # Returns     :
#@ #
#@ # Note        :
#@ #
#@ ##########################################################################
#@ proc P_insert_pre_place_cells_blockage {args} {
#@ 
#@   global INTEL_STDCELL_BONUS_GATEARRAY_TILE INTEL_STDCELL_TILE INTEL_TAP_CELL
#@   parse_proc_arguments -args $args flag
#@   set x_start $flag(-x_start)
#@   set y_start $flag(-y_start)
#@   set x_increment $flag(-x_increment)
#@   set y_increment $flag(-y_increment)
#@   set width_prplace_cell $flag(-w_preplace_cell)
#@   set height_prplace_cell $flag(-h_preplace_cell)
#@ 
#@   if { [info exists flag(-x_trim)] } {
#@     set x_trim $flag(-x_trim)
#@   } else {
#@     set x_trim 0
#@   }
#@   if { [info exists flag(-y_trim)] } {
#@     set y_trim $flag(-y_trim)
#@   } else {
#@     set y_trim 0
#@   }
#@   if { [info exists flag(-as_blockage)] } {
#@     set as_blockage 1
#@   } else {
#@     set as_blockage 0
#@   }
#@   if { [info exists flag(-ignore_hard_blockage)] } {
#@     set ignore_hard_blockage 1
#@   } else {
#@     set ignore_hard_blockage 0
#@   }
#@   if { [info exists flag(-no_flip)] } {
#@     set no_flip 1
#@   } else {
#@     set no_flip 0
#@   }
#@ 
#@   if { [info exists flag(-stagger)] } {
#@     set stagger 1
#@   } else {
#@     set stagger 0
#@   }
#@ 
#@   ### Derive tile widths
#@   set sample_site [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_TILE"]] 0]
#@   set stdcell_tile_height [expr [get_attribute [get_site_row $sample_site] bbox_ury] - [get_attribute [get_site_row $sample_site] bbox_lly]]
#@   set stdcell_tile_width [get_attribute [get_site_rows $sample_site] site_space]
#@   if { [info exists INTEL_STDCELL_BONUS_GATEARRAY_TILE] } {
#@     set stdcell_bonus_tile_width [get_attribute [get_site_rows [lindex [get_object_name [get_site_rows -filter "site_type==$INTEL_STDCELL_BONUS_GATEARRAY_TILE"]] 0]] site_space]
#@   }
#@ 
#@   if { [info exists flag(-tile)] } {
#@     if { [regexp "bonuscore" $flag(-tile) ] } {
#@       set tile_width $stdcell_bonus_tile_width
#@     } else {
#@       set tile_width $stdcell_tile_width
#@     }
#@   } else {
#@     set tile_width $stdcell_tile_width
#@   }
#@ 
#@   if { [info exists flag(-ignore_tap_cell)] } {
#@     set ignore_tap_cell 1
#@   } else {
#@     set ignore_tap_cell 0
#@   }
#@ 
#@   ###Find the first ROW rotation
#@   scan [get_attribute [get_core_areas] bbox] "{%f %f} {%f %f}" core_llx core_lly core_urx core_ury
#@   set my_site_rows [get_site_rows -quiet -filter "bbox_lly == $core_lly && bbox_ury == [expr $core_lly + $stdcell_tile_height]       && site_type ==  $INTEL_STDCELL_TILE"]
#@   if {$my_site_rows ne ""} {
#@     set first_cell_orientation [lindex [get_attribute [get_site_rows [lindex $my_site_rows 0]] orientation] 0]
#@   } else {
#@     set first_cell_orientation "N"
#@   }
#@ 
#@   set step_y [expr (floor ( [expr $y_increment / ( 2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@   set half_step_y  [expr $step_y / 2.0]
#@   if { $no_flip == 1 } {
#@     # Need to find the VSS row
#@     if { $first_cell_orientation == "N"} {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@     }  else {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
#@     }
#@   } else {
#@     if { $first_cell_orientation == "N"} {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) - $stdcell_tile_height]
#@     }  else {
#@       set ystart [expr (floor ( [expr ($y_start + $core_lly) / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height)]
#@     }
#@   }
#@ 
#@   set step_x [expr (floor ( [expr $x_increment / $tile_width] )) *  $tile_width]
#@   set half_step_x  [expr $step_x / 2.0]
#@   set xstart [expr (floor ( [expr ($x_start) / $tile_width] )) *  $tile_width + $core_llx]
#@ 
#@   remove_placement_blockage _tmp_pre_place_placement_blk_*
#@   set_object_snap_type -enabled 0
#@ 
#@   unset -nocomplain boundary
#@   set boundary [get_attribute -quiet [get_die_area] boundary]
#@   # to cover paranoid case of extra braces, remove a set if only 1 point
#@   if { [llength $boundary] == 1 } { set boundary [lindex $boundary 0] }
#@ 
#@   unset -nocomplain all_locations_newpolygon
#@   unset -nocomplain all_blk_newpolygon
#@   set all_locations_newpolygon $boundary
#@ 
#@   ### Find the original placement blockage
#@   set original_placement_blks [get_placement_blockages -type hard ]
#@ 
#@   ### Find the Voltage area rings
#@   unset -nocomplain _va_boundary_polys
#@   unset -nocomplain _tmp_use_polys _tmp_use_polys2
#@   set _va_boundary_polys ""
#@   foreach_in_collection _va [get_voltage_areas] {
#@     set _tmp_use_polys [get_attribute [get_voltage_areas $_va] points]
#@     set _va_boundary_polys [P_adv_polygon_logic or $_va_boundary_polys                                 [P_adv_polygon_logic not $_tmp_use_polys [P_adv_polygon_size $_tmp_use_polys "-$stdcell_tile_height -$stdcell_tile_height"]]]
#@   }
#@   set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_va_boundary_polys]
#@ 
#@   ### Find all is_fixed cells
#@   set _tmp_use_polys {}
#@   if { $ignore_tap_cell ==1 } {
#@     foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true && ref_name!=$INTEL_TAP_CELL"]                                  [all_macro_cells]] {
#@                                    lappend _tmp_use_polys [get_attribute $c boundary]
#@                                  }
#@   } else {
#@     foreach_in_collection c [remove_from_collection [get_flat_cells -all -filter "is_fixed==true"]                                  [all_macro_cells]] {
#@                                    lappend _tmp_use_polys [get_attribute $c boundary]
#@                                  }
#@   }
#@   ### To prevent pre_place cells too close to EBB (might cause density violation)
#@   set _tmp_use_polys2 {}
#@   foreach_in_collection c [all_macro_cells] {
#@     foreach poly_shape [P_adv_polygon_size [get_attribute $c boundary] "[expr 3 * $stdcell_tile_width] 0.0"] {
#@       lappend _tmp_use_polys2 $poly_shape
#@     }
#@   }
#@   if { ![P_adv_polygon_check empty $_tmp_use_polys2]} {
#@     set _tmp_use_polys [P_adv_polygon_logic or $_tmp_use_polys $_tmp_use_polys2]
#@   }
#@   set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]
#@ 
#@   ### Find all existing placement blockages
#@   set _tmp_use_polys {}
#@   if { $ignore_hard_blockage != 1 } {
#@     foreach_in_collection blk $original_placement_blks {
#@       if { [llength [convert_to_polygon [get_placement_blockage $blk]]] >= 5 } {
#@         lappend _tmp_use_polys [convert_to_polygon [get_placement_blockage $blk]]
#@       } elseif { [llength [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]] >= 5 } {
#@         lappend _tmp_use_polys [lindex [convert_to_polygon [get_placement_blockage $blk]] 0]
#@       }
#@     }
#@     set all_locations_newpolygon [P_adv_polygon_logic not $all_locations_newpolygon $_tmp_use_polys]
#@   }
#@ 
#@   set switch 0
#@   set i 0
#@   set _tmp_use_polys {}
#@   unset -nocomplain _tmp_area_array
#@   for {set y $ystart } {$y < $core_ury } {set y [expr $y+$step_y]} {
#@     if { $stagger == 1 } {
#@       if { $switch == 1 } {
#@         set newxstart [expr $xstart + $half_step_x]
#@         set switch 0
#@       } else {
#@         set newxstart $xstart
#@         set switch 1
#@       }
#@     } else {
#@       set newxstart $xstart
#@     }
#@ 
#@     set core_urx_2 [expr $core_urx - $x_trim]
#@     for {set x $newxstart } {$x < $core_urx_2 } {set x [expr $x+$step_x]} {
#@       set x2 [expr $x + $half_step_x]
#@       if { $half_step_y < $height_prplace_cell } {
#@         set y2 [expr $y + $height_prplace_cell]
#@       } else {
#@         set y2 [expr $y + $half_step_y]
#@       }
#@       if {$y2 > [expr $core_ury - $y_trim] } { set y2  $core_ury }
#@       lappend _tmp_use_polys "{$x $y} {$x $y2} {$x2 $y2} {$x2 $y} {$x $y}"
#@       set _tmp_area_array($i) "{{$x $y} {$x2 $y2}}"
#@       incr i
#@     }
#@   }
#@   set all_blk_newpolygon [P_adv_polygon_logic and $all_locations_newpolygon $_tmp_use_polys]
#@ 
#@   unset -nocomplain _tmp_use_polys _tmp_use_polys2 my_pgon all_blk_newpolygon_final
#@   set all_blk_newpolygon_final {}
#@   foreach _tmp_use_polys $all_blk_newpolygon  {
#@     unset -nocomplain newbox
#@     scan [P_adv_polygon_get bbox $_tmp_use_polys] "{%f %f} {%f %f}" _llx _lly _urx _ury
#@     for {set y $_lly } {$y < $_ury } {set y [expr $y+$stdcell_tile_height]} {
#@       if { $no_flip == 1 } {
#@         if { $first_cell_orientation == "N"} {
#@           set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
#@         }  else {
#@           set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
#@         }
#@       } else {
#@         if { $first_cell_orientation == "N"} {
#@           set snap_y [expr ( ceil ( [expr $y / (2.0 * $stdcell_tile_height)] )) *  (2.0 * $stdcell_tile_height) + $stdcell_tile_height]
#@         }  else {
#@           set snap_y [expr ( ceil ( $y / (2.0 * $stdcell_tile_height ))) * (2.0 * $stdcell_tile_height)]
#@         }
#@       }
#@       for {set x $_llx } {$x < $_urx } {set x [expr $x+$tile_width]} {
#@         set snap_x [expr ( ceil ( $x / $tile_width)) * $tile_width + $core_llx]
#@         set x2 [expr $snap_x + $width_prplace_cell]
#@         set y2 [expr $snap_y + $height_prplace_cell]
#@         set _tmp_use_polys2 "{$snap_x $snap_y} {$snap_x $y2} {$x2 $y2} {$x2 $snap_y} {$snap_x $snap_y}"
#@         set my_pgon [P_adv_polygon_logic and $_tmp_use_polys $_tmp_use_polys2]
#@         set area_diff [expr [P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)]
#@         if { [expr (abs ([P_adv_polygon_get area $my_pgon] - ( $width_prplace_cell * $height_prplace_cell)))] < 0.001 } {
#@           set all_blk_newpolygon_final [P_adv_polygon_logic or $all_blk_newpolygon_final $my_pgon]
#@           set x $_urx
#@           set y $_ury
#@         }
#@       }
#@     }
#@   }
#@ 
#@   remove_placement_blockage _tmp_pre_place_placement_blk_*
#@   set count 0
#@   if { $as_blockage != 1 } {
#@     set all_blk_newpolygon_final [P_adv_polygon_logic not $boundary $all_blk_newpolygon_final]
#@     foreach my_pgon $all_blk_newpolygon_final {
#@       foreach box [convert_from_polygon -format rectangle $my_pgon] {
#@         create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
#@         incr count
#@       }
#@     }
#@   } else {
#@     foreach my_pgon $all_blk_newpolygon_final {
#@       foreach box [convert_from_polygon -format rectangle $my_pgon] {
#@         create_placement_blockage -type hard -bbox $box -name _tmp_pre_place_placement_blk_${count}
#@         incr count
#@       }
#@     }
#@   }
#@ 
#@   set rm_placement_blk_list ""
#@   foreach i [array names _tmp_area_array] {
#@     if {([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet]] > 1) ||              ([sizeof_collection [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet]]  > 1) } {
#@       set _tmp_placement_blk_list [lsort -unique [get_object_name [add_to_collection                                                                        [get_placement_blockages _tmp_pre_place_placement_blk_* -within $_tmp_area_array($i) -quiet ]                                                                        [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $_tmp_area_array($i) -quiet ]]]]
#@       set _tmp_placement_blk_list_bb [lsort -command P_compare [get_attribute  [get_placement_blockages $_tmp_placement_blk_list -quiet ] bbox]]
#@       foreach box [lrange $_tmp_placement_blk_list_bb 1 [expr [llength $_tmp_placement_blk_list] - 1 ]] {
#@         lappend rm_placement_blk_list [get_object_name [get_placement_blockages _tmp_pre_place_placement_blk_* -touching $box]]
#@       }
#@     }
#@   }
#@   foreach blk $rm_placement_blk_list {
#@     remove_placement_blockage $blk
#@   }
#@ 
#@   set_object_snap_type -enabled 1
#@ }
#@ 
#@ define_proc_attributes P_insert_pre_place_cells_blockage     -info "insert the placement blockages at pre_place cells location or reverse locations"     -define_args {
#@       {-x_start "Left point of region which cell be pre-placed" x_start float required}
#@       {-y_start "Bottom point of region which cell be pre-placed" y_start float required}
#@       {-x_increment "X direction increment distance" x_increment float required}
#@       {-y_increment "Y direction increment distance" y_increment float required}
#@       {-x_trim "X direction distance away from core boundary" x_trim float optional}
#@       {-y_trim "Y direction  distance away from core boundary" y_trim float optional}
#@       {-w_preplace_cell "Width of the pre-placed cell" w_preplace_cell float required}
#@       {-h_preplace_cell "Height of the pre-placed cell" h_preplace_cell float required}
#@       {-as_blockage "Create placement blockage at Pre-place cells locations or reverse locations" "" boolean optional}
#@       {-ignore_hard_blockage "Ignore the existing hard placement blockage" "" boolean optional}
#@       {-no_flip "The rotation of pre-place cells as N" "" boolean optional}
#@       {-stagger "Preplace cells in the stagger pattern" "" boolean optional}
#@       {-tile "The tile name for the pre_place_cells" tile string optional}
#@       {-ignore_tap_cell "Ignore the existing tap cells" "" boolean optional}
#@     }
#@ 
#@ ###############################################################################
#@ # Procedure   : P_compare
#@ # Description :
#@ 
#@ proc P_compare {a b} {
#@   set a0 [lindex [lindex $a 0] 0]
#@   set b0 [lindex [lindex $b 0] 0]
#@   if {$a0 < $b0} {
#@     return -1
#@   } elseif {$a0 > $b0} {
#@     return 1
#@   }
#@   set a1 [lindex [lindex $a 0] 1]
#@   set b1 [lindex [lindex $b 0] 1]
#@   if {$a1 < $b1 } {
#@     return -1
#@   } elseif {$a1  > $b1} {
#@     return 1
#@   }
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : P_adv_polygon_get #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  P_adv_polygon_get
#@ # __description:  get 'option' from polygon
#@ #                 polygon can be polygon_set, simple polygon, complex polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result --- (dependent on option: float or (list of) rectangle
#@ #                       area       = return area of the polygon
#@ #                       bound      = return bounding rectangle of the polygon
#@ #                       rectangles = return list of rectangles of the polygon
#@ # __required_args:  option (one of): area bbox bound rectangles
#@ #                   polygon:         polygon_set, simple or complex polygon
#@ # __optional_args:  -size
#@ #                   if size, then post size the rectangles
#@ #                   (i.e. using 'size' can create overlaps or gaps)
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc P_adv_polygon_get { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # check size argument to see if valid
#@   if { [info exists inputs(-size)] } {
#@     set size $inputs(-size)
#@     # allow for separate x,y size
#@     # if only a single value, then x,y default to that value
#@     set xsize [lindex $size 0]
#@     set ysize [lindex $size end]
#@     if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@       error "$func_name: size value \"$size\" is not a float or pair of floats."
#@       unset size xsize ysize
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {P_adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     error "'${func_name} $option': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # perform area calculation if "area" option, return result
#@   if { [string equal $option "area"] } {
#@     set area 0.0
#@ 
#@     # see if polygon lists are accepted or only simple polygons
#@     redirect -variable get_polygon_area_help {get_polygon_area -help}
#@     set simple_polygons [regexp -- {points list of } $get_polygon_area_help]
#@ 
#@     if { $simple_polygons } {
#@       foreach poly_segment $polygon {
#@         set area [expr $area + [get_polygon_area $poly_segment]]
#@       }
#@     } elseif { [llength $polygon] > 0 } {
#@       set area [expr $area + [get_polygon_area $polygon]]
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $area
#@   }
#@ 
#@   # perform bound check if "bound" option, return resulting rectangle
#@   if { [string equal $option "bbox"] || [string equal $option "bound"] } {
#@     # see if polygon is empty
#@     if { [llength $polygon] < 1 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return {}
#@     }
#@ 
#@     set joined_polygon [join $polygon]
#@ 
#@     # get x extents using a list sort
#@     set x_sort [lsort -index 0 -increasing -real $joined_polygon]
#@     set xll [lindex [lindex $x_sort 0] 0]
#@     set xur [lindex [lindex $x_sort end] 0]
#@ 
#@     # get y extents using a list sort
#@     set y_sort [lsort -index 1 -increasing -real $joined_polygon]
#@     set yll [lindex [lindex $y_sort 0] 1]
#@     set yur [lindex [lindex $y_sort end] 1]
#@ 
#@     # optionally size the box
#@     if { [info exists xsize] && [info exists ysize] } {
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@         return {}
#@       }
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     if { [string equal $option "bbox"] } {
#@       return [list [list $xll $yll] [list $xur $yur]]
#@     } else {
#@       return [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@   }
#@ 
#@   ### only option left is "rectangles"
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable convert_from_polygon_help {convert_from_polygon -help}
#@   set simple_polygons [regexp -- {points list of } $convert_from_polygon_help]
#@ 
#@   # create list of rectangles
#@   if { $simple_polygons } {
#@     set rectangles {}
#@     foreach poly_segment $polygon {
#@       foreach rect [convert_from_polygon -format polygon $poly_segment] {
#@         lappend rectangles $rect
#@       }
#@     }
#@   } else {
#@     if { [llength $polygon] == 0 } {
#@       set rectangles {}
#@     } else {
#@       set rectangles [convert_from_polygon -format polygon $polygon]
#@     }
#@     if { $rectangles == "0" } {
#@       set rectangles {}
#@     }
#@   }
#@ 
#@   # optionally size the box
#@   if { [info exists xsize] && [info exists ysize] } {
#@     set sized_rects {}
#@     foreach rect $rectangles {
#@       set x_sort [lsort -index 0 -increasing -real $rect]
#@       set xll [lindex [lindex $x_sort 0] 0]
#@       set xur [lindex [lindex $x_sort end] 0]
#@       set y_sort [lsort -index 1 -increasing -real $rect]
#@       set yll [lindex [lindex $y_sort 0] 1]
#@       set yur [lindex [lindex $y_sort end] 1]
#@ 
#@       # apply sizing
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         continue
#@       }
#@       lappend  sized_rects [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@     set rectangles $sized_rects
#@   }
#@ 
#@   # return list of rectangles
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return $rectangles
#@ 
#@ }
#@ define_proc_attributes P_adv_polygon_get     -info "get 'option' information from polygon"     -define_args {
#@       {option "get option" option one_of_string { required value_help {values { area bbox bound rectangles }}}}
#@       {polygon "polygon" polygon string required}
#@       {"-size" "size (+grow / -shrink)" "" string optional}}
#@ #}}}
#@ 
#@ 
#@ ##########################
#@ # Place-UPF Procedures
#@ ##########################
#@ 
#@ proc P_parse_pwrgrid_params {args} {
#@   parse_proc_arguments -args $args inputs
#@ 
#@   set attribute $inputs(-attribute)
#@   set layer $inputs(-layer)
#@   set param_list $inputs(-params)
#@ 
#@   set layer_index [lsearch [regexp -inline -all -- {\S+} $param_list] $layer]
#@   set width_val [lindex $param_list [expr $layer_index + 1]]
#@   set pitch_val [lindex $param_list [expr $layer_index + 2]]
#@   set offset_val [lindex $param_list [expr $layer_index + 3]]
#@ 
#@   if {$attribute == "offset"} {
#@     return $offset_val
#@   } elseif {$attribute == "pitch"} {
#@     return $pitch_val
#@   } elseif {$attribute == "width"} {
#@     return $width_val
#@   }
#@ }
#@ 
#@ define_proc_attributes P_parse_pwrgrid_params     -info "Parses powergrid parameters to determine offset and pitch values of various layers"     -define_args {
#@       {"-layer"  "Layer for which offset/pitch value is required" "" string required}
#@       {"-params" "INTEL_ parameter variable that contains layer, pitch and offset values" "" list required}
#@       {"-attribute" "Specify the attribute to be fetched" "" one_of_string {required value_help {values {offset pitch width}}}}
#@     }
#@ 
#@ proc P_ret_aon_net {args} {
#@   parse_proc_arguments -args $args inputs
#@ 
#@   set pwr_domain $inputs(-pwr_domain)
#@   redirect -variable rpt_pd {report_power_domain $pwr_domain}
#@ 
#@   set switch_line [regexp -inline -lineanchor -linestop {^Switch:.*} $rpt_pd]
#@   set switch_aon_vcc [lindex [regexp -inline -all {\S+} $switch_line] 2]
#@ 
#@   set primary_line [regexp -inline -lineanchor -linestop {^Primary:.*} $rpt_pd]
#@   set primary_aon_vcc [lindex [regexp -inline -all {\S+} $primary_line] 1]
#@ 
#@ 
#@   if {$switch_aon_vcc != ""} {
#@     return $switch_aon_vcc
#@   } elseif {$primary_aon_vcc != ""} {
#@     return $primary_aon_vcc
#@   } else {
#@     P_msg_error "P_ret_aon_net: Parsing report_power_domain failed. Aborting..."
#@     return
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_ret_aon_net     -info "Returns the always on power net for the provided power domain"     -define_args {
#@       {"-pwr_domain" "Domain for which the always on power net should be returned" "" string required}
#@     }
#@ 
#@ proc P_check_sec_pg_overlap {args} {
#@   parse_proc_arguments -args $args inputs
#@   set aon_net $inputs(-aon_net)
#@   set origin_x $inputs(-origin_x)
#@   set origin_y $inputs(-origin_y)
#@   set length $inputs(-length)
#@   set layer $inputs(-layer)
#@   set width $inputs(-width)
#@ 
#@   set vcc_base [get_attribute [get_nets $aon_net -all] base_name]
#@   set direction [get_attribute [get_layer $layer] preferred_direction]
#@ 
#@   if {$direction == "horizontal"} {
#@     set shape_bbox "{$origin_x $origin_y} {[expr $origin_x + $length] [expr $origin_y + $width]}"
#@   } else {
#@     set shape_bbox "{$origin_x $origin_y} {[expr $origin_x + $width] [expr $origin_y + $length]}"
#@   }
#@   set overlap [get_net_shapes -intersect $shape_bbox -filter "layer == $layer && owner_net != $vcc_base" -quiet]
#@   if {[sizeof_collection $overlap] == 0} {
#@     set overlap [get_vias -intersect $shape_bbox -filter "layer =~ *$layer* && owner_net != $vcc_base" -quiet]
#@   }
#@   if {[sizeof_collection $overlap] == 0} {
#@     set overlap [get_route_guides -intersect $shape_bbox -filter "no_signal_layers == $layer || no_preroute_layers == $layer" -quiet]
#@   }
#@ 
#@   if {[sizeof_collection $overlap] > 0} {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ define_proc_attributes  P_check_sec_pg_overlap     -info "Checks to see if sec pg staples overlap with one another"     -define_args {
#@       {"-layer"  "Staple layer" "" string required}
#@       {"-aon_net"  "AON net name" "" string required}
#@       {"-origin_x"  "Staple shape llx" "" string required}
#@       {"-origin_y"  "Staple shape lly" "" string required}
#@       {"-length"  "Staple length" "" string required}
#@       {"-width"  "Staple width" "" string required}
#@     }
#@ 
#@ ##############################
#@ # CTS-UPF Procedures
#@ ##############################
#@ 
#@ ##########################################################################################################
#@ # Procedure   : P_query_voltage_pgnet
#@ # Description : This proc is to find out the primary pg net for each voltage area for stdcell PG hookup
#@ 
#@ proc P_query_voltage_pgnet {} {
#@   global INTEL_VA_PWR INTEL_AON_PWR
#@   global INTEL_VA_GND
#@ 
#@   # determine if power domains are used in the design
#@   redirect /dev/null {set domains [get_power_domains -hierarchical ] }
#@   # get list of voltage_areas
#@   set va_list {}
#@   foreach_in_collection va [get_voltage_areas] {
#@     set va_name [get_attribute -quiet $va name]
#@     lappend va_list $va_name
#@   }
#@   unset -nocomplain  INTEL_VA_PWR INTEL_VA_GND INTEL_AON_PWR
#@ 
#@   # determine power & ground nets based on whether domains are present
#@   if { ([info exists domains]) && ([sizeof_collection $domains] > 0) } {
#@     # power domains exist
#@     # determine power & ground supplies for each voltage_area
#@ 
#@     # check power domains for corresponding voltage_area (then pwr/gnd nets)
#@     foreach_in_collection domain $domains {
#@       set domain_name [collection_to_list $domain -no_braces -name_only]
#@       redirect -variable rpt_pd  {report_power_domain $domain}
#@       set va_line [regexp -inline -lineanchor -linestop {^Voltage Area Information:\s+(\S+)} $rpt_pd]
#@ 
#@       if { ! [llength $va_line] } {
#@         continue
#@       } elseif { [string equal "N/A" [lindex $va_line 1]] } {
#@         continue
#@       } else {
#@         set voltage_area [lindex $va_line 1]
#@       }
#@ 
#@       # ensure the voltage_area is defined
#@       if { [lsearch -exact $va_list $voltage_area] < 0 } { continue }
#@ 
#@       # get supply info
#@       set primary_line [regexp -inline -lineanchor -linestop {^Primary:\s+(\S+)(\s+\([^\)]*\))?\s*(\S+)} $rpt_pd]
#@       if { [llength $primary_line] >= 4 } {
#@         set INTEL_VA_PWR($voltage_area) [lindex $primary_line 1]
#@         set INTEL_VA_GND($voltage_area) [lindex $primary_line 3]
#@       }
#@       # get AON supply info (if switched)
#@       set switch_line [join [regexp -inline -lineanchor -linestop {^Switch:.*} $rpt_pd]]
#@       if { [llength $switch_line] >= 4 } {
#@         set INTEL_AON_PWR($voltage_area) [lindex $switch_line 2]
#@       } else {
#@         set INTEL_AON_PWR($voltage_area) $INTEL_VA_PWR($voltage_area)
#@       }
#@     }
#@   }
#@ }
#@ 
#@ #######################
#@ # Route Procedures
#@ #######################
#@ 
#@ proc P_bonus_array_blockage {oddeven mode} {
#@   ###  add bonus array placement blockage - decap or spacer cell  ###
#@   ## oddeven - even_blockage | odd_blockage | remove_blockage ## mode - decap | spacer | spacer_vcnv0
#@   set oldSnapState [set_object_snap_type -enabled false]; set cnt 0;
#@   set die_area [get_attribute -quiet [get_die_area] bbox];
#@   regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} $die_area match dllx dlly durx dury; set blkgname "spcrblkg_";
#@   if {[get_placement_blockages -quiet -filter "name=~${blkgname}_*"] != ""} {
#@     remove_placement_blockage -name ${blkgname}_*;  ## always remove previous blockage or get name collision ##
#@   }
#@   if {$oddeven=="odd_blockage" || $oddeven=="even_blockage"} {
#@     set offx 0.28
#@     if {$mode=="decap"} {
#@       set step 4.48
#@       set gap 0
#@       if {$oddeven=="odd_blockage"} {
#@         set startx [expr 0 + $offx + $step + $gap]
#@       } else {
#@         set startx [expr 0 + $offx]
#@       }
#@       while {$startx<$durx} {
#@         create_placement_blockage -bbox "$startx $dlly [expr $startx+$step+$gap] $dury" -name ${blkgname}_${cnt}
#@         set startx [expr $startx+2*$step+2*$gap];
#@         incr cnt
#@       }
#@     }
#@ 
#@     regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} [get_attribute [index_collection  [get_site_rows -filter "site_type==$::INTEL_STDCELL_TILE"] 0] bbox] match llx lly urx ury
#@     set row_height [expr $ury-$lly]
#@     if {$oddeven=="even_blockage"} {
#@       set starty 0
#@     } else {
#@       set starty [expr 2*$row_height]
#@     }
#@     while {$starty<$dury} {
#@       create_placement_blockage -bbox "$dllx $starty $durx [expr $starty+2*$row_height]" -name ${blkgname}_${cnt}
#@       set starty [expr $starty+4*$row_height];
#@       incr cnt
#@     }
#@ 
#@   }
#@   set_object_snap_type -enabled $oldSnapState; set flag 1;
#@ }
#@ 
#@ #######################
#@ # Focal opt Procedures
#@ #######################
#@ 
#@ proc P_fix_min_cap args {
#@   global synopsys_program_name
#@   set DEBUG 0
#@   # Get arguments passed to this proc
#@   parse_proc_arguments -args $args results
#@ 
#@   # Default values
#@   set report_timing_cmd "report_timing -slack_lesser_than 0"
#@   set _iterations 10
#@   set _threshold -100
#@   set _reports [list mincap]
#@   upvar report_timing_cmd _report_timing_cmd
#@ 
#@   # Create variables from arguments with this format: $_<argument name>
#@   foreach _argname [array names results] {
#@     regsub -- {-} $_argname {_} _varname
#@     set $_varname $results($_argname)
#@   }
#@ 
#@   # Initialize argument variables
#@   set iteration_cnt 0
#@   if {[info exists _report_timing] && $_report_timing == 1} {
#@     lappend _reports [list timing]
#@   }
#@   if {[info exists _fix_dont_touch] && $_fix_dont_touch == 1} {
#@     set _fix_dont_touch "true"
#@   } else {
#@     set _fix_dont_touch "false"
#@   }
#@   if {[info exists _fix_cts_fixed] && $_fix_cts_fixed == 1} {
#@     set _fix_cts_fixed "true"
#@   } else {
#@     set _fix_cts_fixed "false"
#@   }
#@   if {[info exists _fix_is_fixed] && $_fix_is_fixed == 1} {
#@     set _fix_is_fixed "true"
#@   } else {
#@     set _fix_is_fixed "false"
#@   }
#@ 
#@   # Issue warning if user is in pt_shell
#@   if {$synopsys_program_name == "pt_shell"} {
#@     P_msg_warn "User is in pt_shell: Clock cells, fixed cells, and cells not explicitly marked as dont_touch will be modified"
#@   }
#@ 
#@   # Begin iterations for min cap fixing
#@   P_msg_info "Beignning min cap fixing"
#@   while {$iteration_cnt < $_iterations} {
#@     incr iteration_cnt
#@     P_msg_info "Begin iteration $iteration_cnt"
#@     P_msg_info "Printing reports..."
#@     foreach report $_reports {
#@       if {$report == "mincap"} {
#@         report_constraint -all_violators -min_capacitance
#@       }
#@       if {$report == "timing"} {
#@         eval $_report_timing_cmd
#@       }
#@     }
#@ 
#@     # Writing out violations
#@     P_msg_info "Getting violations..."
#@     redirect -file ./temp_mincap_rpt.txt {report_constraint -all_violators -min_capacitance -nosplit}
#@     set noviol 0
#@     # Grep violations from report
#@     set rc [catch {eval exec "grep VIOLATED ./temp_mincap_rpt.txt > ./temp_mincap.txt"} output]
#@     if {$rc == 0} {
#@       P_msg_info "Successfully grepped violations"
#@       sh rm ./temp_mincap_rpt.txt
#@     } else {
#@       if {[lindex $::errorCode 0] eq "CHILDSTATUS"} {
#@         if {[lindex $::errorCode 2] == 1} {
#@           P_msg_info "No violations found"
#@           # show output with "child process exited abnormally message
#@           P_msg_info "Exit status: $output"
#@           # Stop fixing violations
#@           set noviol 1
#@           sh rm ./temp_mincap_rpt.txt
#@           sh rm ./temp_mincap.txt
#@         } else {
#@           P_msg_error "grep error: $output"
#@         }
#@       } else {
#@         P_msg_error "error calling grep: $output"
#@       }
#@     }
#@ 
#@     if {$noviol == 1} {
#@       set vcnt 0
#@       set nofixcnt 0
#@       # No violations found in the file - can skip
#@       break
#@     }
#@ 
#@     # Parse violations
#@     P_msg_info "Parsing violations..."
#@     set fd [open "./temp_mincap.txt" "r"]
#@     # Violation Count
#@     set nofixcnt 0
#@     set vcnt 0
#@     while {[gets $fd line] > -1} {
#@       # Get Data
#@       set sline ""
#@       foreach item [split $line] {
#@         if {$item ne ""} { lappend sline $item }
#@       }
#@ 
#@       # In ICC _name is a net, in PT _name is a pin
#@       set _name [lindex $sline 0]
#@       set _is_port [sizeof_collection [get_ports $_name -quiet]]
#@       if {$_is_port} {
#@         P_msg_info "Skipping net $_name because its driver is a port"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       set _net_name $_name
#@       if {$synopsys_program_name == "pt_shell"} {
#@         set _net_name [get_object_name [get_nets -of_objects [get_pins $_name]]]
#@         set _driver [get_cells -of_objects [get_pins $_name]]
#@       } elseif {$synopsys_program_name == "icc_shell"} {
#@         set _driver [get_cells -of_objects [get_pins -of_objects [get_nets $_name] -filter "pin_direction==out" -leaf]]
#@       }
#@ 
#@       set _net_dont_touch [get_attribute [get_net $_net_name] is_dont_touch -quiet]
#@       set _is_macro [get_attribute $_driver is_macro -quiet]
#@       set _cell_dont_touch [get_attribute $_driver is_dont_touch -quiet]
#@       set _cell_cts_fixed "false"
#@       if {$_fix_cts_fixed == "false" && [get_attribute $_driver cts_fixed -quiet] == "true"} {
#@         set _cell_cts_fixed "true"
#@       }
#@       set _cell_is_fixed "false"
#@       if {$_fix_is_fixed == "false" && [get_attribute $_driver is_fixed -quiet] == "true"} {
#@         set _cell_is_fixed "true"
#@       }
#@ 
#@       if {$DEBUG} {
#@         puts "**DEBUG-MSG**> net: $_net_name"
#@         puts "**DEBUG-MSG**> driver: [get_object_name $_driver]"
#@       }
#@ 
#@       # NO FIX CONDITIONS
#@       # Driver is a macro
#@       if {$_is_macro == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is a macro ([get_object_name $_driver])"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver has cts_fixed==true attribute
#@       if {$_cell_cts_fixed == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is cts_fixed"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver has is_fixed==true attribute
#@       if {$_cell_is_fixed == "true"} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver [get_object_name $_driver] is fixed"
#@         incr nofixcnt
#@         continue
#@       }
#@       # Driver is dont_touch
#@       if {$_fix_dont_touch == "false"} {
#@         if {$_net_dont_touch == "true"} {
#@           P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is dont_touch"
#@           incr nofixcnt
#@           continue
#@         } elseif {$_cell_dont_touch == "true"} {
#@           P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because driver [get_object_name $_driver] is dont_touch"
#@           incr nofixcnt
#@           continue
#@         }
#@       }
#@       # Output net is a dangling net
#@       if {[sizeof_collection [all_connected [get_nets $_net_name] -leaf]] <= 1} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because it is a dangling net.  Consider waiving this violation"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       # Get slack
#@       if {$_net_dont_touch == "true"} {
#@         set slack_column 4
#@       } else {
#@         set slack_column 3
#@       }
#@       set _slack [lindex $sline $slack_column]
#@ 
#@       # Don't fix if slack is greater than threshold
#@       if {[expr $_slack < $_threshold]} {
#@         P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its slack ($_slack) is greater than the threshold ($_threshold)"
#@         incr nofixcnt
#@         continue
#@       }
#@ 
#@       set ref_name [get_attribute $_driver ref_name]
#@       set base [string replace $ref_name 9 [string length $ref_name]]
#@       if {$synopsys_program_name == "icc_shell"} { set _attr "name" } else { set _attr "base_name" }
#@       set libcells [get_attribute [get_lib_cells */$base*] $_attr]
#@       set libcells [lsort -dictionary -unique $libcells]
#@       # Find cells and downsize
#@       set prev ""
#@       for {set j 0} {[expr $j < [llength $libcells]]} {incr j} {
#@         set mylibcell [lindex $libcells $j]
#@         if {$mylibcell == $ref_name} {
#@           if {$prev == ""} {
#@             P_msg_info "Skipping net $_net_name ([get_object_name $_driver]) because its driver is already minimum size."
#@             incr nofixcnt
#@           } else {
#@             P_msg_info "Swapping cell [get_object_name $_driver] from $ref_name to $prev"
#@             size_cell $_driver $prev
#@             incr vcnt
#@           }
#@           continue
#@         } else {
#@           set prev $mylibcell
#@         }
#@       }
#@     }
#@     sh rm ./temp_mincap.txt
#@     P_msg_info "Iteration $iteration_cnt complete"
#@     if {$vcnt == 0} {
#@       break
#@     }
#@   }
#@   report_constraint -all_violators -min_capacitance
#@   P_msg_info "Min Cap Fixing complete after $iteration_cnt iterations"
#@   P_msg_info "$vcnt fixable violations remain"
#@   P_msg_info "$nofixcnt non-fixable violations remain"
#@ }
#@ 
#@ #-----------------------------------#
#@ #--- Proc Attributes & Arguments ---#
#@ #-----------------------------------#
#@ define_proc_attributes P_fix_min_cap -info "Fixes mincap violations by down-sizing cells"     -define_args {                        {-iterations "Max number of downsizing iterations" iterations int optional}                        {-threshold  "Slack threshold - violations worse than this  will not be fixed" threshold float optional}                        {-report_timing "Prints timing report before each iteration" "" boolean optional}                        {-fix_dont_touch "Fix dont_touch nets & instances" "" boolean optional}                        {-fix_cts_fixed "Fix cts_fixed cells (Mainly flops)" "" boolean optional}                        {-fix_is_fixed "Fix fixed-placement cells" "" boolean optional}                      }
#@ 
#@ #####################
#@ # STA Procedures
#@ #####################
#@ 
#@ #######################################################################
#@ # Usage: P_report_xtalk_deltas
#@ #
#@ # This procedure reports xtalk delta delays
#@ #######################################################################
#@ suppress_message UIAT-4
#@ 
#@ proc P_report_xtalk_deltas {args} {
#@   global sh_dev_null
#@ 
#@   set results(nets) {}
#@   set results(-sort) {}
#@   set results(-verbose) 0
#@   parse_proc_arguments -args $args results
#@ 
#@   if {$results(nets) == ""} {
#@     set results(nets) [get_nets -hierarchical *]
#@   }
#@ 
#@   set sort_type $results(-sort)
#@ 
#@   set nets [get_nets $results(nets)]
#@   define_user_attribute -type float -class net dtrans_min_attr
#@   define_user_attribute -type float -class net dtrans_max_attr
#@   define_user_attribute -type float -class net delta_min_attr
#@   define_user_attribute -type float -class net delta_max_attr
#@   define_user_attribute -type float -class net abs_dtrans_attr
#@   define_user_attribute -type float -class net abs_delta_attr
#@ 
#@   echo ""
#@   echo ""
#@   set header [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"                   "Net Name" "Abs Dtrans" "Min Dtrans" "Max Dtrans" "Abs Delta" "Min Delta" "Max Delta"]
#@   echo $header
#@   echo [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"             "----------" "----------" "----------" "----------" "----------" "----------" "----------"]
#@ 
#@   foreach_in_collection this_net $nets {
#@     set net_loads {}
#@     set net_drivers {}
#@     set this_net_name [get_attribute -quiet $this_net full_name]
#@     set connections [all_connected [get_nets $this_net_name]]
#@     foreach_in_collection this_connection $connections {
#@       if {[get_attribute -quiet $this_connection object_class] == "port"} {
#@         if {[get_attribute -quiet [get_ports $this_connection] direction] == "in"} {
#@           set net_drivers [add_to_collection $net_drivers [get_ports $this_connection]]
#@         }
#@         if {[get_attribute -quiet [get_ports $this_connection] direction] == "out"} {
#@           set net_loads [add_to_collection $net_loads [get_ports $this_connection]]
#@         }
#@       }
#@       if {[get_attribute -quiet $this_connection object_class] == "pin"} {
#@         if {[get_attribute -quiet [get_pins $this_connection] direction] == "in"} {
#@           set net_loads [add_to_collection $net_loads [get_pins $this_connection]]
#@         }
#@         if {[get_attribute -quiet [get_pins $this_connection] direction] == "out"} {
#@           set net_drivers [add_to_collection $net_drivers [get_pins $this_connection]]
#@         }
#@       }
#@     }
#@ 
#@     set dtrans_min 0.00000
#@     set dtrans_max 0.00000
#@     set delta_min 0.00000
#@     set delta_max 0.00000
#@     set report ""
#@     foreach_in_collection this_load $net_loads {
#@       if {[get_attribute -quiet $this_load object_class] == "pin"} {
#@         if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]} {
#@           set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_min]
#@         }
#@         if {$dtrans_min > [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]} {
#@           set dtrans_min [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_min]
#@         }
#@         if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]} {
#@           set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_rise_transition_delta_max]
#@         }
#@         if {$dtrans_max < [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]} {
#@           set dtrans_max [get_attribute -quiet [get_pins $this_load] annotated_fall_transition_delta_max]
#@         }
#@       }
#@       foreach_in_collection this_net_driver $net_drivers {
#@         set arcs [get_timing_arcs -from $this_net_driver -to $this_load]
#@         foreach_in_collection arc $arcs {
#@           if {$delta_min > [get_attribute -quiet $arc                                 annotated_delay_delta_min_rise]} {
#@             set delta_min [get_attribute -quiet $arc                                annotated_delay_delta_min_rise]
#@           }
#@           if {$delta_min > [get_attribute -quiet $arc                                 annotated_delay_delta_min_fall]} {
#@             set delta_min [get_attribute -quiet $arc                                annotated_delay_delta_min_fall]
#@           }
#@           if {$delta_max < [get_attribute -quiet $arc                                 annotated_delay_delta_max_rise]} {
#@             set delta_max [get_attribute -quiet $arc                                annotated_delay_delta_max_rise]
#@           }
#@           if {$delta_max < [get_attribute -quiet $arc                                 annotated_delay_delta_max_fall]} {
#@             set delta_max [get_attribute -quiet $arc                                annotated_delay_delta_max_fall]
#@           }
#@         }
#@       }
#@       if {$dtrans_min != ""} {
#@         set dtrans_min_nosign [expr abs($dtrans_min)]
#@       }
#@       if {$delta_min != ""} {
#@         set delta_min_nosign [expr abs($delta_min)]
#@       }
#@       set abs_dtrans $dtrans_max
#@       set abs_delta $delta_max
#@       if {$dtrans_min_nosign > $dtrans_max} {
#@         set abs_dtrans $dtrans_min_nosign
#@       }
#@       if {$delta_min_nosign > $delta_max} {
#@         set abs_delta $delta_min_nosign
#@       }
#@     }
#@ 
#@     if {$dtrans_min == 0.00000 && $dtrans_max == 0.00000 && $delta_min == 0.00000 &&             $delta_max == 0.00000 && !$results(-verbose)} {
#@       set_user_attribute -quiet -class net $this_net_name dtrans_min_attr 9999
#@       continue
#@     }
#@     set_user_attribute -quiet -class net $this_net_name dtrans_min_attr $dtrans_min
#@     set_user_attribute -quiet -class net $this_net_name dtrans_max_attr $dtrans_max
#@     set_user_attribute -quiet -class net $this_net_name delta_min_attr $delta_min
#@     set_user_attribute -quiet -class net $this_net_name delta_max_attr $delta_max
#@     set_user_attribute -quiet -class net $this_net_name abs_dtrans_attr $abs_dtrans
#@     set_user_attribute -quiet -class net $this_net_name abs_delta_attr $abs_delta
#@   }
#@ 
#@   set temp [filter_collection $nets "dtrans_min_attr != 9999" ]
#@   set no_crosstalk true
#@   if {[sizeof_collection $temp] != 0} {
#@     set temp_sort $temp
#@     if {$sort_type == "dtrans"} {
#@       set temp_sort [sort_collection -descending $temp {abs_dtrans_attr}]
#@     }
#@     if {$sort_type == "delta"} {
#@       set temp_sort [sort_collection -descending $temp {abs_delta_attr}]
#@     }
#@ 
#@     foreach_in_collection this_net_to_report $temp_sort {
#@       set dtrans_min [get_attribute -quiet $this_net_to_report dtrans_min_attr]
#@       set dtrans_max [get_attribute -quiet $this_net_to_report dtrans_max_attr]
#@       set delta_min  [get_attribute -quiet $this_net_to_report delta_min_attr]
#@       set delta_max  [get_attribute -quiet $this_net_to_report delta_max_attr]
#@       set abs_dtrans [get_attribute -quiet $this_net_to_report abs_dtrans_attr]
#@       set abs_delta  [get_attribute -quiet $this_net_to_report abs_delta_attr]
#@       set this_net_to_report_name [get_attribute -quiet $this_net_to_report full_name]
#@       set output [format "%-60s  %10s  %10s  %10s  %10s  %10s  %10s"                       "$this_net_to_report_name" $abs_dtrans $dtrans_min $dtrans_max $abs_delta $delta_min $delta_max ]
#@       echo "$output"
#@     }
#@     set no_crosstalk false
#@   }
#@   if {$no_crosstalk == "true"} {
#@     echo "No crosstalk effects in this analysis."
#@   }
#@   echo "Analysis of [sizeof_collection $nets] net(s) complete."
#@ }
#@ 
#@ 
#@ define_proc_attributes P_report_xtalk_deltas     -info "reports delta delay and delta transition information for nets"     -define_args     {
#@       {-sort "dtrans to sort by absolute value of dtrans or delta to sort by absolute value of delta" "dtrans/delta" one_of_string {value_help {values {dtrans delta}} optional}}
#@       {-verbose "show all selected nets" "" boolean optional}
#@       {nets "nets to check" "nets" string optional}
#@     }
#@ 
#@ #######################################################################
#@ # Usage: P_restore_dmsa_session
#@ #
#@ # This procedure creates dmsa scenarios from a directory of saved sessions
#@ #######################################################################
#@ 
#@ proc P_restore_dmsa_session {args} {
#@   parse_proc_arguments -args $args results
#@ 
#@   if {[set dirs [glob -nocomplain -type f $results(dir_name)/*/*/lib_map]]
#@       eq {}} {
#@     echo "Error: no save_session directories found."
#@     return 0
#@   }
#@ 
#@   foreach dir $dirs {
#@     set dir [file dirname $dir]
#@     set name [file tail $dir]
#@     regsub "\/$name" $dir "" scenario
#@     regsub "..\/" $scenario "" scenario
#@     echo "Defining scenario ${scenario}."
#@ 
#@     create_scenario -name $scenario -image $dir
#@   }
#@ }
#@ 
#@ define_proc_attributes P_restore_dmsa_session     -info "Restores PrimeTime sessions in DMSA"     -define_args     {
#@       {dir_name "Dir name to restore from" "dir_name" string required}
#@     }
#@ 
#@ #######################################################################
#@ # Usage: P_report_qor
#@ #
#@ # This procedure to emulate DC's report_qor in PT
#@ #######################################################################
#@ 
#@ proc P_report_qor {args} {
#@ 
#@   global sh_product_version
#@   global sh_dev_null
#@   global report_default_significant_digits
#@   global synopsys_program_name
#@   global pt_shell_mode
#@ 
#@   set results(-help) "no help"
#@   set results(-significant_digits) "none"
#@   set results(-only_violated) "false"
#@   set results(-summary) "false"
#@ 
#@   parse_proc_arguments -args $args results
#@ 
#@   if {$results(-help)==""} {
#@     help -verbose report_qor
#@     return 1
#@   }
#@ 
#@   if {$results(-significant_digits)=="none"} {
#@     set significant_digits $report_default_significant_digits
#@   } else {
#@     if {$results(-significant_digits) < 0 || $results(-significant_digits) > 13} {
#@       echo "Error: value '$results(-significant_digits)' not in range (0 to 13). (CMD-019)"
#@       return 0
#@     } else {
#@       set significant_digits $results(-significant_digits)
#@     }
#@   }
#@ 
#@   proc P_count_levels {path} {
#@     set levels 0
#@     set endpoint [get_object_name [get_attribute -quiet $path endpoint]]
#@     foreach_in_collection point [get_attribute -quiet $path points] {
#@       set object [get_attribute -quiet $point object]
#@       if {[get_attribute -quiet $object object_class] == "pin"} {
#@         if {[get_attribute -quiet $object pin_direction] == "in"} {
#@           if {[get_attribute -quiet $object is_port] == "false"} {
#@             if {[get_attribute -quiet $object full_name] != $endpoint} {
#@               incr levels
#@             }
#@           }
#@         }
#@       }
#@     }
#@     return $levels
#@   }
#@ 
#@   proc P_display_path_group {levels arrival slack cost count significant_digits scenario} {
#@     echo "  ---------------------------------------------"
#@     echo [format "  Levels of Logic:%29d$scenario" $levels]
#@     echo [format "  Critical Path Length:%24.${significant_digits}f$scenario" $arrival]
#@     if {[regexp {[^a-zA-Z]} $slack full]} {
#@       echo [format "  Critical Path Slack:%25.${significant_digits}f$scenario" $slack]
#@     } else {
#@       echo [format "  Critical Path Slack:            unconstrained$scenario"]
#@     }
#@     echo [format "  Total Negative Slack:%24.${significant_digits}f" $cost]
#@     echo [format "  No. of Violating Paths:%22d" $count]
#@     echo "  ---------------------------------------------"
#@   }
#@ 
#@   proc P_display_cell_count_and_drcs {hier_cells_count nonhier_cells_count area hier_pins_count nonhier_pins_count cost count drc_list significant_digits scenario} {
#@     upvar $cost cost_local
#@     upvar $count count_local
#@     echo "\n\n  Cell Count"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Hierarchical Cell Count:%21d$scenario" $hier_cells_count]
#@     echo [format "  Hierarchical Port Count:%21d$scenario" $hier_pins_count]
#@     echo [format "  Leaf Cell Count:%29d$scenario" $nonhier_cells_count]
#@     echo "  ---------------------------------------------"
#@     echo "\n\n  Area"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Design Area:%33.6f$scenario" $area]
#@     if {[info exists cost_local(max_area)]} {
#@       echo [format "  Area Cost:%35.6f" $cost_local(max_area)]
#@     }
#@     echo "  ---------------------------------------------"
#@     echo "\n\n  Design Rule Violations"
#@     echo "  ---------------------------------------------"
#@     echo [format "  Total No. of Pins in Design:%17d$scenario" $nonhier_pins_count]
#@     foreach i $drc_list {
#@       if {$count_local($i) != 0} {
#@         set len [expr 38 - [string length $i]]
#@         echo [format "  $i Count:%${len}d" $count_local($i)]
#@       }
#@     }
#@     set total_cost 0
#@     foreach i $drc_list {
#@       if {$cost_local($i) != 0} {
#@         set len [expr 39 - [string length $i]]
#@         set total_cost [expr $total_cost + $cost_local($i)]
#@         echo [format "  $i Cost:%${len}.${significant_digits}f" $cost_local($i)]
#@       }
#@     }
#@     echo [format "  Total DRC Cost:%30.${significant_digits}f" $total_cost]
#@     echo "  ---------------------------------------------\n"
#@   }
#@ 
#@   if {$synopsys_program_name != "pt_shell"} {
#@     echo "Error: This script only functions properly in PrimeTime."
#@     return 0
#@   }
#@ 
#@   set constraint_text ""
#@   set drc_list ""
#@   set group_list ""
#@ 
#@   if {$pt_shell_mode == "primetime" || $pt_shell_mode == "primetime_slave"} {
#@ 
#@     set cost(unconstrained) 0
#@     set count(unconstrained) 0
#@ 
#@     redirect $sh_dev_null {catch {set design [current_design]}}
#@ 
#@     if { $design == "" } {
#@       echo "Error: Current design is not defined. (DES-001)"
#@       return 0
#@     }
#@ 
#@     echo "\n****************************************"
#@     echo "Report : qor"
#@     echo "Design : [get_object_name $design]"
#@     echo "Version: $sh_product_version"
#@     echo "Date   : [date]"
#@     echo "****************************************\n"
#@ 
#@     redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}
#@ 
#@     foreach line [split $constraint_text "\n"] {
#@       switch -regexp $line {
#@         {^.* +([-\.0-9]+) +\(VIOLATED} {
#@           regexp {^.* +([-\.0-9]+) +\(VIOLATED} $line full slack
#@           set cost($group) [expr $cost($group) + $slack]
#@           incr count($group)
#@           continue
#@         }
#@         { *max_delay/setup.*'(.*)'} {
#@           regexp { *max_delay/setup.*'(.*)'} $line full group
#@           set cost($group) 0
#@           set count($group) 0
#@           continue
#@         }
#@         { *min_delay/hold.*'(.*)'} {
#@           regexp { *min_delay/hold.*'(.*)'} $line full group
#@           set group ${group}_min
#@           set cost($group) 0
#@           set count($group) 0
#@           continue
#@         }
#@         {^ *([a-zA-Z_]+) *$} {
#@           regexp {^ *([a-zA-Z_]+) *$} $line full group
#@           if {$group == "recovery" } {
#@             set group async_default
#@           }
#@           if {$group == "removal"} {
#@             set group async_default_min
#@           }
#@           if ![info exists cost($group)] {
#@             set cost($group) 0
#@             set count($group) 0
#@             if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
#@               lappend drc_list $group
#@             }
#@           }
#@           continue
#@         }
#@       }
#@     }
#@ 
#@     set WNS 0.0; set TNS 0.0; set NVP 0;
#@     set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;
#@ 
#@     foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group]] path_group] {
#@       set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost($path_group)]} {
#@         set cost($path_group) 0
#@         set count($path_group) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@ 
#@       if {$slack < $WNS} { set WNS $slack }
#@       set TNS [expr $TNS + $cost(${path_group})]
#@       set NVP [expr $NVP + $count(${path_group})]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits ""
#@     }
#@ 
#@     echo ""
#@ 
#@     foreach_in_collection path [sort_collection [get_timing_paths -group [get_path_group] -delay_type min] path_group] {
#@       redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost(${path_group}_min)]} {
#@         set cost(${path_group}_min) 0
#@         set count(${path_group}_min) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@ 
#@       if {$slack < $WNS_min} { set WNS_min $slack }
#@       set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
#@       set NVP_min [expr $NVP_min + $count(${path_group}_min)]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits ""
#@     }
#@ 
#@ 
#@     if {$results(-summary)} {
#@       puts "  Summary"
#@       puts "  ---------------------------------------------"
#@       puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
#@       puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
#@       puts "  ---------------------------------------------"
#@     }
#@ 
#@     set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"]
#@     set nonhier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == false"]
#@ 
#@     P_display_cell_count_and_drcs [sizeof_collection $hier_cells]         [sizeof_collection $nonhier_cells]         [get_attribute -quiet $design area]         [sizeof_collection [get_pins -quiet -of_objects $hier_cells]]         [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]]         cost         count         $drc_list         $significant_digits         ""
#@ 
#@   } elseif {$pt_shell_mode == "primetime_master"} {
#@ 
#@     global multi_scenario_message_verbosity_level
#@ 
#@     set old_verbosity_level $multi_scenario_message_verbosity_level
#@     set multi_scenario_message_verbosity_level low
#@ 
#@     if [info exists constraint_text] {
#@       unset constraint_text
#@     }
#@ 
#@     if {$sh_product_version=="Z-2007.06"||$sh_product_version=="Z-2007.06-SP1"||$sh_product_version=="Z-2007.06-SP2"||$sh_product_version=="Z-2007.06-SP2-1"} {
#@       echo "Error: Aborting script execution! Due to a DMSA bug in Z-2007.06 versions prior to Z-2007.06-SP3 (STAR 9000188708),"
#@       echo "       this script will produce inconsistent and incorrect results. The bug is fixed in Z-2007.06-SP3 PrimeTime."
#@       echo "       To use this script in DMSA mode, please use Z-2007.06-SP3 or later PrimeTime instead."
#@       return 0
#@     }
#@ 
#@     echo "\n****************************************"
#@     echo "Report : qor"
#@     echo "Design : multi-scenario design"
#@     echo "Version: $sh_product_version"
#@     echo "Date   : [date]"
#@     echo "****************************************\n"
#@ 
#@     get_distributed_variables -pre_commands         {redirect -variable constraint_text {report_constraint -all_violators -nosplit -significant_digits 5}}         constraint_text
#@ 
#@     set max_paths [get_timing_paths -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]
#@     set min_paths [get_timing_paths -delay_type min -attributes "full_name slack path_group points arrival object object_class pin_direction is_port endpoint"]
#@ 
#@     set old_scenario_list [current_scenario]
#@ 
#@     foreach_in_collection scenario $old_scenario_list {
#@       set first_scenario_name [get_object_name $scenario]
#@       break
#@     }
#@ 
#@     current_scenario $first_scenario_name
#@ 
#@     get_distributed_variables -pre_commands         {set hier_cells [get_cells -quiet -hierarchical * -filter "is_hierarchical == true"];              set nonhier_cells [get_cells -quiet -hieriarchical * -filter "is_hierarchical == false"];              set hier_cells_count [sizeof_collection $hier_cells];              set hier_pins_count [sizeof_collection [get_pins -quiet -of_objects $hier_cells]];              set nonhier_cells_count [sizeof_collection $nonhier_cells];              set nonhier_pins_count [sizeof_collection [get_pins -quiet -hierarchical * -filter "is_hierarchical==false"]];              set area [get_attribute -quiet [current_design] area];            } "hier_cells_count nonhier_cells_count hier_pins_count nonhier_pins_count area"
#@ 
#@     current_scenario $old_scenario_list
#@ 
#@     set multi_scenario_message_verbosity_level $old_verbosity_level
#@     set group ""
#@     foreach scenario [array names constraint_text] {
#@       foreach line [split $constraint_text($scenario) "\n"] {
#@         switch -regexp $line {
#@           {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} {
#@             regexp {^ +(\S+ ?[\(\)a-zA-Z]*).* ([-\.0-9]+) +\(VIOLATED} $line full object slack
#@             set object [string trimright $object]
#@             if ![info exists slack_${group}($object)] {
#@               set slack_${group}($object) $slack
#@             } else {
#@               if [expr $slack < [set slack_${group}($object)]] {
#@                 set slack_${group}($object) $slack
#@               }
#@               continue
#@             }
#@           }
#@           { *max_delay/setup.*'(.*)'} {
#@             regexp { *max_delay/setup.*'(.*)'} $line full group
#@             if ![info exists slack_$group] {
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@               lappend group_list $group
#@             }
#@             continue
#@           }
#@           { *min_delay/hold.*'(.*)'} {
#@             regexp { *min_delay/hold.*'(.*)'} $line full group
#@             set group ${group}_min
#@             if ![info exists slack_$group] {
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@               lappend group_list $group
#@             }
#@             continue
#@           }
#@           {^ *([a-zA-Z_]+) *$} {
#@             regexp {^ *([a-zA-Z_]+) *$} $line full group
#@             if {$group == "recovery"} {
#@               set group async_default
#@               if ![info exists slack_async_default] {
#@                 lappend group_list async_default
#@               }
#@             }
#@             if {$group == "removal"} {
#@               set group async_default_min
#@               if ![info exists slack_async_default_min] {
#@                 lappend group_list async_default_min
#@               }
#@             }
#@             if ![info exists slack_$group] {
#@               if {$group != "max_area" && $group != "async_default" && $group != "async_default_min"} {
#@                 lappend drc_list $group
#@               }
#@               array set slack_$group ""
#@               array set slack_$group ""
#@               set cost($group) 0
#@               set count($group) 0
#@             }
#@             continue
#@           }
#@         }
#@       }
#@     }
#@ 
#@     foreach group "$group_list $drc_list" {
#@       foreach object [array names slack_$group] {
#@         set cost($group) [expr $cost($group) + [set slack_${group}($object)]]
#@         incr count($group)
#@       }
#@     }
#@ 
#@     set WNS 0.0; set TNS 0.0; set NVP 0;
#@     set WNS_min 0.0; set TNS_min 0.0; set NVP_min 0;
#@ 
#@     foreach_in_collection path [sort_collection $max_paths path_group] {
#@       set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost($path_group)]} {
#@         set cost($path_group) 0
#@         set count($path_group) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@       set scenario_name [get_attribute $path scenario_name]
#@ 
#@       if {$slack < $WNS} { set WNS $slack }
#@       set TNS [expr $TNS + $cost(${path_group})]
#@       set NVP [expr $NVP + $count(${path_group})]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count($path_group) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (max_delay/setup)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost($path_group) $count($path_group) $significant_digits " ($scenario_name)"
#@     }
#@ 
#@     echo ""
#@ 
#@     foreach_in_collection path [sort_collection $min_paths path_group] {
#@       redirect $sh_dev_null {set path_group [get_attribute -quiet [get_attribute -quiet $path path_group] full_name]}
#@       if {$path_group == ""} {
#@         set path_group unconstrained
#@       }
#@       if {[regexp {\*\*[a-z_]*\*\*} $path_group full]} {
#@         set path_group [string map {\* ""} $path_group]
#@       }
#@       if {![info exists cost(${path_group}_min)]} {
#@         set cost(${path_group}_min) 0
#@         set count(${path_group}_min) 0
#@       }
#@ 
#@       set levels [P_count_levels $path]
#@ 
#@       set slack [get_attribute -quiet $path slack]
#@       set scenario_name [get_attribute $path scenario_name]
#@ 
#@       if {$slack < $WNS_min} { set WNS_min $slack }
#@       set TNS_min [expr $TNS_min + $cost(${path_group}_min)]
#@       set NVP_min [expr $NVP_min + $count(${path_group}_min)]
#@ 
#@       if {$results(-summary) || ($results(-only_violated) && $count(${path_group}_min) == 0)} { continue }
#@       echo "\n  Timing Path Group '$path_group' (min_delay/hold)"
#@       P_display_path_group $levels [get_attribute -quiet $path arrival] $slack $cost(${path_group}_min) $count(${path_group}_min) $significant_digits " ($scenario_name)"
#@     }
#@ 
#@     if {$results(-summary)} {
#@       puts "  Summary"
#@       puts "  ---------------------------------------------"
#@       puts [format "  Setup WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS $TNS $NVP]
#@       puts [format "  Hold  WNS: %10.${significant_digits}f  TNS: %10.${significant_digits}f  Number of Violating Paths: %d" $WNS_min $TNS_min $NVP_min]
#@       puts "  ---------------------------------------------"
#@     }
#@ 
#@     P_display_cell_count_and_drcs $hier_cells_count($first_scenario_name)         $nonhier_cells_count($first_scenario_name)         $area($first_scenario_name)         $hier_pins_count($first_scenario_name)         $nonhier_pins_count($first_scenario_name)         cost         count         $drc_list         $significant_digits         " ($first_scenario_name)"
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_report_qor     -info "Report QoR"     -define_args {                      {-physical "For compatibility with DC/ICC report_qor; ignored in PrimeTime" "" boolean optional}
#@       {-significant_digits "Precision level of report (range from 0 to 13)" "<digits>" int optional}
#@       {-only_violated "Show only violating path groups" "" boolean optional}
#@       {-summary "QoR Summary report" "" boolean optional}
#@     }
#@ 
#@ ###################################
#@ # Reports and Outputs Procedures
#@ ###################################
#@ 
#@ ########################################################################################################
#@ # Procedure   : P_create_xyv_icc
#@ # Description : This proc is used to create top level block's XYV file for RV LTE analysis
#@ #               The xyv file contains rotation, flipping and coordinates information of top
#@ #               level block and all instances within top level block
#@ 
#@ proc P_create_xyv_icc {args } {
#@ 
#@   set topcell_name [get_attribute [current_design] name]
#@   if { $topcell_name == ""} {
#@     error "P_create_xyv_icc -ERROR- current design name for top level block is not defined\n"
#@   }
#@ 
#@   parse_proc_arguments -args $args flag
#@ 
#@   if {![info exists flag(-step)]} {
#@     error "P_create_xyv_icc -ERROR- Required APR step is not defined\n"
#@   } else {
#@     set step $flag(-step)
#@     set outputfile "outputs/${topcell_name}.${step}.xyv"}
#@   set fp [open $outputfile w]
#@ 
#@   global mw_attr_value_extra_braces
#@   set existing_value_of_extra_braces_var $mw_attr_value_extra_braces
#@   set mw_attr_value_extra_braces false
#@ 
#@   #############################################
#@   #xyv for top level block
#@   #############################################
#@ 
#@   set top_xy_coords ""
#@   set top_boundary [get_attribute [get_die_area] boundary]
#@   for {set tcount 0} {$tcount < [expr [llength $top_boundary] - 1]} {incr tcount} {
#@     set top_firstval [lindex $top_boundary $tcount]
#@     set top_xmin [lindex $top_firstval 0]
#@     set top_ymin [lindex $top_firstval 1]
#@     set top_xmin_nm [expr int($top_xmin*1000)]
#@     set top_ymin_nm [expr int($top_ymin*1000)]
#@     append top_xy_coords " $top_xmin_nm $top_ymin_nm"
#@   }
#@   puts $fp "$topcell_name $topcell_name 0 0 0 0 $top_xy_coords"
#@ 
#@   #############################################
#@   #xyv for all instances within top level block
#@   #############################################
#@ 
#@   foreach_in_collection cell [get_fp_cells -all] {
#@     set inst_name [get_attribute $cell full_name]
#@     set cell_name [get_attribute $cell ref_name]
#@     set inst_origin_x [lindex [get_attribute $cell origin] 0]
#@     set inst_origin_y [lindex [get_attribute $cell origin] 1]
#@     set orientation [get_attribute $cell orientation]
#@     if { $orientation eq "N"} {
#@       set inst_orient "0 0"
#@     } elseif {$orientation eq "FS"} {
#@       set inst_orient "1 0"
#@     } elseif {$orientation eq "FN"} {
#@       set inst_orient "2 0"
#@     } elseif {$orientation eq "S" } {
#@       set inst_orient "0 2"
#@     } else {
#@       puts "P_create_xyv_icc -ERROR- Invalid orientation is found for instance: $inst_name cell: $cell_name"
#@     }
#@     set inst_xy_coords ""
#@     set inst_boundary [get_attribute $cell boundary]
#@     for {set icount 0} {$icount < [expr [llength $inst_boundary] - 1]} {incr icount} {
#@       set inst_firstval [lindex $inst_boundary $icount]
#@       set inst_xmin [lindex $inst_firstval 0]
#@       set inst_ymin [lindex $inst_firstval 1]
#@       set inst_xmin_nm [expr int($inst_xmin*1000)]
#@       set inst_ymin_nm [expr int($inst_ymin*1000)]
#@       append inst_xy_coords " $inst_xmin_nm $inst_ymin_nm"
#@     }
#@     puts $fp "${topcell_name}/$inst_name $cell_name $inst_origin_x $inst_origin_y $inst_orient $inst_xy_coords"
#@   }
#@ 
#@   close $fp
#@ 
#@   set mw_attr_value_extra_braces $existing_value_of_extra_braces_var
#@ 
#@ }
#@ 
#@ define_proc_attributes P_create_xyv_icc      -info "Used to create top level block's XYV file for RV LTE analysis from ICC database"     -define_args {
#@       {-step "APR Step for which XYV file is created" string string required}
#@     }
#@ 
#@ #########################################################
#@ # Procedure: P_report_related_supply_net
#@ # Description: Report related supply nets for given ports.
#@ 
#@ proc P_report_related_supply_net { ports } {
#@   echo "\n****************************************"
#@   echo "Report : related_supply_net"
#@   echo "Design : [current_design_name]"
#@   echo "Version: $::sh_product_version"
#@   echo "Date   : [sh date]"
#@   echo "****************************************\n"
#@   array set miss_num {
#@     power  0
#@     ground 0
#@   }
#@   foreach_in_collection port [sort_collection -dictionary $ports full_name] {
#@     array unset rsn
#@     redirect $::sh_dev_null {
#@       set rsn(power) [get_related_supply_net $port]
#@       set rsn(ground) [get_related_supply_net -ground $port]
#@     }
#@     foreach net_type {power ground} {
#@       if { [sizeof_collection $rsn($net_type)] == 0 } {
#@         incr miss_num($net_type)
#@       }
#@     }
#@     echo "Port [get_object_name $port] ([get_attribute $port direction]) : power = [get_object_name $rsn(power)] , ground = [get_object_name $rsn(ground)]"
#@   }
#@   if { $miss_num(power) > 0 || $miss_num(ground) > 0 } {
#@     echo "\nERROR: $miss_num(power) of [sizeof_collection $ports] ports missing related power net & $miss_num(ground) of [sizeof_collection $ports] ports missing related ground net!\n"
#@     return 0
#@   } else {
#@     echo {}
#@     return 1
#@   }
#@ }
#@ 
#@ #########################################################
#@ # Procedure: P_reports
#@ # Description:  Writes out report files for SYN, APR, PV
#@ 
#@ proc P_reports {step} {
#@   set _start [clock seconds]
#@   global INTEL_DESIGN_NAME INTEL_UPF INTEL_REPORTS
#@   global INTEL_INSERT_SCAN INTEL_HARD_MACRO_NAME
#@   global INTEL_SLACK_LIMIT INTEL_MAX_PATHS INTEL_NWORST
#@   global synopsys_program_name
#@ 
#@   if {[info exists INTEL_MAX_PATHS($step)]} {
#@     set tmax_paths $INTEL_MAX_PATHS($step)
#@   } else {
#@     set tmax_paths 1000
#@   }
#@   if {[info exists INTEL_SLACK_LIMIT($step)]} {
#@     set tslack_limit $INTEL_SLACK_LIMIT($step)
#@   } else {
#@     set tslack_limit 9999
#@   }
#@   if {[info exists INTEL_NWORST($step)]} {
#@     set tnworst $INTEL_NWORST($step)
#@   } else {
#@     set tnworst 1
#@   }
#@ 
#@   set reports_path ./reports
#@   set report_timing_options "report_timing -nosplit -capacitance -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
#@   set check_timing_options "check_timing"
#@ 
#@ 
#@   set rpt_cmd ""
#@   if {$synopsys_program_name == "pt_shell"} {
#@     set report_timing_options "report_timing -nosplit -capacitance -crosstalk_delta -transition_time -significant_digits 2 -input_pins -nets -max_paths $tmax_paths -nworst $tnworst -path_type full -derate -slack_lesser_than $tslack_limit"
#@     set check_timing_options "check_timing -verbose"
#@   }
#@ 
#@   set act_scenarios ""
#@   if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
#@      set act_scenarios [all_active_scenarios]
#@   } 
#@ 
#@   if {[info exists INTEL_REPORTS($step)]} {
#@     foreach report $INTEL_REPORTS($step) {
#@       #         puts "==>INFORMATION: Generating $report report..."
#@       switch -exact -- $report {
#@         area {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set hard_macro_area 0.0
#@           set hard_macro_count 0
#@           if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@             foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@               foreach_in_collection inst_col [get_cells -hierarchical -filter ref_name==$hard_macro_name] {
#@                 set area [get_attribute $inst_col area]
#@                 set hard_macro_area [expr $hard_macro_area + $area]
#@                 incr hard_macro_count
#@               }
#@             }
#@           }
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
#@             report_area
#@             echo "HARD MACRO COUNT= $hard_macro_count"
#@             echo "HARD MACRO AREA = $hard_macro_area sq. microns"
#@             report_reference -hierarchy -nosplit
#@           }
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         qor {
#@           puts "==>INFORMATION: Generating $report report..."
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_report_qor}\n}\n"
#@           } else {
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_qor}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             if { $act_scenarios != "" } {
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt {report_qor -summary}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.summary.rpt reports/${INTEL_DESIGN_NAME}.${report}.summary.rpt
#@             }
#@           }
#@         }
#@         power {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_power -verbose -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               }
#@             } else {
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_power -verbose -nosplit }
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         congestion {
#@           if {[shell_is_in_topographical_mode] || [regexp {^icc} $synopsys_program_name]} {
#@             # reports estimated routing related congestion after topo mode synthesis.
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_congestion}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported in this mode."
#@           }
#@         }
#@         multi_vth {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         aocvm {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_aocvm -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         high_fanout {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_net_fanout -high_fanout}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         logic_levels {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {P_get_logic_levels}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         max_delay {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.delay.rpt {report_constraint -all_violators -max_delay -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.delay.rpt {report_constraint -all_violators -max_delay -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.delay.rpt reports/${INTEL_DESIGN_NAME}.delay.rpt
#@             }
#@           }
#@         }
#@         max_cap {
#@           if {[regexp {^pt_shell} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.cap.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.cap.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.cap.rpt {report_constraint -all_violators -max_capacitance -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.cap.rpt reports/${INTEL_DESIGN_NAME}.cap.rpt
#@             }
#@           }
#@         }
#@         max_tran {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt {report_constraint -all_violators -max_transition -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.tran.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.tran.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.tran.rpt {report_constraint -all_violators -max_transition -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tran.rpt reports/${INTEL_DESIGN_NAME}.tran.rpt
#@             }
#@           }
#@         }
#@         all_violators {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_constraint -all_violators -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_constraint -all_violators -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         create_qor_snapshot {
#@           P_msg_info "Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "create_qor_snapshot -name $step -show_all -clock_tree"}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         timing_setup {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type max}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type max -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type max"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         timing_hold {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay_type min}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -delay_type min -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options -delay_type min"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         timing_setup_zeroRC {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  set_zero_interconnect_delay_mode true\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$report_timing_options -delay min}\n set_zero_interconnect_delay_mode false\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 set_zero_interconnect_delay_mode true
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {eval "$report_timing_options -scenarios $scenario"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@                 set_zero_interconnect_delay_mode false
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               set_zero_interconnect_delay_mode true
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval "$report_timing_options"}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@               set_zero_interconnect_delay_mode false
#@             }
#@           }
#@         }
#@         timing_setup_groups {
#@           puts "==>INFORMATION: Generating $report report..."
#@           foreach_in_collection group [get_path_groups] {
#@             set group_name [get_object_name ${group}]
#@             regsub -all {\*} $group_name "" group_rpt_name
#@             regsub -all {\/} $group_rpt_name "-" group_rpt_name
#@             if {[regexp {^pt} $synopsys_program_name]} {
#@               set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {$report_timing_options -group $group_name}}\n"
#@             } else {
#@               if { $act_scenarios != "" } {
#@                 foreach scenario [all_active_scenarios] {
#@                   redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name -scenarios $scenario"}
#@                   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
#@                 }
#@               } else {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt {eval "$report_timing_options -group $group_name"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_setup_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_setup_${group_rpt_name}.rpt
#@               }
#@             }
#@           }
#@         }
#@         timing_hold_groups {
#@           puts "==>INFORMATION: Generating $report report..."
#@           foreach_in_collection group [get_path_groups] {
#@             set group_name [get_object_name ${group}]
#@             regsub -all {\*} $group_name "" group_rpt_name
#@             regsub -all {\/} $group_rpt_name "-" group_rpt_name
#@             if {[regexp {^pt} $synopsys_program_name]} {
#@               set rpt_cmd "$rpt_cmd {redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {$report_timing_options -delay_type min -group $group_name}}\n"
#@             } else {
#@               if { $act_scenarios != "" } {
#@                 foreach scenario [all_active_scenarios] {
#@                   redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name -scenarios $scenario"}
#@                   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.timing_setup_${group_rpt_name}.rpt
#@                 }
#@               } else {
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt {eval "$report_timing_options -delay_type min -group $group_name"}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_hold_${group_rpt_name}.rpt reports/${INTEL_DESIGN_NAME}.timing_hold_${group_rpt_name}.rpt
#@               }
#@             }
#@           }
#@         }
#@         timing_loops {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {$report_timing_options -loops}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt {eval "$report_timing_options -loops"}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.max.timingloops.rpt reports/${INTEL_DESIGN_NAME}.max.timingloops.rpt
#@           }
#@         }
#@         timing_histogram {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -range_maximum 0}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.timing_histogram.rpt {report_timing_histogram -bin_range 25 -scenarios $scenario}
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt {report_timing_histogram -bin_range 25}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.timing_histogram.rpt reports/${INTEL_DESIGN_NAME}.timing_histogram.rpt
#@             }
#@           }
#@         }
#@         clock {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock -skew -attributes -nosplit -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock -skew -attributes -nosplit}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         physical {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_design -physical}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         clock_tree {
#@           if { $act_scenarios != "" } {
#@             foreach scenario [all_active_scenarios] {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_tree -scenarios $scenario}
#@               redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup -scenarios $scenario}
#@               redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup -scenario $scenario }
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@             }
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect         $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_tree }
#@             redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type transition -nworst 100 -setup }
#@             redirect -append $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_timing -type latency    -nworst 100 -setup  }
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         clock_gating {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_clock_gating -ungated -style}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_timing {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {$check_timing_options}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {eval $check_timing_options}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         min_pulse_width {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}\n}\n"
#@           } else {
#@             if { $act_scenarios != "" } {
#@               foreach scenario [all_active_scenarios] {
#@                 puts "==>INFORMATION: Generating $report report for all scenarios in MCMM..."
#@                 redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt {report_min_pulse_width -all_violators -scenarios $scenario}
#@                 sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${scenario}.${report}.rpt
#@               }
#@             } else {
#@               puts "==>INFORMATION: Generating $report report..."
#@               redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_min_pulse_width -all_violators}
#@               sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@             }
#@           }
#@         }
#@         check_zrt_routability {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_zrt_routability -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         drc {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_drc -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err}
#@           sh ln -fs ${INTEL_DESIGN_NAME}_${step}_${report}.err reports/${INTEL_DESIGN_NAME}_${report}.err
#@         }
#@         lvs {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {verify_lvs -error_cell ${INTEL_DESIGN_NAME}_${step}_${report}.err -max_error 200 -check_short_locator -check_open_locator}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_design {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_design}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         error_info {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}\n}\n"
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt  
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {print_message_info}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         saif {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_saif -hier -missing -annotated_flag -type gate}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         check_mv_design {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_mv_design -verbose}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         upf {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating $report report because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {
#@               eval report_power_domain [get_power_domains -quiet -hierarchical *]
#@               eval report_supply_port [get_supply_ports -quiet -hierarchical *]
#@               eval report_supply_net -include_exception [get_supply_nets -quiet -hierarchical *]
#@               eval report_power_switch -verbose [get_power_switches -quiet -hierarchical *]
#@               # Somehow, ICC report_isolation_cell needs associate_mv_cells -isolation_cells.
#@               report_isolation_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               # Somehow, ICC report_level_shifter needs domain names instead of domain objects.
#@               if { $::synopsys_program_name == {icc_shell} } {
#@                 report_level_shifter -verbose -domain [get_object_name [get_power_domains -quiet -hierarchical *]]
#@               } else {
#@                 report_level_shifter -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               }
#@               report_retention_cell -verbose -domain [get_power_domains -quiet -hierarchical *]
#@               P_report_related_supply_net [get_ports *]
#@             }
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         check_legality {
#@           puts "==>INFORMATION: Generating $report report..."
#@           redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {check_legality -verbose}
#@           sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@         }
#@         threshold_voltage_group {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_threshold_voltage_group -nosplit}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           }
#@         }
#@         vars {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {\n    echo \"##### Environment Variables #####\"\n     printenv\n   echo \" \"\n   echo \"##### Flow Related Variables #####\"\n    printvar\n}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.vars {
#@               echo "##### Environment Variables #####"
#@               printenv
#@               echo " "
#@               echo "##### Flow Related Variables #####"
#@               printvar
#@             }
#@             ################
#@             # dump file paths of libraries and technology data.
#@             #   resulting file can be run through sha1sum for audit purposes.
#@             # libraries
#@             set libs [get_libs *]
#@             foreach_in_collection lib $libs {
#@               set file [get_attribute $lib extended_name]
#@               set l [split $file ":"]
#@               lappend names [lindex $l 0]
#@             }
#@             set names [lsort -unique $names]
#@             set f [open "$reports_path/${INTEL_DESIGN_NAME}.${step}.files" "w"]
#@             foreach n $names {
#@               puts $f $n
#@             }
#@             if {[regexp {icc} $synopsys_program_name] || ([regexp {dc} $synopsys_program_name] && [shell_is_in_topographical_mode])} {
#@               # tlu files
#@               redirect -variable tlu_files {report_tlu_plus_files}
#@               foreach line [split $tlu_files "\n"] {
#@                 regsub -all {\s+} $line {} line
#@                 if {[regexp {file:} $line]} {
#@                   puts $f [lindex [split $line ":"] 1]
#@                 }
#@               }
#@               # techfile - ??
#@             }
#@             close $f
#@           }
#@         }
#@         flow_vars {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {\n   echo \"#### INTEL_* flow varaibles #####\"\n   printvar INTEL_*\n}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report} {
#@               echo "#### INTEL_* flow varaibles #####"
#@               printvar INTEL_*
#@             }
#@           }
#@         }
#@         dft_drc {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {dft_drc -coverage_estimate}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         dft_signal {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_dft_signal}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         scanpath {
#@           if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.${step}.${report}.rpt {report_scan_path}
#@             sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${report}.rpt reports/${INTEL_DESIGN_NAME}.${report}.rpt
#@           } else {
#@             puts "==>WARNING: $report report is not supported, since scan was not inserted."
#@           }
#@         }
#@         parasitic_not_annotated_check {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n   redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {report_annotated_parasitics -internal_nets -boundary_nets -list_not_annotated}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/$INTEL_DESIGN_NAME.net_not_annotated_w_RC.pv.rpt {
#@               report_annotated_parasitics                   -internal_nets                   -boundary_nets                   -list_not_annotated                 }
#@           }
#@         }
#@         pin_margin   {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_margin.pv.rpt
#@           redirect $output_file {echo [format "%-50s %-7s %-7s %-7s %-7s %-4s %-15s" #pin_name max_rise max_fall min_rise min_fall direction cell ]}
#@           redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection pin [get_pins -hierarchical * -filter "is_hierarchical == false && is_clock_pin == false"] {
#@             set temp [format "%-50s %7.2f %7.2f %7.2f %7.2f %-4s %-15s" [get_attribute -quiet -class pin $pin full_name]                           [get_attribute -quiet -class pin $pin max_rise_slack]                           [get_attribute -quiet -class pin $pin max_fall_slack]                           [get_attribute -quiet -class pin $pin min_rise_slack]                           [get_attribute -quiet -class pin $pin min_fall_slack]                           [get_attribute -quiet -class pin $pin direction]                           [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]
#@ 
#@             redirect -append $output_file { echo $temp}
#@           }
#@         }
#@         pin_attribute {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_pin_attribute.pv.rpt
#@           redirect $output_file {echo [format "%60s %14s" #RISE_TRAN FALL_TRAN]}
#@           redirect -append $output_file {echo [format "%-50s %-6s %-6s %-6s %-6s %-4s %-15s" #pin_name max  min  max  min  arr_window  cell]}
#@           redirect -append $output_file {echo "#-------------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection pin [get_pins -hierarchical * ] {
#@             set temp [format "%-50s %5.2f %5.2f %5.2f %5.2f %-50s %-15s" [get_attribute -quiet -class pin $pin full_name]                           [get_attribute -quiet -class pin $pin actual_rise_transition_max]                           [get_attribute -quiet -class pin $pin actual_rise_transition_min]                           [get_attribute -quiet -class pin $pin actual_fall_transition_max]                           [get_attribute -quiet -class pin $pin actual_fall_transition_min]                           [get_attribute -quiet -class pin $pin arrival_window]                           [get_attribute -quiet -class cell [get_cells -of_objects $pin] ref_name]]
#@             redirect -append $output_file { echo $temp }
#@           }
#@         }
#@         net_attribute {
#@           puts "==>INFORMATION: Generating $report report..."
#@           set output_file $reports_path/$INTEL_DESIGN_NAME.${step}_net_attribute.pv.rpt
#@           redirect output_file {echo [format "%40s " #CAPACITANCE_MAX# ]}
#@           redirect -append $output_file {echo [format "%-20s %-7s %-7s %-7s %-7s %-4s %-15s" #net wire pin Total R_max lth_H  lth_V]}
#@           redirect -append $output_file {echo "#------------------------------------------------------------------------------------------------"}
#@           foreach_in_collection hn [get_nets -hierarchical * ] {
#@             set tmp_val [get_attribute -quiet -class net $hn x_coordinate_max]
#@             if {[info exists tmp_val] && $tmp_val == ""} {
#@               set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-5s %-5s" [get_attribute -quiet -class net $hn full_name]                             [get_attribute -quiet -class net $hn wire_capacitance_max]                             [get_attribute -quiet -class net $hn pin_capacitance_max]                             [get_attribute -quiet -class net $hn total_capacitance_max]                             [get_attribute -quiet -class net $hn net_resistance_max]                             --- ---]
#@             } else {
#@               set temp [format "%-20s %5.2f %5.2f %5.2f %5.2f %-9.2s %-9.2s" [get_attribute -quiet -class net $hn full_name]                             [get_attribute -quiet -class net $hn wire_capacitance_max]                             [get_attribute -quiet -class net $hn pin_capacitance_max]                             [get_attribute -quiet -class net $hn total_capacitance_max]                             [get_attribute -quiet -class net $hn net_resistance_max]                             [expr {[get_attribute -quiet -class net $hn x_coordinate_max] - [get_attribute -quiet -class net $hn x_coordinate_min]}]                             [expr {[get_attribute -quiet -class net $hn y_coordinate_max] - [get_attribute -quiet -class net $hn y_coordinate_min]}]]
#@             }
#@             redirect -append $output_file { echo $temp }
#@           }
#@         }
#@         noise_all_vio {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators -slack_type height -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_all_vio.pv.rpt { report_noise -all_violators                                                                                    -verbose                                                                                    -slack_type height                                                                                    -nosplit }
#@           }
#@         }
#@         noise_below {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_below.pv.rpt { report_noise -below                                                                                  -verbose                                                                                  -slack_type height                                                                                  -nworst 10000                                                                                  -nosplit }
#@           }
#@         }
#@         noise_above {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above -verbose -slack_type height -nworst 10000 -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.noise_above.pv.rpt { report_noise -above                                                                                  -verbose                                                                                  -slack_type height                                                                                  -nworst 10000                                                                                  -nosplit }
#@           }
#@         }
#@         check_noise {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n  P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity} -beyond_rail -verbose}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.check_noise.pv.rpt { check_noise -include {noise_driver noise_immunity}                                                                                  -verbose }
#@           }
#@         }
#@         max_analysis_coverage {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"\n  redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage -status_details untested -check_type \"setup recovery clock_gating_setup out_setup\" -exclude_untested \"user_disabled false_paths constant_disabled\" -sort_by name -nosplit}\n}\n"
#@           } else {
#@             puts "==>INFORMATION: Generating $report report..."
#@             redirect $reports_path/${INTEL_DESIGN_NAME}.max_analysis_coverage.pv.rpt { report_analysis_coverage                                                                                            -status_details untested                                                                                            -check_type "setup recovery clock_gating_setup out_setup"                                                                                            -exclude_untested "user_disabled false_paths"                                                                                            -sort_by name                                                                                            -nosplit }
#@           }
#@         }
#@         switching_activity {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.switching_activity.rpt {report_switching_activity}\n}\n"
#@           }
#@         }
#@ 
#@         hier_switching_activity {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \"Generating $report report...\"  redirect $reports_path/${INTEL_DESIGN_NAME}.hier.switching_activity.rpt { report_switching_activity -hierarchy}\n}\n"
#@           }
#@         }
#@         missing_power_tables {
#@           if {[regexp {^pt} $synopsys_program_name]} {
#@             set rpt_cmd "$rpt_cmd {\n P_msg_info \" Generating $report report \"\n redirect $reports_path/${INTEL_DESIGN_NAME}.no_power_table.rpt {check_power -verbose  -override_defaults missing_table }\n}\n"
#@           }
#@         }
#@         default {
#@           puts "==>WARNING: The defined report \"$report\" is not configured at $step in the default flow."
#@         }
#@       }
#@     }
#@   } else {
#@     puts "==>WARNING: No reports are defined at $step step in the default flow."
#@   }
#@ 
#@   if {[regexp {^pt} $synopsys_program_name]} {
#@     set rpt_cmd "parallel_execute -commands_only {\n $rpt_cmd }"
#@     echo $rpt_cmd
#@     eval $rpt_cmd
#@   }
#@   set _end [clock seconds]
#@   P_msg_info "Runtime for reports: [expr ($_end - $_start)/60.0] minutes"
#@ 
#@ }
#@ 
#@ ### procedure get_logic_levels takes in the output of "get_timing_path"
#@ proc P_get_logic_levels {args} {
#@   parse_proc_arguments -args $args results
#@   if {[info exists results(-paths)] && $results(-paths) != ""} {
#@     set paths $results(-paths)
#@   } elseif {[info exists results(-gtp_options)] && $results(-gtp_options) != ""} {
#@     set paths [eval get_timing_paths $results(-gtp_options)]
#@   } else {
#@     set paths [get_timing_paths -max_paths 25]
#@   }
#@   puts "\nPrining logic levels per start/end point\n"
#@   puts "Startpoint, Endpoint, # of logic cells, slack"
#@   puts "============================================="
#@   foreach_in_collection path $paths {
#@     set slack [get_attribute $path slack]
#@     set startpoint [get_object_name [get_attribute $path startpoint]]
#@     set endpoint [get_object_name [get_attribute $path endpoint]]
#@     set points [get_attribute $path points]
#@     set cells {}
#@     foreach_in_collection point $points {
#@       set obj [get_attribute $point object]
#@       set obj_class [get_attribute $obj object_class]
#@       set dir [get_attribute $obj direction]
#@       if {$dir == "in" && $obj_class == "pin" } {
#@         set cells [add_to_collection $cells [get_cells -of_objects $obj -filter "@is_combinational == true"]]
#@       }
#@     }
#@     puts "$startpoint, $endpoint, [sizeof_collection $cells], $slack"
#@   }
#@ }
#@ 
#@ define_proc_attributes P_get_logic_levels     -info "Prints logic levels in a start/end point pair"     -define_args {
#@       {-paths "output of get_timing_paths command" timing_paths string optional}
#@       {-gtp_options "options to be used by get_timing_paths command" get_timing_path_options string optional}
#@     }
#@ 
#@ ## procedure to create PG terminals on the entire strap of top metal layer to ensure correct FRAM creation
#@ proc P_create_pg_terminals {} {
#@   global INTEL_MAX_PG_LAYER
#@   global INTEL_TERM_LENGTH
#@ 
#@   set pports [get_ports -all -filter "port_type=~*Power* || port_type=~*Ground*"]
#@ 
#@   # Remove existing terminals
#@   set top_layer [string map {m ""} $INTEL_MAX_PG_LAYER]
#@   set filter_exp "layer!=tm1 && layer!=c4b"
#@   for {set i [expr $top_layer + 1]} {[expr $i <= 12]} {incr i} {
#@     set filter_exp "$filter_exp && layer!=m${i}"
#@   }
#@   remove_terminal [get_terminals -of_objects $pports -filter "$filter_exp"]
#@ 
#@   # Create new terminals
#@   set all_pg_nets [get_net_shapes -of_objects [get_nets -all -of_objects $pports] -filter "route_type==pg_strap"]
#@   set top_layer_nets [filter_collection $all_pg_nets "layer==$INTEL_MAX_PG_LAYER"]
#@   set other_nets [remove_from_collection $all_pg_nets $top_layer_nets]
#@ 
#@   # Terminals half DR in size
#@   foreach {metal stub} $INTEL_TERM_LENGTH {
#@     set stub_size($metal) [expr $stub / 2]
#@   }
#@ 
#@   # Get vertical/horizontal edges
#@   set boundary [get_attribute [get_die_area] boundary]
#@   set vert_edges ""
#@   set horz_edges ""
#@   set first 1
#@   foreach point $boundary {
#@     if {$first} {
#@       set first 0
#@     } else {
#@       #  puts "point:$point, prev:$prev"
#@       if {[lindex $point 0] == [lindex $prev 0]} {
#@         # X didn't change, vertical edge
#@         lappend vert_edges [format "%.3f" [lindex $point 0]]
#@       } else {
#@         lappend horz_edges [format "%.3f" [lindex $point 1]]
#@       }
#@     }
#@     set prev $point
#@   }
#@ 
#@   set first_layer 5
#@   for {set i 5} {[expr $i < [string map {m ""} $INTEL_MAX_PG_LAYER]]} {incr i} {
#@     # Create terminal stubs
#@     set layer "m${i}"
#@     P_msg_info "Creating terminals on layer $layer"
#@     foreach_in_collection net_shape [filter_collection $other_nets "layer==$layer"] {
#@       scan [get_attribute $net_shape bbox] "{%f %f} {%f %f}" llx lly urx ury
#@       if {[get_attribute [get_layer $layer] preferred_direction] == "horizontal"} {
#@         # L/R sides
#@         if {[lsearch $vert_edges [format "%.3f" $llx]] > -1} {
#@           set bbox1 [list $llx $lly [expr $llx + $stub_size($layer)] $ury]
#@           create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@         if {[lsearch $vert_edges [format "%.3f" $urx]] > -1} {
#@           set bbox2 [list [expr $urx - $stub_size($layer)] $lly $urx $ury]
#@           create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@       } else {
#@         # T/B sides
#@         if {[lsearch $horz_edges [format "%.3f" $lly]] > -1} {
#@           set bbox1 [list $llx $lly $urx [expr $lly + $stub_size($layer)]]
#@           create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@         if {[lsearch $horz_edges [format "%.3f" $ury]] > -1} {
#@           set bbox2 [list $llx [expr $ury - $stub_size($layer)] $urx $ury]
#@           create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@         }
#@       }
#@       #      create_terminal -bbox $bbox1 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@       #      create_terminal -bbox $bbox2 -layer $layer -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@     }
#@   }
#@ 
#@   # Terminals of top metal layers
#@   P_msg_info "Creating terminals on layer $INTEL_MAX_PG_LAYER"
#@   foreach_in_collection net_shape $top_layer_nets {
#@     create_terminal -bbox [get_attribute $net_shape bbox] -layer $INTEL_MAX_PG_LAYER -port [get_ports -all -of_objects [get_nets -all [get_attribute $net_shape owner_net]]] -no_snap
#@   }
#@ 
#@   proc P_poly2bbox {polygon} {
#@     return [join [list [lindex $polygon 0] [lindex $polygon 2]] " "]
#@   }
#@ 
#@   foreach_in_collection pin_shape [get_pin_shapes -of_objects [get_pins -all -of_objects [all_macro_cells ] -filter "pin_type=~*Power* || pin_type=~*Ground*" -quiet] -filter "layer==$INTEL_MAX_PG_LAYER" -quiet] {
#@     set port [get_ports -all -of_objects [get_nets -all [get_attribute [get_pins -all -of_objects $pin_shape -quiet] net_name -quiet] -quiet] -quiet]
#@     if {[sizeof_collection $port] > 0} {
#@       set points [get_attribute $pin_shape points]
#@       set plength [llength $points]
#@       if {[expr $plength % 5] == 0} {
#@         for {set pi 0} {[expr $pi < $plength]} {set pi [expr $pi + 5]} {
#@           set ppoints [lrange $points $pi [expr $pi + 4]]
#@           create_terminal -bbox [P_poly2bbox $ppoints] -layer $INTEL_MAX_PG_LAYER -port $port -no_snap
#@         }
#@       }
#@     }
#@   }
#@ }
#@ 
#@ proc P_outputs_linkname {} {
#@   global synopsys_program_name
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
#@     set ::output_linkname syn
#@   } else {
#@     set ::output_linkname apr
#@   }
#@ }
#@ 
#@ proc P_outputs_verilog {step} {
#@   global INTEL_DESIGN_NAME
#@   global synopsys_program_name
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.vg
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell"} {
#@     write_file -format verilog -hierarchy -output $output_file
#@   } else {
#@     write_verilog -diode_ports -no_physical_only_cells -no_core_filler_cells -no_tap_cells -unconnected_ports $output_file
#@   }
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.vg outputs/${INTEL_DESIGN_NAME}.${output_linkname}.vg
#@ }
#@ 
#@ proc P_outputs_verilog_pg {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}_lvs.vg
#@   write_verilog -pg -diode_ports -unconnected_ports -output_net_name_for_tie $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}_lvs.vg outputs/${INTEL_DESIGN_NAME}.${output_linkname}_lvs.vg
#@ }
#@ 
#@ proc P_outputs_upf {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.upf
#@   save_upf $output_file
#@   P_msg_info "Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.upf outputs/${INTEL_DESIGN_NAME}.${output_linkname}.upf
#@ }
#@ 
#@ 
#@ proc P_outputs_spef {step} {
#@   global synopsys_program_name
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   if {($synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell")  && [shell_is_in_topographical_mode]} {
#@     write_parasitics -format distributed -output ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     if {[file exists ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz]} {
#@       sh rm ./outputs/${INTEL_DESIGN_NAME}.${step}.spef.gz
#@     }
#@     sh gzip ./outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.gz
#@   } elseif {$synopsys_program_name != "dc_shell"} {
#@     global INTEL_DESIGN_NAME
#@     extract_rc -coupling_cap
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.spef
#@     write_parasitics -format SPEF -compress -output $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}.max.gz ${output_file}.min.gz"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.max.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.max.gz
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.spef.min.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.spef.min.gz
#@   }
#@ }
#@ 
#@ proc P_outputs_def {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   global synopsys_program_name
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
#@   if {($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode]) || $synopsys_program_name == "de_shell" } {
#@     write_def -output $output_file -placed
#@ 		sh ln -fs ${INTEL_DESIGN_NAME}.${step}.def outputs/${INTEL_DESIGN_NAME}.${output_linkname}.def
#@     puts "==>INFORMATION: Output file: ${INTEL_DESIGN_NAME}.${step}.def"
#@   } elseif {$synopsys_program_name == "icc_shell" } {
#@     write_def -compressed -output $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}.gz"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.def.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.def.gz
#@   }
#@ }
#@ 
#@ proc P_outputs_techlef {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tech.lef
#@   set libpath  [file dirname [ get_attribute [current_mw_lib] path]]
#@   set libname [get_attribute [current_mw_lib] name]
#@   set f_out [open write_lef.tcl "w"]
#@   puts $f_out "write_lef -output_version 5.5 -lib_name $libpath/$libname -ignore_tech_signal_em -ignore_tech_antenna_rule -ignore_cell_geom $output_file"
#@   puts $f_out "exit"
#@   close $f_out
#@   if {[catch {sh which Milkyway} id] } {
#@     puts "==>WARNING: Milkyway tool not set, techlef cannot be generated"
#@   } else {
#@     exec Milkyway -nullDisplay -nogui -tcl -file ./write_lef.tcl -logd logs/mw -cmdd logs/mw >& /dev/null
#@   } 
#@   sh rm ./write_lef.tcl
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.tech.lef outputs/${INTEL_DESIGN_NAME}.${output_linkname}.tech.lef
#@ }
#@ 
#@ proc P_syn_output_def {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_SCRIPTS_SEARCH_PATH
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.def
#@   set file1 icc_dp.tcl
#@   if {[catch {sh which icc_shell} id] } {
#@     puts "ICC is not set , def file cannot be geneartaed"
#@   } else {
#@     set iccpath [sh which icc_shell]
#@     set_icc_dp_options -icc_executable $iccpath
#@     foreach search_dir $INTEL_SCRIPTS_SEARCH_PATH {
#@       if {[file exists [ file join $search_dir $file1]] } {
#@         set file_icc_dp [file join $search_dir $file1]
#@       }
#@     }
#@     start_icc_dp -f $file_icc_dp
#@     if { [file exists icc_dp_error] } {
#@       puts "WARNING: cannot write def file due to error in icc_dp"
#@     }
#@   }
#@ }
#@ 
#@ proc P_outputs_fp {step} {
#@   global INTEL_DESIGN_NAME
#@ 
#@   ### All floorplan contents
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.tcl
#@   write_floorplan -all $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@ 
#@   ### Hard macro placements only
#@   if {[sizeof_collection [all_macro_cells]] != 0} {
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.macro_placement.tcl
#@     write_floorplan -placement { hard_macro }  -no_placement_blockage -no_bound         -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary         $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}"
#@   }
#@ 
#@   ### IO placements only
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.io_placement.tcl
#@   write_floorplan -placement { terminal }  -no_placement_blockage -no_bound       -no_plan_group  -no_voltage_area -no_route_guide -no_create_boundary       $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@ }
#@ 
#@ proc P_outputs_sdc {step} {
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   global synopsys_program_name
#@ 
#@   P_outputs_linkname
#@ 
#@   set act_scenarios ""
#@   if {$synopsys_program_name == "icc_shell" || $synopsys_program_name == "de_shell"  || ($synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode])} {
#@     set act_scenarios [all_active_scenarios]
#@   }
#@   if { $act_scenarios == ""} {
#@     set output_file outputs/${INTEL_DESIGN_NAME}.${step}.sdc.orig
#@     write_sdc -nosplit $output_file
#@     puts "==>INFORMATION: Output file: ${output_file}"
#@     if { [file exists $output_file ] } {
#@       set org_sdc [ open $output_file ]
#@       set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.sdc w]
#@       while { [ gets $org_sdc line ] != -1 } {
#@         if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
#@           set new_line [concat #$line]
#@           puts $mod_sdc "$new_line"
#@         } else {
#@           puts $mod_sdc "$line"
#@         }
#@       }
#@       close $org_sdc
#@       close $mod_sdc
#@     }
#@     puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.sdc"
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.sdc
#@ 
#@   } else {
#@     foreach scenario [all_active_scenarios] {
#@       set output_file outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc.orig
#@       write_sdc -nosplit $output_file
#@       puts "==>INFORMATION: Output file: ${output_file}"
#@ 
#@       #Modify SDC for PV usage
#@       if { [file exists $output_file ] } {
#@         set org_sdc [ open $output_file ]
#@         set mod_sdc [ open outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc w]
#@         while { [ gets $org_sdc line ] != -1 } {
#@           if {[regexp {set_operating_conditions|set_drive|set_wire_load|set_timing_derate|set_max_dynamic_power|create_voltage_area|set_max_leakage_power|set_resistance|set_max_time_borrow|set_load.*get_net} $line match]} {
#@             set new_line [concat #$line]
#@             puts $mod_sdc "$new_line"
#@           } else {
#@             puts $mod_sdc "$line"
#@           }
#@         }
#@         close $org_sdc
#@         close $mod_sdc
#@       }
#@       puts "==>INFORMATION: Output file: outputs/${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc"
#@       sh ln -fs ${INTEL_DESIGN_NAME}.${step}.${scenario}.sdc outputs/${INTEL_DESIGN_NAME}.${output_linkname}.${scenario}.sdc
#@     }
#@   }
#@ }
#@ 
#@ 
#@ proc P_outputs_saif {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_SAIF
#@   global synopsys_program_name
#@   if {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell" } {
#@     saif_map -end
#@     saif_map -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap
#@     if {[info exists INTEL_SAIF] && $INTEL_SAIF == 1} {
#@       saif_map -type ptpx -write_map ./outputs/${INTEL_DESIGN_NAME}.${step}.saif.namemap.ptpx
#@ 
#@     }
#@     set_vsdc -off
#@   }
#@ }
#@ 
#@ proc P_outputs_scandef {step} {
#@   global INTEL_INSERT_SCAN
#@   global INTEL_DESIGN_NAME
#@   global output_linkname
#@   P_outputs_linkname
#@   if {[info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN == 1} {
#@     puts "==>INFORMATION: writing a scandef since INTEL_INSERT_SCAN is set to $INTEL_INSERT_SCAN"
#@     write_scan_def -output ./outputs/${INTEL_DESIGN_NAME}.${step}.scandef
#@     sh ln -fs ${INTEL_DESIGN_NAME}.${step}.scandef outputs/${INTEL_DESIGN_NAME}.${output_linkname}.scandef
#@   }
#@ }
#@ 
#@ 
#@ proc P_outputs_oas {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@   P_outputs_linkname
#@   set_write_stream_options -reset
#@   set_write_stream_options       -map_fill_data       -output_first_same_name_cell       -skip_global_route_contact       -contact_prefix X       -child_depth 1000       -output_filling fill       -output_outdated_fill       -output_pin {text geometry}       -keep_data_type       -map_layer $INTEL_GDS_OUT_LAYER_MAP       -output_instance_name_as_property 112       -max_name_length 128       -output_net text
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
#@   write_stream -cells $INTEL_DESIGN_NAME -format oasis $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.oas outputs/${INTEL_DESIGN_NAME}.${output_linkname}.oas
#@ }
#@ 
#@ 
#@ #proc P_outputs_oas {step} {
#@ #   global INTEL_DESIGN_NAME
#@ #   global fdk_asic_flows_dir
#@ #
#@ #   if {$step == "fill"} {
#@ #      set output_file outputs/${INTEL_DESIGN_NAME}.apr.oas
#@ #      set gds_file outputs/${INTEL_DESIGN_NAME}.apr.gds.gz
#@ #      echo "Need GDS file to create OAS. Creating GDS..."
#@ #      P_outputs_gds apr
#@ #   } else {
#@ #      set output_file outputs/${INTEL_DESIGN_NAME}.${step}.oas
#@ #      set gds_file outputs/${INTEL_DESIGN_NAME}.${step}.gds.gz
#@ #      echo "Need GDS file to create OAS. Creating GDS..."
#@ #      P_outputs_gds $step
#@ #   }
#@ #
#@ #   puts "==>INFORMATION: Generating OAS database using Calibre"
#@ #   set gds2oas_script $fdk_asic_flows_dir/apr/layout_merge_calibre.tcl
#@ #   set status [catch {sh calibredrv -64 $gds2oas_script convert $gds_file $output_file oas} msg]
#@ #   echo "$msg";
#@ #   puts "==>INFORMATION: Generated OAS database"
#@ #}
#@ 
#@ 
#@ proc P_outputs_gds {step} {
#@   global INTEL_DESIGN_NAME
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@   P_outputs_linkname
#@   set_write_stream_options -reset
#@   set_write_stream_options       -map_fill_data       -child_depth 1000       -output_filling fill       -output_outdated_fill       -output_pin {text geometry}       -keep_data_type       -map_layer $INTEL_GDS_OUT_LAYER_MAP       -output_instance_name_as_property 112       -max_name_length 128       -output_net text       -compressed
#@   set output_file outputs/${INTEL_DESIGN_NAME}.${step}.gds.gz
#@   write_stream -cells $INTEL_DESIGN_NAME -format gds $output_file
#@   puts "==>INFORMATION: Output file: ${output_file}"
#@   sh ln -fs ${INTEL_DESIGN_NAME}.${step}.gds.gz outputs/${INTEL_DESIGN_NAME}.${output_linkname}.gds.gz
#@ }
#@ 
#@ proc P_outputs_fram {step} {
#@   global INTEL_MAX_PG_LAYER
#@   global INTEL_DESIGN_NAME
#@ 
#@   P_create_pg_terminals; #Creates PG terminals on the entire strap of top metal layer
#@ 
#@ 
#@   # Create macro fram work around give by SNPS:
#@   # 1. Create_macro_fram with default setting, so you will get the top metal layer blockages. Write out the top level blockages to a file.
#@   # 2. Create_macro_fram with no top layer blockage setting, so you can get all the VIAN-1 extracted. And then read the files contain the top level blockages to the FRAM and save the FRAM, by doing this, you get both VIAN-1 vias and the top level blockages in your FRAM view.
#@ 
#@ 
#@   # Open temp file to right fram info
#@   set fp [open "scripts/.fram.tcl" w+]
#@   set my_mw_cel [get_object_name [current_mw_cel]]
#@ 
#@ 
#@   if {$INTEL_MAX_PG_LAYER=="m12"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m14 -1.0 m15 -1.0} -extract_via_on_layer V12 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m12] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m12 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V12 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   }  elseif {$INTEL_MAX_PG_LAYER=="m11"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V11 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m11] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m11 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V11 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m10"} {
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V10 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m10] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m10 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V10 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m9"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V9 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m9] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m9 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V9 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m8"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V8 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m8] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m8 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V8 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m7"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V7 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m7] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m7 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V7 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m6"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V6 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m6] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m6 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V6 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m5"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V5 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m5] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m5 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V5 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m4"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V4 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m4] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m4 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V4 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } elseif {$INTEL_MAX_PG_LAYER=="m3"} {
#@ 
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name "$my_mw_cel"         -extract_blockage_by_block_core_with_margin {m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V3 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     foreach bbox [get_attribute [get_user_shapes -filter layer==m3] bbox] {
#@       puts $fp "create_user_shape -bbox \"$bbox\" -layer m3 -route_type user_enter"
#@     }
#@     # Remove unwanted base layers in FRAM because they are output in LEF
#@     puts $fp {remove_user_shape [get_user_shapes -filter {layer==gcn || layer==nwell}]}
#@     flush $fp
#@ 
#@     close $fp
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     create_macro_fram -library_name ${INTEL_DESIGN_NAME}_LIB -cell_name [get_object_name [current_mw_cel]]         -extract_blockage_by_block_core_with_margin {m4 -1.0 m5 -1.0 m6 -1.0 m7 -1.0 m8 -1.0 m9 -1.0 m10 -1.0 m11 -1.0 m12 -1.0 m13 -1.0 m14 -1.0 m15 -1.0} -extract_via_on_layer V3 -treat_all_blockage_as_thin_wire
#@     open_mw_cel "$my_mw_cel.FRAM"
#@     source "scripts/.fram.tcl"
#@     save_mw_cel "$my_mw_cel.FRAM"
#@     close_mw_cel "$my_mw_cel.FRAM"
#@     current_mw_cel $my_mw_cel
#@     link -force;
#@     P_msg_info "Output file: $my_mw_cel.FRAM"
#@ 
#@   } else {
#@     P_msg_error "FRAM view is not properly created."
#@   }
#@ }
#@ 
#@ proc P_outputs_lteloc {step} {
#@   global INTEL_DESIGN_NAME
#@ 
#@   set output_file ./outputs/${INTEL_DESIGN_NAME}.${step}.xyv
#@   P_create_xyv_icc -step $step
#@   P_msg_info "Output file: ${output_file}"
#@ }
#@ 
#@ proc P_outputs {step} {
#@   global INTEL_DESIGN_NAME INTEL_UPF INTEL_SPG INTEL_INSERT_SCAN INTEL_SCAN_REPLACE_FLOPS
#@   global INTEL_OUTPUTS
#@   global INTEL_GDS_OUT_LAYER_MAP
#@   global output_linkname
#@ 
#@   if {[info exists INTEL_OUTPUTS($step)]} {
#@     set step_name $step
#@     foreach v $INTEL_OUTPUTS($step) {
#@       #         puts "==>INFORMATION: Writing an output $v"
#@       switch -exact -- $v {
#@         verilog {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_verilog $step_name
#@         }
#@         verilog_pg {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_verilog_pg $step_name
#@         }
#@         upf {
#@           if { ![info exists INTEL_UPF] } {
#@             P_msg_warn "Skip generating output $v because INTEL_UPF var not exist!"
#@           } elseif { !$INTEL_UPF } {
#@             P_msg_warn "Skip generating output $v because INTEL_UPF is '$INTEL_UPF' instead of '1'!"
#@           } else {
#@             P_msg_info "Generating an output $v"
#@             P_outputs_upf $step_name
#@           }
#@         }
#@         spef {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_spef $step_name
#@         }
#@         def {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_def $step_name
#@         }
#@         techlef {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_techlef $step_name
#@         }
#@         syn_def {
#@           if  { [shell_is_in_topographical_mode] && $INTEL_SPG == 1 } {
#@             puts "==>INFORMATION: Generating an output $v"
#@             P_syn_output_def $step_name
#@           } else {
#@             P_msg_warn "Skip generating def file as spg option is turned off"
#@           }
#@         }
#@         fp {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_fp $step_name
#@         }
#@         sdc {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_sdc $step_name
#@         }
#@         saif {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_saif $step_name
#@         }
#@         scandef {
#@           if {$INTEL_SCAN_REPLACE_FLOPS==1 && $INTEL_INSERT_SCAN==1} {
#@             puts "==>INFORMATION: Generating an output $v"
#@             P_outputs_scandef $step_name
#@           } else {
#@             puts "==>INFORMATION : either INTEL_INSERT_SCAN or INTEL_SCAN_REPLACE_FLOPS are turned off , No scnadef will be generated"
#@           }
#@         }
#@         oas {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_oas $step_name
#@         }
#@         gds {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_gds $step_name
#@         }
#@         lteloc {
#@           puts "==>INFORMATION: Generating an output $v"
#@           P_outputs_lteloc $step_name
#@         }
#@         fram {
#@           P_msg_info "Generating an output $v"
#@           P_outputs_fram $step_name
#@         }
#@ 
#@         default {
#@           puts "==>WARNING: The defined output is not configured at $step in the default flow"
#@         }
#@       }
#@     }
#@   } else {
#@     puts "==>WARNING: No outputs are defined at $step step in the default flow"
#@   }
#@ }
#@ 
#@ ##############################################################################
#@ ## Define procedure: P_check_place_overlap
#@ ## This proc checks for overlapped cells
#@ ## Usage: P_check_place_overlap
#@ ##############################################################################
#@ proc P_check_place_overlap {} {
#@   P_msg_info " Checking for cell overlap "
#@   set legalize_support_phys_only_cell true
#@   redirect -file ./temp_check_legality_v0.txt {check_legality -verbose}
#@   #takes care the CTS spacer cells
#@   sh grep -v "cts_fill" ./temp_check_legality_v0.txt 1> ./temp_check_legality.txt
#@ 
#@   #check if no cells overlap ( count the number of lines in the ./temp_overlap.txt )
#@   set fd [open "./temp_check_legality.txt" "r"]
#@   set count 0;
#@   set pattern "overlaps with cell"
#@   while {[gets $fd line] > -1 } {
#@     set isMatch [string match *$pattern* $line]
#@     if { $isMatch != 0 } {
#@       incr count 1
#@     }
#@   }
#@   close $fd
#@ 
#@   echo $count
#@ 
#@ 
#@   if { $count == 0 } {
#@     P_msg_info " There is no overlapped cells "
#@   } else {
#@     #there is some overlap cells, now post process that cells
#@     sh grep "overlaps with cell" ./temp_check_legality.txt 1> ./temp_overlap.txt
#@     #create awk script for log file post processing
#@     set fd [open "./temp_post_process.awk" "w"]
#@     puts $fd "{ if (NF == 9 || NF == 8)"
#@     puts $fd "   print \$3;"
#@     puts $fd " else if (NF == 10) "
#@     puts $fd "   print \$5;"
#@     puts $fd "}"
#@     close $fd
#@     #run awk script
#@     sh awk -f ./temp_post_process.awk ./temp_overlap.txt  > ./temp_overlap_cell.txt
#@     #post-process the overlapped cells
#@     set list_overlap {}
#@     set fd [open "./temp_overlap_cell.txt" "r"]
#@     while {[gets $fd line] > -1} {
#@       lappend list_overlap $line
#@     }
#@     close $fd
#@     #print cell_type and cell name of overlapped cells
#@     foreach cell_overlap $list_overlap {
#@       set cell_name [get_attribute $cell_overlap full_name]
#@       set cell_type [get_attribute $cell_overlap ref_name]
#@       P_msg_error "Overlap Cell in place: $cell_type : $cell_name"
#@     }
#@     #remove all temporary files
#@     sh rm ./temp_check_legality_v0.txt
#@     sh rm ./temp_check_legality.txt
#@     sh rm ./temp_overlap.txt
#@     sh rm ./temp_overlap_cell.txt
#@     sh rm ./temp_post_process.awk
#@   }
#@   P_msg_info " Done: Checking for cell overlap "
#@ }
#@ 
#@ ##################################################################
#@ # Procedure   : P_check_cells
#@ # Description : This proc checks if specified cells are used in the list of instances.
#@ #               when given a list of reference cell names and a list of instances,
#@ #               if the instance cell matches any cell in the reference cell list,
#@ #               it flags it as a warning or error depending on the flag.
#@ # Usage: P_check_cells <ref_list> <inst_list> <msg> <flag>
#@ # Example: P_check_cells $ref_list $inst_list $msg $flag
#@ # $ref_list : list of cells to check
#@ # $inst_list : collection of instance to check
#@ # $msg: message prefix
#@ # $flag: indicates to print as warning or error (P_msg_warn or P_msg_err)
#@ ###################################################################
#@ 
#@ proc P_check_cells {ref_list inst_list msg flag} {
#@   P_msg_info "Checking cells in the design..."
#@   #collection of instances to check
#@   set coll_of_insts $inst_list
#@   #flag message depending on the flag value: Error or Warning
#@   if { $flag == "err" } {
#@     set flag_local "P_msg_error"
#@   } elseif { $flag == "warn" } {
#@     set flag_local "P_msg_warn"
#@   } else {
#@     set flag_local "P_msg_info"
#@   }
#@   set dont_use_list [list]
#@ 
#@   foreach cell $ref_list {
#@     if {$cell ne ""} {
#@       set pattern "(ref_name=~[join $cell {) || (ref_name =~} ])"
#@       lappend dont_use_list $pattern
#@     }
#@   }
#@   set dont_use_expr [join $dont_use_list || ]
#@   set ic_cntr  0
#@   foreach_in_collection c [get_cells $inst_list -filter "is_hierarchical==false && $dont_use_expr"  -quiet] {
#@     set c_name [get_attribute $c full_name]
#@     $flag_local "$c_name is a $msg [get_attribute $c ref_name]"
#@     incr ic_cntr
#@   }
#@ 
#@   if {!$ic_cntr} {
#@     P_msg_info "No dont_use cells found in your design"
#@   } else {
#@     $flag_local "$ic_cntr dont_use cells found in your design"
#@   }
#@ 
#@   P_msg_info "Done: Checking cells in the design..."
#@ }
#@ 
#@ define_proc_attributes P_check_cells     -info "Procedure to check if ref cells are used in the list of instances"
#@ 
#@ 
#@ ###########################################################################################
#@ # check if there are any shorts or opens or floating on power/ground nets
#@ # The script parse the verify_lvs reports
#@ # if there are any shorts/opens/floatings on PG, this script will issue an error message
#@ # if user see error message, user may look more detail on the verify_lvs reports
#@ 
#@ ###########################################################################################
#@ 
#@ proc P_check_power_ground_nets {} {
#@   P_msg_info "Check if there are any shorts or opens on power/ground nets"
#@ 
#@   #set DEBUG 1
#@   set DEBUG 0
#@   global INTEL_MW_POWER_NET INTEL_MW_GROUND_NET
#@ 
#@   set icc_pg_nets "$INTEL_MW_POWER_NET $INTEL_MW_GROUND_NET"
#@   redirect -file ./temp_verify_lvs_pg.txt {verify_lvs  -nets $icc_pg_nets }
#@ 
#@   set fd [open "./temp_verify_lvs_pg.txt" "r"]
#@   set err_count 0; set war_count 0;
#@   set pattern1 "Total Floating Nets are 1"
#@   set pattern2 "Total Floating Nets are 2"
#@   set pattern3 "Total SHORT Nets are 1"
#@   set pattern4 "Total SHORT Nets are 2"
#@   set pattern5 "Total OPEN Nets are 1"
#@   set pattern6 "Total OPEN Nets are 2"
#@ 
#@   while {[gets $fd line] > -1} {
#@     set isMatch1 [string match *$pattern1* $line]
#@     set isMatch2 [string match *$pattern2* $line]
#@     set isMatch3 [string match *$pattern3* $line]
#@     set isMatch4 [string match *$pattern4* $line]
#@     set isMatch5 [string match *$pattern5* $line]
#@     set isMatch6 [string match *$pattern5* $line]
#@     set errMatch [expr $isMatch3 || $isMatch4 || $isMatch5 || $isMatch6]
#@     set warMatch [expr $isMatch1 || $isMatch2]
#@     if { $errMatch != 0 } {
#@       incr err_count 1;
#@     }
#@     if { $warMatch != 0 } {
#@       incr war_count 1;
#@     }
#@   }
#@   close $fd
#@ 
#@   if {$DEBUG} {puts $err_count}
#@ 
#@   if { $err_count > 0 } {
#@     P_msg_error " Power/Ground net has short/open\n                Please review the verify_lvs reports for more information"
#@   }
#@   if { $war_count > 0 } {
#@     P_msg_warn " Power/Ground net has floating\n                Please review the verify_lvs reports for more information"
#@   }
#@ 
#@   #unset temporary variables
#@   unset -nocomplain pattern1 pattern2 pattern3 pattern4 pattern5 pattern6 isMatch1 isMatch2 isMatch4 isMatch5 isMatch6 anyMatch count icc_pg_nets fd
#@   #remove all temporary files
#@   sh rm ./temp_verify_lvs_pg.txt
#@   P_msg_info "Done: Check if there are any shorts or opens on power/ground nets"
#@ 
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## End Of File
#@ ## -----------------------------------------------------------------------------
#@ 
#@ puts "==>ENDING: [info script] END TIME: [date] RUNTIME in (hh:mm:ss): [clock format [expr [clock seconds] - $start_time] -format %T -gmt 1] MEMORY: [mem]KB"
#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ # msgcat.tcl --
#@ #
#@ #	This file defines various procedures which implement a
#@ #	message catalog facility for Tcl programs.  It should be
#@ #	loaded with the command "package require msgcat".
#@ #
#@ # Copyright (c) 1998-2000 by Ajuba Solutions.
#@ # Copyright (c) 1998 by Mark Harrison.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ package require Tcl 8.5
#@ # When the version number changes, be sure to update the pkgIndex.tcl file,
#@ # and the installation directory in the Makefiles.
#@ package provide msgcat 1.4.5
#@ 
#@ namespace eval msgcat {
#@     namespace export mc mcload mclocale mcmax mcmset mcpreferences mcset 	    mcunknown
#@ 
#@     # Records the current locale as passed to mclocale
#@     variable Locale ""
#@ 
#@     # Records the list of locales to search
#@     variable Loclist {}
#@ 
#@     # Records the mapping between source strings and translated strings.  The
#@     # dict key is of the form "<locale> <namespace> <src>", where locale and
#@     # namespace should be themselves dict values and the value is
#@     # the translated string.
#@     variable Msgs [dict create]
#@ 
#@     # Map of language codes used in Windows registry to those of ISO-639
#@     if {[info sharedlibextension] eq ".dll"} {
#@ 	variable WinRegToISO639 [dict create  {*}{
#@ 	    01 ar 0401 ar_SA 0801 ar_IQ 0c01 ar_EG 1001 ar_LY 1401 ar_DZ
#@ 		  1801 ar_MA 1c01 ar_TN 2001 ar_OM 2401 ar_YE 2801 ar_SY
#@ 		  2c01 ar_JO 3001 ar_LB 3401 ar_KW 3801 ar_AE 3c01 ar_BH
#@ 		  4001 ar_QA
#@ 	    02 bg 0402 bg_BG
#@ 	    03 ca 0403 ca_ES
#@ 	    04 zh 0404 zh_TW 0804 zh_CN 0c04 zh_HK 1004 zh_SG 1404 zh_MO
#@ 	    05 cs 0405 cs_CZ
#@ 	    06 da 0406 da_DK
#@ 	    07 de 0407 de_DE 0807 de_CH 0c07 de_AT 1007 de_LU 1407 de_LI
#@ 	    08 el 0408 el_GR
#@ 	    09 en 0409 en_US 0809 en_GB 0c09 en_AU 1009 en_CA 1409 en_NZ
#@ 		  1809 en_IE 1c09 en_ZA 2009 en_JM 2409 en_GD 2809 en_BZ
#@ 		  2c09 en_TT 3009 en_ZW 3409 en_PH
#@ 	    0a es 040a es_ES 080a es_MX 0c0a es_ES@modern 100a es_GT 140a es_CR
#@ 		  180a es_PA 1c0a es_DO 200a es_VE 240a es_CO 280a es_PE
#@ 		  2c0a es_AR 300a es_EC 340a es_CL 380a es_UY 3c0a es_PY
#@ 		  400a es_BO 440a es_SV 480a es_HN 4c0a es_NI 500a es_PR
#@ 	    0b fi 040b fi_FI
#@ 	    0c fr 040c fr_FR 080c fr_BE 0c0c fr_CA 100c fr_CH 140c fr_LU
#@ 		  180c fr_MC
#@ 	    0d he 040d he_IL
#@ 	    0e hu 040e hu_HU
#@ 	    0f is 040f is_IS
#@ 	    10 it 0410 it_IT 0810 it_CH
#@ 	    11 ja 0411 ja_JP
#@ 	    12 ko 0412 ko_KR
#@ 	    13 nl 0413 nl_NL 0813 nl_BE
#@ 	    14 no 0414 no_NO 0814 nn_NO
#@ 	    15 pl 0415 pl_PL
#@ 	    16 pt 0416 pt_BR 0816 pt_PT
#@ 	    17 rm 0417 rm_CH
#@ 	    18 ro 0418 ro_RO 0818 ro_MO
#@ 	    19 ru 0819 ru_MO
#@ 	    1a hr 041a hr_HR 081a sr_YU 0c1a sr_YU@cyrillic
#@ 	    1b sk 041b sk_SK
#@ 	    1c sq 041c sq_AL
#@ 	    1d sv 041d sv_SE 081d sv_FI
#@ 	    1e th 041e th_TH
#@ 	    1f tr 041f tr_TR
#@ 	    20 ur 0420 ur_PK 0820 ur_IN
#@ 	    21 id 0421 id_ID
#@ 	    22 uk 0422 uk_UA
#@ 	    23 be 0423 be_BY
#@ 	    24 sl 0424 sl_SI
#@ 	    25 et 0425 et_EE
#@ 	    26 lv 0426 lv_LV
#@ 	    27 lt 0427 lt_LT
#@ 	    28 tg 0428 tg_TJ
#@ 	    29 fa 0429 fa_IR
#@ 	    2a vi 042a vi_VN
#@ 	    2b hy 042b hy_AM
#@ 	    2c az 042c az_AZ@latin 082c az_AZ@cyrillic
#@ 	    2d eu
#@ 	    2e wen 042e wen_DE
#@ 	    2f mk 042f mk_MK
#@ 	    30 bnt 0430 bnt_TZ
#@ 	    31 ts 0431 ts_ZA
#@ 	    32 tn
#@ 	    33 ven 0433 ven_ZA
#@ 	    34 xh 0434 xh_ZA
#@ 	    35 zu 0435 zu_ZA
#@ 	    36 af 0436 af_ZA
#@ 	    37 ka 0437 ka_GE
#@ 	    38 fo 0438 fo_FO
#@ 	    39 hi 0439 hi_IN
#@ 	    3a mt 043a mt_MT
#@ 	    3b se 043b se_NO
#@ 	    043c gd_UK 083c ga_IE
#@ 	    3d yi 043d yi_IL
#@ 	    3e ms 043e ms_MY 083e ms_BN
#@ 	    3f kk 043f kk_KZ
#@ 	    40 ky 0440 ky_KG
#@ 	    41 sw 0441 sw_KE
#@ 	    42 tk 0442 tk_TM
#@ 	    43 uz 0443 uz_UZ@latin 0843 uz_UZ@cyrillic
#@ 	    44 tt 0444 tt_RU
#@ 	    45 bn 0445 bn_IN
#@ 	    46 pa 0446 pa_IN
#@ 	    47 gu 0447 gu_IN
#@ 	    48 or 0448 or_IN
#@ 	    49 ta
#@ 	    4a te 044a te_IN
#@ 	    4b kn 044b kn_IN
#@ 	    4c ml 044c ml_IN
#@ 	    4d as 044d as_IN
#@ 	    4e mr 044e mr_IN
#@ 	    4f sa 044f sa_IN
#@ 	    50 mn
#@ 	    51 bo 0451 bo_CN
#@ 	    52 cy 0452 cy_GB
#@ 	    53 km 0453 km_KH
#@ 	    54 lo 0454 lo_LA
#@ 	    55 my 0455 my_MM
#@ 	    56 gl 0456 gl_ES
#@ 	    57 kok 0457 kok_IN
#@ 	    58 mni 0458 mni_IN
#@ 	    59 sd
#@ 	    5a syr 045a syr_TR
#@ 	    5b si 045b si_LK
#@ 	    5c chr 045c chr_US
#@ 	    5d iu 045d iu_CA
#@ 	    5e am 045e am_ET
#@ 	    5f ber 045f ber_MA
#@ 	    60 ks 0460 ks_PK 0860 ks_IN
#@ 	    61 ne 0461 ne_NP 0861 ne_IN
#@ 	    62 fy 0462 fy_NL
#@ 	    63 ps
#@ 	    64 tl 0464 tl_PH
#@ 	    65 div 0465 div_MV
#@ 	    66 bin 0466 bin_NG
#@ 	    67 ful 0467 ful_NG
#@ 	    68 ha 0468 ha_NG
#@ 	    69 nic 0469 nic_NG
#@ 	    6a yo 046a yo_NG
#@ 	    70 ibo 0470 ibo_NG
#@ 	    71 kau 0471 kau_NG
#@ 	    72 om 0472 om_ET
#@ 	    73 ti 0473 ti_ET
#@ 	    74 gn 0474 gn_PY
#@ 	    75 cpe 0475 cpe_US
#@ 	    76 la 0476 la_VA
#@ 	    77 so 0477 so_SO
#@ 	    78 sit 0478 sit_CN
#@ 	    79 pap 0479 pap_AN
#@ 	}]
#@     }
#@ }
#@ 
#@ # msgcat::mc --
#@ #
#@ #	Find the translation for the given string based on the current
#@ #	locale setting. Check the local namespace first, then look in each
#@ #	parent namespace until the source is found.  If additional args are
#@ #	specified, use the format command to work them into the traslated
#@ #	string.
#@ #
#@ # Arguments:
#@ #	src	The string to translate.
#@ #	args	Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated string.  Propagates errors thrown by the
#@ #	format command.
#@ 
#@ proc msgcat::mc {src args} {
#@     # Check for the src in each namespace starting from the local and
#@     # ending in the global.
#@ 
#@     variable Msgs
#@     variable Loclist
#@     variable Locale
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     while {$ns != ""} {
#@ 	foreach loc $Loclist {
#@ 	    if {[dict exists $Msgs $loc $ns $src]} {
#@ 		if {[llength $args] == 0} {
#@ 		    return [dict get $Msgs $loc $ns $src]
#@ 		} else {
#@ 		    return [format [dict get $Msgs $loc $ns $src] {*}$args]
#@ 		}
#@ 	    }
#@ 	}
#@ 	set ns [namespace parent $ns]
#@     }
#@     # we have not found the translation
#@     return [uplevel 1 [list [namespace origin mcunknown] 	    $Locale $src {*}$args]]
#@ }
#@ 
#@ # msgcat::mclocale --
#@ #
#@ #	Query or set the current locale.
#@ #
#@ # Arguments:
#@ #	newLocale	(Optional) The new locale string. Locale strings
#@ #			should be composed of one or more sublocale parts
#@ #			separated by underscores (e.g. en_US).
#@ #
#@ # Results:
#@ #	Returns the current locale.
#@ 
#@ proc msgcat::mclocale {args} {
#@     variable Loclist
#@     variable Locale
#@     set len [llength $args]
#@ 
#@     if {$len > 1} {
#@ 	return -code error "wrong # args: should be		\"[lindex [info level 0] 0] ?newLocale?\""
#@     }
#@ 
#@     if {$len == 1} {
#@ 	set newLocale [lindex $args 0]
#@ 	if {$newLocale ne [file tail $newLocale]} {
#@ 	    return -code error "invalid newLocale value \"$newLocale\":		    could be path to unsafe code."
#@ 	}
#@ 	set Locale [string tolower $newLocale]
#@ 	set Loclist {}
#@ 	set word ""
#@ 	foreach part [split $Locale _] {
#@ 	    set word [string trim "${word}_${part}" _]
#@ 	    if {$word ne [lindex $Loclist 0]} {
#@ 		set Loclist [linsert $Loclist 0 $word]
#@ 	    }
#@ 	}
#@ 	lappend Loclist {}
#@ 	set Locale [lindex $Loclist 0]
#@     }
#@     return $Locale
#@ }
#@ 
#@ # msgcat::mcpreferences --
#@ #
#@ #	Fetch the list of locales used to look up strings, ordered from
#@ #	most preferred to least preferred.
#@ #
#@ # Arguments:
#@ #	None.
#@ #
#@ # Results:
#@ #	Returns an ordered list of the locales preferred by the user.
#@ 
#@ proc msgcat::mcpreferences {} {
#@     variable Loclist
#@     return $Loclist
#@ }
#@ 
#@ # msgcat::mcload --
#@ #
#@ #	Attempt to load message catalogs for each locale in the
#@ #	preference list from the specified directory.
#@ #
#@ # Arguments:
#@ #	langdir		The directory to search.
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::mcload {langdir} {
#@     set x 0
#@     foreach p [mcpreferences] {
#@ 	if { $p eq {} } {
#@ 	    set p ROOT
#@ 	}
#@ 	set langfile [file join $langdir $p.msg]
#@ 	if {[file exists $langfile]} {
#@ 	    incr x
#@ 	    uplevel 1 [list ::source -encoding utf-8 $langfile]
#@ 	}
#@     }
#@     return $x
#@ }
#@ 
#@ # msgcat::mcset --
#@ #
#@ #	Set the translation for a given string in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	src		The source string.
#@ #	dest		(Optional) The translated string.  If omitted,
#@ #			the source string is used.
#@ #
#@ # Results:
#@ #	Returns the new locale.
#@ 
#@ proc msgcat::mcset {locale src {dest ""}} {
#@     variable Msgs
#@     if {[llength [info level 0]] == 3} { ;# dest not specified
#@ 	set dest $src
#@     }
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     set locale [string tolower $locale]
#@ 
#@     dict set Msgs $locale $ns $src $dest
#@     return $dest
#@ }
#@ 
#@ # msgcat::mcmset --
#@ #
#@ #	Set the translation for multiple strings in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	pairs		One or more src/dest pairs (must be even length)
#@ #
#@ # Results:
#@ #	Returns the number of pairs processed
#@ 
#@ proc msgcat::mcmset {locale pairs } {
#@     variable Msgs
#@ 
#@     set length [llength $pairs]
#@     if {$length % 2} {
#@ 	return -code error "bad translation list:		 should be \"[lindex [info level 0] 0] locale {src dest ...}\""
#@     }
#@ 
#@     set locale [string tolower $locale]
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     foreach {src dest} $pairs {
#@ 	dict set Msgs $locale $ns $src $dest
#@     }
#@ 
#@     return $length
#@ }
#@ 
#@ # msgcat::mcunknown --
#@ #
#@ #	This routine is called by msgcat::mc if a translation cannot
#@ #	be found for a string.  This routine is intended to be replaced
#@ #	by an application specific routine for error reporting
#@ #	purposes.  The default behavior is to return the source string.
#@ #	If additional args are specified, the format command will be used
#@ #	to work them into the traslated string.
#@ #
#@ # Arguments:
#@ #	locale		The current locale.
#@ #	src		The string to be translated.
#@ #	args		Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated value.
#@ 
#@ proc msgcat::mcunknown {locale src args} {
#@     if {[llength $args]} {
#@ 	return [format $src {*}$args]
#@     } else {
#@ 	return $src
#@     }
#@ }
#@ 
#@ # msgcat::mcmax --
#@ #
#@ #	Calculates the maximum length of the translated strings of the given
#@ #	list.
#@ #
#@ # Arguments:
#@ #	args	strings to translate.
#@ #
#@ # Results:
#@ #	Returns the length of the longest translated string.
#@ 
#@ proc msgcat::mcmax {args} {
#@     set max 0
#@     foreach string $args {
#@ 	set translated [uplevel 1 [list [namespace origin mc] $string]]
#@ 	set len [string length $translated]
#@ 	if {$len>$max} {
#@ 	    set max $len
#@ 	}
#@     }
#@     return $max
#@ }
#@ 
#@ # Convert the locale values stored in environment variables to a form
#@ # suitable for passing to [mclocale]
#@ proc msgcat::ConvertLocale {value} {
#@     # Assume $value is of form: $language[_$territory][.$codeset][@modifier]
#@     # Convert to form: $language[_$territory][_$modifier]
#@     #
#@     # Comment out expanded RE version -- bugs alleged
#@     # regexp -expanded {
#@     #	^		# Match all the way to the beginning
#@     #	([^_.@]*)	# Match "lanugage"; ends with _, ., or @
#@     #	(_([^.@]*))?	# Match (optional) "territory"; starts with _
#@     #	([.]([^@]*))?	# Match (optional) "codeset"; starts with .
#@     #	(@(.*))?	# Match (optional) "modifier"; starts with @
#@     #	$		# Match all the way to the end
#@     # } $value -> language _ territory _ codeset _ modifier
#@     if {![regexp {^([^_.@]+)(_([^.@]*))?([.]([^@]*))?(@(.*))?$} $value 	    -> language _ territory _ codeset _ modifier]} {
#@ 	return -code error "invalid locale '$value': empty language part"
#@     }
#@     set ret $language
#@     if {[string length $territory]} {
#@ 	append ret _$territory
#@     }
#@     if {[string length $modifier]} {
#@ 	append ret _$modifier
#@     }
#@     return $ret
#@ }
#@ 
#@ # Initialize the default locale
#@ proc msgcat::Init {} {
#@     global env
#@ 
#@     #
#@     # set default locale, try to get from environment
#@     #
#@     foreach varName {LC_ALL LC_MESSAGES LANG} {
#@ 	if {[info exists env($varName)] && ("" ne $env($varName))} {
#@ 	    if {![catch {
#@ 		mclocale [ConvertLocale $env($varName)]
#@ 	    }]} {
#@ 		return
#@ 	    }
#@ 	}
#@     }
#@     #
#@     # On Darwin, fallback to current CFLocale identifier if available.
#@     #
#@     if {[info exists ::tcl::mac::locale] && $::tcl::mac::locale ne ""} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $::tcl::mac::locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@     #
#@     # The rest of this routine is special processing for Windows or
#@     # Cygwin. All other platforms, get out now.
#@     #
#@     if {([info sharedlibextension] ne ".dll")
#@ 	    || [catch {package require registry}]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # On Windows or Cygwin, try to set locale depending on registry
#@     # settings, or fall back on locale of "C".
#@     #
#@ 
#@     # First check registry value LocalName present from Windows Vista
#@     # which contains the local string as RFC5646, composed of:
#@     # [a-z]{2,3} : language
#@     # -[a-z]{4}  : script (optional, translated by table Latn->latin)
#@     # -[a-z]{2}|[0-9]{3} : territory (optional, numerical region codes not used)
#@     # (-.*)* : variant, extension, private use (optional, not used)
#@     # Those are translated to local strings.
#@     # Examples: de-CH -> de_ch, sr-Latn-CS -> sr_cs@latin, es-419 -> es
#@     #
#@     set key {HKEY_CURRENT_USER\Control Panel\International}
#@     if {([registry values $key "LocaleName"] ne "")
#@ 	    && [regexp {^([a-z]{2,3})(?:-([a-z]{4}))?(?:-([a-z]{2}))?(?:-.+)?$}	    [string tolower [registry get $key "LocaleName"]] match locale	    script territory]} {
#@ 	if {"" ne $territory} {
#@ 	    append locale _ $territory
#@ 	}
#@ 	set modifierDict [dict create latn latin cyrl cyrillic]
#@ 	if {[dict exists $modifierDict $script]} {
#@ 	    append locale @ [dict get $modifierDict $script]
#@ 	}
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@ 
#@     # then check key locale which contains a numerical language ID
#@     if {[catch {
#@ 	set locale [registry get $key "locale"]
#@     }]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # Keep trying to match against smaller and smaller suffixes
#@     # of the registry value, since the latter hexadigits appear
#@     # to determine general language and earlier hexadigits determine
#@     # more precise information, such as territory.  For example,
#@     #     0409 - English - United States
#@     #     0809 - English - United Kingdom
#@     # Add more translations to the WinRegToISO639 array above.
#@     #
#@     variable WinRegToISO639
#@     set locale [string tolower $locale]
#@     while {[string length $locale]} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale [dict get $WinRegToISO639 $locale]]
#@ 	}]} {
#@ 	    return
#@ 	}
#@ 	set locale [string range $locale 1 end]
#@     }
#@     #
#@     # No translation known.  Fall back on "C" locale
#@     #
#@     mclocale C
#@ }
#@ msgcat::Init
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/common/procs.tcl

#@ 
#@ P_source_if_exists procs_common.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/procs_common.tcl

#@ ##############################################################################
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : P_run_CheckDiskSpace
#@ # Description : This script will check the use percentage and cautions the user
#@ 
#@ proc P_run_CheckDiskSpace { } {
#@ 
#@   #set threshold
#@   set lowLimit "95%"
#@ 
#@   set perc [exec df -k . | awk {{print $4}} | sed -n "2,14 p"]
#@ 
#@   #define condition
#@   if {$perc > $lowLimit} {
#@     echo "\n CAUTION: Available Disk Space is at $perc , Your disk space is approaching full and is less than the default low limits set. Please ensure sufficient diskspace to run complete APR flow on the design.\n"
#@   } else {
#@     echo "\n Available Disk Space is at $perc. Disk space is design dependant, continue to monitor the available space on your disk.\n"
#@   }
#@ 
#@ }
#@ 
#@ 
#@ ################################################################################
#@ 
#@ ############################################################
#@ # Procedure   : P_lsearch
#@ # Input(s)    : ?mode? ;# Optional, can be "-glob", "-regexp", "-exact"
#@ #                      ;# Default: -glob
#@ #                list  ;# List to search
#@ #                pattern ;# Search pattern
#@ # Output(s)   : list ;# List containing all elements matching the pattern
#@ # Help line   : Returns list containing all elements matching specified pattern
#@ # Description : This is a "modified" lsearch command.  lsearch only returns
#@ #               the index of the first element it finds in the list.  This
#@ #               procedure finds all the elements matching the pattern
#@ #               and returns all the elements as a list.
#@ #               Default "mode" is "-glob"
#@ #
#@ # Example(s)  : <set list1 "My1 My2 Your1 Your2 SoMe SOME"
#@ #               <T_lsearch $list1 "My1"
#@ #               >"My1"
#@ #
#@ #               <T_lsearch $list1 "My"
#@ #               >""
#@ #               Note that "My" does not match anything, however "My*"
#@ #               will match.
#@ #
#@ #               <T_lsearch $list1 "My*"
#@ #               >"My1 My2"
#@ #
#@ #               <T_lsearch $list1 "*2"
#@ #               >"My2 Your2"
#@ #
#@ #               <T_lsearch $list1 "Some"
#@ #               >"My2 Your2"
#@ #
#@ #               <T_lsearch -regexp $list1 "^(S)+(\[oO])+"
#@ #               >"SoMe SOME"
#@ #
#@ # Note(s)     :
#@ #
#@ proc P_lsearch { args } {
#@   set return_val ""
#@ 
#@   set convert ""
#@ 
#@   # Get all the arguments
#@   set mode ""
#@   set list ""
#@   set pattern ""
#@   if {[regexp "^(-)" $args] == 1} {
#@     set mode [lindex $args 0]
#@     set i 1
#@   } else {
#@     set mode "-glob"
#@     set i 0
#@   }
#@   set list [lindex $args $i]
#@   set pattern [lindex $args [incr i]]
#@ 
#@   # Build the list of elements that match the pattern
#@   # Have to do the following cause TCL will not accept "" as
#@   # the mode
#@   if {$convert != ""} {
#@     set index [lsearch $mode [string $convert $list] [string $convert $pattern]]
#@   } else {
#@     set index [lsearch $mode $list $pattern]
#@   }
#@   while {$index >= 0} {
#@     # Append the element found to the return list
#@     lappend return_val [lindex $list $index]
#@     # Remove the element from the original list
#@     set list [lrange $list [expr $index + 1] end]
#@     if {$convert != ""} {
#@       set index [lsearch $mode [string $convert $list] [string $convert $pattern]]
#@     } else {
#@       set index [lsearch $mode $list $pattern]
#@     }
#@   }
#@   return $return_val
#@ }
#@ 
#@ ############################################################
#@ # Procedure   : P_lminus
#@ # Input(s)    : list1  ;# First list
#@ #               list2  ;# Second list
#@ # Output(s)   : list
#@ # Help line   : Takes out list2 elements from list1, i.e. list1 - list2
#@ # Description : For each element in list2, this function finds
#@ #               exact matching element in list1 and removes it.
#@ #               It returns the new list1 with all list2 elements
#@ #               removed.
#@ # Example(s)  : <set list1 "a b c"
#@ #               <set list2 "d c"
#@ #               <T_lminus $list1 $list2
#@ #               >"a b"
#@ # Note(s)     :
#@ proc P_lminus { args } {
#@   set list1 [lindex $args 0]
#@   set list2 [lindex $args 1]
#@   set return_list $list1
#@   set found ""
#@   set element ""
#@   foreach element $list2 {
#@     set found [lsearch -exact $return_list $element]
#@     if {$found != -1} {
#@       set return_list [lreplace $return_list $found $found]
#@     }
#@   }
#@   return $return_list
#@ }
#@ 
#@ 
#@ ############################################################
#@ # Procedure   : P_lminus_r (REVERSE OF P_lminus)
#@ # Input(s)    : list1  ;# First list
#@ #               list2  ;# Second list
#@ # Output(s)   : list
#@ # Help line   : Takes out list2 elements from list1, i.e. list1 - list2 IN REVERSE
#@ # Description : For each element in list2, this function finds
#@ #               exact matching element in list1 and removes it.
#@ #               It returns the new list1 with all list2 elements
#@ #               removed.
#@ # Example(s)  : <set list1 "a b c"
#@ #               <set list2 "d c"
#@ #               <T_lminus $list1 $list2
#@ #               >"a b"
#@ # Note(s)     :
#@ proc P_lminus_r {args} {
#@ 
#@   set list1 [lindex $args 0]
#@   set list2 [lindex $args 1]
#@   set return_list $list1
#@   set found ""
#@   set element ""
#@   foreach element $list2 {
#@     set found [lindex [lsearch -all -exact $return_list $element] end]
#@     if {$found != -1} {
#@       set return_list [lreplace $return_list $found $found]
#@     }
#@   }
#@   return $return_list
#@ }
#@ 
#@ ############################################################
#@ # Procedure   : P_true
#@ # Input(s)    : value ;# Can be anything!
#@ # Output(s)   : 0 ;# when value = false or 0 or ""
#@ #               1 ;# when value = true or 1 or non-empty string
#@ #               $value ;# when value is numeric and non-zero
#@ # Help line   : Returns 0 or 1 or $value depeninding on contents of value
#@ # Description : Returns 0 when value is "false" or "0" or ""
#@ #               Returns 1 when value is "true" or non-empty string
#@ #               Returns $value when value is numeric and non-zero
#@ # Example(s)  : <set a 4
#@ #               <T_true $a
#@ #               >4
#@ #
#@ #               <set b ""
#@ #               <if {[P_true $b]} {
#@ #               <  puts "List not empty!"
#@ #               <} else {
#@ #               <  puts "nothing!"
#@ #               <}
#@ #               >nothing!
#@ #
#@ # Note(s)     :
#@ #
#@ proc P_true { args } {
#@ 
#@   set value [lindex $args 0]
#@ 
#@   # numeric
#@   if {[string match {[0-9]} $value]} {
#@     if {$value != 0} {
#@       return $value
#@     } else {
#@       return 0
#@     }
#@   } elseif {$value == "false" || $value == ""} {
#@     return 0
#@   } elseif {$value == "true" || $value != ""} {
#@     return 1
#@   }
#@ }
#@ 
#@ ############################################################
#@ # Procedure   : P_eval
#@ # Input(s)    : cmd
#@ # Output(s)   : none
#@ # Help line   : Returns 0/1 based on successful execution of the
#@ #               Tcl command "cmd".  Prints error msg to stderr if it fails.
#@ # Description : Executed the "cmd" if it is a valid tcl command.
#@ #               If an error is produced during execution,
#@ #               gives out the command at execution and the
#@ #               error message.
#@ # Example(s)  : <if {[P_eval {puts some}]} {
#@ #               < puts "ok!"
#@ #               <}
#@ #               >ok!
#@ #
#@ #               <if {[P_eval {puts some some}]} {
#@ #               < puts "ok!"
#@ #               <}
#@ #               >T_eval: Error executing: "puts some some"
#@ #               >can not find channel named "some"
#@ #
#@ # Note(s)     :
#@ #
#@ proc P_eval { args } {
#@ 
#@   set cmd [lindex $args 0]
#@   set success 1
#@   set error_msg ""
#@   set catch_val 0
#@ 
#@   if {[info complete $cmd]} {
#@     set catch_val [catch {eval $cmd} error_msg]
#@ 
#@     # puts "Executing $cmd"
#@     if {$catch_val == 1} {
#@       puts stderr "T_eval-ERROR: Error executing: \"$cmd\""
#@       puts stderr "T_eval-ERROR: $error_msg"
#@       set success 0
#@     }
#@   } else {
#@     puts stderr "T_eval-ERROR: \"$cmd\" is not a complete tcl command"
#@     set success 0
#@   }
#@ 
#@   return $success
#@ }
#@ 
#@ 
#@ 
#@ ############################################################
#@ # Procedure   : P_lcommon
#@ # Input(s)    : list1  ;# First list
#@ #               list2  ;# Second list
#@ # Output(s)   : list
#@ # Description : Returns a list of common elements in both lists
#@ #
#@ proc P_lcommon { args } {
#@   set list1 [lindex $args 0]
#@   set list2 [lindex $args 1]
#@ 
#@   set return_list ""
#@   if { [llength $list1] > [llength $list2] } {
#@     set nlist1 $list2
#@     set nlist2 $list1
#@   } else {
#@     set nlist1 $list1
#@     set nlist2 $list2
#@   }
#@   foreach element $nlist1 {
#@     set add [expr [lsearch -exact $nlist2 $element] != -1]
#@     set redundunt [expr [lsearch -exact $return_list $element] != -1]
#@     if {[expr $add && !$redundunt] } {
#@       lappend return_list $element
#@     }
#@   }
#@   return $return_list
#@ }
#@ 
#@ 
#@ ############################################################
#@ # Procedure   : P_sel2list
#@ # Input(s)    : selection ;# Any selection
#@ # Output(s)   : list ;# Selection contents in list form
#@ # Help line   : Converts PrimeTime/DesignCompiler TCL selection to list
#@ # Description : Converts PrimeTime/DesignCompiler TCL selection to list
#@ #               Looks at global variable synopsys_program_name to figure
#@ #               out which program is currently using this proc.
#@ #               Only accepts one selection!
#@ #
#@ # Example(s)  :  <set some [get_cell *]
#@ #                >CELL1 CELL1/CELL11
#@ #                <set some
#@ #                >_sel445
#@ #                <set lll [P_sel2list $some]
#@ #                <set lll
#@ #                >CELL1 CELL1/CELL11
#@ #
#@ # Note(s)     : - global variable synopsys_program_name has to exist and
#@ #                 has to be a non-empty string.
#@ #               - Only accepts one selection
#@ #
#@ proc P_sel2list { args } {
#@   global synopsys_program_name
#@ 
#@   set sel [lindex $args 0]
#@ 
#@   if {[info exists synopsys_program_name] &&           $synopsys_program_name != ""} {
#@ 
#@     if {[llength $sel] == 1} {
#@       if {[string match "_sel*" $sel] == 1} {
#@         # get_attribute works for a single object only in PT!!!
#@         #if {$synopsys_program_name == "pt_shell" ||                                                  #    $synopsys_program_name == "primetime"} {
#@         set return_val ""
#@         foreach_in_collection ss $sel {
#@           lappend return_val [get_object_name $ss]
#@         }
#@         #} else {
#@         # This is not working!  Maybe a Synopsys bug!
#@         #set return_val [get_attribute $sel full_name]
#@         #}
#@         return $return_val
#@       } else {
#@         return $sel
#@       }
#@     } else {
#@       return $sel
#@     }
#@   } else {
#@     P_msg_warn "This procedure will only work from within Synopsys tools"
#@     return $args
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/procs_common.tcl

#@ P_source_if_exists tooltype.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/tooltype.tcl

#@ ##############################################################################
#@ #
#@ # Procedures to  return 1/0 if running under certain tools.
#@ # Enable these for ALL tools so if/then logic can be used no matter where
#@ #
#@ 
#@ proc P_is_synopsys_tool { args } {
#@   parse_proc_arguments -args $args arg
#@ 
#@   global synopsys_program_name
#@   global sh_product_version
#@   global INTEL_SYNOPSYS_PROGRAM_SUITE
#@ 
#@   if {![info exists INTEL_SYNOPSYS_PROGRAM_SUITE]} {
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(DC)   {dc_shell design_vision design_analyzer de_shell}
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(PT)   {pt_shell primetime}
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(PSYN) {psyn_shell psyn_gui}
#@     set INTEL_SYNOPSYS_PROGRAM_SUITE(ICC)  {icc_shell}
#@   }
#@ 
#@   if {[info exists synopsys_program_name] && $synopsys_program_name != ""} {
#@     # Valid tool name?
#@     if {[lsearch -exact [array names INTEL_SYNOPSYS_PROGRAM_SUITE] $arg(tool)] == -1} {
#@       P_warning "Tool '$arg(tool)' not programmed in 'INTEL_SYNOPSYS_PROGRAM_SUITE'"
#@       return 0
#@     }
#@     # Does synopsys_program_name match the programmed strings?
#@     if {[lsearch -exact $INTEL_SYNOPSYS_PROGRAM_SUITE($arg(tool)) $synopsys_program_name] == -1} {
#@       return 0
#@     }
#@     # If the version is given, does it match current version?
#@     if {[info exists sh_product_version] &&             [info exists arg(version)]} {
#@       if {![string match $arg(version) $sh_product_version]} {
#@         return 0
#@       }
#@     }
#@     # All checks passed, return 1
#@     return 1
#@   } else {
#@     return 0
#@   }
#@   return 1
#@ }
#@ define_proc_attributes P_is_synopsys_tool     -info "Returns 1 if procedure was executed within the given Synopsys tool & version, 0 otherwise"     -define_args {
#@       {tool "Name of synopsys tool (as programmed in 'INTEL_SYNOPSYS_PROGRAM_SUITE')" toolname string required}
#@       {version "Version of synopsys tool"                                        version  string optional}
#@     }
#@ 
#@ 
#@ proc P_is_DC { args } {
#@ 
#@   set tool_name "DC"
#@   parse_proc_arguments -args $args arg
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_DC     -info "Returns 1 if current Synopsys tool is specified version (optional) of Design-Compiler/Design-Vision/Design-Analyzer, 0 otherwise"     -define_args {
#@       {version "Version of DC"                                                   version  string optional}
#@     }
#@ 
#@ 
#@ proc P_is_PT { args } {
#@   set tool_name "PT"
#@   parse_proc_arguments -args $args arg
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_PT     -info "Returns 1 if current Synopsys tool is specified version (optional) of PrimeTime, 0 otherwise"     -define_args {
#@       {version "Version of PT"                                                   version  string optional}
#@     }
#@ 
#@ 
#@ proc P_is_PSYN { args } {
#@   set tool_name "PSYN"
#@   parse_proc_arguments -args $args arg
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_PSYN     -info "Returns 1 if current Synopsys tool is specified version (optional) of Physical-Compiler, 0 otherwise"     -define_args {
#@       {version "Version of PSYN"                                                   version  string optional}
#@     }
#@ 
#@ proc P_is_PC { args } {
#@   return [P_is_PSYN $args]
#@ }
#@ 
#@ 
#@ # Command to check if you are in icc_shell
#@ proc P_is_ICC { args } {
#@   set tool_name "ICC"
#@   parse_proc_arguments -args $args arg
#@ 
#@   if {[info exists arg(version)]} {
#@     return [P_is_synopsys_tool $tool_name $arg(version)]
#@   } else {
#@     return [P_is_synopsys_tool $tool_name]
#@   }
#@ }
#@ define_proc_attributes P_is_ICC     -info "Returns 1 if current Synopsys tool is specified version (optional) of IC-Compiler, 0 otherwise"     -define_args {
#@       {version "Version of ICC"                                                   version  string optional}
#@     }
#@ 
#@ # some synopsys tool (don't care which)
#@ proc P_is_SNPS { } {
#@   global sh_product_version
#@   if {[info exists sh_product_version]} {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ 
#@ proc P_is_ENCOUNTER { } {
#@   global encounterVersion
#@   if {[info exists encounterVersion]} {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ proc P_is_FE { } {
#@   return [P_is_ENCOUNTER]
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/tooltype.tcl

#@ P_source_if_exists run_proc.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/run_proc.tcl

#@ ##############################################################################
#@ 
#@ 
#@ proc runADF {args} {
#@   global target_library link_library search_path mw_reference_library
#@   global INTEL_MW_LIB env
#@   global synopsys_program_name
#@   global suppress_errors
#@   global INTEL_SAVE_WD
#@   global INTEL_STEP_CURR
#@ 
#@   foreach glbl [info globals INTEL_*] {
#@     global $glbl
#@   }
#@ 
#@   if {[P_is_ICC]} {
#@     set INTEL_STEPS $INTEL_APR_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_APR_SUBSTEPS]
#@   } elseif {[P_is_DC]} {
#@     set INTEL_STEPS $INTEL_SYN_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_SYN_SUBSTEPS]
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@     return 0
#@   }
#@ 
#@   set pid [pid]
#@   set extension [P_save_extension]
#@ 
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@   parse_proc_arguments -args $args results
#@ 
#@   global sh_output_log_file
#@   global sh_command_log_file
#@ 
#@ 
#@   ## report status if enabled (design must be open)
#@   if { [info exists results(-status) ] } {
#@     if { [P_current_design_status] } {
#@       P_get_design_status
#@       return 1
#@     } else {
#@       P_msg_error "Unable to determine status."
#@       return 1
#@     }
#@   }
#@ 
#@   #########################################
#@   #  Setup
#@ 
#@   # Support tmp_proj run with sync to INTEL_SAVE_WD
#@   if { ![info exists INTEL_SAVE_WD] } {
#@     set INTEL_SAVE_WD [pwd]
#@   }
#@   # If syncing data to $INTEL_SAVE_WD, make sure scripts/inputs are linked and needed dirs are in $INTEL_SAVE_WD.
#@   if {$INTEL_SAVE_WD != [pwd]} {
#@     sh ln -sf $INTEL_SAVE_WD/scripts .
#@     sh ln -sf $INTEL_SAVE_WD/inputs .
#@     if { ![file isdirectory $INTEL_SAVE_WD/mwdb] } { file mkdir $INTEL_SAVE_WD/mwdb }
#@     if { ![file isdirectory $INTEL_SAVE_WD/$INTEL_MW_LIB] } { file mkdir $INTEL_SAVE_WD/$INTEL_MW_LIB }
#@     if { ![file isdirectory $INTEL_SAVE_WD/$INTEL_OUTPUTS_PATH] } { file mkdir $INTEL_SAVE_WD/$INTEL_OUTPUTS_PATH }
#@     if { ![file isdirectory $INTEL_SAVE_WD/$INTEL_REPORTS_PATH] } { file mkdir $INTEL_SAVE_WD/$INTEL_REPORTS_PATH }
#@     if { ![file isdirectory $INTEL_SAVE_WD/logs] } { file mkdir $INTEL_SAVE_WD/logs }
#@   }
#@   if { ![file isdirectory mwdb] } { file mkdir mwdb }
#@   if { ![file isdirectory $INTEL_MW_LIB] } { file mkdir $INTEL_MW_LIB }
#@   if { ![file isdirectory $INTEL_OUTPUTS_PATH] } { file mkdir outputs }
#@   if { ![file isdirectory $INTEL_REPORTS_PATH] } { file mkdir reports }
#@ 
#@   if { [P_current_design_status] && ![info exists results(-continue)]  } {
#@     P_msg_error "Please specify -continue"
#@     P_msg_error "    or   "
#@     P_msg_error "close_mw_lib and use -load "
#@     return 0
#@   }
#@ 
#@   #########################################
#@   #  -Load
#@   if { [info exists results(-load)]  && ![file isdirectory $results(-load)] && [P_is_ICC]} {
#@     P_msg_error "Invalid library specified . path to MWDB required e.g. ./${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_import_design${extension}"
#@     return 0
#@   }
#@   if { [info exists results(-load)]  && ![file exists $results(-load)] && [P_is_DC]} {
#@     P_msg_error "Invalid library specified . path to ddc required e.g. ./${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_import_design${extension}"
#@     return 0
#@   }
#@   if { [info exists results(-continue)] && [info exists results(-load)] } {
#@     P_msg_error "Invalid command line options! Cannot specify -load with -continue."
#@     return 0
#@   }
#@ 
#@   if { [info exists results(-load)] && [llength $args] == 2 } {
#@     P_open_design $results(-load)
#@     return 1
#@   }
#@ 
#@   if { [info exists results(-load)] } {
#@     set load_lib $results(-load)
#@   }
#@ 
#@ 
#@ 
#@   #########################################
#@   #  -Start
#@   # Define the name of the lib design will save to. $step_lib
#@   # Define lib to load and start from. $load_lib
#@   if { [info exists results(-start)] && ![info exists results(-load)] } {
#@     if {[lsearch -exact $INTEL_STEPS $results(-start)] > -1 } {
#@       set step_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_$results(-start)${extension}
#@       set load_step [lindex $INTEL_STEPS [expr [lsearch -exact $INTEL_STEPS $results(-start)] - 1]]
#@       if { $load_step eq "" } {
#@         # Starting from beginning. Don't define $load_step.
#@       } else {
#@         # If -start and user is still in tool, need to close current mw_lib and load saved one.
#@         redirect /dev/null {[close_mw_lib]}
#@         set load_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_${load_step}${extension}
#@       }
#@     } else {
#@       P_msg_error "Cannot find start point $results(-start) "
#@       P_msg_error " Needs to be one of $INTEL_STEPS "
#@       return 0
#@       # Dont know what to do or where to start
#@     }
#@   } elseif { [info exists results(-start)] && [info exists results(-load)] } {
#@     P_msg_error "Cannot specify both -start and -load!"
#@   }
#@ 
#@ 
#@   #########################################
#@   #  Open Design
#@   # Open the $load_lib
#@   if { ![info exists results(-continue)] } {
#@     if { [info exists load_lib] } {
#@       if { [file exists $load_lib] } {
#@         P_msg_info " Starting with lib $load_lib"
#@         P_open_design ${load_lib}
#@       } else {
#@         P_msg_error "Cannot find MWDB to load $load_lib"
#@         return 0
#@       }
#@     }
#@   }
#@ 
#@ 
#@   #########################################
#@   #  -Load
#@   # Set step_lib when using -load
#@   if { [info exists results(-load)] && ![info exists results(step)] } {
#@     set tmp_step [lindex [file split $results(-load)] end]
#@     if { [info exists tmp_step] } {
#@       regsub "${INTEL_DESIGN_NAME}_" $tmp_step "" tmp_step
#@       regsub "$extension" $tmp_step "" tmp_step
#@       if {  [lsearch -exact $INTEL_STEPS $tmp_step] > -1 } {
#@         set idx [expr [lsearch -exact $INTEL_STEPS $tmp_step ] + 1 ]
#@         set next_step [lindex $INTEL_STEPS $idx]
#@         set step_lib ${INTEL_MW_LIB}/${INTEL_DESIGN_NAME}_${next_step}${extension}
#@         puts " STEP : $step_lib"
#@       } else {
#@         P_msg_error "specified MW $tmp_step  is not part of standard substeps "
#@         P_msg_error "--Valid steps :  $INTEL_STEPS "
#@         return 0
#@       }
#@     } else {
#@       # Assuming first STEP of INTEL_STEPS
#@     }
#@   }
#@ 
#@ 
#@   #########################################
#@   #  STEP RUN
#@   # Run custom steps
#@   #    or
#@   # Run through $INTEL_STEPS in order
#@   if { [info exists results(step)] } {
#@     for {set i 0 } { $i < [llength $results(step)] } {incr i} {
#@       set step [lindex $results(step) $i]
#@       if { [info exists INTEL_SUBSTEPS($step) ] } {
#@         lappend steps_to_run $step
#@         P_msg_info " $step -- $INTEL_SUBSTEPS($step)"
#@       } else  {
#@         P_msg_error "No substeps specified for step $step"
#@         return 0
#@       }
#@     }
#@     P_msg_info "Executing Custom Specified step : $results(step) "
#@   } else {
#@     set steps_to_run $INTEL_STEPS
#@     set steps_done [get_completed_steps]
#@     set steps_to_run [P_lminus $steps_to_run $steps_done]
#@     P_msg_info "  Completed steps $steps_done"
#@ 
#@     if { [ info exists results(-stop)] && $results(-stop) != "" } {
#@       set step_stop $results(-stop)
#@       set substep_stop ""
#@       if { [string match "*:*" $results(-stop) ] } {
#@         set step_stop [lindex [split $results(-stop) ":" ] 0]
#@         set substep_stop [lindex [split $results(-stop) ":" ] 1]
#@       }
#@       if { [lsearch $steps_to_run $step_stop] > -1 } {
#@         if { $substep_stop != "" } {
#@           set completed_substeps [get_completed_substeps $step_stop]
#@           if { [lsearch $INTEL_SUBSTEPS($step_stop) $substep_stop] < 0 } {
#@             P_msg_error "Specified stop $results(-stop) needs to be one of  $INTEL_SUBSTEPS($step_stop) "
#@             return 0
#@           } elseif { [lsearch $completed_substeps $substep_stop] > -1 && [llength [lsearch -exact -all $INTEL_SUBSTEPS($step_stop) $substep_stop]] < 2} {
#@             # Check if step was already completed. But don't stop if there is more than one step in the step with the same name.
#@             P_msg_error " Specified stop $results(-stop) already executed!"
#@             P_msg_error "  Completed: $completed_substeps"
#@             P_msg_error "  Of:        $INTEL_SUBSTEPS($step_stop)"
#@             return 0
#@           }
#@         }
#@       } else {
#@         P_msg_error "Specified stop $results(-stop) maybe already done/ or specified incorrectly  "
#@         P_msg_error "Specified step Needs to be one of : $steps_to_run "
#@         return 0
#@       }
#@     }
#@   }
#@ 
#@   #########################################
#@   #  Start from beginning!
#@   #  Create mwdb
#@   if { ![info exists load_lib] && ![info exists results(-continue)] } {
#@     P_msg_info " Starting from first step:  [lindex $steps_to_run 0]"
#@     set step_lib ${INTEL_DESIGN_NAME}_${pid}${extension}
#@     set test_lib ""
#@     if { [P_current_design_status] && ![info exists results(-continue)]  } {
#@       set test_lib [get_object_name [current_mw_lib]]
#@     }
#@     if { [file exists $step_lib] && $step_lib == $test_lib && ![info exists results(-continue)]} {
#@       P_msg_error " MWDB exists Please delete MWDB $step_lib to restart "
#@       return 0
#@     }
#@     if { [file isdirectory ${step_lib}] } {
#@       P_msg_info " ${step_lib} already exists! "
#@       P_msg_info " Deleting local version $step_lib "
#@       catch {file delete -force  ${step_lib}} tmpvar
#@       if {$tmpvar != "" } {
#@         catch {sh mv ${step_lib} junk${extension}} movevar
#@       }
#@     }
#@     if {[P_is_ICC]} {
#@       create_mw_lib -technology $INTEL_MW_TECH_FILE -mw_reference_library $mw_reference_library -open $step_lib
#@     }
#@   }
#@ 
#@   #########################################
#@   # -continue
#@   # Continue on Existing Open MWDB
#@ 
#@   if { [info exists results(-continue) ] && [P_is_ICC]} {
#@     set step_lib [get_object_name [current_mw_lib]]
#@   }
#@ 
#@   #########################################
#@   #  MAIN LOOP
#@   #  For loop through steps.
#@   set in_step_loop 0
#@   set return_after_mark 0
#@   for {set ii 0 } {$ii < [llength $steps_to_run] } { incr ii } {
#@     set step [lindex $steps_to_run $ii]
#@     set INTEL_STEP_CURR $step
#@     set step_log_file ${INTEL_LOG_PATH}/${step}.log
#@     set step_command_log_file ${INTEL_LOG_PATH}/${step}.cmd_log
#@ 
#@     if { [file exists ${INTEL_LOG_PATH}/${step}.log] && ![info exists results(-continue)] } {
#@       file copy -force ${INTEL_LOG_PATH}/${step}.log ${INTEL_LOG_PATH}/${step}.log.bak
#@     }
#@     if { [file exists ${INTEL_LOG_PATH}/${step}.cmd_log] && ![info exists results(-continue)] } {
#@       file copy -force ${INTEL_LOG_PATH}/${step}.cmd_log ${INTEL_LOG_PATH}/${step}.cmd_log.bak
#@     }
#@     set sh_output_log_file $step_log_file
#@     set sh_command_log_file $step_command_log_file
#@     P_msg_info " Setting log file  : $step_log_file"
#@ 
#@     # INTEL_SKIP_SUBSTEPS: allow user to skip substeps in a STEP via INTEL_ var.
#@     if { [info exists INTEL_SKIP_STEP] && $INTEL_SKIP_SUBSTEPS != "" && [regexp "${step}( |$)" $INTEL_SKIP_SUBSTEPS match] } {
#@       P_msg_info "Skipping the following: ${step}"
#@       mark_step $step "Skipped"
#@       continue
#@     }
#@ 
#@     # copy over lib to load and work within for ICC only, otherwise just read_ddc in DC.
#@     if { [info exists load_lib]  && ![info exists results(-continue)] } {
#@       if {[P_is_ICC]} {
#@         redirect /dev/null {[close_mw_lib ${load_lib}]}
#@         set step_lib  ${INTEL_DESIGN_NAME}_${pid}${extension}
#@         P_msg_info "Loading $load_lib (moving to $step_lib first)"
#@         P_msg_info "rsync-ing $load_lib to $step_lib "
#@         P_rsync $load_lib $step_lib
#@         if { [file exists [file tail $load_lib]] } {
#@           redirect /dev/null {[close_mw_lib ${load_lib}]}
#@           P_msg_info " Removing work dir copy [file tail $load_lib]"
#@           #file delete -force [file tail $load_lib]
#@           catch {file delete -force [file tail $load_lib]} tmpvar
#@           if {$tmpvar != "" } {
#@             catch {sh mv [file tail $load_lib] junk${extension}} movevar
#@           }
#@         }
#@         P_open_design ${step_lib}
#@       } elseif {[P_is_DC]} {
#@         set step_lib $load_lib
#@       }
#@ 
#@     }
#@     set start_step_time [clock seconds]
#@ 
#@     # Define step specific active scenarios
#@     if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@       if { [all_scenarios] != "" } {
#@         set_active_scenarios [all_scenarios]
#@         if { [info exists INTEL_MCMM_SCENARIO_ACTIVE($step)] && $INTEL_MCMM_SCENARIO_ACTIVE($step) != "" } {
#@           P_msg_info "Setting the following as active scenarios in step $step :  $INTEL_MCMM_SCENARIO_ACTIVE($step)"
#@           set_active_scenarios $INTEL_MCMM_SCENARIO_ACTIVE($step)
#@         } else {
#@           P_msg_info "Current active scenarios : [all_active_scenarios]"
#@         }
#@         P_msg_info "Setting the following default active scenarios in step $step :  $INTEL_MCMM_SCENARIO_DEFAULT"
#@         current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@       }
#@     }
#@ 
#@     #
#@     # Manage substeps to be run
#@     # Trim substeps to be run only if -continue specified else run STEP from start.
#@     #
#@     set substeps_to_run  $INTEL_SUBSTEPS($step)
#@     set substeps_done ""
#@     if { [info exists results(-continue) ] } {
#@       set substeps_done [get_completed_substeps $step]
#@       set substeps_to_run [P_lminus $substeps_to_run $substeps_done]
#@     }
#@ 
#@     P_msg_info "  ALL $step substeps : $INTEL_SUBSTEPS($step)"
#@     if {[P_is_ICC]} {
#@       P_msg_info "  Current MW lib  : [get_object_name [current_mw_lib]]"
#@     }
#@     P_msg_info "  Completed substeps : $substeps_done"
#@     P_msg_info "  Remaining substeps : $substeps_to_run "
#@ 
#@     #########################################
#@     #  MAIN LOOP
#@     #  For loop through substeps.
#@     if { [llength $substeps_to_run]  > 0 } {
#@       for {set jj 0 } {$jj < [llength $substeps_to_run ] } { incr jj } {
#@         set substep [lindex $substeps_to_run $jj]
#@         # Skip STEP
#@         if { [info exists INTEL_SKIP_SUBSTEPS] && $INTEL_SKIP_SUBSTEPS != "" && [regexp "${step}:${substep}( |$)" $INTEL_SKIP_SUBSTEPS match] } {
#@           P_msg_info "Skipping the following: ${step}:${substep}"
#@           mark_substep $step $substep "Skipped"
#@           continue
#@         }
#@         P_msg_info "Executing substep $substep"
#@         set start_substep_time [clock seconds]
#@ 
#@         source_if_exists ${substep}.tcl
#@ 
#@         set duration [P_rdtConvertSeconds [expr ([clock seconds] - $start_substep_time)]]
#@         P_msg_info "Time to run substep $substep in (hh:mm:ss) : $duration hrs"
#@         mark_substep $step $substep "$duration"
#@         if { [info exists results(-stop)] && [string match $results(-stop) ${step}:${substep} ] > 0 } {
#@           if { [P_lminus $INTEL_SUBSTEPS($step) [get_completed_substeps $step]] == "" } {
#@             # Don't return yet, make sure you Mark the STEP as done and set time stamps
#@             set return_after_mark 1
#@           } else {
#@             P_msg_info "Stopping per users request: -stop ${step}:${substep}"
#@             return
#@           }
#@         }
#@       }
#@ 
#@       set duration [P_rdtConvertSeconds [expr ([clock seconds] - $start_step_time)]]
#@       P_msg_info "Time to run step $step in (hh:mm:ss) : $duration hrs"
#@       set mem_fp [expr [mem]/1024.0]
#@       if { $mem_fp > 1024.0 } {
#@         set mem_fp [format "%7.2f GB" [expr [mem]/(1024.0*1024)]]
#@       } else {
#@         set mem_fp [format "%7.2f MB" [expr [mem]/1024.0]]
#@       }
#@       mark_step $step "$duration  $mem_fp"
#@     } else {
#@       P_msg_info "Nothing to be done for Step. All substeps already completed "
#@     }
#@     set start_ro_time [clock seconds]
#@ 
#@     P_msg_info "Saving design ${INTEL_DESIGN_NAME} ..."
#@     P_save_design $step
#@ 
#@     if { [info exists INTEL_REPORTS($step) ] && $INTEL_REPORTS($step) != "" } {
#@       P_reports $step
#@     } else {
#@       P_msg_info " No report requirement specified INTEL_REPORTS($step) "
#@     }
#@     if { [info exists INTEL_OUTPUTS($step) ] && $INTEL_OUTPUTS($step) != "" } {
#@       P_outputs $step
#@     } else {
#@       P_msg_info " No report requirement specified INTEL_OUTPUTS($step) "
#@     }
#@ 
#@     if {[P_is_ICC]} {
#@       set save_lib  ${INTEL_DESIGN_NAME}_${step}${extension}
#@       P_msg_info "Saving/rsync-ing  $step_lib into ${INTEL_MW_LIB}/${save_lib}"
#@       P_rsync ${step_lib} "${INTEL_MW_LIB}/${save_lib}"
#@     }
#@ 
#@     #Rsync results back to INTEL_SAVE_WD
#@     if { $INTEL_SAVE_WD != [pwd] } {
#@       P_msg_info "Saving/rsync-ing ${step_lib} back to $INTEL_SAVE_WD"
#@       P_rsync  "${INTEL_MW_LIB}/${save_lib}" "${INTEL_SAVE_WD}/${INTEL_MW_LIB}/${save_lib}"
#@       sh rm -rf ${INTEL_SAVE_WD}/reports/${INTEL_DESIGN_NAME}.${step}.*
#@       sh rm -rf ${INTEL_SAVE_WD}/outputs/${INTEL_DESIGN_NAME}.${step}.*
#@       if { [glob -nocomplain reports/${INTEL_DESIGN_NAME}.${step}.*] != "" } {
#@         sh cp -pf reports/${INTEL_DESIGN_NAME}.${step}.* ${INTEL_SAVE_WD}/reports/
#@       }
#@       if { [glob -nocomplain outputs/${INTEL_DESIGN_NAME}.${step}.*] != "" } {
#@         sh cp -pf outputs/${INTEL_DESIGN_NAME}.${step}.* ${INTEL_SAVE_WD}/outputs/
#@       }
#@       sh cp -pf logs/${step}.* ${INTEL_SAVE_WD}/logs/
#@     }
#@     set duration [P_rdtConvertSeconds [expr ([clock seconds] - $start_ro_time)]]
#@     P_msg_info "Time to create reports and outputs for $step in (hh:mm:ss) : $duration hrs"
#@ 
#@     if {$return_after_mark == 1} {
#@       set return_after_mark 0
#@       P_msg_info "Stopping per users request: -stop ${step}:${substep}"
#@       return
#@     }
#@ 
#@     if { [info exists load_lib] } {
#@       unset load_lib
#@     }
#@     if { [info exists results(-continue)] } {
#@       unset results(-continue)
#@     }
#@     if { [info exists results(-stop)] && [string match $results(-stop) $step] > 0 } {
#@       P_msg_info " Stopping at $step as required by -stop $results(-stop)"
#@       return
#@     }
#@   }
#@ }
#@ 
#@ define_proc_attributes runADF     -info "ICF Flow Control"     -define_args {                        {step "Custom step/s to execute" step list optional }                        {-load "Load a mwdb" step string optional}                        {-start "Step start" step string optional}                        {-stop "Step stop" step string optional }                        {-continue "Continue with current mwdb in memory" "" boolean  optional }                        {-status "Report status" "" boolean optional }                      }
#@ 
#@ 
#@ proc P_get_design_status {args} {
#@   foreach glbl [info globals INTEL_*] {
#@     global $glbl
#@   }
#@   parse_proc_arguments -args $args results
#@ 
#@ 
#@   if { [P_current_design_status] } {
#@     # Cell open
#@   } else {
#@     P_msg_error "Unable to determine status. No MW cel open"
#@     return 0
#@   }
#@ 
#@   if {[P_is_ICC]} {
#@     set INTEL_STEPS $INTEL_APR_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_APR_SUBSTEPS]
#@   } elseif {[P_is_DC]} {
#@     set INTEL_STEPS $INTEL_SYN_STEPS
#@     array set INTEL_SUBSTEPS [array get INTEL_SYN_SUBSTEPS]
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@     return 0
#@   }
#@ 
#@   redirect -variable aa {list_attributes -class [P_get_class]}
#@   set steps_run [get_completed_steps]
#@   #set custom_steps [P_lminus $steps_run $INTEL_STEPS]
#@   set steps_not_run [P_lminus $INTEL_STEPS $steps_run]
#@   P_msg_info " Steps run : $steps_run"
#@   if { ! [info exists results(-verbose)]  && ![info exists results(step)]} {
#@     puts "============================================================================================================="
#@     puts "      STEP  Name      :  Duration/Status "
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     for {set i 0 } { $i < [llength $steps_run] } { incr i} {
#@       set step [lindex $steps_run $i]
#@       puts " [format %30s $step ] : [get_attribute -quiet [P_get_current] step:${step}]"
#@     }
#@     for {set i 0 } { $i < [llength $steps_not_run] } { incr i} {
#@       set step [lindex $steps_not_run $i]
#@       puts " [format %30s $step ] : Not Run/Skipped"
#@     }
#@     return
#@   }
#@   if { ![info exists results(-verbose)] && [info exists results(step)] } {
#@     set step $results(step)
#@     set steps_run [P_lcommon [get_completed_steps] $results(step)]
#@     puts "============================================================================================================="
#@     puts "                  STEP  Name    :  [format %10s $step]  : [get_attribute -quiet [P_get_current] step:${step}]"
#@     puts "                          Step  :  Duration    :  Script Used "
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     for {set j 0 } {$j < [llength $INTEL_SUBSTEPS($step) ] } { incr j } {
#@       set step [lindex $INTEL_SUBSTEPS($step) $j]
#@       redirect -variable file {P_source_if_exists ${substep}.tcl -display}
#@       set substep_duration [get_attribute -quiet [P_get_current] step_${step}:${substep}]
#@       if {$substep_duration == ""} { set substep_duration "Skipped " }
#@       puts " [format %30s $step] :  $substep_duration  :$file "
#@     }
#@     return
#@ 
#@   }
#@   if { ![info exists results(step)] } {
#@     for {set i 0 } { $i < [llength $steps_run] } { incr i} {
#@       set step [lindex $steps_run $i ]
#@       puts "============================================================================================================="
#@       puts "                  Step  Name    :  [format %10s $step]  : [get_attribute -quiet [P_get_current] step:${step}]"
#@       puts "                       substep  :  Duration    :  Script Used "
#@       puts "-------------------------------------------------------------------------------------------------------------"
#@       for {set j 0 } {$j < [llength $INTEL_SUBSTEPS($step) ] } { incr j } {
#@         set substep [lindex $INTEL_SUBSTEPS($step) $j]
#@         redirect -variable file {P_source_if_exists ${substep}.tcl -display}
#@         set substep_duration [get_attribute -quiet [P_get_current] step_${step}:${substep}]
#@         if {$substep_duration == ""} { set substep_duration "Skipped " }
#@         puts " [format %30s $substep] :  $substep_duration  :$file "
#@       }
#@     }
#@   }
#@   for {set i 0 } { $i < [llength $steps_not_run] } { incr i} {
#@     set step [lindex $steps_not_run $i ]
#@     puts "============================================================================================================="
#@     puts "  Step  Name    :   $step "
#@     puts "    Status      :   Not Run / Skipped"
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     puts "                          Step  :  Duration  :  Script Used "
#@     puts "-------------------------------------------------------------------------------------------------------------"
#@     for {set j 0 } {$j < [llength $INTEL_SUBSTEPS($step) ] } { incr j } {
#@       set substep [lindex $INTEL_SUBSTEPS($step) $j]
#@       redirect -variable file {P_source_if_exists ${substep}.tcl -display}
#@       puts " [format %30s $substep] :  Not Run   :$file "
#@     }
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes P_get_design_status     -info "Get design status"     -define_args {                        {step "status of specific" step list optional }                        {-verbose  "detail status report" "" boolean optional }                      }
#@ 
#@ 
#@ proc P_rsync {from to} {
#@   catch {sh rsync --archive --verbose --delete --exclude="*@*" --exclude="*_INIT_RT_*" --exclude="*_fdksave_*" --exclude="*.lock"  ${from}/ $to } tmpvar
#@   puts $tmpvar
#@ }
#@ 
#@ proc P_open_design {arg} {
#@ 
#@   global INTEL_DESIGN_NAME mw_reference_library mw_design_library INTEL_MW_TECH_FILE INTEL_MAX_TLUPLUS_FILE INTEL_TLUPLUS_MAP_FILE
#@ 
#@   if {[P_is_ICC]} {
#@     open_mw_lib $arg
#@     open_mw_cel $INTEL_DESIGN_NAME
#@   } elseif {[P_is_DC]} {
#@     if { [shell_is_in_topographical_mode] } {
#@       redirect -variable aa {current_mw_lib}
#@       if { [string match "*No current milkyway library*" $aa] } {
#@         if {[file exists ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB]} {
#@           open_mw_lib mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@         } else {
#@           file delete -force -- ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@           set_app_var mw_design_library ./mwdb/${INTEL_DESIGN_NAME}_syn_LIB
#@           create_mw_lib -technology $INTEL_MW_TECH_FILE  -mw_reference_library $mw_reference_library $mw_design_library
#@           open_mw_lib $mw_design_library
#@         }
#@       }
#@       set_tlu_plus_files -max_tluplus $INTEL_MAX_TLUPLUS_FILE -min_tluplus $INTEL_MAX_TLUPLUS_FILE -tech2itf_map $INTEL_TLUPLUS_MAP_FILE
#@     }
#@     read_ddc $arg
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ 
#@ }
#@ 
#@ proc P_save_design {arg} {
#@ 
#@   global INTEL_DESIGN_NAME
#@   global INTEL_MCMM
#@   global INTEL_MW_LIB
#@   if {[P_is_ICC]} {
#@     if {$INTEL_MCMM == 1} {
#@       save_mw_cel -as ${INTEL_DESIGN_NAME} -scenarios [all_scenarios]
#@     } else {
#@       save_mw_cel -as ${INTEL_DESIGN_NAME}
#@     }
#@   } elseif {[P_is_DC]} {
#@     write_file -format ddc -hierarchy -output $INTEL_MW_LIB/${INTEL_DESIGN_NAME}_${arg}.ddc
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ 
#@ }
#@ 
#@ # Proc P_current_design_status
#@ # Returns 1 if the design is loaded.
#@ # Returns 0 if the design isn't loaded.
#@ proc P_current_design_status {} {
#@ 
#@   global INTEL_DESIGN_NAME
#@ 
#@   if {[P_is_ICC]} {
#@     redirect -variable aa {current_mw_lib}
#@     if { [string match "*No current milkyway library*" $aa] } {
#@       return 0
#@     } else {
#@       return 1
#@     }
#@   } elseif {[P_is_DC]} {
#@     redirect -variable aa {current_design}
#@     if { [string match "*Current design is not defined*" $aa] } {
#@       return 0
#@     } else {
#@       return 1
#@     }
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ 
#@ }
#@ 
#@ proc P_save_extension {} {
#@   if {[P_is_ICC]} {
#@     return "_LIB"
#@   } elseif {[P_is_DC]} {
#@     return ".ddc"
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ }
#@ 
#@ proc P_get_class {} {
#@   if {[P_is_ICC]} {
#@     return "mw_cel"
#@   } elseif {[P_is_DC]} {
#@     return "design"
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@   }
#@ }
#@ 
#@ proc P_get_current {} {
#@   set command "current_"
#@   append command [P_get_class]
#@   redirect /dev/null {set obj [eval $command]}
#@   return $obj
#@ }
#@ 
#@ 
#@ proc mark_step {step {comment ""}} {
#@   set done_steps ""
#@   if {$comment eq ""} { set comment "Marked/Skipped" }
#@   if { [P_current_design_status] } {
#@     set done_steps [get_attribute -quiet [P_get_current] completed_steps]
#@     lappend done_steps $step
#@     redirect /dev/null {define_user_attribute -class [P_get_class] -type string step:${step} -quiet }
#@     redirect /dev/null {set_attribute -quiet [P_get_current] step:$step $comment}
#@     redirect /dev/null {define_user_attribute -class [P_get_class] -type string  completed_steps -quiet}
#@     redirect /dev/null {set_attribute -quiet [P_get_current] completed_steps $done_steps}
#@   }
#@ }
#@ 
#@ 
#@ proc mark_substep {step substep {comment ""}} {
#@   global INTEL_SYN_SUBSTEPS INTEL_APR_SUBSTEPS
#@ 
#@   if {[P_is_ICC]} {
#@     array set INTEL_SUBSTEPS [array get INTEL_APR_SUBSTEPS]
#@   } elseif {[P_is_DC]} {
#@     array set INTEL_SUBSTEPS [array get INTEL_SYN_SUBSTEPS]
#@   } else {
#@     P_msg_error "ERROR! No known tool type!"
#@     return 0
#@   }
#@ 
#@   if {$comment eq ""} { set comment "Marked/Skipped" }
#@   redirect /dev/null {define_user_attribute -class [P_get_class] -type string  step:${step} -quiet }
#@   redirect /dev/null {define_user_attribute -class [P_get_class] -type string  completed_substeps:${step} -quiet}
#@   redirect /dev/null {define_user_attribute -class [P_get_class] -type string  step_${step}:${substep} -quiet}
#@   redirect -variable aa {list_attributes -class [P_get_class]}
#@   if { [P_current_design_status] } {
#@     set done_substeps [get_completed_substeps $step]
#@     foreach index [lsearch -all  $INTEL_SUBSTEPS($step) $substep] {
#@       if {[lindex $done_substeps $index] != $substep } {
#@         set done_substeps [linsert $done_substeps $index $substep]
#@         break
#@       }
#@     }
#@     redirect /dev/null {set_attribute [P_get_current] completed_substeps:${step} $done_substeps}
#@     redirect /dev/null {set_attribute [P_get_current] step_${step}:${substep} $comment}
#@   }
#@ 
#@ }
#@ 
#@ 
#@ proc unmark_step {step} {
#@   set done_steps ""
#@   if { [P_current_design_status] } {
#@     redirect /dev/null {redirect -variable aa {list_attributes -class [P_get_class]}}
#@     set done_steps [get_attribute [P_get_current] completed_steps]
#@     set done_steps [P_lminus $done_steps $step]
#@     redirect /dev/null {set_attribute [P_get_current] completed_steps $done_steps}
#@     foreach substep [get_completed_substeps $step] { unmark_substep $step $substep }
#@   }
#@ }
#@ 
#@ 
#@ proc unmark_substep {step substep} {
#@   redirect -variable aa {list_attributes -class [P_get_class]}
#@   set steps_run [P_lsearch $aa step*]
#@   set attr_to_remove [P_lsearch $steps_run step_${step}:$substep]
#@   foreach attr $attr_to_remove {
#@     redirect /dev/null {remove_attribute -quiet [P_get_current] $attr}
#@   }
#@   set done_substeps [get_attribute [P_get_current] completed_substeps:${step}]
#@   set updated_done_substeps [P_lminus_r $done_substeps $substep]
#@   redirect /dev/null {set_attribute [P_get_current] completed_substeps:${step} $updated_done_substeps}
#@   redirect /dev/null {redirect -variable aa {list_attributes -class [P_get_class]}}
#@   set done_steps [get_attribute [P_get_current] completed_steps]
#@   set done_steps [P_lminus $done_steps $step]
#@   redirect /dev/null {set_attribute [P_get_current] completed_steps $done_steps}
#@ }
#@ 
#@ 
#@ proc get_completed_steps {args} {
#@   parse_proc_arguments -args $args results
#@ 
#@   set done_steps ""
#@   if { [P_current_design_status] } {
#@     if { [info exists results(step)] } {
#@       redirect -variable aa {list_attributes -class [P_get_class]}
#@       set done_steps [ get_attribute [P_get_current] completed_steps]
#@       foreach done_step $done_steps {
#@         if {$done_step eq $results(step)} {
#@           return $done_step
#@         }
#@       }
#@     } else {
#@       redirect -variable aa {list_attributes -class [P_get_class]}
#@       set done_steps [ get_attribute [P_get_current] completed_steps]
#@       return $done_steps
#@     }
#@   } else {
#@     return $done_steps
#@   }
#@ }
#@ define_proc_attributes get_completed_steps     -info "Get a list of complted steps"     -define_args {                        {step "Return step if it had completed." step list optional }
#@     }
#@ 
#@ 
#@ proc get_completed_substeps {step} {
#@   set done_substeps ""
#@   if { [P_current_design_status] } {
#@     redirect -variable aa {list_attributes -class [P_get_class]}
#@     set done_substeps [ get_attribute [P_get_current] completed_substeps:${step} -quiet]
#@     return $done_substeps
#@   } else {
#@     return $done_substeps
#@   }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/run_proc.tcl

#@ P_source_if_exists aliases.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/aliases.tcl

#@ ##############################################################################
#@ ### General Aliases
#@ alias runicc  runADF
#@ alias rundc   runADF
#@ alias runICC  runADF
#@ alias runDC   runADF
#@ alias so      source
#@ alias h       history
#@ alias cls     sh clear
#@ alias cdn     current_design
#@ alias pv      printvar
#@ alias source_if_exists P_source_if_exists
#@ alias PS      P_source_if_exists
#@ alias ps      P_source_if_exists
#@ 
#@ ### Aliases for read
#@ alias rdv     read_verilog
#@ alias rdb     read_db
#@ alias rdc     read_ddc
#@ 
#@ ### Aliases for reports
#@ alias rn      report_net -connections -verbose
#@ alias rc      report_cell -connections -verbose
#@ alias rtf     report_transitive_fanout
#@ alias rtt     report_transitive_fanin
#@ alias ra      report_attribute
#@ alias rt      report_timing -nets -capacitance -transition_time -input_pins -nosplit -significant_digits 1
#@ alias rt2     {rt -to}
#@ 
#@ ### Aliases for constraints
#@ alias sid     set_input_delay
#@ alias sod     set_output_delay
#@ alias set_mcp set_multicycle_path
#@ alias set_fp  set_false_path
#@ 
#@ ### Other aliases
#@ alias gp      get_pins
#@ alias ga      get_attribute
#@ alias gn      get_nets
#@ alias ac      all_connected
#@ alias rmd     remove_design
#@ alias ai      all_fanin -flat -to
#@ alias ao      all_fanout -flat -from
#@ alias afi     all_fanin -flat -start -to
#@ alias afo     all_fanout -flat -end -from
#@ alias cs      change_selection
#@ alias rmb     remove_placement_keepout
#@ alias gtp     get_timing_path
#@ 
#@ 
#@ if { [P_is_PSYN] || [P_is_ICC] } {
#@   ### Aliases for Physical compiler
#@   alias rn   report_net -connections -verbose -physical -nosplit
#@   alias rc   report_cell -connections -verbose -physical -nosplit
#@   alias rt   report_timing -transition_time -nets -capacitance -input_pins -nosplit -physical -significant_digits 3
#@   alias rtns report_timing -transition_time -nets -capacitance -input_pins -nosplit -physical -significant_digits 3
#@   alias rtm  report_timing -transition_time -nets -capacitance -input_pins -nosplit -delay_type min -significant_digits 3 -physical
#@   alias rtf  report_transitive_fanout -nosplit -from
#@   alias rtt  report_transitive_fanin -nosplit -to
#@   alias gs   get_selection
#@   alias rct  report_clock_timing -type latency -verbose -nosplit -physical -nets
#@   alias gc   get_cells
#@   alias gfc  get_flat_cells
#@   alias gfn  get_flat_nets
#@   alias gfp  get_flat_pins
#@ }
#@ 
#@ ### Aliases for PrimeTime
#@ if { [P_is_PT] } {
#@   alias rtM   report_timing -nosplit -nets -delay_type max -input_pins -significant_digits 0 -capacitance
#@   alias rt    report_timing -nosplit -nets -delay_type max -input_pins -significant_digits 0 -capacitance -transition_time
#@   alias rtm   report_timing -nosplit -nets -delay_type min -input_pins -significant_digits 0 -capacitance
#@   alias rtl   report_timing_location
#@   alias rnl   report_net_location
#@   alias rtMl  report_timing_location -delay_type max  -significant_digits 0 -pba path
#@   alias rtml  report_timing_location -delay_type min  -significant_digits 0 -pba path
#@   alias rtp   report_timing -nosplit -nets -delay_type min -input_pins -significant_digits 0 -path_type full_clock_expanded
#@   alias rtnM  report_timing -nosplit -nets -delay_type max -input_pins -significant_digits 0 -capacitance -crosstalk_delta
#@   alias rtnm  report_timing -nosplit -nets -delay_type min -input_pins -significant_digits 0 -capacitance -crosstalk_delta
#@   alias sc    sizeof_collection
#@   alias fc    filter_collection
#@   alias rfc   remove_from_collection
#@   alias rdc   report_delay_calculation -nosplit -cross
#@   alias rtf   report_transitive_fanout -nosplit -from
#@   alias rtt   report_transitive_fanin -nosplit -to
#@   alias gc    get_cells
#@   alias ga    get_attribute
#@   alias sad   set_annotated_delay
#@   alias ra    report_attribute -nosplit -application -class
#@   alias ai    all_fanin -flat -trace all -to
#@   alias ao    all_fanout -flat -trace all -from
#@   alias afia  all_fanin -flat -start -trace all -to
#@   alias afoa  all_fanout -flat -end -trace all -from
#@   alias get_flat_cells get_cells -hierarchical *
#@   alias gfc   get_flat_cells
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/aliases.tcl

#@ 
#@ 
#@ ### project specific setting
#@ P_source_if_exists project_setup.tcl -require
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/project_setup.tcl

#@ ##############################################################################
#@ 
#@ ####################################
#@ # Flow Vars
#@ ####################################
#@ 
#@ # Synthesis flow vars
#@ # To add an extra step to the flow update the *_STEPS var to add the new step
#@ # Also define *_SUBSTEPS(<new step>) to include the tcl files that need to be sourced during that step
#@ 
#@ set INTEL_SYN_STEPS {read_design read_constraints compile insert_dft inc_compile}
#@ 
#@ set INTEL_SYN_SUBSTEPS(read_design)           { read_design }
#@ set INTEL_SYN_SUBSTEPS(read_constraints)      { read_constraints read_phys_constraints create_scenarios }
#@ set INTEL_SYN_SUBSTEPS(compile)               { compile_prep create_path_group compile }
#@ set INTEL_SYN_SUBSTEPS(insert_dft)            { insert_dft }
#@ set INTEL_SYN_SUBSTEPS(inc_compile)           { compile_prep inc_compile change_names }
#@ 
#@ # APR Flow vars
#@ 
#@ set INTEL_APR_STEPS {import_design floorplan place post_place cts route post_route adr fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(import_design)      { dont_use import_design read_constraints create_scenarios create_path_group derive_pg}
#@ 
#@ set INTEL_APR_SUBSTEPS(floorplan)          { dont_use tool_constraints init_floorplan set_wiretracks macro_placement halo_d04 derive_pg create_power_straps interface_metals isolated_pin_extension io_placement add_tap_cells insert_antenna_diodes_on_input pre_place_fiducial_d04 pre_place_bonus_fib_d04 create_check_grid check_floorplan derive_pg }
#@ 
#@ set INTEL_APR_SUBSTEPS(place)              { dont_use tool_constraints cmax_interpolate set_ideal_clock_network cell_spacing_d04 layer_promotion place_opt  check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(post_place)         { dont_use tool_constraints cmax_interpolate psynopt insert_spare_kit check_place derive_pg change_names}
#@ 
#@ set INTEL_APR_SUBSTEPS(cts)                { dont_use tool_constraints cmax_interpolate cts_ndr_rules cts_options create_route_guides remove_ideal_clock_network cts add_pg_hookup route_options_drc redundant_via_insertion clock_route create_clock_shield remove_pg_hookup freeze_clock_nets update_clocks check_cts derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(route)              { dont_use tool_constraints cmax_interpolate route_options route_options_drc report_pre_route route_trackassign add_pg_hookup initial_detailroute incr_create_clock_shield verify_zrt_route derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(post_route) { dont_use tool_constraints cmax_interpolate route_options  route_options_drc antenna_rules remove_pg_hookup incr_route_opt insert_antenna_diodes_on_input tie_high incr_eco_detail_route opportunistic_local_fiducial_place incr_create_clock_shield add_filler_cells_d04 derive_pg add_pg_hookup incr_detailroute verify_zrt_route derive_pg check_route change_names }
#@ 
#@ #set INTEL_APR_SUBSTEPS(focal_opt)          { dont_use tool_constraints cmax_interpolate route_options route_options_drc remove_pg_hookup focal_opt incr_create_clock_shield inc_add_filler_cells_d04 add_pg_hookup focal_opt_cleanup derive_pg check_route change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(adr)                { dont_use tool_constraints route_options route_options_drc adr derive_pg}
#@ 
#@ set INTEL_APR_SUBSTEPS(fill)               { dont_use check_fill_view metal_via_fill create_port_layer }
#@ 
#@ # TO run UPF flow uncomment the APR_STEPS line below
#@ #set INTEL_APR_STEPS {import_design upf_floorplan upf_place upf_post_place cts route upf_post_route adr fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_floorplan)      { dont_use tool_constraints init_floorplan set_wiretracks macro_placement halo_d04 halo_power_voltage_island derive_pg create_power_switch connect_power_switch derive_pg create_ls_bounds create_power_plan compile_power_plan connect_sec_pg_power_switch interface_metals isolated_pin_extension io_placement add_tap_cells insert_antenna_diodes_on_input pre_place_fiducial_d04 pre_place_bonus_fib_d04 create_check_grid check_floorplan derive_pg }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_place)              { dont_use tool_constraints cmax_interpolate set_ideal_clock_network upf_sec_pg_hookup magnet_placement cell_spacing_d04 layer_promotion place_opt  check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_post_place)          { dont_use tool_constraints cmax_interpolate psynopt insert_spare_kit upf_sec_pg_hookup route_upf_ao_pg check_place derive_pg change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(upf_post_route)          { dont_use tool_constraints cmax_interpolate route_options route_options_drc antenna_rules remove_pg_hookup incr_route_opt insert_antenna_diodes_on_input tie_high incr_eco_detail_route opportunistic_local_fiducial_place add_filler_cells_d04 derive_pg upf_sec_pg_hookup route_upf_ao_pg add_pg_hookup incr_detailroute verify_zrt_route derive_pg check_route change_names }
#@ 
#@ # To Run ECO flow uncomment the INTEL_APR_STEPS line below
#@ #set INTEL_APR_STEPS {eco fill}
#@ 
#@ set INTEL_APR_SUBSTEPS(eco)                { dont_use tool_constraints cmax_interpolate route_options route_options_drc eco_remove_filler remove_pg_hookup eco derive_pg eco_legalize_placement add_filler_cells_d04 route_eco add_pg_hookup incr_detailroute verify_zrt_route change_names }
#@ 
#@ set INTEL_APR_SUBSTEPS(metal_only_eco)     { dont_use tool_constraints cmax_interpolate route_options route_options_drc metal_only_eco verify_zrt_route change_names }
#@ 
#@ ####################################
#@ #Path Settings
#@ ####################################
#@ 
#@ set fdk_lib                     d04
#@ set fdk_stdcells_sp_dir         $env(INTEL_STDCELLS)
#@ set fdk_stdcells_misc_dir       $env(INTEL_STDCELLS_MISC)
#@ set fdk_asic_flows_dir          $env(INTEL_ASIC)/asicflows/synopsys
#@ set fdk_icv_fill_dir            $env(INTEL_PDK)/fill/icv
#@ set fdk_icv_adr_dir             $env(INTEL_PDK)/runsets/adr
#@ set fdk_star_ext_tech_dir       $env(INTEL_PDK)/extraction/starrc/cmdfiles
#@ set fdk_icc_ext_tech_dir        $env(INTEL_PDK)/extraction/icc/techfiles
#@ set fdk_icc_tech_dir            $env(INTEL_PDK)/apr/icc/
#@ 
#@ ######################################
#@ #Library Variables
#@ ######################################
#@ 
#@ # Variable used to set operating condition. Valid values are bc_wc, on_chip_variation.
#@ set INTEL_ANALYSIS_TYPE             "bc_wc"
#@ 
#@ # Max and Min operating condition used during set_operating_condition setting
#@ set INTEL_MAX_OPCON           slow_1.00
#@ if {$synopsys_program_name == "icc_shell" } {
#@   set INTEL_MIN_OPCON       fast_1.00
#@ } elseif {$synopsys_program_name == "dc_shell" || $synopsys_program_name == "de_shell" } {
#@   set INTEL_MIN_OPCON       slow_1.00
#@ }
#@ 
#@ # Include the names of all memories, io's etc to be used in the block. An example is given below
#@ # set INTEL_HARD_MACRO_NAME         [list c69p0rgf1r1w4t128x34 c69p0ssa2048x52cm4]
#@ 
#@ 
#@ #######################################
#@ #Tech File Variables
#@ #######################################
#@ 
#@ set INTEL_GDS_OUT_LAYER_MAP       $fdk_icc_tech_dir/1273Milkyway2GdsLayerMap
#@ set INTEL_MW_TECH_FILE            $fdk_icc_tech_dir/${fdk_lib}/p1273.tf
#@ set INTEL_MAX_TLUPLUS_FILE        $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.tluplus
#@ set INTEL_MIN_TLUPLUS_FILE        $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.tluplus
#@ set INTEL_TLUPLUS_MAP_FILE        $fdk_star_ext_tech_dir/asic.starrc.map
#@ set INTEL_MAX_TLUPLUS_EMUL_FILE   $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.mfill.tluplus
#@ set INTEL_MIN_TLUPLUS_EMUL_FILE   $fdk_icc_ext_tech_dir/p1273_3x1r6.tttt.mfill.tluplus
#@ 
#@ ########################################
#@ #Design Variables:
#@ ########################################
#@ 
#@ ############SYN, APR and PV#############
#@ ########################################
#@ 
#@ # Top level block name for Physical Design
#@ set INTEL_DESIGN_NAME   ""
#@ 
#@ # Modular grid x and y
#@ set INTEL_MD_GRID_X                 1.680
#@ set INTEL_MD_GRID_Y                 1.596
#@ 
#@ # Max and min routing layers. These variables are used by set_ignored_layers icc command and various other tcl scripts.
#@ set INTEL_MAX_ROUTING_LAYER                  "m8"
#@ set INTEL_MIN_ROUTING_LAYER                  "m0"
#@ set INTEL_RC_IGNORE_LAYERS                   "m0 tm1"
#@ # Override the min routing layer contraint during placement only. Used in tool_constraints.tcl.
#@ # This has proven to improve post route QOR by reducing RC in placement.
#@ set INTEL_MIN_ROUTING_LAYER_OVERRIDE(place)           "m2"
#@ set INTEL_MIN_ROUTING_LAYER_OVERRIDE(post_place)      "m2"
#@ 
#@ # MW Power net Name
#@ set INTEL_MW_POWER_NET    vcc
#@ set INTEL_MW_GROUND_NET   vss
#@ 
#@ # Variable to enable the usage of SDC file. If set to 1, read ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc. If set to 0, read ./inputs/constraints/clocks.tcl and ./inputs/constraints/constraints.tcl
#@ set INTEL_SDC_FILE      0
#@ 
#@ 
#@ # Variable to use scan flops or not (if 1, compile -scan otherwise -scan is not used). If var set to 1 then, Synthesis will run compile -scan and compiled netlist will have scan flops.
#@ set INTEL_SCAN_REPLACE_FLOPS 1
#@ 
#@ #Variable to insert scan chain, if set to 1, DC will insert scan chain and  write out ./outputs/${INTEL_DESIGN_NAME}.scandef. APR will read in ./inputs/${INTEL_DESIGN_NAME}.scandef and run place_opt -optimize_dft
#@ set INTEL_INSERT_SCAN   0
#@ 
#@ # If set to 1, enables UPF flow for synthesis and APR.
#@ set INTEL_UPF     0
#@ 
#@ # Set RTL & post-synthesis UPF version, either 1.0 or 2.0.
#@ set INTEL_UPF_VERSION   1.0
#@ 
#@ # Set the list of nets incase of UPF design
#@ set INTEL_UPF_POWER_NETS {vss vcc}
#@ 
#@ # If set to 1, synthesis and APR flow will read ./inputs/constraints/${INTEL_DESIGN_NAME}.saif and optimizes dynamic power.
#@ set INTEL_SAIF      0
#@ 
#@ # Variable used to define the hierarchical instance (top/instA) for which switching activity is annotated. If not defined then top level design name will be assumed
#@ set INTEL_SAIF_INSTANCE   ""
#@ 
#@ # SPECIFY DEFAULT SWITCHING ACTIVITY for VECTOR-FREE power analysis and dynamic power optimization.
#@ # Use these variables to set switching activity for dynamic power optimization if not using SAIF.
#@ # Annotate a suitable default Toggle Rate value and Static Probability, for example, 0.2 to all the starting points.
#@ set INTEL_POWER_TR 0.2
#@ set INTEL_POWER_SP 0.3
#@ 
#@ ############SYN Specific################
#@ ########################################
#@ 
#@ # If set to 1 then DC will read the .def file for floorplan from ./inputs/floorplan/${INTEL_DESIGN_NAME}.def
#@ set INTEL_TOPO_DEF      0
#@ 
#@ # Variable to set insert_clock_gating (if 1 then insert_clock_gating and compile_ultra -clock_gate is used)
#@ set INTEL_INSERT_CLOCKGATES         1
#@ 
#@ # Set to 1, to invoke synopsys physical guidance to generate ddc/mwdb for seed placement to APR. DEF file must be provided and INTEL_TOPO_DEF set to 1.
#@ set INTEL_SPG                       0
#@ 
#@ # Set to 1, to enable congestion optimization
#@ set INTEL_CONGESTION_OPTIMIZE       0
#@ 
#@ # If set to 1 then ICC will read .ddc file from ./inputs/${INTEL_DESIGN_NAME}.syn.ddc
#@ set INTEL_DDC                       0
#@ 
#@ ###########APR Specific #################
#@ #####################################################################
#@ 
#@ #Input file name variables - Provide full paths to file names. Examples provided below.
#@ #Note - if variable not set, default path and filename (as shown in example below) will be assumed.
#@ 
#@ # set INTEL_INPUT_NETLIST ./inputs/<INTEL_DESIGN_NAME>.syn.vg
#@ # set INTEL_INPUT_SCANDEF ./inputs/<INTEL_DESIGN_NAME>.syn.scandef
#@ # set INTEL_INPUT_DEF ./inputs/floorplan/<INTEL_DESIGN_NAME>.floorplan.def
#@ # set INTEL_INPUT_UPF ./inputs/upf/<INTEL_DESIGN_NAME>.syn.upf
#@ # set INTEL_INPUT_SDC ./inputs/constraints/<INTEL_DESIGN_NAME>.sdc
#@ 
#@ ########## Main Command Variables ###################################
#@ # The following variables set the options to main APR commands like place_opt, psynopt, etc
#@ 
#@ # place_opt.tcl may append additional switches "-power", "-layer_optimization", "-optimize_dft" or "-spg" conditionally based on other INTEL_* conrol vars.
#@ set INTEL_PLACE_CMD "place_opt -congestion -effort medium"
#@ 
#@ # used in psynopt.tcl
#@ set INTEL_POST_PLACE_CMD "psynopt -area_recovery -power -congestion"
#@ 
#@ # used in cts.tcl
#@ set INTEL_CLK_OPT_CMD "clock_opt -only_cts -no_clock_route -power"
#@ set INTEL_POST_CTS_OPT_CMD "psynopt -only_hold_time"
#@ 
#@ # route_trackassign.tcl may append "-power" switch conditionally based on other INTEL_* conrol vars.
#@ set INTEL_ROUTE_TRACK_ASSIGN_CMD "route_opt -stage track -effort medium -xtalk_reduction"
#@ 
#@ # used in initial_detailroute.tcl
#@ set INTEL_INITIAL_DETAIL_ROUTE_CMD "route_opt  -initial_route_only -stage detail"
#@ 
#@ # used in incr_route_opt.tcl
#@ set INTEL_INCR_ROUTE_OPT_CMD "route_opt -incremental -xtalk_reduction -power"
#@ 
#@ # used in incr_eco_detail_route.tcl
#@ set INTEL_INCR_ECO_DETAIL_ROUTE_CMD "route_zrt_eco -open_net_driven true -reroute modified_nets_first_then_others; route_zrt_detail -incremental true"
#@ 
#@ # used in incr_detailroute.tcl
#@ set INTEL_INCR_DETAIL_ROUTE_OPT_CMD "route_zrt_detail -incremental true -max_number_iterations 45"
#@ 
#@ # if additional focal_opt fixing needs to be done please update variable and add necessary focal_opt commands
#@ #set INTEL_FOCAL_OPT_CMD "focal_opt -power; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_power"
#@ # for example if drc fixing needs to be done apart from power, variable can be udpated as below
#@ # set INTEL_FOCAL_OPT_CMD "focal_opt -drc_pins all; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_drc; focal_opt -power; save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_fopt_power"
#@ 
#@ # Set this according to focal_opt being done, if just -power is used, incr route may not be needed. If using other modes you will need to do incr routing.  
#@ # used in focal_opt_cleanup.tcl
#@ #set INTEL_POST_FOCAL_OPT_ROUTE_CMD "verify_zrt_route"
#@ # Example showing incr routing done for non -power focal_opt modes.
#@ # set INTEL_POST_FOCAL_OPT_ROUTE_CMD "verify_zrt_route;route_zrt_detail -incremental true"
#@ 
#@ # Set to 1 to enable dynamic power optimization in ICC
#@ set INTEL_DYNAMIC_POWER 0
#@ 
#@ #############PG Hookup##################
#@ 
#@ ## Boundary net info file are used by the tcl/binary based pg hookup flow. Not needed by runset based flow.
#@ set INTEL_PWR_HOOKUP_ATTRIB [list $fdk_stdcells_sp_dir/utilities/d04_p1273.4_c.0_all_boundary_net_info.txt                                  $fdk_stdcells_misc_dir/utilities/d04_misc_p1273.4_c.0_all_boundary_net_info.txt]
#@ 
#@ ## Runset based needed variables.
#@ set INTEL_PWR_HOOKUP_GRID_COUNT              4
#@ set INTEL_PWR_HOOKUP_LAYERS                  "vcn tcn gcn m0 v0 m1 v1"
#@ set INTEL_PWR_HOOKUP_DH_BONUS_CELLS_LIST     {c04bfy??????? d04bfy???????}
#@ set INTEL_PWR_HOOKUP_CELLS_LIST              {*c04?????[^grx]???? *d04?????[^grx]????}
#@ set INTEL_PWR_HOOKUP_CELLS_LIST_XN           {*d04?????x????}
#@ set INTEL_PWR_HOOKUP_REMOVAL_COMPATIBILITY   1
#@ 
#@ set INTEL_PROCESS_NAME p1273
#@ set INTEL_STDCELL_TILE_HEIGHT 0.399
#@ set INTEL_FLIP_FIRST_ROW 0
#@ set INTEL_XN_LIBRARY 0
#@ 
#@ # The following variables are also used, but defined in other parts of project_setup.tcl, by the runset based pg hookup.
#@ # INTEL_UPF, INTEL_MW_POWER_NET, INTEL_MW_GROUND_NET, INTEL_STDCELL_TILE, INTEL_DFM_RELEASE_DIR
#@ 
#@ 
#@ #############Floorplan##################
#@ 
#@ set INTEL_FP_INPUT                 "" ; # DEF(import fp def)|FP_TCL(import fp tcl)|""
#@ set INTEL_DESIGN_WIDTH             "";  #must be set by user for each design
#@ set INTEL_DESIGN_HEIGHT            "";  #must be set by user for each design
#@ 
#@ # Example
#@ # set INTEL_FP_BOUNDARY             "{{0.000 0.000} {2138.112 0.000} {2138.112 1804.032} {409.248 1804.032} {409.248 651.456} {0.000 651.456} {0.000 0.000}}";
#@ 
#@ set INTEL_METAL_LAYERS {m2 m3 m4 m5 m6 m7 m8 m9}
#@ set INTEL_MAX_PG_LAYER "m9"
#@ 
#@ set INTEL_STDCELL_TILE                   "core"
#@ set INTEL_STDCELL_BONUS_GATEARRAY_TILE   "bonuscore"
#@ set INTEL_STDCELL_CORE2H_TILE            "core2h"
#@ 
#@ # List of halo cells to be used during halo insertion
#@ set INTEL_halo_b_horiz         "fdk73d84_asic_halo_hhb"
#@ set INTEL_halo_c_horiz         "fdk73d84_asic_halo_hhc"
#@ set INTEL_halo_b_corner        "fdk73d84_asic_halo_hcb"
#@ set INTEL_halo_c_corner        "fdk73d84_asic_halo_hcc"
#@ set INTEL_halo_b_inside_corner "fdk73d84_asic_halo_hib"
#@ set INTEL_halo_c_inside_corner "fdk73d84_asic_halo_hic"
#@ set INTEL_halo_side            "fdk73d84_asic_halo_hvn"
#@ set INTEL_halo_power_cell      "fdk73d84_asic_halo_hvniso"
#@ 
#@ # Tap cell to be used during tap cell insertion
#@ set INTEL_TAP_CELL                       "${fdk_lib}tap02ldz05"
#@ 
#@ # Sets the terminal length for each metal layer for use in P_create_pg_terminals procedure during FRAM generation.
#@ set INTEL_TERM_LENGTH "m1 0.070 m2 0.084 m3 0.084 m4 0.084 m5 0.084 m6 0.160 m7 0.204 m8 0.274 m9 0.540"
#@ 
#@ #Create route guides over specified macros
#@ #------------------------------------------
#@ #1. Route Guides will be created only on layers m0-m4 and layers containing macro pins.
#@ #2. Route guides should be provided in the format <layer_name> <x_bloat_val> <y_bloat_val>
#@ #3. Both x and y bloat values should be provided. Either both x and y bloat should be NA (or) both x and y bloat should be a double value.
#@ #4. If both x_bloat_val and y_bloat_val equal 0, RGs will be created the exact size of the macro
#@ #5. If both x_bloat_val and y_bloat_val equal NA, RGs will not be created for that layer
#@ #6. Use INTEL_MACRO_RG_LIST(DEFAULT) to specify the default bloat values to use for all macros
#@ #7. Use INTEL_MACRO_RG_LIST(<macro_ref_name>) to override the default bloat values for the specified <macro_ref_name>
#@ #8. Use INTEL_MACRO_EXCLUSION_LIST to specify macros which should be completely excluded from creating RGs.
#@ 
#@ #Note: (E2E Spacing) - (MinSpacing value of layer in techfile) = (Bloat Value of route guide outside macro boundary)
#@ #FYI: Pre-calculated Bloat values for all layers based on M*_41 (E2E spacing) and MinSpacing value in Techfile.
#@ #set INTEL_MACRO_RG_LIST(DEFAULT)  "m2  0.032  0      m3  0  0.032  \   
#@ #                                   m4  0.032  0      m5  0  0.032  #                                   m6  0.040  0      m7  0  0.034  #                                   m8  0.014  0      m9  NA NA"
#@ 
#@ set INTEL_MACRO_RG_LIST(DEFAULT) "m2  0.032 0      m3  0  0.032     m4  0.032 0                                   m5  0     0.032  m6  NA NA        m7  NA    NA                                   m8  NA    NA     m9  NA NA"
#@ 
#@ #The example below shows how to override default RG values for macro reference (iromu1r0w6144d16w1spu0p) for layers m4 and m5.
#@ #set INTEL_MACRO_RG_LIST(iromu1r0w6144d16w1spu0p) "m4 0.10 -0.10 m5 -0.210 -0.210"
#@ 
#@ #The example below shows how to completely exclude some macro references.
#@ #set INTEL_MACRO_EXCLUSION_LIST [list iromu1r0w6144d16w1spu0p iromu1r0w6144d16w1spu1p]
#@ 
#@ # Enable bonus gate array cel pre-placement
#@ set INTEL_INSERT_BONUS_GATE_ARRAY 1
#@ 
#@ # Set pre-placement bonus array cell
#@ set INTEL_PREPLACE_BONUSGATEARRAY_CELL "${fdk_lib}bar00nnz64"
#@ 
#@ #Update the list of ports where you don't need diode insertion
#@ set INTEL_NO_INPUT_DIODE_PORTS ""
#@ 
#@ ############### LOCAL FIDUCIALS ##########################
#@ # 2x fiducial cells are placed spaced apart in staggered  fashion, the follwing variables control the fiducial cell being placed.
#@ set INTEL_LOCAL_FIDUCIAL_PREPLACE_CELL "d04qfd02ndz00"
#@ 
#@ # These cells are placed opportunistically post-route
#@ set INTEL_LOCAL_FIDUCIAL_POSTROUTE_CELLS "d04qfd02nnz00 d04qfd01ndz00"
#@ 
#@ 
#@ ################# UPF Specific variables ############################
#@ 
#@ ####################################################################################
#@ # Sets up the UPF flow specific variables
#@ # These are only block independent vars. You may need to setup block specific vars
#@ # Example of a block specfic block_setup.tcl is provided with the DHM testcase.
#@ ####################################################################################
#@ 
#@ ###################################
#@ # Generic variables
#@ ###################################
#@ 
#@ # Select the UPF power plan to use if $INTEL_UPF == 1.
#@ set INTEL_POWER_PLAN mesh_upf_1aosv
#@ 
#@ # Sets default values for Power Switch. All the values provided below are the default values. User can override these variables locally in block_setup.tcl on a per domainn basis.
#@ 
#@ # Defines the power switch lib cell to use. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_POWER_SWITCH(default) d04pws00ld8b0
#@ 
#@ # Sets the x and y pitch of Power switch used for create_power_switch_array command. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_PS_X_PITCH(default) 13.44
#@ set INTEL_PS_Y_PITCH(default) 9.576
#@ 
#@ # Set the connect configuration for Power switch enables. Default value is used for all voltage ares. Users can update on a per domain basis if needed.
#@ set INTEL_PS_CONNECT_CONFIG(default) "daisy"
#@ set INTEL_PS_CONNECT_CORNER(default) "lower_left"
#@ 
#@ # The following variables(INTEL_PS_ALIGN_METAL_*) are used by the flow to calculate lower_left offset of power switches w.r.to the voltage area.
#@ # The values provided below are offset values of AON Power straps for the layer specified.
#@ # These values are used to align the Power Switch cells under m7 and m6.
#@ # Users are not needed to change these values unless the Power Strap offsets/pitch is updated (or) users want to align the power swtich cells differently and not under m6/m7 AON straps
#@ 
#@ # The offset value provides the offset values for AON power straps in the same order as the INTEL_UPF_POWER_NETS. The value also changes for singe supply vs dual supply grids. The variable is indexed accordingly
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_2aosv,m7) {0.896 1.344 2.464}
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_1aosv,m7) {0.896 2.464}
#@ 
#@ # The pitch value provides the pitch of AON power straps for which the offset is provided above.
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_2aosv,m7) 6.72
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_1aosv,m7) 6.72
#@ 
#@ # Values for m6 AON straps
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_2aosv,m6) {0.336 0.672 2.520}
#@ set INTEL_PS_ALIGN_METAL_OFFSET(mesh_upf_1aosv,m6) {0.336 1.932}
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_2aosv,m6) 3.192
#@ set INTEL_PS_ALIGN_METAL_PITCH(mesh_upf_1aosv,m6) 3.192
#@ 
#@ # Values for power switch offset for top/right boundary. The left/bottom offset is calculated by flow based on INTEL_PS_ALIGN_METAL_* values provided above.
#@ # For a non-zero value, the insertion region for power switches is shrinked from the voltage area boundary by the offset value provided below.
#@ set INTEL_PS_RIGHT_OFFSET 0
#@ set INTEL_PS_TOP_OFFSET 0
#@ 
#@ # Users can create Level shifter bounds and assign level shifters cells to these bounds.
#@ # All Always-on straps are distributed over these bounds to enable seconday PG hookup for Level shifter cells.
#@ # Users need to set the variables following the constraints provided.
#@ 
#@ # NOTE: Side margins for VA bands start from lower left-most side of voltage area of $power_domain in clockwise order, and must be 0 or positive numbers on grids of horizontal placement width for vertical sides and double-row height for horizontal sides.
#@ # NOTE: Number of margins must match the sides of voltage area of $power_domain.
#@ # NOTE: VA band width should be at least widths of vertical halo cell + widest isolation or level-shifter cells used.
#@ # NOTE: VA band height should be at least 2 rows as the lwevel shifter cells are double height cells.
#@ 
#@ # NOTE: INTEL_LS_BOUND_CELLS($power_domain,<inner/outer>) must match cells of level shifter with parent/self location of $power_domain specified in UPF.
#@ 
#@ #set INTEL_LS_BOUND(pd_sleep1,inner) "0 0 $band_width 0"
#@ #set INTEL_LS_BOUND_CELLS(pd_sleep1,inner) u_dhm_unit_1/u_dhm_bypass/u_dhm_sleep_logic/*_UPF_LS
#@ 
#@ # Set name of templates to use from template file
#@ # The template name values provided below are for the default templates provided with the kit. Users are expected to update this list only if they change template names/add additional templates.
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,top) {common common_second_swap}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,always_on) {always_on_swap always_on always_on_second always_on_third}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_1aosv,primary) {primary primary_second primary_third}
#@ 
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,top) {common common_second_swap}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,always_on) {always_on always_on_second_vss}
#@ set INTEL_POWER_PLAN_TEMPLATE_NAMES(mesh_upf_2aosv,primary) {primary primary_second primary_second_swap primary_second_power}
#@ 
#@ 
#@ ###############################################
#@ # Variables used for Secondary PG hookup
#@ ###############################################
#@ 
#@ #Note - Use 1aosv if $INTEL_POWER_PLAN is set to mesh_upf_1aosv. Use 2aosv if $INTEL_POWER_PLAN is set to mesh_upf_2aosv.
#@ #none implies default params applied across the entire design. Specify <va_name> to override params for a specific voltage area.
#@ 
#@ # INTEL_PWRGRID_PARAMS_PRIMARY(1aosv/2aosv, <va_name>/none) "<layer> <width> <pitch> <offset>"
#@ 
#@ set INTEL_PWRGRID_PARAMS_PRIMARY(1aosv,none)  "m4b 0.076 6.384 5.090                                                m4a 0.076 6.384 2.890                                                m4  0.084 6.384 0.798                                                m3  0.084 1.680 1.288"
#@ 
#@ set INTEL_PWRGRID_PARAMS_PRIMARY(2aosv,none)   "m4b 0.084 9.576 7.182                                                 m4a 0.084 9.576 3.990                                                 m4  0.084 9.576 0.798                                                 m3  0.084 1.680 1.288"
#@ 
#@ # INTEL_PWRGRID_PARAMS_PRIMARY(1aosv/2aosv, <index>, <va_name>/none) "<layer> <width> <pitch> <offset>"
#@ # index implies index value of the AON net in INTEL_UPF_POWER_NETS.
#@ # Eg. INTEL_UPF_POWER_NETS is [list vss vcc vccL]. To specify params for vcc AON, use index 1. To specify params for vccL AON, use index 2.
#@ 
#@ set INTEL_PWRGRID_PARAMS_AON(1aosv,1,none)    "m4b 0.076 6.384 6.082                                                m4a 0.084 6.384 3.990                                                m4  0.076 6.384 1.898                                                m3  0.084 1.680 1000000.0"
#@ set INTEL_PWRGRID_PARAMS_AON(2aosv,1,none)     "m4b 0.076 9.576 8.282                                                 m4a 0.076 9.576 5.090                                                 m4  0.076 9.576 1.898                                                 m3  0.084 1.680 1000000.0"
#@ set INTEL_PWRGRID_PARAMS_AON(2aosv,2,none)     "m4b 0.076 9.576 9.274                                                 m4a 0.076 9.576 6.082                                                 m4  0.076 9.576 2.890                                                 m3  0.084 1.680 1000000.0"
#@ 
#@ ################################################
#@ # Variables used for Frequency based Max-Cap LUT
#@ ################################################
#@ #Location of Max-Cap LUT CSV file
#@ set INTEL_CMAX_LUT $env(INTEL_STDCELLS)/erc/stdcell73_3x1r6u1_d04_rv_allfreq.csv
#@ 
#@ #Clock period to use if min clock period could not be determined
#@ set INTEL_CMAX_DEFAULT_PERIOD 1500.00
#@ 
#@ #############Placement##################
#@ 
#@ set INTEL_CRITICAL_RANGE           "2000";
#@ set INTEL_AREA_CRITICAL_RANGE      "not_set";
#@ set INTEL_POWER_CRITICAL_RANGE     "not_set";
#@ set INTEL_TIE_HIGH_CELL            "${fdk_lib}tih00wnz00"
#@ set INTEL_TIE_LOW_CELL             "${fdk_lib}til00wnz00"
#@ 
#@ set INTEL_INSERT_SPARE_KITS        "0"
#@ set INTEL_SPARE_CELLS              "${fdk_lib}nan02ln0b5 ${fdk_lib}nan02ln0c0 ${fdk_lib}nan02ln0d0 ${fdk_lib}non02ln0b5 ${fdk_lib}non02ln0c0 ${fdk_lib}non02ln0c5 ${fdk_lib}inn00ln0a5 ${fdk_lib}inn00ln0b5"
#@ set INTEL_DIST_BTW_SPARE_KITS      "30";
#@ 
#@ ## Set to 1 to enable Layer Promotion
#@ set INTEL_LAYER_PROMOTION           0
#@ 
#@ # Set to "magnet" for magnet placement, "port" for placing cells close to ports and "" to let place_opt place the iso cells.
#@ set INTEL_ISOCELL_PLACER            ""
#@ 
#@ ################CTS#####################
#@ 
#@ set INTEL_CTS_NETS                          ""
#@ set INTEL_CTS_MAX_ROUTING_LAYER(DEFAULT)    "m8"
#@ set INTEL_CTS_MIN_ROUTING_LAYER(DEFAULT)    "m6"
#@ set INTEL_CTS_LEAF_MIN_LAYER                "m6"
#@ set INTEL_CTS_LEAF_MAX_LAYER                "m7"
#@ set INTEL_ENABLE_CLOCK_SPACING              "1" ; #Enables/disables clock cell spacing for IR/EM
#@ set INTEL_CTS_MAX_FANOUT                    "24"
#@ set INTEL_CTS_ADVANCED_DRC_FIXING           "true"
#@ 
#@ ######################################
#@ # CTS NDR SETUP
#@ ######################################
#@ set INTEL_ENABLE_CLOCK_NDR "1"
#@ set INTEL_CTS_NDR_RULE(DEFAULT) "ndr_defaultW_3T_noSh_Lth"
#@ 
#@ ########################################################################
#@ # NDR definitions for each clock in the design
#@ #   Note - If INTEL_ENABLE_CLOCK_NDR is set to '0', then default routing
#@ #          rules are used for clocks
#@ ########################################################################
#@ #set INTEL_CTS_NDR_RULE(clk) "2xSpacing"
#@ #set INTEL_CTS_MAX_ROUTING_LAYER(clk) "m8"
#@ #set INTEL_CTS_MIN_ROUTING_LAYER(clk) "m7"
#@ 
#@ set INTEL_CTS_CELLS_DEFAULT "${fdk_lib}gbf00nd0* ${fdk_lib}gin00nd*"
#@ set INTEL_CTS_CELLS_SIZE "${fdk_lib}gbf00nd0* ${fdk_lib}gin00nd* ${fdk_lib}cgc01nd* ${fdk_lib}cgc03nd*                           ${fdk_lib}cgc00nd* ${fdk_lib}cgc02nd* ${fdk_lib}cgm22nd*                           ${fdk_lib}gan10nd* ${fdk_lib}gan20nd*                           ${fdk_lib}gan30nd* ${fdk_lib}gan40nd*                           ${fdk_lib}gmx22nd* ${fdk_lib}gna00nd*                           ${fdk_lib}gna02nd* ${fdk_lib}gno00nd*                           ${fdk_lib}gno02nd* ${fdk_lib}gor00nd*"
#@ set INTEL_CTS_CELLS_DELAY_INSERT "${fdk_lib}gbf10nd* ${fdk_lib}gbf20nd* ${fdk_lib}gbf30nd* ${fdk_lib}gin20nd*"
#@ set INTEL_CTS_CELL_BOUNDARY "${fdk_lib}gbf00nd0h0"
#@ 
#@ ##############Routing###################
#@ 
#@ set INTEL_ZROUTE_FIX_ANTENNA       1
#@ set INTEL_ZROUTE_VIA_DBL           "1"     ;# Redundant via insertion
#@ set INTEL_ANTENNA_DIODE            "${fdk_lib}gnc01lnz00"
#@ set INTEL_DELAY_CELL_LIST          "${fdk_lib}bfn11wn* ${fdk_lib}bfn12wn* ${fdk_lib}bfn13wn*"
#@ 
#@ #############Filler cells###############
#@ 
#@ set INTEL_BONUS_GATEARRAY_CELLS    "${fdk_lib}bar00nnz64 ${fdk_lib}bar00nnz32 ${fdk_lib}bar01nnz16 ${fdk_lib}bar01nnz08 ${fdk_lib}bar01nnz04"
#@ set INTEL_STDCELL_FILLER_CELLS     "${fdk_lib}spc00nnz03 ${fdk_lib}spc00nnz02 ${fdk_lib}spc00nnz01"
#@ set INTEL_DECAP_CELLS              "${fdk_lib}dcp00wnz08 ${fdk_lib}dcp00wnz04"
#@ set INTEL_2X_DECAP_CELLS           "${fdk_lib}dcp00wdz64"
#@ 
#@ # Set this switch to pick type of fillers, valid options are default & decap. Please refer add_filler_cells.tcl for more details
#@ set INTEL_STDCELL_FILLER_MODE decap
#@ 
#@ ############Metal/via fill##############
#@ 
#@ set INTEL_DFM_RELEASE_DIR   $fdk_icv_fill_dir
#@ set INTEL_DFM_UIN_DIR       $INTEL_DFM_RELEASE_DIR/uin/${fdk_lib}
#@ set INTEL_DFM_WRITE_MW_OUTPUT true
#@ set INTEL_DFM_ZONE_VIA_FILL true
#@ set INTEL_DFM_MAX_FILL_LAYER "m9"
#@ 
#@ ################ ADR ###################
#@ 
#@ set INTEL_ADR_RELEASEPATH $fdk_icv_adr_dir
#@ set INTEL_ADR_RUNSET_FILE "$INTEL_ADR_RELEASEPATH/adr.rs"
#@ # Sets pointer to configuration file that defines DRCs to target
#@ set INTEL_ADR_CONFIG_FILE "$INTEL_ADR_RELEASEPATH/adr.cfg"
#@ set INTEL_ADR_USER_DEF_OPT "-I . -I [pwd]/adr_work/adr_control/ -I $INTEL_ADR_RELEASEPATH/ -I $INTEL_DFM_UIN_DIR/"
#@ # Specifies the number of ADR iterations
#@ set INTEL_ADR_LOOPS 5
#@ 
#@ ############# ECO Flow Specific Variables #######
#@ # NOTE: In Normal Operation INTEL_ECO_TYPE is set 0; In ECO mode INTEL_ECO_TYPE can be set to 1, 2 or 3 based on the type of ECO that you are performing
#@ # When INTEL_ECO_TYPE set to 1, ECO is based on a TCL script where all your ECO's are defined.
#@ # When INTEL_ECO_TYPE set to 2, ECO is based on a verilog netlist. It is a unfreeze approach.  A verilog netlist w/ minor deltas is used.
#@ # For freeze silicon verilog approach, refer to place_freeze_silicon command in ICC for more details.
#@ set INTEL_ECO_TYPE 0
#@ #set INTEL_ECO_TCL inputs/eco1.tcl
#@ #set INTEL_ECO_NETLIST dhm.eco2.vg
#@ 
#@ ############# MCMM Flow Specific Variables ################
#@ # Comments on MCMM Flow:
#@ # The prerequisite for running the MCMM flow is:
#@ #   1) The library.tcl is updated to include PVTs referenced here by set_operating_conditions. Macros PVT must match the PVT of the stdcell libraries for the tools to link to them correctly.
#@ #   2) The variable below be set for each scenario created.
#@ #
#@ # All MCMM related setup is now done through create_scenarios.tcl. If something custom is required, please copy the file over locally an modify as needed.
#@ 
#@ # When using MCMM (set INTEL_MCMM 1), it is set to 0 by default
#@ # Also need to set all the MCMM variables below (example provided below)
#@ set INTEL_MCMM 0
#@ 
#@ ### Specify the name of each scenario.
#@ ### By default, all scenarios are active.
#@ ##set INTEL_MCMM_SCENARIOS         "max_corner_1 max_corner_2 min_corner_1"
#@ ##
#@ ### Specify the active scenarios by step. (OPTIONAL)
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(place)      "max_corner_1"
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(post_place) "max_corner_1 max_corner_2"
#@ ##set INTEL_MCMM_SCENARIO_ACTIVE(cts)        "max_corner_1 min_corner_1"
#@ ##
#@ ### Specify the default 'current_scenario'
#@ ##set INTEL_MCMM_SCENARIO_DEFAULT  "max_corner_1"
#@ ##
#@ ### Foreach scenario, define the operating condition for that scenario.
#@ ##set INTEL_MCMM_OPCON(max_corner_1) "set_operating_conditions -analysis_type on_chip_variation -max slow_1.00 -max_library d04_nn_p1273_6x1r2_psss_0.75v_125c_ccst"
#@ ##set INTEL_MCMM_OPCON(max_corner_2) "set_operating_conditions -analysis_type on_chip_variation -max slow_1.00 -max_library d04_nn_p1273_6x1r2_psss_0.98v_125c_ccst"
#@ ##set INTEL_MCMM_OPCON(min_corner_2) "set_operating_conditions -analysis_type on_chip_variation -max fast_1.00 -max_library d04_nn_p1273_6x1r2_pfff_0.98v_-40c_ccst"
#@ ##
#@ ### Foreach scenario, define the min and max tlu+ file
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(max_corner_1) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(max_corner_2) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_FILE(min_corner_1) $INTEL_MAX_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(max_corner_1) $INTEL_MIN_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(max_corner_2) $INTEL_MIN_TLUPLUS_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_FILE(min_corner_1) $INTEL_MIN_TLUPLUS_FILE
#@ ##
#@ ### Foreach scenario, define the min and max emulated tlu+ file (OPTIONAL)
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(max_corner_1) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(max_corner_2) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE(min_corner_1) $INTEL_MAX_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(max_corner_1) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(max_corner_2) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ ##set INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE(min_corner_1) $INTEL_MIN_TLUPLUS_EMUL_FILE
#@ 
#@ ### For scenario options, please provide just true or false for setup, hold, leakage_power, and cts_mode.
#@ ### The values for cts_corner can be max, min, min_max or none.
#@ ### Please refer to the set_scenario_options man page for further information.
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(max_corner_1)   "set_scenario_options -setup true  -hold true  -leakage_power true  -cts_mode true -cts_corner max"
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(max_corner_2)   "set_scenario_options -setup true  -hold true  -leakage_power true  -cts_mode true -cts_corner max"
#@ ##set INTEL_MCMM_SCENARIO_OPTIONS(min_corner_2)   "set_scenario_options -setup false -hold true  -leakage_power false -cts_mode false"
#@ 
#@ # The MCMM flow will either read all SDC files or all tcl files (but not both) for each scenario.
#@ # This is controlled via the $INTEL_SDC_FILE
#@ #        if {$INTEL_SDC_FILE == 1} {foreach $INTEL_MCMM_CONS_SDC($scenario) { read_sdc $sdc }}
#@ #   elseif ($INTEL_SDC_FILE == 0} {foreach $INTEL_MCMM_CONS_TCL($scenario) { source $tcl }}
#@ set INTEL_SDC_FILE 0
#@ ##set INTEL_MCMM_CONS_SDC(max_corner_1) "./inputs/constraints/max_corner_1.clocks.sdc ./inputs/constraints/max_corner_1.io.sdc"
#@ ##set INTEL_MCMM_CONS_SDC(max_corner_2) "./inputs/constraints/max_corner_2.clocks.sdc ./inputs/constraints/max_corner_2.io.sdc"
#@ ##set INTEL_MCMM_CONS_SDC(min_corner_1) "./inputs/constraints/min_corner_1.clocks.sdc ./inputs/constraints/min_corner_1.io.sdc"
#@ ### OR
#@ ##set INTEL_MCMM_CONS_TCL(max_corner_1) "./inputs/constraints/max_corner_1.clocks.tcl ./inputs/constraints/max_corner_1.io.tcl"
#@ ##set INTEL_MCMM_CONS_TCL(max_corner_2) "./inputs/constraints/max_corner_2.clocks.tcl ./inputs/constraints/max_corner_2.io.tcl"
#@ ##set INTEL_MCMM_CONS_TCL(min_corner_2) "./inputs/constraints/min_corner_1.clocks.tcl ./inputs/constraints/min_corner_1.io.tcl"
#@ 
#@ # In the case where two scenarios are defined to have similar PVT, the tool can have difficulty distinguishing which library to associate for that scenario.
#@ # For this case, there is an optional setting INTEL_MCMM_LINK_LIBRARY_SUBSET which will use the tool command link_library_subset to specify which libraries should be used for the given scenario.
#@ #set INTEL_MCMM_LINK_LIBRARY_SUBSET(max_corner_1) [list d04_ln_p1273_6x1r2_psss_0.75v_-40c_nldm.ldb]
#@ #set INTEL_MCMM_LINK_LIBRARY_SUBSET(max_corner_2) [list d04_ln_p1273_6x1r2_pfff_0.75v_-40c_nldm.ldb]
#@ 
#@ ###########STA Specific##################
#@ ########################################
#@ 
#@ ###########Setup Variables##############
#@ 
#@ if {[regexp {^pt_shell} $synopsys_program_name]} {
#@   # Variable used to set operating condition. Valid values are bc_wc, on_chip_variation.
#@   set INTEL_ANALYSIS_TYPE             "on_chip_variation"
#@ }
#@ 
#@ # Include List of all lib pair (max corner used for link lib during PV). The min lib will be used for setting the set_min_library which will provide the min lib corresponding to all max lib.
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(max)   "${fdk_lib}_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst ${fdk_lib}_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_nn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_ln_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_wn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm  ${fdk_lib}_yn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(min)   "${fdk_lib}_nn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_nn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_ln_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_ln_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_wn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_wn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_yn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst ${fdk_lib}_yn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_1.1v_-40c_nldm"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(power) "${fdk_lib}_nn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_nn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_ln_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_ln_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_wn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_wn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_yn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap ${fdk_lib}_yn_p1273_3x1r6u1_tttt_1.1v_90c_ccst_pwr_pincap                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_nn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_ln_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_wn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap ${fdk_lib}_yn_misc_p1273_3x1r6u1_tttt_1.1v_90c_nldm_pwr_pincap"
#@ 
#@ set INTEL_PV_MAX_MIN_LIB_PAIR(noise) "${fdk_lib}_nn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_nn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_ln_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_ln_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_wn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_wn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_yn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn ${fdk_lib}_yn_p1273_3x1r6u1_pfff_0.88v_110c_ccsn                                       ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_nn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_ln_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_wn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm                                       ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm ${fdk_lib}_yn_misc_p1273_3x1r6u1_pfff_0.88v_110c_nldm"
#@ 
#@ # Specify the valid run_type and stage. User can configure custom run type and stages in the following vars.
#@ set INTEL_RUN_TYPES                  [list max min noise power]
#@ set INTEL_RUN_STAGES                 [list prelayout prects postlayout]
#@ 
#@ # Set the extraction file (SPEF) for the design.
#@ 
#@ set INTEL_SPEF_FILE(max)           ""
#@ set INTEL_SPEF_FILE(min)     ""
#@ set INTEL_SPEF_FILE(noise)     ""
#@ set INTEL_SPEF_FILE(power)     ""
#@ 
#@ # Set the SDC File for the design.
#@ set INTEL_PV_SDC(max)                   ""
#@ set INTEL_PV_SDC(min)                   ""
#@ set INTEL_PV_SDC(power)                 ""
#@ set INTEL_PV_SDC(noise)                 ""
#@ 
#@ # Set the Max-Min Operating conditions for the design.
#@ set INTEL_PV_MAX_OPCON(max)             "slow_1.00"
#@ set INTEL_PV_MAX_OPCON(min)             "fast_1.00"
#@ set INTEL_PV_MAX_OPCON(power)           "typical_1.00"
#@ set INTEL_PV_MAX_OPCON(noise)           "fast_1.00"
#@ 
#@ set INTEL_PV_MIN_OPCON(max)             "slow_1.00"
#@ set INTEL_PV_MIN_OPCON(min)             "fast_1.00"
#@ set INTEL_PV_MIN_OPCON(power)           "typical_1.00"
#@ set INTEL_PV_MIN_OPCON(noise)           "fast_1.00"
#@ 
#@ # Configure the number of cores on the local machine to use during the run.
#@ set_host_options -max_cores 4
#@ 
#@ # Variable used to setup AOCVM based runs.
#@ set INTEL_ENABLE_AOCVM     0
#@ 
#@ # Variables used to define early and late AOCVM tables. Populate the list with entire path of the table.
#@ set INTEL_AOCVM_TABLE(max)   [list ]
#@ set INTEL_AOCVM_TABLE(min)   [list ]
#@ 
#@ 
#@ 
#@ # Variable used to enable ILM generation for design.
#@ set INTEL_GENERATE_ILM               0
#@ 
#@ # Variable used to set absolute and percentage comparison limit for ILM model validation.
#@ set INTEL_ILM_ABS_TOL                200
#@ set INTEL_ILM_PER_TOL                5
#@ 
#@ #Variable to invoke PV Fast Analysis
#@ set INTEL_PV_FAST_ANALYSIS           0
#@ 
#@ ###########DMSA Variables (Variables not yet in use!!)##############
#@ 
#@ # Define DMSA corners: <mode> <run-type> <slew> <voltage> <temperature>
#@ # Syntax: <func|scan_shift|scan_capture> <max|min|power|noise> <psss|tttt|pfff> <lib voltage as in library name> <lib temp as in library name>
#@ set INTEL_DMSA_VARS               "func max psss 0.9v 125.00c                                scan_shift max psss 0.9v 125.00c                                scan_capture max psss 0.9v 125.00c                                func min pfff 1.025v 0.00c                                scan_shift min pfff 1.025v 0.00c                                scan_capture min pfff 1.025v 0.00c                                func power pfff 1.025v 0.00c                                func power psss 1.025v 105.00c"
#@ 
#@ # Specify all Vt variants present in netlist
#@ set INTEL_DMSA_VT                  [list ln nn wn]
#@ 
#@ # Scenarios to analyze currently. Can contain wildcard characters"
#@ set INTEL_DMSA_CURRENT_SCENARIOS   ""
#@ 
#@ # SPEF files for all corners. Create similar variables for extra temperatures than provided above.
#@ set INTEL_DMSA_SPEF(0.00)          ""
#@ set INTEL_DMSA_SPEF(125.00)        ""
#@ 
#@ # Clocks for all runs
#@ set INTEL_DMSA_CLOCKS              ""
#@ 
#@ # Constraint file for all run types
#@ set INTEL_DMSA_CONSTRAINTS(max)    ""
#@ set INTEL_DMSA_CONSTRAINTS(min)    ""
#@ set INTEL_DMSA_CONSTRAINTS(power)  ""
#@ set INTEL_DMSA_CONSTRAINTS(noise)  ""
#@ 
#@ # SDC files for all run types
#@ set INTEL_DMSA_SDC(max)           ""
#@ set INTEL_DMSA_SDC(min)           ""
#@ set INTEL_DMSA_SDC(power)         ""
#@ set INTEL_DMSA_SDC(noise)         ""
#@ 
#@ ############Power variables#############
#@ 
#@ # Variable is used to enable VCD/SAIF file read for PTPX Power Calculation ./inputs/${INTEL_DESIGN_NAME}.vcd/.fsdb/.saif. Specify the full path of the activity file name.
#@ set INTEL_ACTIVITY_FILE    ""
#@ 
#@ # Specifies a path prefix that is to be stripped from all the object names read from the VCD file. This option is applied to strip the testbench/instance path from the VCD file.
#@ set INTEL_STRIP_PATH         ""
#@ 
#@ # Variables used to specify the map file while using VCD from RTL. Give full path of the file. Map file will make sure that RTL names in the VCD match with those in the gate-level netlist.
#@ set INTEL_RTL_VCD_MAP_FILE     ""
#@ 
#@ # Variable used to set average or peak power_analysis type. Valid values are avg, peak.
#@ set INTEL_POWER_ANALYSIS     "avg"
#@ 
#@ ########################################
#@ #Outputs and Reports Variables
#@ ########################################
#@ 
#@ #############Synthesis##################
#@ ########################################
#@ 
#@ # Setting the reports var. All the reports listed are in common/scripts/procs_reference.tcl
#@ set INTEL_REPORTS(inc_compile) "qor area clock clock_gating max_delay max_cap                                 max_tran all_violators saif power check_timing                                 check_design high_fanout timing_setup timing_setup_groups                                 timing_loops congestion dft_drc dft_signal scanpath vars check_mv_design"
#@ 
#@ # Variable used to control report_timing parameters
#@ foreach step $INTEL_SYN_STEPS {
#@   set INTEL_MAX_PATHS($step)   1000
#@   set INTEL_SLACK_LIMIT($step) 9999
#@   set INTEL_NWORST($step)      1
#@ }
#@ 
#@ set INTEL_OUTPUTS(compile)     "verilog upf"
#@ set INTEL_OUTPUTS(insert_dft)  "verilog upf"
#@ if { $::sh_product_version < {I-2013.12} } {
#@   set INTEL_OUTPUTS(inc_compile) "verilog upf sdc saif spef scandef syn_def"
#@ } else {
#@   set INTEL_OUTPUTS(inc_compile) "verilog upf sdc saif spef scandef def"
#@ }
#@ 
#@ ################ APR ################################################
#@ #####################################################################
#@ 
#@ # Available report types:
#@ # NOTE: check_mv_design & upf will only be reported if $INTEL_UPF == 1.
#@ # Design checks:   check_design check_mv_design check_timing check_legality check_zrt_routability
#@ # Design reports:  area threshold_voltage_group high_fanout physical
#@ # UPF reports:     upf
#@ # Timing reports:  qor all_violators timing_setup timing_hold timing_setup_zeroRC timing_setup_groups timing_loops
#@ # Clock reports:   clock_tree clock_gating
#@ # Power reports:   saif power
#@ # Route reports:   verify_zrt_route lvs
#@ # Other reports:   logic_levels vars
#@ 
#@ set INTEL_REPORTS(import_design)    "timing_setup_zeroRC flow_vars"
#@ 
#@ set INTEL_REPORTS(floorplan)        ""
#@ set INTEL_REPORTS(upf_floorplan)    "$INTEL_REPORTS(floorplan) check_mv_design upf"
#@ 
#@ set INTEL_REPORTS(place)            "qor physical"
#@ set INTEL_REPORTS(upf_place)        $INTEL_REPORTS(place)
#@ set INTEL_REPORTS(post_place)       $INTEL_REPORTS(place)
#@ set INTEL_REPORTS(upf_post_place)   "$INTEL_REPORTS(post_place) check_mv_design upf"
#@ 
#@ set INTEL_REPORTS(cts)              "clock_tree qor physical"
#@ 
#@ set INTEL_REPORTS(route)            "all_violators timing_setup timing_hold qor power                                      threshold_voltage_group logic_levels vars physical lvs"
#@ set INTEL_REPORTS(post_route)       $INTEL_REPORTS(route)
#@ set INTEL_REPORTS(upf_post_route)   "$INTEL_REPORTS(post_route) check_mv_design upf"
#@ 
#@ #set INTEL_REPORTS(focal_opt)         $INTEL_REPORTS(post_route)
#@ set INTEL_REPORTS(fill)             "$INTEL_REPORTS(post_route) timing_setup_groups"
#@ 
#@ foreach step $INTEL_APR_STEPS {
#@   set INTEL_MAX_PATHS($step)   1000
#@   set INTEL_SLACK_LIMIT($step) 9999
#@   set INTEL_NWORST($step)      1
#@ }
#@ 
#@ # Available output types: verilog verilog_pg spef def fp sdc oas gds
#@ # NOTE: check_mv_design & upf will only be reported if $INTEL_UPF == 1.
#@ 
#@ set INTEL_OUTPUTS(import_design)   ""
#@ set INTEL_OUTPUTS(floorplan)       ""
#@ set INTEL_OUTPUTS(upf_floorplan)   $INTEL_OUTPUTS(floorplan)
#@ set INTEL_OUTPUTS(place)           ""
#@ set INTEL_OUTPUTS(upf_place)       $INTEL_OUTPUTS(place)
#@ set INTEL_OUTPUTS(post_place)      $INTEL_OUTPUTS(place)
#@ set INTEL_OUTPUTS(upf_post_place)  $INTEL_OUTPUTS(post_place)
#@ set INTEL_OUTPUTS(cts)             ""
#@ set INTEL_OUTPUTS(route)           "verilog_pg oas"
#@ set INTEL_OUTPUTS(post_route)      $INTEL_OUTPUTS(route)
#@ set INTEL_OUTPUTS(upf_post_route)  $INTEL_OUTPUTS(post_route)
#@ #set INTEL_OUTPUTS(focal_opt)       $INTEL_OUTPUTS(route)
#@ set INTEL_OUTPUTS(adr)             "$INTEL_OUTPUTS(route) def"
#@ set INTEL_OUTPUTS(fill)            "verilog verilog_pg upf sdc def spef oas lteloc techlef"
#@ set INTEL_OUTPUTS(eco)             "verilog verilog_pg upf sdc def spef oas"
#@ 
#@ ################PV######################
#@ 
#@ # Variable used to set generate reports for different runs
#@ 
#@ set INTEL_REPORTS(max)             [list timing_setup all_violators clock check_timing timing_setup_groups pin_margin net_attribute pin_attribute parasitic_not_annotated_check vars max_cap max_tran max_delay error_info aocvm qor min_pulse_width]
#@ set INTEL_REPORTS(min)             [list timing_hold  all_violators clock check_timing timing_hold_groups  pin_margin net_attribute pin_attribute parasitic_not_annotated_check vars error_info aocvm qor min_pulse_width]
#@ set INTEL_REPORTS(noise)           [list noise_all_vio noise_below noise_above check_noise parasitic_not_annotated_check max_analysis_coverage vars error_info qor]
#@ set INTEL_REPORTS(power)           [list power switching_activity missing_power_tables parasitic_not_annotated_check vars error_info qor]
#@ 
#@ # Variable used to control report_timing parameters
#@ set INTEL_MAX_PATHS(max)            1000
#@ set INTEL_SLACK_LIMIT(max)          9999
#@ set INTEL_NWORST(max)               1
#@ 
#@ set INTEL_MAX_PATHS(min)            1000
#@ set INTEL_SLACK_LIMIT(min)          9999
#@ set INTEL_NWORST(min)               1
#@ 
#@ set INTEL_MAX_PATHS(power)            1000
#@ set INTEL_SLACK_LIMIT(power)          9999
#@ set INTEL_NWORST(power)               1
#@ 
#@ set INTEL_MAX_PATHS(noise)            1000
#@ set INTEL_SLACK_LIMIT(noise)          9999
#@ set INTEL_NWORST(noise)               1
#@ 
#@ # ERC checks variables and reporting
#@ # Variable to enable ERC checks
#@ set INTEL_PT_ERC_CHECK_ENABLE 0
#@ 
#@ 
#@ 
#@ 
#@ ################PV-DMSA (Variables not yet in use!!)######################
#@ 
#@ set INTEL_REPORTS(dmsa)              [list timing_setup timing_hold all_violators vars max_cap max_tran max_delay max_analysis_coverage clock_summary]
#@ set INTEL_MAX_PATHS(dmsa)            1000
#@ set INTEL_SLACK_LIMIT(dmsa)          9999
#@ set INTEL_NWORST(dmsa)               1
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/project_setup.tcl

#@ 
#@ ### design specific setting
#@ P_source_if_exists block_setup.tcl -require
#@ # -- Starting source ./scripts/block_setup.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ # Set design name, width and height
#@ set INTEL_DESIGN_NAME "fdkex"
#@ 
#@ #set INTEL_DESIGN_WIDTH              "151.2"
#@ #set INTEL_DESIGN_HEIGHT             "151.62"
#@ 
#@ # Set bigger design size for scan-insertion (design sizes kept same as in fdk73_testcase_repo) 
#@ set INTEL_DESIGN_WIDTH              "302.4"
#@ set INTEL_DESIGN_HEIGHT             "303.24"
#@ 
#@ set INTEL_INSERT_SCAN  1
#@ # -- End source ./scripts/block_setup.tcl

#@ 
#@ 
#@ P_source_if_exists icc_vars.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/icc_vars.tcl

#@ ##############################################################################
#@ 
#@ 
#@ ###################################################
#@ # General
#@ ###################################################
#@ set auto_restore_mw_cel_lib_setup true
#@ set_app_var enable_page_mode false
#@ #set_app_var sh_enable_page_mode false
#@ 
#@ ###################################################
#@ # UPF Related
#@ ###################################################
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@   if { [info exists INTEL_UPF_VERSION] && $INTEL_UPF_VERSION >= 2.0 } {
#@     set_app_var upf_create_implicit_supply_sets true
#@   } else {
#@     set_app_var upf_create_implicit_supply_sets false
#@   }
#@   set_app_var mv_insert_level_shifters_on_ideal_nets all
#@   set_app_var auto_insert_level_shifters_on_clocks all
#@   #set_app_var mv_no_main_power_violations false
#@ }
#@ 
#@ ###################################################
#@ # Floorplan
#@ ###################################################
#@ set mw_logic1_net $INTEL_MW_POWER_NET
#@ set mw_logic0_net $INTEL_MW_GROUND_NET
#@ set_app_var physopt_check_site_array_overlap false
#@ set_app_var legalize_support_phys_only_cell true
#@ set legalize_auto_x_keepout_margin 0; #workaround to ignore false violations around macros
#@ set legalize_auto_y_keepout_margin 0; #workaround to ignore false violations around macros
#@ set no_row_gap 1             ; #Hidden variable to avoid gaps between rows
#@ set rectilinear_no_row_gap 1 ; #Hidden variable to avoid gaps between rows
#@ 
#@ 
#@ ##################################################
#@ #Place
#@ ##################################################
#@ 
#@ #To keep unloaded latch/flop - Default is true
#@ set_app_var physopt_delete_unloaded_sequential_cells false
#@ 
#@ #Added for Pad_Pin buffer issue
#@ set_app_var physopt_pin_based_pad true
#@ 
#@ ###################################################
#@ # CTS
#@ ###################################################
#@ set_app_var cts_instance_name_prefix cts_
#@ set_app_var cts_use_debug_mode true
#@ set_app_var cts_move_clock_gate false
#@ 
#@ # Identify clock gates
#@ set_app_var power_cg_auto_identify true
#@ 
#@ ###################################################
#@ #Timing
#@ ###################################################
#@ set_app_var enable_recovery_removal_arcs true
#@ set_app_var timing_remove_clock_reconvergence_pessimism true
#@ set_app_var rc_degrade_min_slew_when_rd_less_than_rnet true; #better min correlation
#@ set_app_var timing_enable_multiple_clocks_per_reg true; #Enables analysis of multiple clocks to a single register
#@ 
#@ # Enable dynamic max_cap tables for pin frequency based cap limit lookups
#@ # set_app_var compile_enable_dyn_max_cap true
#@ 
#@ ###################################################
#@ # MISC
#@ ###################################################
#@ #Tap cells and filler cells name
#@ # Use "_" instead of default "!" in the tap and filler cell instance name
#@ #set_parameter -module place -name nameSeparator -value 95; # if using B-2008.09-SP4 or earlier
#@ set fillercell_name_separator 95
#@ 
#@ # Prevent assign statements in verilog netlists
#@ set_app_var verilogout_no_tri true
#@ 
#@ ## Disable command and argument abbreviation.
#@ #set_app_var sh_command_abbrev_mode none
#@ #set_app_var sh_command_abbrev_options false
#@ 
#@ ###################################################
#@ # Warnings
#@ ###################################################
#@ 
#@ # suppress it for now... (need to review later)
#@ 
#@ suppress_message {PSYN-025}
#@ suppress_message {OPT-1201}
#@ suppress_message {OPT-200}
#@ 
#@ #Warning: Cell 'halo_v468' is being marked as "dont_touch" because it has
#@ #        a fixed_placement attribute. (PSYN-040)
#@ suppress_message {PSYN-040}
#@ 
#@ # Suppress following msgs for now
#@ set_message_info -id PSYN-069 -limit 10 ;# Stdcell height different from site height - suppress for now
#@ set_message_info -id DDB-100 -limit 10  ;# Unable to find min version of cell - suppress for now
#@ 
#@ # MSG seen during routing after PG hookup is done
#@ set_message_info -id ZRT-032 -limit 10 ;# Limits warning that VCN is an invalid routing layer
#@ 
#@ # MSG seen during write_def command
#@ set_message_info -id DDEFW-004 -limit 10 ;# Limits warning that TCN is undefined.
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/icc_vars.tcl

#@ P_source_if_exists library.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/library.tcl

#@ ##############################################################################
#@ 
#@ ##############################################################
#@ # The list of procs used by this script:
#@ # 1. P_msg_info
#@ #
#@ ###############################################################
#@ 
#@ ###########################################
#@ # Variables for CCST Timing Model
#@ ###########################################
#@ 
#@ # NOTE: Set the variables to basic for NLDM Timing Model if required.
#@ 
#@ P_msg_info "==>INFORMATION: Setting variables to support CCS Timing Models"
#@ set_app_var rc_driver_model_mode advanced
#@ set_app_var rc_receiver_model_mode advanced
#@ 
#@ ###########################################################################
#@ # Description: This file sets up libraries for the entire design
#@ ###########################################################################
#@ 
#@ # NOTE: This is a reference of what could be done. You can use hard paths here.
#@ 
#@ set tmp_search_path [list                          $env(INTEL_STDCELLS_MISC)/lib/ln                          $env(INTEL_STDCELLS_MISC)/lib/nn                          $env(INTEL_STDCELLS_MISC)/lib/wn                          $env(INTEL_STDCELLS_MISC)/lib/yn                          $env(INTEL_STDCELLS)/lib/ln                          $env(INTEL_STDCELLS)/lib/nn                          $env(INTEL_STDCELLS)/lib/wn                          $env(INTEL_STDCELLS)/lib/yn                          $env(INTEL_STDCELLS)/ccs/ln                          $env(INTEL_STDCELLS)/ccs/nn                          $env(INTEL_STDCELLS)/ccs/wn                          $env(INTEL_STDCELLS)/ccs/yn                     ]
#@ set_app_var search_path [concat $search_path [lsort -unique $tmp_search_path]]
#@ 
#@ P_msg_info "==>INFORMATION: search_path is set to $search_path"
#@ 
#@ 
#@ set_app_var target_library [list                                 d04_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                                 d04_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                                 d04_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                                 d04_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb                            ]
#@ set misc_library [list                       d04_ln_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm.ldb                       d04_nn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm.ldb                       d04_wn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm.ldb                       d04_yn_misc_p1273_3x1r6u1_psss_0.75v_-10c_nldm.ldb]
#@ 
#@ set target_library [concat $target_library $misc_library ]
#@ 
#@ puts "==>INFORMATION: target_library is set to $target_library"
#@ 
#@ set_min_library d04_ln_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb -min_version d04_ln_p1273_3x1r6u1_pfff_1.1v_-40c_ccst.ldb
#@ set_min_library d04_nn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb -min_version d04_nn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst.ldb
#@ set_min_library d04_wn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb -min_version d04_wn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst.ldb
#@ set_min_library d04_yn_p1273_3x1r6u1_psss_0.75v_-10c_ccst.ldb -min_version d04_yn_p1273_3x1r6u1_pfff_1.1v_-40c_ccst.ldb
#@ 
#@ 
#@ 
#@ set_app_var link_library [list *]
#@ set_app_var link_library [concat $link_library $target_library]
#@ set_app_var link_library [concat $link_library dw_foundation.sldb]
#@ 
#@ P_msg_info "==>INFORMATION: link_library is set to $link_library"
#@ 
#@ set mw_reference_library [list                               $env(INTEL_STDCELLS_MISC)/fram/ln/d04_ln_misc                               $env(INTEL_STDCELLS_MISC)/fram/ln/d04_ln_misc_tapcore2h                               $env(INTEL_STDCELLS_MISC)/fram/nn/d04_nn_misc                               $env(INTEL_STDCELLS_MISC)/fram/nn/d04_nn_misc_tapcore2h                               $env(INTEL_STDCELLS_MISC)/fram/wn/d04_wn_misc                               $env(INTEL_STDCELLS_MISC)/fram/wn/d04_wn_misc_tapcore2h                               $env(INTEL_STDCELLS_MISC)/fram/yn/d04_yn_misc                               $env(INTEL_STDCELLS_MISC)/fram/yn/d04_yn_misc_tapcore2h                               $env(INTEL_STDCELLS)//fram/ln/d04_ln                               $env(INTEL_STDCELLS)//fram/nn/d04_nn                               $env(INTEL_STDCELLS)//fram/wn/d04_wn                               $env(INTEL_STDCELLS)//fram/yn/d04_yn                               $env(INTEL_HALO)/fram/intel73halo_d04]
#@ 
#@ P_msg_info "==>INFORMATION: mw_reference_library is set to $mw_reference_library"
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/library.tcl

#@ P_source_if_exists dont_use.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ 
#@ P_source_if_exists block_level_stdcell_power_hookup_runset.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/block_level_stdcell_power_hookup_runset.tcl

#@ ##############################################################################
#@ 
#@ lappend auto_path $env(INTEL_ASIC)/asicflows/synopsys/fill/
#@ package require parseOpt
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/parseOpt/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded parseOpt 1.0 [list source [file join $dir parseOpt.tcl]]
#@ package ifneeded parseOpt 2.0 [list source [file join $dir parseOpt.2.0.tcl]]
#@ package ifneeded parseOpt 3.0 [list source [file join $dir parseOpt.3.0.tcl]]
#@ package ifneeded parseOpt 4.0 [list source [file join $dir parseOpt.4.0.tcl]]
#@ package ifneeded parseOpt 5.0 [list source [file join $dir parseOpt.5.0.tcl]]
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/parseOpt/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/syn/layout/pkgIndex.tcl

#@ ###
#@ ### This layout package is originally a snapshot of icc/layout 6/20/07.
#@ ### The version is bumped from 1.0 to 1.2 
#@ ### Subsequently merged with ICC on July 2007 and became the only version
#@ ### available 
#@ ### The migration of the package is to facilitate code sharing between
#@ ### applications which need layout view customizations.
#@ ###
#@ ### Updates:
#@ ###        added package snpsPathsSlackVM
#@ ###        added package snpsCellSlackVM 
#@ ###        added package snpsNetCapacitanceVM
#@ ###        added package snpsScanChainVM 
#@ 
#@ package ifneeded snpsVMDialogPathsSlack     1.2 [list source -direct [file join $dir DialogVMPathsSlack.tcl]]
#@ package ifneeded snpsVMDialogCellSlack      1.2 [list source -direct [file join $dir DialogVMCellSlack.tcl]]
#@ package ifneeded snpsVMDialogNetCapacitance 1.2 [list source -direct [file join $dir DialogVMNetCapacitance.tcl]]
#@ package ifneeded snpsVMDialogClockLT 1.2 [list source -direct [file join $dir DialogVMClockLT.tcl]]
#@ 
#@ package ifneeded snpsImportedPathPinsVM     1.2 [list source -direct [file join $dir snpsImportedPathPinsVM.tcl]]
#@ package ifneeded snpsPathsSlackVM     1.2 [list source -direct [file join $dir snpsPathsSlackVM.tcl]]
#@ package ifneeded snpsCellSlackVM      1.2 [list source -direct [file join $dir snpsCellSlackVM.tcl]]
#@ package ifneeded snpsIllegalCellPlacementVM      1.2 [list source -direct [file join $dir snpsIllegalCellPlacementVM.tcl]]
#@ package ifneeded snpsVoltageAreaVM      1.2 [list source -direct [file join $dir snpsVoltageAreaVM.tcl]]
#@ package ifneeded snpsXTalkVM      1.2 [list source -direct [file join $dir snpsXTalkVM.tcl]]
#@ package ifneeded snpsDeltaDelayVM      1.2 [list source -direct [file join $dir snpsDeltaDelayVM.tcl]]
#@ package ifneeded snpsNoiseVM      1.2 [list source -direct [file join $dir snpsNoiseVM.tcl]]
#@ package ifneeded snpsCellDisplacementVM      1.2 [list source -direct [file join $dir snpsCellDisplacementVM.tcl]]
#@ package ifneeded snpsAreaNetConnectionVM      1.2 [list source -direct [file join $dir snpsAreaNetConnectionVM.tcl]]
#@ package ifneeded snpsNetCapacitanceVM 1.2 [list source -direct [file join $dir snpsNetCapacitanceVM.tcl]]
#@ package ifneeded snpsClockLTVM 1.2 [list source -direct [file join $dir snpsClockLTVM.tcl]]
#@ package ifneeded snpsScanChainVM 1.2 [list source -direct [file join $dir snpsScanChainVM.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/syn/layout/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/WindowFrameWork/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsWindowFrameWork 1.0 [list source -direct [file join $dir windowFrameWork.tcl]]
#@ package ifneeded snpsBusyCursorSkipList 1.0 [list source -direct [file join $dir skipBusyCursorCmdList.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/WindowFrameWork/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/acg/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsAcg 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/acg/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/commandform/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCommandForm 1.0 [list source -direct [file join $dir commandform.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/commandform/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/dialogs/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsDialogsBinsOnlyInformation 1.0 [list source -direct [file join $dir BinsOnlyInformation.tcl]]
#@ package ifneeded snpsDialogsCompileLinkDesign 1.0 [list source -direct [file join $dir CompileLinkDesign.tcl]]
#@ package ifneeded snpsDialogsFanInOutInfo 1.0 [list source -direct [file join $dir FanInOutInfo.tcl]]
#@ package ifneeded snpsDialogsFileChooser 1.0 [list source -direct [file join $dir FileChooser.tcl]]
#@ package ifneeded snpsDialogsHistBin1Information 1.0 [list source -direct [file join $dir HistBin1Information.tcl]]
#@ package ifneeded snpsDialogsHistBinInformation 1.0 [list source -direct [file join $dir HistBinInformation.tcl]]
#@ package ifneeded snpsDialogsHistBumpNoise 1.0 [list source -direct [file join $dir HistBumpNoise.tcl]]
#@ package ifneeded snpsDialogsHistBumpVoltage 1.0 [list source -direct [file join $dir HistBumpVoltage.tcl]]
#@ package ifneeded snpsDialogsHistDeltaDelay 1.0 [list source -direct [file join $dir HistDeltaDelay.tcl]]
#@ package ifneeded snpsDialogsClockMapInformation 1.0 [list source -direct [file join $dir ClockMapInformation.tcl]]
#@ package ifneeded snpsDialogsNumberOfLevelsChooser 1.0 [list source -direct [file join $dir NumberOfLevelsChooser.tcl]]
#@ package ifneeded snpsDialogsObjectChooser 1.0 [list source -direct [file join $dir ObjectChooser.tcl]]
#@ package ifneeded snpsDialogsObjectListInfo 1.0 [list source -direct [file join $dir ObjectListInfo.tcl]]
#@ package ifneeded snpsDialogsPathPinSimpleInfo 1.0 [list source -direct [file join $dir PathPinSimpleInfo.tcl]]
#@ package ifneeded snpsDialogsPathsBasicInfo 1.0 [list source -direct [file join $dir PathsBasicInfo.tcl]]
#@ package ifneeded snpsDialogsPathsBasicSimpleInfo 1.0 [list source -direct [file join $dir PathsBasicSimpleInfo.tcl]]
#@ package ifneeded snpsDialogsReportOutputOptionInfo 1.0 [list source -direct [file join $dir ReportOutputOptionInfo.tcl]]
#@ package ifneeded snpsDialogsSchematicWhatIf 1.0 [list source -direct [file join $dir SchematicWhatIf.tcl]]
#@ package ifneeded snpsDialogsSlctOperationInfo 1.0 [list source -direct [file join $dir SlctOperationInfo.tcl]]
#@ package ifneeded snpsDialogsWindowReuseInfo 1.0 [list source -direct [file join $dir WindowReuseInfo.tcl]]
#@ package ifneeded snpsDialogsPath 1.0 [list source -direct [file join $dir PathDialog.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/dialogs/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/docBrowser/pkgIndex.tcl

#@ 
#@ package ifneeded snpsDocBrowser 1.0 [list source -direct [file join $dir docBrowser.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/docBrowser/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/fanoutviewer/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCTB 1.0 [list source -direct [file join $dir ctb.tcl]]
#@ package ifneeded snpsCTBInternal 1.0 [list source -direct [file join $dir ctbInternal.tcl]]
#@ package ifneeded snpsFanoutViewer 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/fanoutviewer/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/hierarchy/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsDesignObjectBrowser 1.0 [list source -direct [file join $dir DesignObjectBrowser.tcl]]
#@ package ifneeded snpsHier 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsHier::children 1.0 [list source -direct [file join $dir children.tcl]]
#@ package ifneeded snpsHier::columns 1.0 [list source -direct [file join $dir columns.tcl]]
#@ package ifneeded snpsHier::dialogs 1.0 [list source -direct [file join $dir dialogs.tcl]]
#@ package ifneeded snpsHier::hierarchies 1.0 [list source -direct [file join $dir hierarchies.tcl]]
#@ package ifneeded snpsHier::rootFcts 1.0 [list source -direct [file join $dir rootFcts.tcl]]
#@ package ifneeded snpsHierExample1 1.0 [list source -direct [file join $dir Example1.tcl]]
#@ package ifneeded snpsHierExample2 1.0 [list source -direct [file join $dir Example2.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/hierarchy/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/highlight/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded Highlight 1.0 [list source -direct [file join $dir highlight.tcl]]
#@ package ifneeded snpsHighlight 1.0 [list source -direct [file join $dir highlight.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/highlight/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/histogram/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsHistogram 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsHistogramDialogBottleneck 1.0 [list source -direct [file join $dir DialogBottleneck.tcl]]
#@ package ifneeded snpsHistogramDialogTable 1.0 [list source -direct [file join $dir DialogTable.tcl]]
#@ package ifneeded snpsHistogramDialogBumpNoise 1.0 [list source -direct [file join $dir DialogBumpNoise.tcl]]
#@ package ifneeded snpsHistogramDialogBumpVoltage 1.0 [list source -direct [file join $dir DialogBumpVoltage.tcl]]
#@ package ifneeded snpsHistogramDialogDRC 1.0 [list source -direct [file join $dir DialogDRC.tcl]]
#@ package ifneeded snpsHistogramDialogDeltaDelay 1.0 [list source -direct [file join $dir DialogDeltaDelay.tcl]]
#@ package ifneeded snpsHistogramDialogEndpointSlack 1.0 [list source -direct [file join $dir DialogEndpointSlack.tcl]]
#@ package ifneeded snpsHistogramDialogNetCapacitance 1.0 [list source -direct [file join $dir DialogNetCapacitance.tcl]]
#@ package ifneeded snpsHistogramDialogPathsSlack 1.0 [list source -direct [file join $dir DialogPathsSlack.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/histogram/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/layout/pkgIndex.tcl

#@ package ifneeded snpsLayout                 1.2 [list source -direct [file join $dir layout.tcl]]
#@ package ifneeded snpsLayoutTools            1.2 [list source -direct [file join $dir snpsLayoutTools.tcl]]
#@ package ifneeded snpsLayoutLayers           1.2 [list source -direct [file join $dir layout_layers.tcl]]
#@ package ifneeded snpsLayoutTest             1.2 [list source -direct [file join $dir layout_test.tcl]]
#@ 
#@ package ifneeded colSrv                    1.2 [list source -direct [file join $dir colSrv.tcl]]
#@ package ifneeded snpsVM                     1.2 [list source -direct [file join $dir snpsVM.tcl]]
#@ package ifneeded snpsMM                     1.2 [list source -direct [file join $dir snpsMM.tcl]]
#@ 
#@ package ifneeded snpsLayoutPreferences      1.0 [list source -direct [file join $dir preferences.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/layout/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/libviewer/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsLibViewer 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/libviewer/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/menus/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsMenus 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/menus/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/misc/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCalculateWindowGeometry 1.0 [list source -direct [file join $dir calculateWindowGeometry.tcl]]
#@ package ifneeded snpsCommonViewMenu 1.0 [list source -direct [file join $dir viewmenu.tcl]]
#@ package ifneeded snpsCopyPaste 1.0 [list source -direct [file join $dir copyPaste.tcl]]
#@ package ifneeded snpsCreateViewType 1.0 [list source -direct [file join $dir createViewType.tcl]]
#@ package ifneeded snpsCurrInst 1.0 [list source -direct [file join $dir snpsCurrInst.tcl]]
#@ package ifneeded snpsDebug 1.0 [list source -direct [file join $dir debug.tcl]]
#@ package ifneeded snpsDemo 1.0 [list source -direct [file join $dir demo.tcl]]
#@ package ifneeded snpsFile 1.0 [list source -direct [file join $dir file.tcl]]
#@ package ifneeded snpsFollowNlFactory 1.0 [list source -direct [file join $dir followNlFactory.tcl]]
#@ package ifneeded snpsGuiMenuEnable 1.0 [list source -direct [file join $dir GuiMenuEnable.tcl]]
#@ package ifneeded snpsInfotips 1.0 [list source -direct [file join $dir infotip.tcl]]
#@ package ifneeded snpsLoadsDrivers 1.0 [list source -direct [file join $dir loadsDrivers.tcl]]
#@ package ifneeded snpsMisc 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsMiscAnchorPoint 1.0 [list source -direct [file join $dir anchor.tcl]]
#@ package ifneeded snpsMiscDialogObjectChooser 1.0 [list source -direct [file join $dir DialogObjectChooser.tcl]]
#@ package ifneeded snpsMiscEditMovebounds 1.0 [list source -direct [file join $dir EditMovebounds.tcl]]
#@ package ifneeded snpsMiscSetting 1.0 [list source -direct [file join $dir setting.tcl]]
#@ package ifneeded snpsMiscTiming 1.0 [list source -direct [file join $dir timing.tcl]]
#@ package ifneeded snpsMiscViewportHistory 1.0 [list source -direct [file join $dir viewporthistory.tcl]]
#@ package ifneeded snpsOutput 1.0 [list source -direct [file join $dir output.tcl]]
#@ package ifneeded snpsQObjectViewer 1.0 [list source -direct [file join $dir qobjectviewer.tcl]]
#@ package ifneeded snpsStack 1.0 [list source -direct [file join $dir stack.tcl]]
#@ package ifneeded snpsTypedText 1.0 [list source -direct [file join $dir typedText.tcl]]
#@ package ifneeded snpsViewMgr 1.0 [list source -direct [file join $dir viewmgr.tcl]]
#@ package ifneeded snpsMiscPreset 1.0 [list source -direct [file join $dir preset.tcl]]
#@ package ifneeded snpsTaskAssistant 1.0 [list source -direct [file join $dir taskassistant.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/misc/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/mrupalette/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsMRUPalette 1.0 [list source -direct [file join $dir mrupalette.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/mrupalette/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/opdlg/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsOpDlg 1.0 [list source -direct [file join $dir base.tcl]]\n[list source -direct [file join $dir data.tcl]]\n[list source -direct [file join $dir frame1.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/opdlg/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/palettegroup/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsPaletteGroup 1.0 [list source -direct [file join $dir palettegroup.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/palettegroup/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/pathinspector/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsPathInspector 1.0 [list source -direct [file join $dir base.tcl]]\n[list source -direct [file join $dir create_window_and_menu.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/pathinspector/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/profiler/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsProfiler 1.0 [list source -direct [file join $dir base.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/profiler/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/qtcl/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsQtcl 1.0           [list source -direct [file join $dir .synopsys_qtcl.tcl]]
#@ package ifneeded snpsQtclExtensions 1.0 [list source -direct [file join $dir qtcl_extensions.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/qtcl/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/regressionToolkit/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsGUITest 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsDialogTest 1.0 [list source -direct [file join $dir dialogTest.tcl]]
#@ package ifneeded snpsCommandHelpTest 1.0 [list source -direct [file join $dir commandHelpTest.tcl]]
#@ package ifneeded snpsGUIAppSpecifics 1.0 [list source -direct [file join $dir appSpecifics.tcl]]
#@ package ifneeded snpsQtclCoreTests 1.0 [list source -direct [file join $dir snpsQtclCoreTests.tcl]]
#@ package ifneeded snpsTestBinning 1.0 [list source -direct [file join $dir binning.tcl]]
#@ package ifneeded snpsTestDialogAddFaninFanout 1.0 [list source -direct [file join $dir dialogAddFaninFanout.tcl]]
#@ package ifneeded snpsTestDialogAddPaths 1.0 [list source -direct [file join $dir dialogAddPaths.tcl]]
#@ package ifneeded snpsTestDialogEndpointSlackHistogram 1.0 [list source -direct [file join $dir dialogEndpointSlackHistogram.tcl]]
#@ package ifneeded snpsTestDialogNetCapacitanceHistogram 1.0 [list source -direct [file join $dir dialogNetCapacitanceHistogram.tcl]]
#@ package ifneeded snpsTestDialogObjectChooser 1.0 [list source -direct [file join $dir dialogObjectChooser.tcl]]
#@ package ifneeded snpsTestDialogPathsSlackHistogram 1.0 [list source -direct [file join $dir dialogPathsSlackHistogram.tcl]]
#@ package ifneeded snpsTestDialogs 1.0 [list source -direct [file join $dir dialogs.tcl]]
#@ package ifneeded snpsTestDialogSelectByName 1.0 [list source -direct [file join $dir dialogSelectByName.tcl]]
#@ package ifneeded snpsTestHistogram 1.0 [list source -direct [file join $dir histogram.tcl]]
#@ package ifneeded snpsTestList 1.0 [list source -direct [file join $dir list.tcl]]
#@ package ifneeded snpsTestListUtils 1.0 [list source -direct [file join $dir listUtils.tcl]]
#@ package ifneeded snpsTestMenu 1.0 [list source -direct [file join $dir menu.tcl]]
#@ package ifneeded snpsTestMouse 1.0 [list source -direct [file join $dir mouse.tcl]]
#@ package ifneeded snpsTestNl 1.0 [list source -direct [file join $dir nl.tcl]]
#@ package ifneeded snpsWriteXMLNl 1.0 [list source -direct [file join $dir writeXMLNl.tcl]]
#@ package ifneeded snpsTestObjectAtPoint 1.0 [list source -direct [file join $dir testObjectAtPoint.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/regressionToolkit/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/schematic/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsSchematic 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsSchematicDialogPathSchematicAddFanInOut 1.0 [list source -direct [file join $dir DialogPathSchematicFanInOut.tcl]]
#@ package ifneeded snpsSchematicDialogPathSchematicAddPaths 1.0 [list source -direct [file join $dir DialogPathSchematicAddPaths.tcl]]
#@ package ifneeded snpsSchematicDialogSchematicSizeCell 1.0 [list source -direct [file join $dir DialogSchematicWhatIf.tcl]]
#@ package ifneeded snpsSchematicEnable 1.0 [list source -direct [file join $dir enable.tcl]]
#@ package ifneeded snpsSchematicMethod 1.0 [list source -direct [file join $dir method.tcl]]
#@ package ifneeded snpsSchematicNetlist 1.0 [list source -direct [file join $dir netlist.tcl]]
#@ package ifneeded snpsSchematicNetlistInternal 1.0 [list source -direct [file join $dir schematicNetlistInternal.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/schematic/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/select/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsSelectDialogFanInOut 1.0 [list source -direct [file join $dir DialogSelectFanInOut.tcl]]
#@ package ifneeded snpsSelection 1.0 [list source -direct [file join $dir base.tcl]]
#@ package ifneeded snpsSelectionInternal 1.0 [list source -direct [file join $dir baseInternal.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/select/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/setup/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsCommonSetup 1.0 [list source -direct [file join $dir snpsCommonSetup.tcl]]
#@ package ifneeded snpsCustomize 1.0 [list source -direct [file join $dir snpsCustomize.tcl]]
#@ package ifneeded snpsCollections 1.0 [list source -direct [file join $dir snpsCollections.tcl]]
#@ package ifneeded snpsProcheck 1.0 [list source -direct [file join $dir snpsProcheck.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/setup/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/strokes/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded strokes 1.0 [list source -direct [file join $dir stroke_defaults.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/strokes/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/table/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTable 1.0 [list source -direct [file join $dir table.tcl]]
#@ package ifneeded snpsTableInternal 1.0 [list source -direct [file join $dir table_internal.tcl]]
#@ package ifneeded snpsTableCustomize 1.0 [list source -direct [file join $dir table_customize.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/table/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/tcl-dp/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded EkkiInterProcessSelect 1.0 [list source -direct [file join $dir ekkiCrossSelect.tcl]]
#@ package ifneeded snpsInterProcessCommunication 1.0 [list source -direct [file join $dir serv.tcl]]
#@ package ifneeded snpsUpdateTimer 1.0 [list source -direct [file join $dir timer.tcl]]
#@ package ifneeded tcl-dp 1.0 [list source -direct [file join $dir acl.tcl]]\n[list source -direct [file join $dir distribObj.tcl]]\n[list source -direct [file join $dir dp_atclose.tcl]]\n[list source -direct [file join $dir dp_atexit.tcl]]\n[list source -direct [file join $dir ldelete.tcl]]\n[list source -direct [file join $dir oo.tcl]]\n[list source -direct [file join $dir rpc.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/tcl-dp/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/tiledview/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTiledView 1.0 [list source -direct [file join $dir tiledview.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/tiledview/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/timing/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTimingGUI 1.0 [list source -direct [file join $dir base.tcl]]
#@ 
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/timing/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/tq/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTkStyle 1.0 [list source -direct [file join $dir snpsTkStyle.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/tq/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/view/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/common/view/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/dv/pkgIndex.tcl

#@ 
#@ package ifneeded snpsPathAnalyzer 1.0 [list source -direct [file join $dir dv_path_cat_view.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/gui/dv/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTclPro 1.0 [list source [file join $dir			snpsTclPro.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/snpsTest/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTest 1.0 [list source [file join $dir snpsTest.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/snpsTest/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/snpsUtils/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsUtils 1.0 [list source [file join $dir snpsUtils.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/snpsUtils/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/pkgIndex.tcl

#@ package ifneeded Itcl 3.4 {load {} Itcl}
#@ package ifneeded tbcload 1.7 {load {} tbcload}
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/snps_tcl/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/dde/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/dde/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/http/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded http 2.7.9 [list tclPkgSetup $dir http 2.7.9 {{http.tcl source {::http::config ::http::formatQuery ::http::geturl ::http::reset ::http::wait ::http::register ::http::unregister ::http::mapReply}}}]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/http/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/http1.0/pkgIndex.tcl

#@ # Tcl package index file, version 1.0
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded http 1.0 [list tclPkgSetup $dir http 1.0 {{http.tcl source {httpCopyDone httpCopyStart httpEof httpEvent httpFinish httpMapReply httpProxyRequired http_code http_config http_data http_formatQuery http_get http_reset http_size http_status http_wait}}}]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/http1.0/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/msgcat/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded msgcat 1.4.5 [list source [file join $dir msgcat.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/msgcat/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/opt/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded opt 0.4.5 [list source [file join $dir optparse.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/opt/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/platform/pkgIndex.tcl

#@ package ifneeded platform        1.0.10 [list source [file join $dir platform.tcl]]
#@ package ifneeded platform::shell 1.1.4 [list source [file join $dir shell.tcl]]
#@ 
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/platform/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/reg/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/reg/pkgIndex.tcl

#@ # -- Starting source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/tcltest/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded tcltest 2.3.4 [list source [file join $dir tcltest.tcl]]
#@ # -- End source /p/foundry/eda/em64t_SLES11/iccompiler/J-2014.09-SP1/auxx/tcllib/lib/tcl8.5/tcltest/pkgIndex.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/parseOpt/parseOpt.5.0.tcl

#@ #####################################################
#@ #
#@ # Package defintion for:
#@ #     parseOpt
#@ #
#@ # The following package parseOpt a given args for a procedure.
#@ # 
#@ #  Procedures:
#@ #     ::parseOpt::cmdSpec - Define a spec for a command
#@ #     ::parseOpt::parseOpt - Parse args for a given command
#@ #
#@ #
#@ # Created by Kadan Haba at 12/01/2006
#@ #
#@ # Updates:
#@ #
#@ 
#@ 
#@ ######################################################
#@ #
#@ # Example of usage:
#@ # Let say I write a procedure called testProc that
#@ #   get 3 options:
#@ #     -cell <cell name>      : String that define the cell name
#@ #     -action <action name>  : String that define the action to do on the cell
#@ #     -all                   : Flag that say - do the action on all cells.
#@ #
#@ # 1. First I will include the new parseOpt package:
#@ #       package require parseOpt 1.0
#@ #       namespace import ::parseOpt::cmdSpec ::parseOpt::parseOpt
#@ # 2. Create a spec for the procedure:
#@ #       cmdSpec testProc {
#@ #         -help "(Any help message for the procedure can be writen here) The procedire perform action on cell"
#@ #         -opt {
#@ #           {-optname cell   -type string -default "" -required 0 -help "Define the cell name"}
#@ #           {-optname action -type string -default "" -required 1 -help "Define the action name"}
#@ #           {-optname all    -type bool   -default 0  -required 0 -help "Define whether to work on all cells"}
#@ #         }
#@ #       }
#@ #    Note:
#@ #      The opt internal list define the rpocedure different option.
#@ #       -optname <Option name in the procedure switch>
#@ #       -type    <string/int/float/bool/ebool/list/one_of_string> - Incase of string, it will be init with an empty string unless the user define else.
#@ #                                     In case of bool the default will be set and if the user will use the procedure with 
#@ #                                       the given switch, the value will be negate.
#@ #                                     In case of list - empty list will be used unless ...
#@ #                                     In case one_of_string - String selection from value list
#@ #       -required <0/1>  - If set to 1 than this option will be must during option parsing.
#@ #       -default <default value> - Define a new default value.
#@ #       -help  <Help message for option> 
#@ #       -values <List of valid value list for usage with one_of_string>
#@ # 3. Usage inside the procedure
#@ #         proc testProc {args} {
#@ #           # If parsing have failed - exist
#@ #           if { ![parseOpt testProc $args] } { return 0 }
#@ #           puts "-I- User info: "
#@ #           puts "-I- Cell: $opt(-cell)"
#@ #           puts "-I- Action: $opt(-action)"
#@ #           puts "-I- All: $opt(-all)"
#@ #         }
#@ 
#@ package provide parseOpt 5.0
#@ 
#@ 
#@ namespace eval ::parseOpt {
#@     # The following veriable will hold all procedure info
#@     variable procInfo
#@     array set procInfo {}
#@ 
#@     variable level0ProcDef
#@     set level0ProcDef {}
#@ 
#@     variable parseOptPath
#@     set parseOptPath [file dirname [info script]]
#@     
#@     variable validOptTypes
#@     set validOptTypes [list bool                            ebool                            string                            list                            int                            float                            file                            directory                            one_of_string                            point                            bbox                            lib_cell                            lib_pin                            cell                            port                            pin                            pin_port                            net                            order ]
#@ 
#@     variable upLevel 2
#@ 
#@     ##############################
#@     # In order to make procedure visible
#@     namespace export parseOpt parseOpts cmdSpec redefine_proc_attributes CmdSpec setOptions
#@ }
#@ 
#@ 
#@ 
#@ 
#@ #####################################
#@ #
#@ # Proc: cmdSpec
#@ #
#@ # Define the wanted stwitches and default
#@ # value for the given procedure
#@ #
#@ # Arg sturcture: 
#@ #   procedure_name {
#@ #     -help "Help message"
#@ #     -opt {
#@ #       {-type <type> -optname <option name> -default <default value> -required <0/1 must ot not option> -help <help message>}
#@ #     }
#@ #     -default {defaultVariable ...}
#@ #   }  
#@ #
#@ # Example:
#@ #   my_proc {
#@ #     -help "Help message for my proc"
#@ #     -opt {
#@ #        {-type string -optname "cell" -default "" -required 0 -help "Cell name to work on"}
#@ #        {-type string -optname "cell" -default_from_pg "<param name>" -required 0 -help "Cell name to work on"}
#@ #     }
#@ #     -default {fubName1 fubName2}   # This is not must to be define - but if it have been define than it become must variable
#@ #   }
#@ #
#@ # The valid types and values are:
#@ #   string - Must start and end with the sign ". Only a single string can be given.
#@ #            Default: empty string.
#@ #   file   - File name (same as string )
#@ #   directory - Directory name (same as string)
#@ #   list   - Must start and end with {}. 
#@ #            Default: emtpy list.
#@ #   int    - Must be an integer number
#@ #   float  - Must be a number
#@ #   bool   - Can be set to 0 or 1. No value is given after flag that is a bool type.
#@ #            Default: 0.  If user use it - it change its value.
#@ #            If other default is define using command spec (default = 1) than using this flag will negeta the value.
#@ #   ebool  - like bool but actually requires a value, (on/true => 1, off/false => 0)
#@ #   selection - A list of valid values that can be specified. (If using such a type - a default value must be set.
#@ #   order  - a list of unnamed, ordered arguments that must precede named arguments
#@ #
#@ #
#@ #####################################
#@ # This is only wrapper over cmdSpec - in order to enable more clean move to convagre flow with JKT
#@ proc ::parseOpt::CmdSpec {args} {
#@     #echo "-D- warpper of FM ::parseOpt::cmdSpec $args"
#@     eval ::parseOpt::cmdSpec $args
#@ }
#@ 
#@ 
#@ proc ::parseOpt::cmdSpec {args} {
#@     
#@     # Getting procedure full name
#@     set procName [::parseOpt::varPop args]
#@ 
#@     array set procInfo [::parseOpt::varPop args]
#@     
#@     # Checking if the following command have been already define.
#@     # If so - remove the old info
#@     if { [info exist ::parseOpt::procInfo($procName:Init)] } { 
#@         global PARSEOPT_QUIET_MODE
#@         if { [info exists  PARSEOPT_QUIET_MODE] && $PARSEOPT_QUIET_MODE } {
#@         } else {
#@             puts "-W- parseOpt::cmdSpec : The following command have been already defined, override the following command. ($procName)"
#@         }
#@         unset ::parseOpt::procInfo($procName:Init)
#@         unset ::parseOpt::procInfo($procName:Help)
#@         unset ::parseOpt::procInfo($procName:Opt)
#@         unset ::parseOpt::procInfo($procName:Default)
#@     }
#@ 
#@     # Setting a flag to define the procedure name have been already use (for next call)
#@     set ::parseOpt::procInfo($procName:Init) 1
#@     set ::parseOpt::procInfo($procName:Help) ""
#@     set ::parseOpt::procInfo($procName:Opt) {}
#@     set ::parseOpt::procInfo($procName:Default) {}
#@     set ::parseOpt::procInfo($procName:Opt:optList) {}
#@     set ::parseOpt::procInfo($procName:reqOrderArgs) 0
#@     set ::parseOpt::procInfo($procName:optOrderArgs) 0
#@ 
#@     # Getting all info of procedure
#@     # Goning over the input array and parsing it
#@     foreach obj [array names procInfo] { 
#@         if { [regexp -nocase {\-help} $obj] } {
#@             # The element is Help
#@             set ::parseOpt::procInfo($procName:Help) $procInfo($obj)
#@         } elseif { [regexp -nocase {\-opt} $obj] } {
#@             # The elemnt is opt
#@             set ::parseOpt::procInfo($procName:Opt) $procInfo($obj)
#@             
#@             # Parsing opt for detail info
#@             # Going over the list of options
#@             foreach option $procInfo($obj) {
#@                 # For each list - get all its info
#@                 set optname ""
#@                 set default ""
#@                 set default_from_pg ""
#@                 set type ""
#@                 set selection_values {}
#@                 set help ""
#@                 set required 0
#@                 set singel_selection 0
#@                 set radio_grp ""
#@                 set hidden 0
#@                 set values [list ]
#@                 set filter [list ]
#@                 set validOpt {"optname" "type" "default" "default_from_pg" "help" "required" "values" "filter" "singel_selection" "radio_grp" "hidden"}
#@                 
#@                 #foreach option_opt [split $option "-"] {}
#@                 while { [llength $option] > 0 } {
#@                     set option_name_full [::parseOpt::varPop option]
#@                     regsub {^\-} $option_name_full {} option_name
#@                     
#@                     # Ignore epmty variables
#@                     if { [regexp {^[[:space:]]*$} $option_name] } { continue }
#@                     
#@                     # Checking that this is a valid option
#@                     if { [lsearch -exact $validOpt $option_name] < 0 } { 
#@                         puts "-E- parseOpt::cmdSpec : Unknown option type: $option_name (Valid option are: $validOpt)"
#@                         return 0  
#@                     }
#@                     
#@                     set value [::parseOpt::varPop option]
#@                     set $option_name $value
#@                     
#@                 }
#@                 
#@                 # Checking that there is a valid option type
#@                 if { $optname == "" } {
#@                     puts "-E- parseOpt::cmdSpec : Error parsing options, empty option have been found in option name."
#@                     return 0
#@                 }
#@                 
#@                 # Checking that there is a valid option name
#@                 if { $type == "" } {
#@                     puts "-E- parseOpt::cmdSpec : Unable to find option type for \"$optname\", assuming type string"
#@                     set type "string"
#@                 }
#@ 
#@ 
#@                 # Checking that type is one of the valid types
#@                 #                if { ![regexp {bool} $type] && ![regexp {string} $type] && ![regexp {list} $type] } {
#@                 #                    puts "-E- parseOpt::cmdSpec : Wrong type used in $procName under option $optname. Valid types are bool/string/list."
#@                 #                }
#@                 set skip 1
#@                 foreach valid_type $::parseOpt::validOptTypes {
#@                     if { [regexp $valid_type $type] } {
#@                         set skip 0
#@                         break
#@                     }
#@                 }
#@                 if { $skip } {
#@                     puts "-E- parseOpt::cmdSpec : Wrong type used in procedure \"$procName\" under option \"$optname\" type \"$type\" (skipping). Valid types are $::parseOpt::validOptTypes"
#@                     continue
#@                 }
#@                 
#@                 # Define the elemt info in the global array
#@                 lappend ::parseOpt::procInfo($procName:Opt:optList) $optname
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:Help) $help
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:Default) $default
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:Type) $type
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:Required) $required
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:DefaultFromPG) $default_from_pg
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:RadioGrp) $radio_grp
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:Filter) $filter
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:SingelSelection) $singel_selection
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:Hidden) $hidden
#@                 set ::parseOpt::procInfo($procName:Opt:$optname:Values) $values
#@ 
#@                 if { $type eq "order" } {
#@                    if { $required } {
#@                       incr ::parseOpt::procInfo($procName:reqOrderArgs)
#@                    } else {
#@                       incr ::parseOpt::procInfo($procName:optOrderArgs)
#@                    }
#@                 }
#@             }
#@             
#@         } elseif { [regexp -nocase {\-default} $obj] } {
#@             set ::parseOpt::procInfo($procName:Default) $procInfo($obj)
#@         } else {
#@             puts "-W- parseOpt::cmdSpec : Unknown option $obj, ignoring."
#@         }
#@     }
#@ 
#@     # Inserting level 0 procedure (in case on usage in level 0)
#@     if { [info level] == 1 } {
#@         lappend ::parseOpt::level0ProcDef $procName
#@     }
#@ 
#@     return 1
#@ }
#@ 
#@ 
#@ 
#@ #####################################
#@ #
#@ # parse
#@ #
#@ # Init opt array and then parseOpt given args
#@ # 
#@ #####################################
#@ proc ::parseOpt::parseOpt {caller args} {
#@     return [::parseOpt::parseOptsMain $caller opt $args]
#@ }
#@ proc ::parseOpt::parseOpts {caller optvar args} {
#@     return [::parseOpt::parseOptsMain $caller $optvar $args]
#@ }
#@ proc ::parseOpt::setOptions {caller args} {
#@   setUpLevel 1
#@   if { [::parseOpt::parseOptsMain $caller opt $args] } {
#@     foreach option [array names opt] {
#@       regsub {^\-} $option {} option_name
#@       uplevel "set $option_name \{$opt($option)\}"
#@     }
#@     return 1
#@   }
#@   return 0
#@ }
#@ 
#@ 
#@ proc ::parseOpt::parseOptsMain {caller optvar args} {
#@     variable upLevel
#@     upvar $upLevel $optvar opts_ptr
#@     if { [info exists opts_ptr] } {
#@         unset opts_ptr
#@         upvar $upLevel $optvar opts_ptr
#@     }
#@     array set opts_ptr {}
#@     global env
#@ 
#@     # Incase the user send a list of list
#@     # Support up to 20 levels 
#@     set i 0
#@     while { [llength $args] == 1 && $i < 20 } {
#@         set args [::parseOpt::varPop args]
#@         incr i
#@     }
#@     
#@     
#@     # If a proc was not specified, get the name of the proc that called it, and set that as the caller.
#@     if {$caller == ""} {
#@         if { [info level] > 1 } {
#@             set caller [lindex [info level [expr [info level]  - 1] ] 0]
#@             regsub {^::} $caller {} caller
#@         } else {
#@             # This is in case of procedure run in level 0 - 
#@             #  in this case it is used in a script and not in a procedure
#@             set level0Proc [set ::parseOpt::level0ProcDef]      
#@             if { [llength $level0Proc] == 1 } {
#@                 set caller [lindex $level0Proc 0]
#@             } else {
#@                 set scriptName [file tail [info script]]
#@                 regsub [file extension $scriptName] $scriptName {} scriptName
#@                 set caller $scriptName
#@                 puts "-W- ::parseOpt::parseOpt : You are using parseOpt procedure in a script without specifing a name of option list. Please use parseOpt \$argv <option list name> (Assume $scriptName)"
#@             }      
#@         } 
#@     }
#@     
#@     # Verify that command have been defined
#@     if { ![info exist parseOpt::procInfo($caller:Init)] } {
#@         puts "-E- parseOpt::parseOpt : No options have been defined for command $caller (use cmdSpec to define options - Caller $caller)"
#@         return 0
#@     }
#@     
#@     # Init default values for all veriables
#@     ::parseOpt::initDefaultValues $caller $optvar
#@     
#@     set valid_options [set ::parseOpt::procInfo($caller:Opt:optList)]
#@     set use_gui 0
#@ 
#@     # Check unnamed/order arguments
#@     set num_order_args [expr $::parseOpt::procInfo($caller:reqOrderArgs) + $::parseOpt::procInfo($caller:optOrderArgs)]
#@     set order_based 0
#@     foreach arg $args {
#@         if [regexp -- {^-} $arg] { break }
#@         incr order_based
#@     }
#@     if { $order_based > $num_order_args || $order_based < $::parseOpt::procInfo($caller:reqOrderArgs) } {
#@         puts "Error: $::parseOpt::procInfo($caller:reqOrderArgs) required and $::parseOpt::procInfo($caller:optOrderArgs) optional order arguments supported, $order_based order arguments detected"
#@         ::parseOpt::printHelp $caller
#@         return 0
#@     }
#@ 
#@     # Parsing user switches
#@     array set tmp_use_opts {}
#@     set order_arg_indx 0
#@     set arg_cnt 0
#@     while { [llength $args] > 0 } {
#@         set option [::parseOpt::varPop args]
#@         
#@         # Ignore epmty variables
#@         if { [regexp {^[[:space:]]*$} $option] } { continue }
#@         
#@         regsub -all {^[[:space:]]+} $option {} option
#@         
#@         # Checking if help needed - if so -> print help and return 0
#@         if { [regexp -nocase {^\-h$} $option] || [regexp -nocase {^\-help$} $option] } {
#@             ::parseOpt::printHelp $caller
#@             set opts_ptr(-help) 1
#@             return 0
#@         }
#@         if { [regexp -nocase {^\-gui$} $option] } {
#@             set use_gui 1
#@             continue
#@         }
#@ 
#@         # Handle order arguments
#@         if { $arg_cnt < $order_based && ![regexp -- {^-} $option] } {
#@           set var_name [lindex $valid_options $arg_cnt]
#@           set opts_ptr(-$var_name) $option
#@           incr arg_cnt
#@           set tmp_use_opts($var_name) 1
#@           continue
#@         }
#@ 
#@         
#@         # Verifing that option exist in the list of valid option
#@         regsub {^\-} $option {} option_name
#@ 
#@ 
#@         # Trying to complete option if it is not exist 
#@         if { [lsearch -exact $valid_options $option_name] < 0 } {
#@             # Going over the options list - checking if there is a signal start of options
#@             set index {}
#@             for { set i 0 } { $i < [llength $valid_options] } { incr i } { 		
#@                 set opi [lindex $valid_options $i]
#@                 if {[regexp "^$option_name" $opi]} {
#@                     lappend index $i
#@                 }
#@             }
#@ 
#@             if { [llength $index] } {
#@                 if { [llength $index] == 1 } {
#@                     set option_name [lindex $valid_options [lindex $index 0]]
#@                 } else {
#@                     puts -nonewline "-E- $caller: Option $option_name fit to: "
#@                     foreach i $index {
#@                         puts -nonewline "-[lindex $valid_options $i] "
#@                     }
#@                     puts ""
#@                     return 0
#@                 }
#@             }
#@         }
#@         
#@         # Verifing that option exist in the list of valid options
#@         if { [lsearch -exact $valid_options $option_name] < 0 } {
#@             puts "-E- parseOpt::parseOpt : Error, While parsing options of $caller, unknown switch have been found - $option "
#@             ::parseOpt::printHelp $caller
#@             return 0 ;
#@         }
#@         
#@         # Getting the option type
#@         set option_type [set ::parseOpt::procInfo($caller:Opt:$option_name:Type)]
#@         if { [regexp -nocase {^bool(ean)?$} $option_type] } {
#@             #            set option_default_value [set ::parseOpt::procInfo($caller:Opt:$option_name:Default)]
#@             set option_default_value $opts_ptr(-$option_name)
#@             set opts_ptr(-$option_name) [expr !$option_default_value]
#@         } elseif { [regexp -nocase {^ebool(ean)?$} $option_type] } {
#@             # Althoung the usage of all list/string/unknow is the same - keeping it separete for future feature.
#@             set value [::parseOpt::varPop args]
#@             regsub -all {^[[:space:]]+} $value {} value
#@             if {[regexp -nocase {^(on|true|enable|yes)$} $value]} {
#@ 		set value 1
#@ 	    } elseif {[regexp -nocase {^(off|false|disable|no)$} $value]} {
#@ 		set value 0
#@ 	    }
#@ 	    if {$value==1 || $value==0} {
#@                 set opts_ptr(-$option_name) $value
#@             } else {
#@                 puts "-E- parseOpt::parseOpt : Error, While parsing options of $caller,\n    $option_name must be one of (on/true/yes/enable/1 or off/false/no/disable/0) (got: $value)"
#@                 return 0
#@             }
#@         } elseif { [regexp -nocase {^one_of_string$} $option_type] } {
#@             # Getting the value and checking if it is 
#@             set value [::parseOpt::varPop args]
#@             regsub -all {^[[:space:]]+} $value {} value
#@             set values [set ::parseOpt::procInfo($caller:Opt:$option_name:Values)]
#@             if { [lsearch -exact $values $value] < 0 } { 
#@                 puts "-E- parseOpt::parseOpt : Error, While parsing options of $caller, $option_name must get one of the following values: $values (and it got: $value)"
#@                 return 0
#@             }
#@             set opts_ptr(-$option_name) $value
#@         } elseif { [regexp -nocase {^int(eger)?$} $option_type] } {
#@             # Althoung the usage of all list/string/unknow is the same - keeping it separete for future feature.
#@             set value [::parseOpt::varPop args]
#@             regsub -all {^[[:space:]]+} $value {} value
#@             if { [string is int $value]} {
#@                 set opts_ptr(-$option_name) $value
#@             } else {
#@                 puts "-E- parseOpt::parseOpt : Error, While parsing options of $caller, $option_name must be an integer (got: $value)"
#@                 return 0
#@             }
#@         } elseif { [regexp -nocase {^(point|bbox)$} $option_type] } {
#@             set value [::parseOpt::varPop args]
#@ #            set value [join $value]
#@ #            set l 2
#@ #            if {  [regexp -nocase {^bbox$} $option_type] } {
#@ #                set l 4
#@ #            }
#@ #            if { [expr [llength $value] != $l] } {
#@ #                puts "-E- parseOpt::parseOpt : Error, While parsing options of $caller, $option_name must be point - that means exactly $l floating numbers (got [llength $value] points: $value)"
#@ #                return 0
#@ #            }
#@ #            foreach num $value {
#@ #                if { ![string is double $num]} {
#@ #                    puts "-E- parseOpt::parseOpt : Error, While parsing options of $caller, $option_name must be point - that means exactly $l floating numbers (got: $value, $num is not real)"
#@ #                    return 0
#@ #                }
#@ #            }
#@             set opts_ptr(-$option_name) $value
#@         } elseif { [regexp -nocase {^float$} $option_type] } {
#@             # Althoung the usage of all list/string/unknow is the same - keeping it separete for future feature.
#@             set value [::parseOpt::varPop args]
#@             regsub -all {^[[:space:]]+} $value {} value
#@             if { [string is double $value]} {
#@                 set opts_ptr(-$option_name) $value
#@             } else {
#@                 puts "-E- parseOpt::parseOpt : Error, While parsing options of $caller, $option_name must be an number (got: $value)"
#@                 return 0
#@             }
#@         } elseif { [regexp -nocase {^(string|file|directory|pin|pin_port|port|cell|net|lib_cell|lib_pin)$} $option_type] } {
#@             # Althoung the usage of all list/string/unknow is the same - keeping it separete for future feature.
#@             set value [::parseOpt::varPop args]
#@             regsub -all {^[[:space:]]+} $value {} value
#@             set opts_ptr(-$option_name) $value
#@         } elseif { [regexp -nocase {^list$} $option_type] } {
#@             set value [::parseOpt::varPop args]
#@             regsub -all {^[[:space:]]+} $value {} value
#@             set opts_ptr(-$option_name) $value
#@         } else {
#@             puts "-W- parseOpt::parseOpt : Unknown type has been defined for option $option_name ($option_type)"
#@             set value [::parseOpt::varPop args]
#@             regsub -all {^[[:space:]]+} $value {} value
#@             set opts_ptr(-$option_name) $value
#@         }
#@         
#@         set tmp_use_opts($option_name) 1
#@         
#@         # Define GUI varaible 
#@         set ::parseOpt::procInfo($caller:Opt:$option_name:GuiValue) $opts_ptr(-$option_name)
#@     }
#@     
#@     if { $use_gui } {
#@         ::parseOpt::open_gui $caller
#@         return 0
#@     }
#@ 
#@     # Checking for required options
#@     foreach op [set ::parseOpt::procInfo($caller:Opt:optList)] {
#@         # Checking if it is must options
#@         set must [set ::parseOpt::procInfo($caller:Opt:$op:Required)]
#@         if { $must && ![info exist tmp_use_opts($op)] } {
#@             puts "-E- parseOpt:parseOpt : Error, The following option is required: \"$op\"."
#@             ::parseOpt::printHelp $caller 
#@             return 0
#@         }
#@     }
#@ 
#@     return 1;
#@ }
#@ 
#@ 
#@ 
#@ #####################################
#@ #####################################
#@ ##
#@ ## Internal procedures for parseOpt
#@ ##
#@ #####################################
#@ #####################################
#@ 
#@ #####################################
#@ # Set/reset the value of the upLevel variable
#@ #####################################
#@ proc ::parseOpt::setUpLevel { {lev 2} } {
#@   variable upLevel
#@   set upLevel $lev
#@ }
#@ 
#@ #####################################
#@ #
#@ # varPop
#@ #
#@ # The following procedure simply pop out 
#@ # a varialbe for a list and return the variable
#@ ######################################
#@ proc ::parseOpt::varPop {list_name} {
#@     upvar 1 $list_name localList
#@     set first [lindex $localList 0]
#@     set localList [lrange $localList 1 end]
#@     return $first
#@ }
#@ 
#@ 
#@ #####################################
#@ #
#@ # initDefaultValues
#@ #
#@ # Init the global opt array with the default
#@ # value of each elem.
#@ ######################################
#@ 
#@ proc ::parseOpt::initDefaultValues {caller optvar} {
#@     variable upLevel
#@     upvar [expr $upLevel + 1] $optvar opts_ptr
#@     global env
#@ 
#@     foreach op [set ::parseOpt::procInfo($caller:Opt:optList)] {
#@         set  opts_ptr(-$op) [::parseOpt::getDefaultValues $caller $op]
#@     }    
#@ }
#@ 
#@ 
#@ 
#@ proc ::parseOpt::getDefaultValues {caller optName} {
#@     global env
#@ 
#@     set value_return ""
#@ 
#@     set type [set ::parseOpt::procInfo($caller:Opt:$optName:Type)]
#@     set default [set ::parseOpt::procInfo($caller:Opt:$optName:Default)]
#@     set default_from_pg [set ::parseOpt::procInfo($caller:Opt:$optName:DefaultFromPG)]
#@     set values [set ::parseOpt::procInfo($caller:Opt:$optName:Values)]
#@ 
#@     if { $default == {} } {
#@         # User have not define a default - lets define it by ourself
#@         if { [regexp -nocase {^e?bool(ean)?$} $type] } {
#@             set value_return 0
#@         } elseif { [regexp -nocase {^one_of_string$} $type] } {
#@             set value_return [lindex $values 0]
#@         } elseif { [regexp -nocase {^(string|int(eger)?|float)$} $type] } {
#@             set value_return ""
#@         } elseif { [regexp -nocase {^point$} $type] } {
#@             set value "-1 -1"
#@         } elseif { [regexp -nocase {^bbox$} $type] } {
#@             set value "-1 -1 -1 -1"
#@         } else {
#@             set value_return {}
#@         } 
#@     } else {
#@         # Settign the default value that have been defined by user
#@ 
#@         # Replacing enviroment variable (env) with their value
#@         while { [regexp {\$env} $default]} {
#@             regexp {\$env\([^ \t\)]+\)} $default var
#@             regsub {^\$} $var {} var
#@             set var [set $var]
#@             regsub {\$env\([^ \t\)]+\)} $default $var default
#@         }
#@         
#@         set value_return $default
#@     }
#@     
#@     ##############################
#@     # If we need to start from:
#@     #   param_get 
#@     if { $default_from_pg != "" } {
#@         # Verifying that param exists
#@         if { [param_info -quiet -name $default_from_pg] } {
#@             set value_return [param_get -name $default_from_pg]
#@         }
#@     }
#@     
#@     return $value_return
#@ }
#@ 
#@ 
#@ 
#@ 
#@ #####################################
#@ #
#@ # printHelp
#@ #
#@ # Print help message
#@ ######################################
#@ proc ::parseOpt::printHelp {caller} {
#@     setUpLevel
#@     set offset 8
#@     set SPACE [format "%${offset}s" ""]
#@     set table [list]
#@     set must_options ""
#@     foreach op [set ::parseOpt::procInfo($caller:Opt:optList)] { 
#@         foreach field {Type Help DEFAULT Values Required} {
#@             if {$field=="DEFAULT"} {
#@                 set $field [::parseOpt::getDefaultValues $caller $op]
#@             } else {
#@                 set $field [set ::parseOpt::procInfo($caller:Opt:$op:$field)]
#@             }
#@         }
#@         if {[regexp -nocase {^one_of_string$} $Type]} {
#@             append Help "\nValues: [lindex $Values 0]"
#@             foreach val [lrange $Values 1 end] {append Help ", $val"}
#@         }
#@         lappend table [list $Required $op "<" $Type ">" $DEFAULT $Help]
#@ 
#@         if {$Required} {
#@             set must_options "$must_options -$op <$Type>"
#@         }
#@     }
#@     rls_table -header [list Must Option Type "" "" Default Usage] -table $table         -no_sep -breaks -offset $offset -title "Usage:
#@ $SPACE$caller $must_options \[options\]
#@ Description:
#@ $SPACE[set  ::parseOpt::procInfo($caller:Help)]
#@ Options:"
#@     return 1
#@     # LEAVING ORIGINAL CODE FOR BACKUP:
#@ 
#@     # Procedure out create help message for caller proc
#@     
#@     # Collecting the length of each option
#@     # Plus - collection must options
#@     set op_type_max 4
#@     set op_help_max 5
#@     set op_name_max 5
#@     set op_default_max 7
#@     set op_req_max 1
#@     set must_options ""
#@     
#@     global synopsys_program_name
#@     set puts_cmd "puts"
#@     if { [info exists synopsys_program_name] &&              ($synopsys_program_name == "icc_shell" || $synopsys_program_name == "dc_shell") } {
#@         set puts_cmd "echo"
#@     }
#@ 
#@     foreach op [set ::parseOpt::procInfo($caller:Opt:optList)] { 
#@         set op_type [set ::parseOpt::procInfo($caller:Opt:$op:Type)]
#@         set op_help [set ::parseOpt::procInfo($caller:Opt:$op:Help)]
#@         set op_default [::parseOpt::getDefaultValues $caller $op]
#@         set op_required [set ::parseOpt::procInfo($caller:Opt:$op:Required)]
#@         set values [set ::parseOpt::procInfo($caller:Opt:$op:Values)]
#@         
#@         if { $op_type_max < [string length $op_type] } { set op_type_max [string length $op_type] }
#@         if { $op_help_max < [string length $op_help] } { set op_help_max [string length $op_help] }
#@         if { $op_name_max < [string length $op] } { set op_name_max [string length $op] }
#@         if { $op_default_max < [string length $op_default] } { set op_default_max [string length $op_default] }    
#@         
#@         if { $op_required } {
#@             set must_options "$must_options -$op <$op_type>"
#@         }
#@     } 
#@ 
#@     
#@     $puts_cmd "Usage:"
#@     $puts_cmd "\t$caller $must_options \[options\]"
#@     $puts_cmd "Description:"
#@     $puts_cmd "\t[set  ::parseOpt::procInfo($caller:Help)]"
#@     
#@     $puts_cmd "\nOptions:"
#@ 
#@     
#@ 
#@     # Header
#@     $puts_cmd [format "\tMust %-${op_name_max}s   %-${op_type_max}s      %-${op_default_max}s  %-${op_help_max}s" "Option" "Type" "Default" "Usage"] 
#@     $puts_cmd "\t====================================================="
#@     
#@     foreach op [set ::parseOpt::procInfo($caller:Opt:optList)] {
#@         set op_type [set ::parseOpt::procInfo($caller:Opt:$op:Type)]
#@         set op_help [set ::parseOpt::procInfo($caller:Opt:$op:Help)]
#@         set op_default [::parseOpt::getDefaultValues $caller $op]
#@         set op_required [set ::parseOpt::procInfo($caller:Opt:$op:Required)]
#@ 
#@         $puts_cmd [format "\t%d    -%-${op_name_max}s  < %-${op_type_max}s >  %-${op_default_max}s  %-${op_help_max}s" $op_required $op $op_type $op_default $op_help] 
#@         if { $op_type == "one_of_string" } {
#@             set values_str ""
#@             foreach v $values {
#@                 append values_str "$v, "
#@             }
#@             regsub {, $} $values_str {} values_str
#@             $puts_cmd [format "\t%s     %-${op_name_max}s    %-${op_type_max}s    %-${op_default_max}s  %-${op_help_max}s" " " "" "" "" "Values: $values_str"]
#@         }
#@     }
#@     
#@     
#@     return 1
#@ }
#@ 
#@ 
#@ 
#@ 
#@ ##################################################
#@ #
#@ # redefine_proc_attributes
#@ #
#@ # Simply run on all existsing cmdSpec the synopsys
#@ #  define_proc_attribute - to support tabs
#@ #
#@ ##################################################
#@ proc ::parseOpt::redefine_proc_attributes {{debug 0}} {
#@     global synopsys_program_name
#@     set PROC "::parseOpt::redefine_proc_attributes"
#@ 
#@     if { ![info exists synopsys_program_name] ||              ( $synopsys_program_name != "dc_shell" && $synopsys_program_name != "icc_shell" &&
#@                $synopsys_program_name != "de_shell" &&  $synopsys_program_name != "pt_shell")} {
#@         puts "-E- $PROC: Define proc attribute is supported only in synopsys TCL shells."
#@         return 0
#@     }
#@ 
#@     #############################
#@     # Creating new command group
#@     create_command_group parseOpt
#@     
#@ 
#@     foreach procName [array names ::parseOpt::procInfo *:Init] {
#@         regsub {:Init$} $procName {} procName 
#@         if {$debug} { echo "-D- $PROC: Woring on proc: $procName" }
#@         
#@         # Command base
#@         set cmd "define_proc_attributes $procName -command_group parseOpt -info \"$::parseOpt::procInfo($procName:Help)\" -define_args \{ \\\n"
#@ 
#@         # Command options
#@         foreach optName $::parseOpt::procInfo($procName:Opt:optList) {
#@             set optHelp    $::parseOpt::procInfo($procName:Opt:$optName:Help)
#@             set optDefault $::parseOpt::procInfo($procName:Opt:$optName:Default)
#@             set optType    $::parseOpt::procInfo($procName:Opt:$optName:Type)
#@             if { $optType == "order" } { set optType string }
#@             set optTypeHelp $optType
#@             set optReq     $::parseOpt::procInfo($procName:Opt:$optName:Required)
#@             if { [info exists ::parseOpt::procInfo($procName:Opt:$optName:Values)] } {
#@                 set values     $::parseOpt::procInfo($procName:Opt:$optName:Values)
#@             } else {
#@                 set values [list]
#@             }
#@             if { $optReq } {
#@                 set optAttr "required"
#@             } else {
#@                 set optAttr "optional"
#@             }
#@             if { [regexp {^bool(ean)?} $optType] } {
#@                 set optType "boolean"
#@                 set optTypeHelp ""
#@             } elseif {[regexp {^(file|directory|pin|pin_port|port|lib_cell|lib_pin|cell|net|int(eger)|float|point|bbox)$} $optType]} {
#@                 set optType "string"
#@                 set optTypeHelp ""
#@             } elseif { [regexp {^one_of_string$} $optType] } {
#@                 append optAttr " value_help \{values \{$values\}\} "
#@             } elseif { [regexp {^ebool(ean)?$} $optType] } {
#@                 set optType one_of_string
#@                 append optAttr " value_help \{values \{1 yes true enable on 0 no false disable\}\} "
#@             }
#@ 
#@             append cmd "\t\{\"-$optName\" \"$optHelp\" \"$optTypeHelp\" $optType \{ $optAttr \}\} \\\n"
#@         }
#@         
#@         append cmd "\}\n"
#@         regsub -all {\[} $cmd {\\[} cmd
#@             regsub -all {\]} $cmd {\\]} cmd
#@         
#@         if {$debug} { echo "-D- $PROC: Exec:\n$cmd" }
#@ 
#@         if { [catch {eval $cmd} msg] } {
#@             echo "-W- $PROC: $msg"
#@         }
#@     }
#@     
#@     return 1
#@ }
#@ 
#@ 
#@ 
#@ 
#@ #########################################################
#@ # The following procedure will work only in ICC 
#@ #  Only in a gui mode
#@ #
#@ # Simply open window with all options
#@ #
#@ #########################################################
#@ proc ::parseOpt::open_gui {procName} { 
#@     # ArE ewe in icc?
#@     global synopsys_program_name
#@     if { ![info exists synopsys_program_name] || $synopsys_program_name != "icc_shell" } {
#@         return 0
#@     }
#@     
#@     if { [llength [gui_get_window_ids]] == 0 } {
#@         return 0
#@     }
#@ 
#@ 
#@     # Creating new top window
#@     set window_name "parse_opt_gui_$procName"
#@     regsub -all {\:} $window_name {_} window_name
#@     regsub -all {\.} $window_name {_} window_name
#@     set window_name ".$window_name"
#@ 
#@     # Is the window already opened
#@     catch "wm geometry $window_name" msg
#@     if { ![regexp {^bad window path} $msg] } {
#@         echo "-E- Window of command: $procName already opened."
#@         wm deiconify $window_name
#@         raise $window_name
#@         return 0
#@     }
#@ 
#@ 
#@     # Loading Tix
#@     catch {package present Tix} msg
#@     if { [regexp "present" $msg] } {
#@         package require Tix
#@     }
#@ 
#@     set path $::parseOpt::parseOptPath
#@ 
#@ 
#@     toplevel $window_name
#@     wm title $window_name  "$procName Options:"
#@     # Placing the menu in the middle of the sceen
#@     wm grid  $window_name 0 0 1 1
#@     wm geometry $window_name "+[expr [winfo screenwidth .]/2]+[expr [winfo screenheight .]/2]"
#@ 
#@     set f [ frame ${window_name}.f_help -borderwidth  2 -relief sunken]
#@     pack $f -side top -fill x 
#@     
#@     set help_str  $::parseOpt::procInfo($procName:Help)
#@     label $f.help_label -text "Description:\n$help_str"
#@     pack $f.help_label  -side left 
#@ 
#@     # Init ballon
#@     tixBalloon $window_name.ballon -initwait 500
#@ 
#@     set selection_object_list {}
#@     
#@     # Define max label width
#@     set max_label_limit 60
#@     set label_width 0  
#@     foreach optName $::parseOpt::procInfo($procName:Opt:optList) {
#@         set label_width [expr $label_width > [string length $optName] ? $label_width : [expr [string length $optName] + 2] ]
#@     }
#@     if { $label_width > $max_label_limit } { set label_width $max_label_limit }
#@ 
#@     # Going over all options and creating them a GUI
#@     foreach optName $::parseOpt::procInfo($procName:Opt:optList) {
#@         set optHelp    $::parseOpt::procInfo($procName:Opt:$optName:Help)
#@         set optDefault $::parseOpt::procInfo($procName:Opt:$optName:Default)
#@         set optDefault [::parseOpt::getDefaultValues $procName $optName]
#@         set optType    $::parseOpt::procInfo($procName:Opt:$optName:Type)
#@         set optFilter       $::parseOpt::procInfo($procName:Opt:$optName:Filter)
#@         set optSingelSelection $::parseOpt::procInfo($procName:Opt:$optName:SingelSelection)
#@         set hidden     $::parseOpt::procInfo($procName:Opt:$optName:Hidden)
#@         set optTypeHelp $optType
#@         set optReq     $::parseOpt::procInfo($procName:Opt:$optName:Required)
#@         if { [info exists ::parseOpt::procInfo($procName:Opt:$optName:Values)] } {
#@             set values     $::parseOpt::procInfo($procName:Opt:$optName:Values)
#@         } else {
#@             set values [list]
#@         }
#@         
#@ 
#@         # Craeting GUI varaible 
#@         if { ![info exists ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)] } {
#@             set ::parseOpt::procInfo($procName:Opt:$optName:GuiValue) $optDefault
#@         }
#@ 
#@         
#@         #####################################
#@         # If opt is hidden - don't create it
#@         if { $hidden } { continue }
#@ 
#@         
#@         set f [ frame ${window_name}.$optName -borderwidth  2 -relief sunken]
#@         if { $optReq } {
#@             $f configure -bg \#990000 
#@         }
#@         pack $f -side top -fill x 
#@ 
#@         set entry_width 60
#@         
#@         if { [regexp -nocase {^bool(ean)?$} $optType ] } {
#@             checkbutton $f.check_btn -variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue) 
#@             label $f.label -text $optName
#@             pack $f.check_btn $f.label -side left 
#@         } elseif { [regexp -nocase {^ebool(ean)?$} $optType ] } {
#@             tixComboBox $f.combo -label "$optName : " -variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue) 
#@             set combo_list [$f.combo subwidget listbox]
#@             [$f.combo subwidget entry] configure -width $entry_width  -disabledforeground black
#@             foreach e {0 1} {
#@                 $combo_list insert end $e
#@             }
#@             $combo_list see 0
#@             pack $f.combo -side left
#@             $combo_list see 0
#@         } elseif { [regexp -nocase {^one_of_string$} $optType ] } {
#@             tixComboBox $f.combo -label "$optName : " -variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue) 
#@             set combo_list [$f.combo subwidget listbox]
#@             [$f.combo subwidget entry] configure -width $entry_width  -disabledforeground black
#@             [$f.combo subwidget label] configure -width $label_width
#@             foreach e $values {
#@                 $combo_list insert end $e
#@             }
#@             $combo_list see 0
#@             pack $f.combo -side left
#@             $combo_list see 0
#@         } elseif { [regexp -nocase {^string$} $optType ] } {
#@             label $f.label -text "$optName : " -width $label_width -anchor w
#@             entry $f.entry                 -textvariable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -width $entry_width
#@             pack $f.label -side left 
#@             pack $f.entry -side left -fill x 
#@         } elseif { [regexp -nocase {^int(eger)?$} $optType ] } {
#@             label $f.label -text "$optName : " -width $label_width -anchor w
#@             entry $f.entry                 -textvariable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -width $entry_width                 -validatecommand [list ::parseOpt::validate int %P ]                 -validate key
#@             pack $f.label -side left 
#@             pack $f.entry -side left -fill x 
#@         } elseif { [regexp -nocase {^float$} $optType ] } {
#@             label $f.label -text "$optName : " -width $label_width -anchor w
#@             entry $f.entry                 -textvariable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -width $entry_width                 -validatecommand [list ::parseOpt::validate double %P ]                 -validate key
#@             pack $f.label -side left 
#@             pack $f.entry -side left -fill x 
#@         } elseif { [regexp -nocase {^list$} $optType ] } {
#@             label $f.label -text "$optName : " -width $label_width -anchor w
#@             entry $f.entry -textvariable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue) -width $entry_width
#@             pack $f.label -side left 
#@             pack $f.entry -side left -fill x 
#@         } elseif { [regexp -nocase {^file$} $optType ] } {
#@             tixFileEntry $f.file_select                 -label "$optName : "                 -variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -dialogtype tk_getSaveFile 
#@             [$f.file_select subwidget entry] configure -width $entry_width
#@             [$f.file_select subwidget label] configure -width $label_width
#@             pack $f.file_select -side left -fill x
#@         } elseif { [regexp -nocase {^directory$} $optType ] } {
#@             tixFileEntry $f.dir_select                 -label "$optName : "                 -variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -dialogtype tixDirSelectDialog  
#@             [$f.dir_select subwidget entry] configure -width $entry_width
#@             [$f.dir_select subwidget label] configure -width $label_width
#@             pack $f.dir_select -side left -fill x
#@         } elseif { [regexp -nocase {^(lib_pin|lib_cell)$} $optType ] } {
#@             set LibraryObjectName "${procName}_$optName"
#@             regsub -all {[:\.]} $LibraryObjectName {_} LibraryObjectName
#@             LibrarySelection $LibraryObjectName                 -frame $f                 -label "$optName : "                 -object_type $optType                 -entry_variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -entry_width $entry_width                 -label_width $label_width
#@             if { [llength [join $optFilter]] != 0 } {
#@                 $LibraryObjectName configure -filter "$optFilter"
#@             }
#@             $LibraryObjectName CreateFrameWidget
#@             lappend selection_object_list $LibraryObjectName
#@         } elseif { [regexp -nocase {^(point|bbox)$} $optType] } {
#@             set PointObjectName "${procName}_$optName"
#@             regsub -all {[:\.]} $PointObjectName {_} PointObjectName
#@             PointSelection $PointObjectName                 -top_window $window_name                 -frame $f                 -label "$optName : "                 -object_type $optType                 -entry_variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -entry_width $entry_width                 -label_width $label_width
#@             if { $optSingelSelection  } {
#@                 $PointObjectName configure -singel_selection 1
#@             } else {
#@                 $PointObjectName configure -singel_selection 0
#@             }
#@             $PointObjectName CreateFrameWidget
#@             lappend selection_object_list $PointObjectName            
#@         } elseif { [regexp -nocase {^(pin|pin_port|port|cell|net)$} $optType ] } {
#@             set SelectObjectName "${procName}_$optName"
#@             regsub -all {[:\.]} $SelectObjectName {_} SelectObjectName
#@             ObjectSelection $SelectObjectName                 -frame $f                 -label "$optName : "                 -object_type $optType                 -entry_variable ::parseOpt::procInfo($procName:Opt:$optName:GuiValue)                 -entry_width $entry_width                 -label_width $label_width
#@             if { $optSingelSelection  } {
#@                 $SelectObjectName configure -singel_selection 1
#@             }
#@ 
#@             $SelectObjectName CreateFrameWidget
#@             lappend selection_object_list $SelectObjectName
#@         }
#@         
#@         $window_name.ballon bind $f -msg "$optHelp"
#@ 
#@     }
#@     
#@     
#@     # Adding buttons
#@     set f [ frame ${window_name}.cmd_btn -borderwidth  2 -relief sunken]
#@     pack $f -side top -fill x 
#@ 
#@     button $f.ok      -text "OK"      -command [list ::parseOpt::okCmd $procName $window_name $selection_object_list]
#@     button $f.preview -text "Preview" -command [list ::parseOpt::previewCmd $procName $window_name ]
#@     button $f.default -text "Default" -command [list ::parseOpt::defaultCmd $procName $window_name ]
#@     button $f.cancel  -text "Cancel"  -command [list ::parseOpt::cancelCmd $procName $window_name $selection_object_list]
#@ 
#@     wm protocol $window_name WM_DELETE_WINDOW "eval ::parseOpt::cancelCmd $procName $window_name \{$selection_object_list\}"
#@ 
#@     pack         $f.cancel         $f.default         $f.preview         $f.ok         -side right
#@ 
#@     return 1
#@ }
#@ 
#@ 
#@ proc ::parseOpt::cancelCmd {procName window args} {
#@ #    set list [split [lindex $args 0]]
#@ 
#@     foreach objs $args {
#@         foreach obj $objs {
#@             catch {delete object ::parseOpt::$obj} msg
#@         }
#@     }
#@     
#@     destroy $window
#@ }
#@ 
#@ proc ::parseOpt::previewCmd {procName window} {
#@     #    destroy $window
#@ 
#@     set cmd [::parseOpt::buildCmd $procName $window]
#@ 
#@ 
#@     echo $cmd
#@ }
#@ 
#@ proc ::parseOpt::okCmd {procName window args} {
#@     foreach obj [join $args] {
#@         if { $obj == "" } { continue }
#@         catch {delete object $obj}
#@     }
#@ 
#@     destroy $window
#@ 
#@     set cmd [::parseOpt::buildCmd $procName $window]
#@ 
#@     echo $cmd
#@ 
#@     set msg [uplevel \#0 "eval \{$cmd\}"]
#@ 
#@     echo $msg
#@     
#@     return $msg
#@ }
#@ 
#@ 
#@ proc ::parseOpt::defaultCmd {procName window} {
#@ 
#@     # Going on all options and setting defaults
#@     foreach optName $::parseOpt::procInfo($procName:Opt:optList) {
#@         set ::parseOpt::procInfo($procName:Opt:$optName:GuiValue) [::parseOpt::getDefaultValues $procName $optName]
#@     }
#@     
#@ }
#@ 
#@ 
#@ proc ::parseOpt::validate {type value} {
#@ 
#@     if { [regexp {^\s*$} $value] } { return 1 }
#@ 
#@     return [string is $type $value]
#@ }
#@ 
#@ 
#@ 
#@ # Creating CMD for GUI execture or preview
#@ proc ::parseOpt::buildCmd {procName window} {
#@     
#@     set cmd "$procName "
#@ 
#@     # Going over all options and creating them a GUI
#@     foreach optName $::parseOpt::procInfo($procName:Opt:optList) {
#@         set optDefault $::parseOpt::procInfo($procName:Opt:$optName:Default)
#@         set optDefault [::parseOpt::getDefaultValues $procName $optName]
#@         set optHidden  $::parseOpt::procInfo($procName:Opt:$optName:Hidden)
#@         set optType    $::parseOpt::procInfo($procName:Opt:$optName:Type)
#@         set optReq     $::parseOpt::procInfo($procName:Opt:$optName:Required)
#@         if { [info exists ::parseOpt::procInfo($procName:Opt:$optName:Values)] } {
#@             set values     $::parseOpt::procInfo($procName:Opt:$optName:Values)
#@         } else {
#@             set values [list]
#@         }
#@ 
#@         set gui_value $::parseOpt::procInfo($procName:Opt:$optName:GuiValue)
#@         
#@         if { $gui_value == $optDefault || $optHidden } { continue }
#@ 
#@         if { [regexp -nocase {^bool(ean)?$} $optType ] } {
#@             if { $gui_value } {
#@                 append cmd "-$optName "
#@             }
#@         } elseif { [regexp -nocase {^one_of_string$} $optType ] } {
#@             append cmd "-$optName \"$gui_value\" "
#@         } elseif { [regexp -nocase {^(string|int(eger)?|float|ebool(ean)?)$} $optType ] } {
#@             append cmd "-$optName \"$gui_value\" "
#@         } elseif { [regexp -nocase {^list$} $optType ] } {
#@             append cmd "-$optName \{$gui_value\} "
#@         } elseif { [regexp -nocase {^file$} $optType ] } {
#@             append cmd "-$optName \"$gui_value\" "
#@         } elseif { [regexp -nocase {^directory$} $optType ] } {
#@             append cmd "-$optName \"$gui_value\" "
#@         } elseif { [regexp -nocase {^(cell|pin|pin_port|port|net|lib_cell|lib_pin|point|bbox)$} $optType ] } {
#@             append cmd "-$optName \"$gui_value\" "
#@         }
#@         
#@     }
#@     
#@     return $cmd
#@ }
#@ 
#@ 
#@ 
#@ 
#@ proc ::parseOpt::unhide_cmd {cmd} {
#@ 
#@     if { $cmd == "all" } {
#@         foreach k [array get ::parseOpt::procInfo *:Opt:optList] {
#@             regexp {^(\S+):Opt:optList$} $k lost cmdl
#@             if { ![info exists cmdl] } { continue }
#@             foreach opt $::parseOpt::procInfo($cmdl:Opt:optList) {
#@                 set ::parseOpt::procInfo($cmdl:Opt:$opt:Hidden) 0
#@             }
#@         }
#@ 
#@     } else {
#@         if { ![info exists ::parseOpt::procInfo($cmd:Opt:optList)] } {
#@             echo "-E- No such command $cmd"
#@             return 0
#@         }
#@         foreach opt $::parseOpt::procInfo($cmd:Opt:optList) {
#@             set ::parseOpt::procInfo($cmd:Opt:$opt:Hidden) 0
#@         }
#@     }
#@     
#@     return 1
#@ }
#@ 
#@ 
#@ 
#@ 
#@ 
#@ #####################################
#@ # Init RLS TABLE
#@ #####################################
#@ if { [info command rls_table] == "" } {
#@     catch {unset path} msg
#@     set path $::parseOpt::parseOptPath
#@     source $path/rls_table.tcl
#@     unset path
#@ }
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/fill/parseOpt/rls_table.tcl

#@ ::parseOpt::cmdSpec rls_table {
#@     -help "Prints out a list of lists in a text table"
#@     -opt {
#@ 	{-optname title         -type string  -default "" -required 0 -help "title to print before table - no formatting"}
#@         {-optname table         -type list    -default {} -required 0 -help "table data - is a list of lists"}
#@         {-optname header        -type list    -default {} -required 0 -help "table header titles:\nuse empty string to skip a columns title\nuse a '-' prefix to align to the right"}
#@         {-optname repeat_header -type string  -default "" -required 0 -help "repeat header every X number of lines"}
#@         {-optname format        -type list    -default {} -required 0 -help "list of format styles for table columns"}
#@         {-optname breaks        -type bool    -default 0  -required 0 -help "include break lines?"}
#@         {-optname spacious      -type bool    -default 0  -required 0 -help "add extra spaces for columns?"}
#@         {-optname no_separator  -type bool    -default 0  -required 0 -help "no vertical separator?"}
#@         {-optname width_limit   -type string  -default "" -required 0 -help "limit column width (breaks to lines) - off by default"}
#@ 	{-optname offset        -type int     -default 0  -required 0 -help "add some spaces to the left of the entire table"}
#@         {-optname to            -type string  -default "" -required 0 -help "set output file handle instead of STDOUT"}
#@         {-optname file          -type string  -default "" -required 0 -help "set output file name instead of STDOUT"}
#@ 	{-optname footer        -type string  -default "" -required 0 -help "footer to print after table - no formatting"}
#@     }
#@ }
#@ 
#@ # rls_table prints out a list of lists in a text table
#@ proc rls_table {args} {
#@     global synopsys_program_name
#@ 
#@     if { ![::parseOpt::parseOpt rls_table  $args] } { return 0 }
#@ 
#@     set limit -1
#@     set hRepeat -1
#@     set breaks 0
#@     set extraSpaces 0
#@     set header [list]
#@     set format [list]
#@     set vSep "|"
#@     set hSep "-"
#@     set xSep "+"
#@     set target ""
#@     set SPACE ""
#@     catch {if {$opt(-breaks)==1} {set breaks 1}}
#@     catch {if {$opt(-spacious)==1} {set extraSpaces 1}}
#@     catch {if {$opt(-no_separator)==1} {set vSep " "; set xSep "-"}}
#@     if {[info exists opt(-header)]} {set header $opt(-header)}
#@     if {[info exists opt(-format)]} {set format $opt(-format)}
#@     if {[info exists opt(-repeat_header)]} {set hRepeat $opt(-repeat_header)}
#@     if {[info exists opt(-width_limit)]} {set limit $opt(-width_limit)}
#@     set table $opt(-table)
#@ 
#@     # Handle file Handle :) - create rls_table_hidden_procedure_for_echo to handle this option
#@     if { $opt(-to) != "" && $opt(-file) != "" } {
#@         puts "-E- Cannot specify both -file and -to"
#@         return 0
#@     }
#@     if { $opt(-to) != "" } {
#@         set target $opt(-to)
#@     } elseif { $opt(-file) != "" } {
#@         if {[catch {open $opt(-file) w} target]} {
#@             puts "-E- Failed to open $opt(-file) log file for output"
#@             return 0
#@         }
#@     }
#@ 
#@     set create_proc_eval "proc rls_table_hidden_procedure_for_echo {line} {upvar SPACE SPACE ; "
#@     if {$target==""} {
#@ 	if {[info exists synopsys_program_name] && ([regexp {^(icc|dc)_shell$} $synopsys_program_name])} {
#@ 	    append create_proc_eval echo
#@ 	} else {
#@ 	    append create_proc_eval puts
#@ 	}
#@     } else {
#@ 	append create_proc_eval "puts $target"
#@     }
#@     append create_proc_eval " \"\$SPACE\$line\"}"
#@     eval $create_proc_eval
#@  
#@     if {([llength $header]==0) && ($breaks || $hRepeat>-1)} {
#@ 	puts "-E- rls_table: -breaks and -repeat_header require the header to be specified"
#@ 	return 0
#@     }
#@ 
#@     if {$extraSpaces} {
#@ 	set vSep " $vSep "
#@ 	set xSep "$hSep$xSep$hSep"
#@     }
#@ 
#@     # handle padding reversal in header
#@     set direction [list]
#@     if {[llength $header]>0} {
#@ 	set tempHeader [list]
#@ 	foreach column $header {
#@ 	    if {[string range $column 0 0]=="-"} {
#@ 		lappend tempHeader [string range $column 1 end]
#@ 		lappend direction ""
#@ 	    } else {
#@ 		lappend tempHeader $column
#@ 		lappend direction "-"
#@ 	    }
#@ 	}
#@ 	set header $tempHeader
#@     }
#@ 
#@     array set COLUMN {}
#@     array set EXTRA {}
#@     array set VSEP {}
#@     # get column widths for all data lines
#@     set num 0
#@     set fixedTable [list]
#@     array set HEIGHT {}
#@     for {set lineNum 0} {$lineNum<[llength $table]} {incr lineNum} {
#@ 	set line [lindex $table $lineNum]
#@ 	if {($line=="header") || ($line=="break")} {
#@ 	    lappend fixedTable $line
#@ 	    continue
#@ 	}
#@ 	set fixedLine [list]
#@ 	set maxHeight 1
#@ 	for {set i 0} {$i<[llength $line]} {incr i} {
#@ 	    set fixedSub [list]
#@ 
#@ 	    set column [lindex $line $i]
#@ 	    # limit column width
#@ 	    if {$limit>-1} {
#@ 		set fixedColumn [list]
#@ 		foreach subline [split $column "\n"] {
#@ 		    while {[string length $subline]>$limit} {
#@ 			lappend fixedColumn [string range $subline 0 [expr $limit-1]]
#@ 			set subline [string range $subline $limit end]
#@ 		    }
#@ 		    if {[string length $subline]>0} {
#@ 			lappend fixedColumn $subline
#@ 		    }
#@ 		}
#@ 		set column [join $fixedColumn "\n"]
#@ 	    }
#@ 	    set height 0
#@ 	    foreach subline [split $column "\n"] {
#@ 		# format entry
#@ 		incr height
#@ 		if {[llength $format]>0} {
#@ 		    if {[expr [llength $format]>$i]} {
#@ 			set thisFormat [lindex $format $i]
#@ 			if {$thisFormat!=""} {
#@ 			    catch {set subline [format $thisFormat $subline]}
#@ 			}
#@ 		    }
#@ 		}
#@ 		# handle width
#@ 		set len [string length $subline]
#@ 		if {[info exists COLUMN($i)]} {
#@ 		    if {[expr $len>$COLUMN($i)]} {
#@ 			set COLUMN($i) $len
#@ 		    }
#@ 		} else {
#@ 		    set COLUMN($i) $len
#@ 		    set EXTRA($i) ""
#@ 		    set num [expr $i+1]
#@ 		}
#@ 		# handle separator
#@ 		if {[lindex $header [expr 1+$i]]==""} {
#@ 		    regsub -all {.} $vSep { } VSEP($i)
#@ 		} else {
#@ 		    set VSEP($i) $vSep
#@ 		}
#@ 		lappend fixedSub $subline
#@ 	    }
#@ 	    if {[string length $column]==0} {
#@ 		if {![info exists COLUMN($i)]} {
#@ 		    set COLUMN($i) 0
#@ 		}
#@ 		if {![info exists EXTRA($i)]} {
#@ 		    set EXTRA($i) ""
#@ 		}
#@ 		if {![info exists VSEP($i)]} {
#@ 		    if {[lindex $header [expr 1+$i]]==""} {
#@ 			regsub -all {.} $vSep { } VSEP($i)
#@ 		    } else {
#@ 			set VSEP($i) $vSep
#@ 		    }
#@ 		    lappend fixedSub ""
#@ 		}
#@ 	    }
#@ 	    if {$height>$maxHeight} {set maxHeight $height}
#@ 	    lappend fixedLine [join $fixedSub "\n"]
#@ 	}
#@ 	if {$maxHeight>1} {set HEIGHT($lineNum) $maxHeight}
#@ 	lappend fixedTable $fixedLine
#@     }
#@     set table $fixedTable
#@ 
#@     # open multiple lines
#@     if {[llength [array names HEIGHT]]>0} {
#@ 	set fixedTable [list]
#@ 	for {set lineNum 0} {$lineNum<[llength $table]} {incr lineNum} {
#@ 	    set line [lindex $table $lineNum]
#@ 	    if {($line=="header") || ($line=="break") || ![info exists HEIGHT($lineNum)]} {
#@ 		lappend fixedTable $line
#@ 		continue
#@ 	    }
#@ 	    # actual work
#@ 	    for {set slNum 0} {$slNum<$HEIGHT($lineNum)} {incr slNum} {
#@ 		set fixedLine [list]
#@ 		foreach column $line {
#@ 		    lappend fixedLine [lindex [split $column "\n"] $slNum]
#@ 		}
#@ 		lappend fixedTable $fixedLine
#@ 	    }
#@ 	}
#@ 	set table $fixedTable
#@     }
#@ 
#@     if {([info exists opt(-title)]) && ($opt(-title)!="")} {
#@ 	rls_table_hidden_procedure_for_echo $opt(-title)
#@     }
#@ 
#@     if {[info exists opt(-offset)]} {set SPACE [format "%$opt(-offset)s" ""]}
#@ 
#@     if {$header!=""} {
#@ 	# create empty colums if header has more entries
#@ 	while {$num<[llength $header]} {
#@ 	    set COLUMN($num) 0
#@ 	    set EXTRA($num) ""
#@ 	    regsub -all {.} $vSep { } VSEP($num)
#@ 	    incr num
#@ 	}
#@ 	# create empty header titles if table has more columns
#@ 	while {[llength $header]<$num} {
#@ 	    lappend header ""
#@ 	    lappend direction "-"
#@ 	}
#@ 
#@ 	# handle header widths
#@ 	set formattedHeader ""
#@ 	set breakLine ""
#@ 	set extra 0
#@ 	set extraSpot 0
#@ 	for {set i [expr [llength $header]-1]} {$i>=0} {set i [expr $i-1]} {
#@ 	    set element [lindex $header $i]
#@ 	    if {($element=="") && ($i!="0")} {
#@ 		set extra [expr $extra+$COLUMN($i)+1+2*$extraSpaces]
#@ 		if {$extraSpot==0} {
#@ 		    set extraSpot $i
#@ 		}
#@ 	    } else {
#@ 		set missing [expr [string length $element]-$COLUMN($i)-$extra]
#@ 		for {set j 0} {$j<$missing} {incr j} {
#@ 		    if {$extraSpot>0} {
#@ 			append EXTRA($extraSpot) " "
#@ 		    } else {
#@ 			incr COLUMN($i)
#@ 		    }
#@ 		}
#@ 		for {} {$missing<0} {incr missing} {
#@ 		    append element " "
#@ 		}
#@ 		set formattedHeader [format "%s%s%s" $element $vSep $formattedHeader]
#@ 		regsub -all {.} $element $hSep breakPart
#@ 		set breakLine "$breakPart$xSep$breakLine"
#@ 		set extra 0
#@ 		set extraSpot 0
#@ 	    }
#@ 	}
#@ 	set formattedHeader [string range $formattedHeader 0 [expr [string length $formattedHeader]  - [string length $xSep]] ]
#@ 	set breakLine [string range $breakLine 0 [expr [string length $breakLine] - [string length $xSep]]]
#@ 	rls_table_hidden_procedure_for_echo $formattedHeader
#@ 	if {$breaks} {rls_table_hidden_procedure_for_echo $breakLine}
#@     } else {
#@ 	# set default left->right direction
#@ 	for {set i 0} {$i<$num} {incr i} {lappend direction "-"}
#@     }
#@ 
#@     # prepare format line
#@     set formatLine ""
#@     for {set i 0} {$i<$num} {incr i} {
#@ 	append formatLine "%[lindex $direction $i]$COLUMN($i)s$EXTRA($i)$VSEP($i)"
#@     }
#@     set formatLine [string range $formatLine 0 [expr [string length $formatLine]-[string length $vSep]]]
#@ 
#@     set counter 0
#@     foreach line $table {
#@ 	if {($counter==$hRepeat) || ($line=="header")} {
#@ 	    if {$breaks} {rls_table_hidden_procedure_for_echo $breakLine}
#@ 	    rls_table_hidden_procedure_for_echo $formattedHeader
#@ 	    if {$breaks} {rls_table_hidden_procedure_for_echo $breakLine}
#@ 	    set counter 0
#@ 	    if {$line=="header"} {continue}
#@ 	} elseif {$line=="break"} {
#@ 	    if {[info exists breakLine]} {rls_table_hidden_procedure_for_echo $breakLine}
#@ 	    incr counter
#@ 	    continue
#@ 	}
#@ 	while {[llength $line]<$num} {lappend line ""}
#@ 	rls_table_hidden_procedure_for_echo [eval [list format $formatLine] $line]
#@ 	incr counter
#@     }
#@ 
#@     set SPACE ""
#@ 
#@     if {([info exists opt(-footer)]) && ($opt(-footer)!="")} {
#@ 	rls_table_hidden_procedure_for_echo $opt(-footer)
#@     }
#@ 
#@     if { $opt(-file) != "" } {
#@         close $target
#@     }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/fill/parseOpt/rls_table.tcl

#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/parseOpt/parseOpt.5.0.tcl

#@ 
#@ ##########################################################################
#@ 
#@ namespace eval ::pwr {
#@   namespace export *
#@ }
#@ 
#@ 
#@ ##########################################################################
#@ # Procedure   : pwr::create_stdcell_powerhookup
#@ #
#@ # Description : add vias for runset based stdcell powerhookup connection
#@ # Inputs      :
#@ #
#@ # Returns     : # of vias/shapes added if successful
#@ #               -1 if hookup runset is not available
#@ ##########################################################################
#@ proc ::pwr::create_stdcell_powerhookup { args } {
#@   parse_proc_arguments -args $args opts
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   global INTEL_PROCESS_NAME INTEL_PWR_HOOKUP_GRID_COUNT INTEL_PWR_HOOKUP_AVOID_DRV
#@   global INTEL_UNIX_PROTECT_GROUP INTEL_FILL_ICVRUNSET INTEL_DFM_RELEASE_DIR INTEL_GDS_OUT_LAYER_MAP
#@   global INTEL_PWR_HOOKUP_RUN_ON_MW_CEL INTEL_PWR_HOOKUP_LAYERS
#@   global INTEL_MW_POWER_NET INTEL_MW_GROUND_NET INTEL_VA_POWER INTEL_VA_GROUND
#@   global INTEL_STDCELL_TILE_HEIGHT INTEL_STDCELL_TILE INTEL_FLIP_FIRST_ROW
#@   global INTEL_PWR_HOOKUP_ADDL_REFS INTEL_PWR_HOOKUP_DH_BONUS_CELLS_LIST
#@   global INTEL_PWR_HOOKUP_FORCE_HOOKUP_CELLS_LIST
#@   global INTEL_PWR_HOOKUP_CELLS_LIST INTEL_PWR_HOOKUP_CELLS_LIST_XN INTEL_XN_LIBRARY
#@   global INTEL_PWR_HOOKUP_VIA_MASTER
#@ 
#@   set start_time [clock seconds]
#@ 
#@   set block [get_object_name [current_mw_cel]]
#@   set process $INTEL_PROCESS_NAME
#@ 
#@   if { [regexp {127[123]} $process] } {
#@     set grid_count 4
#@   } else {
#@     set grid_count 2
#@   }
#@   if { [info exists opts(-powerhookup_grid_count)] } {
#@     set grid_count $opts(-powerhookup_grid_count)
#@   } elseif { [info exists INTEL_PWR_HOOKUP_GRID_COUNT] && [string is integer -strict $INTEL_PWR_HOOKUP_GRID_COUNT] } {
#@     set grid_count $INTEL_PWR_HOOKUP_GRID_COUNT
#@   }
#@   set empty_area_insertion false
#@   if { [info exists opts(-powerhookup_empty_area) ] } {
#@     set empty_area_insertion true
#@   }
#@   set cell_area_insertion false
#@   if { [info exists opts(-powerhookup_cells_area) ] } {
#@     set cell_area_insertion true
#@   }
#@   set avoid_drv false
#@   if { [info exists opts(-powerhookup_avoid_drv) ] } {
#@     set avoid_drv true
#@   } elseif { [info exists INTEL_PWR_HOOKUP_AVOID_DRV] && $INTEL_PWR_HOOKUP_AVOID_DRV == 1 } {
#@     set avoid_drv true
#@   }
#@   # enabled verbose as default since runtime is extremely low (i.e. a second)
#@   set verbose 1
#@ 
#@   set cell_all_segments false
#@   if { [info exists opts(-powerhookup_all_segments) ] } {
#@     if { [info exists opts(-powerhookup_cell_area) ] } {
#@       set cell_all_segments true
#@     } else {
#@       P_msg_warn "$func_name option is ignored because powerhook_cell_area is false"
#@     }
#@   }
#@ 
#@   set rundir [pwd]/powerhookup
#@   set runpath ${rundir}/work
#@   set orig_dir [pwd]
#@   exec mkdir -p $runpath
#@ 
#@   ## remove old def file(s) if they exist
#@   foreach def_file [glob -nocomplain ${rundir}/${block}_powerhookup*.def] {
#@     exec rm $def_file
#@   }
#@ 
#@   #source $::env(CDS_ISS_OVRRD)/flexfill/templates/dtDfmFillMetalICV.tcl
#@   set path "/tmp/$::env(USER)_${block}_[pid]"
#@   set ::env(WORK_AREA_ROOT_DIR) $path
#@   set ::env(PDSWORKROOT) $path
#@   if { [file exists $path] } {
#@     exec rm -rf $path
#@   }
#@   if { [file exists /tmp/$::env(USER)_${block}_[pid]] == 0 } {
#@     exec mkdir -p /tmp/$::env(USER)_${block}_[pid]
#@     if {[info exists INTEL_UNIX_PROTECT_GROUP] && $INTEL_UNIX_PROTECT_GROUP ne "" } {
#@       exec chgrp $INTEL_UNIX_PROTECT_GROUP -R $path
#@       exec chmod 750 -R $path
#@     } else {
#@       exec chmod 700 -R $path
#@     }
#@   }
#@ 
#@   if { [file exists ${path}/pds/uins] == 0 } {
#@     exec mkdir -p   /tmp/$::env(USER)_${block}_[pid]/pds/uins
#@   }
#@ 
#@   set runset_path $INTEL_DFM_RELEASE_DIR
#@   set flexfill_tcl "${runset_path}/flexfill/templates/dtDfmFillMetalICV.tcl"
#@   if { [info exists INTEL_FILL_ICVRUNSET] && $INTEL_FILL_ICVRUNSET ne "" } {
#@     set runset_path $INTEL_FILL_ICVRUNSET
#@     if { [file exists ${runset_path}/flexfill/templates/dtDfmFillMetalICV.tcl] } {
#@       set flexfill_tcl "${runset_path}/flexfill/templates/dtDfmFillMetalICV.tcl"
#@     }
#@   }
#@ 
#@   # ensure that flexfill setup is loaded in the global namespace
#@   set ::_tmp_flexfill_tcl $flexfill_tcl
#@   namespace eval :: {
#@     redirect /dev/null {source $::_tmp_flexfill_tcl}
#@   }
#@   unset ::_tmp_flexfill_tcl
#@ 
#@   # exit if flexfill tcl is not loaded
#@   if { [info proc ::dtDfm::powerhookup] eq "" } {
#@     return -1
#@   }
#@ 
#@   P_msg_info "Start stdcell power hookup"
#@ 
#@   # check to see if run on MW is enabled
#@   set run_on_mw_cel 0
#@   if { [info exists INTEL_PWR_HOOKUP_RUN_ON_MW_CEL] && [string is true -strict $INTEL_PWR_HOOKUP_RUN_ON_MW_CEL] } {
#@     set run_on_mw_cel 1
#@   }
#@ 
#@   # get original hookup vias & shapes
#@   set via_hookup_layers {}
#@   set shape_hookup_layers {}
#@   set pwrhookup_layers ""
#@   if { [info exists INTEL_PWR_HOOKUP_LAYERS] && $INTEL_PWR_HOOKUP_LAYERS ne "" } {
#@     set pwrhookup_layers [get_attribute -quiet [get_layers -quiet $INTEL_PWR_HOOKUP_LAYERS] name]
#@     set via_hookup_layers [get_attribute -quiet [get_layers -quiet $pwrhookup_layers -filter layer_type==via] name]
#@     set shape_hookup_layers [lminus $pwrhookup_layers $via_hookup_layers]
#@     # treat polycont special - can be either via or net_shape
#@     set polycont [get_attribute -quiet [get_layers -filter mask_name==polyCont] name]
#@     if { ($polycont ne "") && [lsearch -exact $via_hookup_layers $polycont] != -1 } {
#@       lappend shape_hookup_layers $polycont
#@     }
#@     unset -nocomplain polycont
#@   }
#@   set via_filter "[join [regsub -all {\S+} [join $via_hookup_layers] {via_layer==&}] { || }]"
#@   set shape_filter "[join [regsub -all {\S+} [join $shape_hookup_layers] {layer==&}] { || }]"
#@   if { $via_filter ne "" } {
#@     set orig_pwr_hookup_via [get_vias -filter $via_filter -quiet]
#@   } else {
#@     set orig_pwr_hookup_via [get_vias -quiet]
#@   }
#@   if { $shape_filter ne "" } {
#@     set orig_pwr_hookup_shapes [get_net_shapes -filter $shape_filter -quiet]
#@   } else {
#@     set orig_pwr_hookup_shapes [get_net_shapes -quiet]
#@   }
#@ 
#@   set prc [regsub {p} [regsub {\.[0-9]} $process {}] {}]
#@   set mwmap $INTEL_GDS_OUT_LAYER_MAP
#@   # when building the run, disable icv runset caching
#@   if { [info exists opts(-allowed_via_master_overrides)] } {
#@     # skip processing - don't need to initialize icv
#@   } elseif { $run_on_mw_cel } {
#@ 
#@     # create a symbolic link to the mw_lib
#@     set stream_file "${runpath}/${block}.mw_lib"
#@     file delete -force $stream_file
#@     file link -symbolic $stream_file [file normalize [get_attribute [current_mw_lib] path]]
#@ 
#@     # to use the current mwdb the CEL must be saved
#@     save_mw_cel
#@     set icv_options "-norscache -lf $mwmap -dp4"
#@     ::dtDfm::fill_metal_icv_init -cellname $block -viewname CEL -techname $process -layer_map_for_mw $mwmap -save_workdir -stream $stream_file -icv_options $icv_options
#@ 
#@   } else {
#@     ::dtDfm::fill_metal_icv_init -cellname $block -techname $process -layer_map_for_mw $mwmap -save_workdir -icv_options -norscache
#@   }
#@ 
#@   # get power_name and ground_name plus information on voltage_areas
#@   array set va_points {}
#@   if { [info exists opts(-vcc_name)] && $opts(-vcc_name) ne "" } {
#@     set power_name $opts(-vcc_name)
#@   } elseif { [info exists INTEL_MW_POWER_NET] && $INTEL_MW_POWER_NET ne "" } {
#@     set power_name $INTEL_MW_POWER_NET
#@   } else {
#@     set power_name vcc
#@   }
#@   if { [info exists opts(-vss_name)] && $opts(-vss_name) ne "" } {
#@     set ground_name $opts(-vss_name)
#@   } elseif { [info exists INTEL_MW_GROUND_NET] && $INTEL_MW_GROUND_NET ne "" } {
#@     set ground_name $INTEL_MW_GROUND_NET
#@   } else {
#@     set ground_name vss
#@   }
#@   if { [info proc ::apr_query_voltage_pgnet] ne "" } {
#@     if { [info exists INTEL_MW_POWER_NET]  && ($INTEL_MW_POWER_NET ne "") && [info exists INTEL_MW_GROUND_NET] && ($INTEL_MW_GROUND_NET ne "") } {
#@       set power_name  $INTEL_MW_POWER_NET
#@       set ground_name $INTEL_MW_GROUND_NET
#@       apr_query_voltage_pgnet $power_name $ground_name
#@ 
#@       # voltage_areas INTEL_VA_GROUND / INTEL_VA_POWER are arrays giving net per VA
#@       # get area per voltage_area and then pair them together
#@       if { [info proc ::apr_get_va_points] ne "" } {
#@         array set va_points [apr_get_va_points]
#@       }
#@     }
#@   }
#@ 
#@   # if known, define areas for power by voltage_area
#@   array set pwr_va_area {}
#@   foreach va_name [array names INTEL_VA_POWER] {
#@     set net_name $INTEL_VA_POWER($va_name)
#@     if { [info exists opts(-vcc_name)] && [lsearch -exact $opts(-vcc_name) $net_name] eq -1 } {
#@       # this power net was not specified for hookup
#@       continue
#@     }
#@     if { [info exists va_points($va_name)] && [llength $va_points($va_name)] ne 0 } {
#@       if { [info exists pwr_va_area($net_name)] } {
#@         set pwr_va_area($net_name) [compute_polygons -boolean or $va_points($va_name) $pwr_va_area($net_name)]
#@       } else {
#@         set pwr_va_area($net_name) $va_points($va_name)
#@       }
#@     }
#@   }
#@   if { [llength [array names INTEL_VA_POWER]] == 0 } {
#@     # rdt setup found with voltage_area info, but missing the power net
#@     # set an empty area so the flow will not add a bad power name
#@     set pwr_va_area($power_name) {}
#@   }
#@ 
#@   # if known, define areas for ground by voltage_area
#@   array set gnd_va_area {}
#@   foreach va_name [array names INTEL_VA_GROUND] {
#@     set net_name $INTEL_VA_GROUND($va_name)
#@     if { [info exists opts(-vss_name)] && [lsearch -exact $opts(-vss_name) $net_name] eq -1 } {
#@       # this ground net was not specified for hookup
#@       continue
#@     }
#@     if { [info exists va_points($va_name)] && [llength $va_points($va_name)] ne 0 } {
#@       if { [info exists gnd_va_area($net_name)] } {
#@         set gnd_va_area($net_name) [compute_polygons -boolean or $va_points($va_name) $gnd_va_area($net_name)]
#@       } else {
#@         set gnd_va_area($net_name) $va_points($va_name)
#@       }
#@     }
#@   }
#@   if { [llength [array names INTEL_VA_GROUND]] == 0 } {
#@     # rdt setup found with voltage_area info, but missing the ground net
#@     # set an empty area so the flow will not add a bad power name
#@     set gnd_va_area($ground_name) {}
#@   }
#@ 
#@   # find first ground rail
#@   set dsn_bbox [join [join [get_attribute [current_mw_cel] bbox]]]
#@   set tile_h ""
#@   if { [info exists INTEL_STDCELL_TILE_HEIGHT] } {
#@     set tile_h $INTEL_STDCELL_TILE_HEIGHT
#@   }
#@   if { [info exists INTEL_STDCELL_TILE] && $INTEL_STDCELL_TILE ne "" } {
#@     set site_rows [sort_collection [get_site_rows -quiet -filter "site_type==$INTEL_STDCELL_TILE"] bbox_lly]
#@     if { [sizeof_collection $site_rows] > 0 } {
#@       set first_site_row [index_collection $site_rows 0]
#@       set first_site_bbox [join [join [get_attribute -quiet $first_site_row bbox]]]
#@       if { [string match "*N" [get_attribute -quiet $first_site_row orientation]] } {
#@         set y_gnd [lindex $first_site_bbox 1]
#@       } else {
#@         set y_gnd [lindex $first_site_bbox 3]
#@       }
#@       set tile_h [expr [lindex $first_site_bbox 3] - [lindex $first_site_bbox 1]]
#@     }
#@   }
#@   if { ! [info exists y_gnd] } {
#@     set y_gnd [lindex $dsn_bbox 1]
#@     if { ([info exists INTEL_FLIP_FIRST_ROW] && $INTEL_FLIP_FIRST_ROW != 0) && ($tile_h ne "") } {
#@       set y_gnd [expr $y_gnd + $tile_h]
#@     }
#@   }
#@   # if y_gnd is along the boundary, then must shift up
#@   if { ($y_gnd eq [lindex $dsn_bbox 1]) && ($tile_h ne "") } {
#@     # shift to move gnd from the boundary
#@     set y_gnd [expr $y_gnd + (2.0 * $tile_h)]
#@   }
#@ 
#@ 
#@   # find info on tiles - this is used for offset core_area
#@   #   and mixed digital & xn
#@   set site_widths [lsort -unique [get_attribute -quiet [get_site_rows]  site_space]]
#@   foreach width $site_widths {
#@     set sites [get_site_rows -filter site_space==$width]
#@     set int_width [expr int([expr $width * 1000])]
#@     set core_area($int_width) [adv_polygon_logic or {} [join [get_attribute -quiet $sites bbox]]]
#@   }
#@ 
#@   # temporarily remove CDS_ISS_OVRRD & PDS_ISS_OVRRD - restore at end of run
#@   if {[info exists ::env(CDS_ISS_OVRRD)]} {
#@     set CDS_ISS_OVRRD_backup $::env(CDS_ISS_OVRRD)
#@   }
#@   if {[info exists ::env(PDS_ISS_OVRRD)]} {
#@     set PDS_ISS_OVRRD_backup $::env(PDS_ISS_OVRRD)
#@     unset -nocomplain ::env(PDS_ISS_OVRRD)
#@   }
#@ 
#@ 
#@   set host $::env(USER)
#@   set pid [pid]
#@   set ::env(CDS_ISS_OVRRD) $runset_path
#@ 
#@   # find the allowed via_master overrides
#@   # these show up as -*_master options to ::dtDfm::powerhookup proc
#@   set allowed_via_master_overrides {}
#@   redirect -variable powerhookup_proc_opts {::dtDfm::powerhookup -help}
#@   # map bad characters from the returned options
#@   set powerhookup_proc_opts [string map {\" ' < \{ > \} } [split $powerhookup_proc_opts "\n"]]
#@   # parse proc help using cist - parseOptions style return
#@   set powerhookup_proc_via_master_opts [lsearch -all -inline -regexp $powerhookup_proc_opts {^\s*-\S+_master\s+.*}]
#@   if { [llength $powerhookup_proc_via_master_opts] == 0 } {
#@     # else parse proc help using ::parseOpt::parseOpts style return
#@     set powerhookup_proc_via_master_opts [lsearch -all -inline -regexp $powerhookup_proc_opts {^\s*[01]\s+\S+_master\s+.*}]
#@   }
#@   if { $prc > 1273 } {
#@     foreach possible_opt_string $powerhookup_proc_via_master_opts {
#@       set via_master_option [regsub {^\s*([01]\s+|\-)?(\S+)_master\s+.*} $possible_opt_string {\2}]
#@       if { $via_master_option ne "" } {
#@         lappend allowed_via_master_overrides $via_master_option
#@       }
#@     }
#@   }
#@ 
#@   set def_file ${rundir}/${block}_powerhookup
#@ 
#@   # check if only returning allowed_via_master_overrides
#@   if { [info exists opts(-allowed_via_master_overrides)] } {
#@     P_msg_info "Power hookup allowed_via_master_overrides: $allowed_via_master_overrides"
#@     return 0
#@   }
#@ 
#@ 
#@   # process override via_masters
#@   array set override_via_masters {}
#@   array set legacy_via_settings {}
#@   if { $prc > 1273 } {
#@     set proc_via_master_overrides {}
#@     if { [info exists opts(-via_master_overrides)] } {
#@       array set override_via_masters $opts(-via_master_overrides)
#@       set proc_via_master_overrides [array names override_via_masters]
#@     }
#@     # check for INTEL_PWR_HOOKUP_VIA_MASTER settings
#@     foreach via_key [array names INTEL_PWR_HOOKUP_VIA_MASTER] {
#@       set via_arg [join [split [regsub -all {[^A-Za-z0-9]+} $via_key { }]]]
#@       set is_xn [expr [lsearch -exact [string tolower $via_arg] "xn"] != -1]
#@       if { [info exists INTEL_XN_LIBRARY] && [string is true -strict $INTEL_XN_LIBRARY] } {
#@         if { ! $is_xn } {
#@           continue
#@         }
#@         set via_arg [lminus $via_arg "xn"]
#@       } else {
#@         if { $is_xn } {
#@           continue
#@         }
#@       }
#@       # only use the global settings if not set locally
#@       if { [lsearch -exact $proc_via_master_overrides] != -1 } {
#@         continue
#@       }
#@       set override_via_masters($via_arg) $INTEL_PWR_HOOKUP_VIA_MASTER($via_key)
#@     }
#@     # print warning if any override is not in allowed_via_master_overrides
#@     foreach via_master_opt [array names override_via_masters] {
#@       if { [lsearch -exact $allowed_via_master_overrides $via_master_opt] ne -1 } {
#@         # the master_via override is allowed
#@         continue
#@       }
#@       # the override is not allowed - print warning msg
#@       if { [lsearch -exact $proc_via_master_overrides $via_master_opt] eq -1 } {
#@         P_msg_warn "$func_name ignoring via_master override '$via_master_opt' setting from INTEL_PWR_HOOKUP_VIA_MASTER"
#@       } else {
#@         P_msg_warn "$func_name ignoring via_master override '$via_master_opt' setting from -via_master_overrides option"
#@       }
#@       unset -nocomplain override_via_masters($via_master_opt)
#@     }
#@   } else {
#@ 
#@     # for p1271/p1273, via definitions come from:
#@     #    INTEL_PWR_HOOKUP_VIA_GND_MASTER
#@     #    INTEL_PWR_HOOKUP_VIA_PWR_MASTER
#@     #    INTEL_PWR_HOOKUP_VIA_SH_PWR_MASTER
#@     array set legacy_via_settings [::pwr::get_pwr_hookup_via_settings]
#@ 
#@   }
#@ 
#@   set h_macro [get_flat_cells -all -filter is_hard_macro==true]
#@   set h_macro_refs [lsort -unique [get_attribute -quiet $h_macro ref_name]]
#@   if { [info exists INTEL_PWR_HOOKUP_ADDL_REFS] && $INTEL_PWR_HOOKUP_ADDL_REFS != "" } {
#@     set h_macro_refs [lminus $h_macro_refs $INTEL_PWR_HOOKUP_ADDL_REFS]
#@   }
#@   set exclude_macros [regsub -all {(\S+)} $h_macro_refs {!\1}]
#@ 
#@ 
#@   # set up power hookup options
#@   set powerhookup_opts "-powerhookup_grid_count $grid_count -powerhookup_cells_area $cell_area_insertion -powerhookup_all_segments $cell_all_segments -write_def_file_prefix $def_file -power_name $power_name -ground_name $ground_name -ground_rail_y_start $y_gnd -powerhookup_avoid_drv $avoid_drv -power_voltage_areas pwr_va_area -ground_voltage_areas gnd_va_area"
#@   if { $exclude_macros ne "" } {
#@     set exclude_macros "* $exclude_macros"
#@     append  powerhookup_opts " -keepin_cells_list {$exclude_macros}"
#@   }
#@   if { $prc <= 1273 } {
#@     set hookup_flow "powerhookup72"
#@     append powerhookup_opts " -dsn_core_areas core_area"
#@     if { [info exists INTEL_PWR_HOOKUP_DH_BONUS_CELLS_LIST]  && $INTEL_PWR_HOOKUP_DH_BONUS_CELLS_LIST ne "" } {
#@       append powerhookup_opts " -dh_bonus_cells_list {$INTEL_PWR_HOOKUP_DH_BONUS_CELLS_LIST}"
#@     }
#@     if { [info exists INTEL_PWR_HOOKUP_FORCE_HOOKUP_CELLS_LIST] && $INTEL_PWR_HOOKUP_FORCE_HOOKUP_CELLS_LIST ne "" } {
#@       append powerhookup_opts " -force_hookup_cells_list {$INTEL_PWR_HOOKUP_FORCE_HOOKUP_CELLS_LIST}"
#@     }
#@     if { [info exists INTEL_PWR_HOOKUP_CELLS_LIST] && $INTEL_PWR_HOOKUP_CELLS_LIST ne "" } {
#@       append powerhookup_opts " -hookup_cell_names_list {$INTEL_PWR_HOOKUP_CELLS_LIST}"
#@     }
#@     if { [info exists INTEL_PWR_HOOKUP_CELLS_LIST_XN] && $INTEL_PWR_HOOKUP_CELLS_LIST_XN ne "" } {
#@       append powerhookup_opts " -hookup_cell_names_list_xn {$INTEL_PWR_HOOKUP_CELLS_LIST_XN}"
#@     }
#@     if { [llength [array names legacy_via_settings]] > 0 } {
#@       append powerhookup_opts " -hookup_via_settings legacy_via_settings"
#@     }
#@   } else {
#@     set hookup_flow "powerhookup"
#@     # add any via_master overrides
#@     foreach via_master_opt [array names override_via_masters] {
#@       append powerhookup_opts " -${via_master_opt}_master $override_via_masters($via_master_opt)"
#@     }
#@   }
#@ 
#@   # check if insertion is for xn library
#@   if { [info exists INTEL_XN_LIBRARY] && $INTEL_XN_LIBRARY == "1" } {
#@     append powerhookup_opts " -use_xll_grid true"
#@   }
#@ 
#@   # check if -powerhookup_empty_area is an allowed option
#@   if { [lsearch -regexp $powerhookup_proc_opts {\s*-powerhookup_empty_area\s+.*}] ne -1 } {
#@     append powerhookup_opts " -powerhookup_empty_area $empty_area_insertion"
#@   } else {
#@     P_msg_warn "$func_name powerhookup_empty_area option is ignored since it is not valid for this process"
#@   }
#@   # run powerhookup
#@   eval ::dtDfm::powerhookup $powerhookup_opts
#@ 
#@   ::dtDfm::fill_metal_icv_end
#@ 
#@   # restore earlier CDS_ISS_OVRRD & PDS_ISS_OVRRD settings
#@   if {[info exists CDS_ISS_OVRRD_backup]} {
#@     set ::env(CDS_ISS_OVRRD) $CDS_ISS_OVRRD_backup
#@   } else {
#@     unset -nocomplain ::env(CDS_ISS_OVRRD)
#@   }
#@   if {[info exists PDS_ISS_OVRRD_backup]} {
#@     set ::env(PDS_ISS_OVRRD) $PDS_ISS_OVRRD_backup
#@   }
#@ 
#@   # in case the runset failed, make sure the working directory is not changed
#@   cd $orig_dir
#@ 
#@   if { [file exists ${path}/${host}.${block}.${pid}.iss/${host}.${block}.${hookup_flow}.iss] } {
#@     if { [file exists $rundir/${block}.${hookup_flow}.iss] } {
#@       exec rm -rf $rundir/${block}.${hookup_flow}.iss
#@     }
#@     # make sure local copy works, if so, then delete the orignal run area
#@     if {  [catch {exec cp -r  ${path}/${host}.${block}.${pid}.iss/${host}.${block}.${hookup_flow}.iss $rundir/${block}.${hookup_flow}.iss} errMsg] } {
#@       puts "$errMsg"
#@     } else {
#@       exec rm -rf ${path}
#@     }
#@   }
#@ 
#@   if { $prc <= 1273 } {
#@     set def_files [glob -nocomplain ${rundir}/${block}_powerhookup.def]
#@   } else {
#@     set def_files [glob -nocomplain ${rundir}/${block}_powerhookup*.def]
#@   }
#@ 
#@   if { [llength $def_files] eq 0 } {
#@     P_msg_warn "$func_name No Power hookup def files generated"
#@     return -1
#@   }
#@ 
#@   # cycle through to read the def files
#@   set saw_good_def 0
#@   set vias_last_pass $orig_pwr_hookup_via
#@   foreach def $def_files {
#@ 
#@     if { [file size $def] eq 0 } {
#@       P_msg_warn "$func_name Power hookup def file $def is empty"
#@       continue
#@     }
#@     set saw_good_def 1
#@ 
#@     P_msg_info "Loading power hookup def file  $def"
#@     read_def $def -allow_physical -verbose
#@ 
#@     set def_update [regsub "^${rundir}/${block}_powerhookup_(\[^ \]*)\.def$" $def {\1}]
#@     if { ($def_update ne $def) && ([namespace which -command apr_set_via_type] ne "") } {
#@       # find added via
#@       if { $via_filter ne "" } {
#@         set all_vias [get_vias -filter $via_filter -quiet]
#@       } else {
#@         set all_vias [get_vias -quiet]
#@       }
#@       set def_added_via [remove_from_collection $all_vias $vias_last_pass]
#@       set vias_last_pass $all_vias
#@ 
#@       apr_set_via_type -layer_name $def_update -type 1 $def_added_via
#@     }
#@ 
#@   }
#@ 
#@   # find added via
#@   if { $via_filter ne "" } {
#@     set added_via [get_vias -filter $via_filter -quiet]
#@   } else {
#@     set added_via [get_vias -quiet]
#@   }
#@   set added_via [remove_from_collection $added_via $orig_pwr_hookup_via]
#@   set cnt_vias [sizeof_collection $added_via]
#@ 
#@   # find added shapes
#@   if { $shape_filter ne "" } {
#@     set added_shapes [get_net_shapes -filter $shape_filter -quiet]
#@   } else {
#@     set added_shapes [get_net_shapes -quiet]
#@   }
#@   set added_shapes [remove_from_collection $added_shapes $orig_pwr_hookup_shapes]
#@   set cnt_shapes [sizeof_collection $added_shapes]
#@ 
#@   # add hookup attributes on pwrhookup via
#@   set added_via_layers {}
#@   if { $cnt_vias > 0 } {
#@     # change attributes on the added via
#@     define_user_attribute -type boolean -class via stdcell_pg_hookup -quiet
#@     set_attribute $added_via stdcell_pg_hookup true -quiet
#@     if { $prc > 1273 } {
#@       set_attribute $added_via route_type "P/G Strap" -quiet
#@     }
#@     # if verbose, count vias by layer & owner_net
#@     if { $verbose } {
#@       set added_nets [lsort -unique [get_attribute -quiet $added_via owner_net]]
#@       set added_via_layers [lsort -unique [get_attribute -quiet $added_via via_layer]]
#@       foreach net $added_nets {
#@         foreach via_layer $added_via_layers {
#@           set pwr_vias(${net}-${via_layer}) [sizeof_collection [filter_collection $added_via "owner_net==$net && via_layer==$via_layer"]]
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # add hookup attributes on pwrhookup shapes
#@   set polycont ""
#@   if { $cnt_shapes > 0 } {
#@     # change attributes on the added shapes
#@     define_user_attribute -type boolean -class shape stdcell_pg_hookup -quiet
#@     set_attribute $added_shapes stdcell_pg_hookup true -quiet
#@     if { $prc > 1273 } {
#@       set_attribute $added_shapes route_type "P/G Strap" -quiet
#@     }
#@     # if verbose, count shapes by layer & owner_net
#@     if { $verbose } {
#@       set added_nets [lsort -unique [get_attribute -quiet $added_shapes owner_net]]
#@       set added_shape_layers [lsort -unique [get_attribute -quiet $added_shapes layer]]
#@       set polycont [get_attribute -quiet [get_layers -filter mask_name==polyCont $added_shape_layers] name]
#@       foreach net $added_nets {
#@         foreach layer $added_shape_layers {
#@           if { $layer eq $polycont } {
#@             # if polyCont shapes added, then add to pwr_vias
#@             set pwr_vias(${net}-${layer}) [sizeof_collection [filter_collection $added_shapes "owner_net==$net && layer==$layer"]]
#@           } else {
#@             set pwr_shapes(${net}-${layer}) [sizeof_collection [filter_collection $added_shapes "owner_net==$net && layer==$layer"]]
#@           }
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # get the list of all via_layers, shape_layers and net_names
#@   set all_via_layers   {}
#@   set all_shape_layers {}
#@   set all_net_names    {}
#@   foreach item [array names pwr_vias] {
#@     lappend all_net_names  [lindex [split $item {-}] 0]
#@     lappend all_via_layers [lindex [split $item {-}] 1]
#@   }
#@   foreach item [array names pwr_shapes] {
#@     lappend all_net_names    [lindex [split $item {-}] 0]
#@     lappend all_shape_layers [lindex [split $item {-}] 1]
#@   }
#@   set all_via_layers   [lsort -unique $all_via_layers]
#@   set all_shape_layers [lsort -unique $all_shape_layers]
#@   set all_net_names    [lsort -unique $all_net_names]
#@ 
#@   # compute the via count per net
#@   foreach net $all_net_names {
#@     set via_cnt_per_net($net) 0
#@     foreach index [lsearch -all -inline -regexp [array names pwr_vias] "${net}-.*"] {
#@       incr via_cnt_per_net($net) $pwr_vias($index)
#@     }
#@   }
#@ 
#@   # build summary of via stack and shapes added
#@   # first figure out the layers
#@   set hookup_layers  [concat $all_via_layers $all_shape_layers]
#@   if { [info exists INTEL_PWR_HOOKUP_LAYERS] && $INTEL_PWR_HOOKUP_LAYERS ne "" } {
#@     set hookup_layers  $INTEL_PWR_HOOKUP_LAYERS
#@   }
#@   set polycont [get_attribute -quiet [get_layers -filter mask_name==polyCont $hookup_layers] name]
#@   set stack $polycont
#@   for { set i 1 } { $i < 15 } { incr i } {
#@     set next_metal_layer [get_attribute -quiet [get_layers -filter mask_name==metal$i $hookup_layers] name]
#@     lappend stack $next_metal_layer
#@     set next_via_layer [get_attribute -quiet [get_layers -filter mask_name==via$i $hookup_layers] name]
#@     lappend stack $next_via_layer
#@   }
#@   set stack [join $stack]
#@   set missing_from_stack [lsort -unique [lminus $hookup_layers $stack]]
#@   # add to missing layers to start of the stack (in alphabetical order)
#@   set stack [join [concat $missing_from_stack $stack]]
#@ 
#@   # create stats on shapes added for the layer
#@   set cnt_vias 0
#@   set cnt_shapes 0
#@   foreach net $all_net_names {
#@     set stack_stats($net) ""
#@     set v_cnt 0
#@     set s_cnt 0
#@     foreach layer $stack {
#@       set add_cnt 0
#@       if { [info exists pwr_vias(${net}-${layer})] } {
#@         incr add_cnt $pwr_vias(${net}-${layer})
#@       }
#@       if { [info exists pwr_shapes(${net}-${layer})] } {
#@         incr add_cnt $pwr_shapes(${net}-${layer})
#@       }
#@       if { $stack_stats($net) ne "" } {
#@         append stack_stats($net) ", "
#@       }
#@       append stack_stats($net) "$add_cnt $layer"
#@       if { [lsearch -exact $all_via_layers $layer] != -1 } {
#@         append stack_stats($net) " vias"
#@         incr v_cnt $add_cnt
#@       } else {
#@         append stack_stats($net) " shapes"
#@         incr s_cnt $add_cnt
#@       }
#@     }
#@     if { $stack_stats($net) ne "" } {
#@       set stack_stats($net) "Added $v_cnt Vias / $s_cnt Shapes ($stack_stats($net))"
#@       incr cnt_vias $v_cnt
#@       incr cnt_shapes $s_cnt
#@     } else {
#@       set stack_stats($net) "Added 0 Vias / 0 Shapes"
#@     }
#@   }
#@ 
#@   # format and print a summary per net if verbose
#@   if { $verbose } {
#@     P_msg_info ""
#@     foreach net [lsort -unique [array names stack_stats]] {
#@       P_msg_info " Stdcell Power Hookup SUMMARY <$net>  - $stack_stats($net)"
#@     }
#@     P_msg_info ""
#@   }
#@ 
#@ 
#@   set complete_msg "Completed stdcell power hookup at [clock format [clock seconds]]. Added $cnt_vias total powerhookup vias"
#@   if { $cnt_shapes > 0 } {
#@     append complete_msg " and $cnt_shapes powerhookup net_shapes"
#@   }
#@   set clock_elapsed [rdt_convert_seconds [expr [clock seconds] - $start_time]]
#@   append complete_msg " in $clock_elapsed"
#@   P_msg_info ""
#@   P_msg_info $complete_msg
#@   P_msg_info ""
#@ 
#@   return [expr $cnt_vias + $cnt_shapes]
#@ }
#@ 
#@ 
#@ #----------------------------------------------------------------------
#@ define_proc_attributes ::pwr::create_stdcell_powerhookup     -info "Create power hookup for the current design"     -define_args {
#@       {-powerhookup_grid_count "Grid pitch count. Default is 2" grid_count int optional }
#@       {-powerhookup_empty_area "Insert powerhookup via at non-cell area. Default is false" "" boolean optional }
#@       {-powerhookup_cells_area "Insert powerhookup via at cell area. Default is false" "" boolean optional }
#@       {-powerhookup_all_segments "Insert powerhookup via at continuous m0 segments. Default is false" "" boolean optional }
#@       {-powerhookup_avoid_drv "Inserted powerhookup to avoid creating drv. Default is false" "" boolean optional }
#@       {-via_master_overrides "process/library overrides for via_master in array get form" via_master_info string optional}
#@       {-allowed_via_master_overrides "dump out allowed via_master_overrides and return" "" boolean optional}
#@       {-vcc_name  "Do power hookup of the specified vcc net" vcc_net string optional}
#@       {-vss_name  "Do ground hookup of the specified vss net" vss_net string optional}
#@     }
#@ 
#@ 
#@ 
#@ ##########################################################################
#@ # Procedure   : pwr::remove_stdcell_powerhookup
#@ #
#@ # Description : remove_vias vias for stdcell powerhookup connection
#@ # Inputs      :
#@ #
#@ # Returns     :
#@ ##########################################################################
#@ proc ::pwr::remove_stdcell_powerhookup { args } {
#@   parse_proc_arguments -args $args opts
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@ 
#@   # Adjust this variable to avoid hangs during cleanup
#@   set orig_collection_deletion_effort $::collection_deletion_effort
#@   set ::collection_deletion_effort low
#@ 
#@   set start_time [clock seconds]
#@ 
#@   # ensure powerhookup attributes exist
#@   define_user_attribute -type boolean -class via stdcell_pg_hookup -quiet
#@   define_user_attribute -type boolean -class shape stdcell_pg_hookup -quiet
#@ 
#@   # set up filtering by attribute and net_names (if given)
#@   if { [info exists opts(-net_names)] } {
#@     set net_filter "([join [regsub -all {\S+} [join $opts(-net_names)] {owner_net=~&}] { || }])"
#@     set via_net_filter "stdcell_pg_hookup==true && $net_filter"
#@     set shape_net_filter "stdcell_pg_hookup==true && $net_filter"
#@   } else {
#@     set via_net_filter "stdcell_pg_hookup==true"
#@     set shape_net_filter "stdcell_pg_hookup==true"
#@   }
#@ 
#@   # enabled verbose as default since runtime is extremely low (i.e. few second)
#@   set verbose 1
#@ 
#@   # initialize collections of objects to remove
#@   set pwr_hookup_vias {}
#@   set pwr_hookup_shapes {}
#@ 
#@   # find objects to remove
#@   if { [info exists opts(-within)] && [adv_polygon_check polygon $opts(-within)] } {
#@     # if area specified, then cycle through individual polygons
#@     foreach polygon [adv_polygon_logic or {} $opts(-within)] {
#@       append_to_collection -unique pwr_hookup_vias [get_vias -quiet -within $polygon -filter $via_net_filter]
#@       append_to_collection -unique pwr_hookup_vias [get_vias -quiet -intersect $polygon -filter $via_net_filter]
#@       append_to_collection -unique pwr_hookup_shapes [get_net_shapes -quiet -within $polygon -filter $via_net_filter]
#@       append_to_collection -unique pwr_hookup_shapes [get_net_shapes -quiet -intersect $polygon -filter $via_net_filter]
#@     }
#@   } else {
#@     if { [info exists opts(-within)] } {
#@       # an area was specified but was not a valid shape - print msg & ignore
#@       P_msg_warn "$func_name ignoring invalid shape for -within option"
#@     }
#@     set pwr_hookup_vias [get_vias -quiet -filter $via_net_filter]
#@     set pwr_hookup_shapes [get_net_shapes -quiet -filter $shape_net_filter]
#@   }
#@ 
#@   set cnt_vias   [sizeof_collection $pwr_hookup_vias]
#@   set cnt_shapes [sizeof_collection $pwr_hookup_shapes]
#@ 
#@   if { $verbose && ($cnt_vias > 0 || $cnt_shapes > 0) } {
#@     # verbose message will give shapes / vias per layer & net
#@     set all_hookup_nets [lsort -unique [concat [get_attribute -quiet $pwr_hookup_vias owner_net] [get_attribute -quiet $pwr_hookup_shapes owner_net]]]
#@     set all_via_layers [lsort -unique [get_attribute -quiet $pwr_hookup_vias via_layer]]
#@     # order the via layers
#@     set all_via_layers [get_attribute -quiet [sort_collection [get_layers -quiet $all_via_layers] mask_name] name]
#@     set all_shape_layers [lsort -unique [get_attribute -quiet $pwr_hookup_shapes layer]]
#@     set all_metal_layers [lsort -unique [get_attribute -quiet [get_layers -quiet -filter {is_routing_layer==true && mask_name=~metal*} $all_shape_layers] name]]
#@     set all_shape_layers [lminus $all_shape_layers $all_metal_layers]
#@     # move via layers to be at the end of the all_shape_layers
#@     set shape_based_via_layers [get_attribute -quiet [get_layers -quiet $all_shape_layers -filter layer_type==via] name]
#@     set all_shape_layers [concat [lminus $all_shape_layers $shape_based_via_layers] $shape_based_via_layers]
#@ 
#@     # loop per net, then per all_metal_shapes, shapes, vias
#@     set metal_filter "([join [regsub -all {\S+} [join $all_metal_layers] {layer==&}] { || }])"
#@     P_msg_info ""
#@     foreach net $all_hookup_nets {
#@       unset -nocomplain num_shape_objects num_via_objects
#@       if { [llength $all_metal_layers] > 0 } {
#@         set num_metal_objs [sizeof_collection [filter_collection $pwr_hookup_shapes "owner_net==$net && $metal_filter"]]
#@       } else {
#@         set num_metal_objs 0
#@       }
#@       set total_net_hookups $num_metal_objs
#@       foreach layer $all_shape_layers {
#@         set num_shape_objects($layer) [sizeof_collection [filter_collection $pwr_hookup_shapes "owner_net==$net && layer==$layer"]]
#@         incr total_net_hookups $num_shape_objects($layer)
#@       }
#@       foreach layer $all_via_layers {
#@         set num_via_objects($layer) [sizeof_collection [filter_collection $pwr_hookup_vias "owner_net==$net && via_layer==$layer"]]
#@         incr total_net_hookups $num_via_objects($layer)
#@       }
#@       if { $total_net_hookups > 0 } {
#@         P_msg_info "Removing $total_net_hookups total power hookup vias/shapes on net $net"
#@         if { [llength $all_metal_layers] > 0 } {
#@           P_msg_info "   deleting $num_metal_objs metals"
#@         }
#@         foreach layer $all_shape_layers {
#@           if { [info exists num_shape_objects($layer)] && $num_shape_objects($layer) > 0 } {
#@             P_msg_info "   deleting $num_shape_objects($layer) $layer objects"
#@           }
#@         }
#@         foreach layer [array names num_via_objects] {
#@           if { $num_via_objects($layer) > 0 } {
#@             P_msg_info "   deleting $num_via_objects($layer) vias in layer $layer"
#@           }
#@         }
#@         P_msg_info ""
#@       }
#@     }
#@   }
#@ 
#@   if { $cnt_vias eq 0 && $cnt_shapes eq 0 } {
#@     P_msg_info "Found no stdcell powerhookup via/shapes to remove"
#@   } else {
#@     if { $cnt_vias > 0 } {
#@       remove_via $pwr_hookup_vias
#@     }
#@     if { $cnt_shapes > 0 } {
#@       remove_net_shape $pwr_hookup_shapes
#@     }
#@   }
#@ 
#@   set complete_msg "Completed stdcell power hookup removal. Removed $cnt_vias powerhookup vias"
#@   if { $cnt_shapes > 0 } {
#@     append complete_msg " and $cnt_shapes powerhookup net_shapes"
#@   }
#@   set clock_elapsed [rdt_convert_seconds [expr [clock seconds] - $start_time]]
#@   append complete_msg " in $clock_elapsed"
#@   P_msg_info " $complete_msg"
#@ 
#@   # Reset the value to original value
#@   set ::collection_deletion_effort $orig_collection_deletion_effort
#@ 
#@   return [expr $cnt_vias + $cnt_shapes]
#@ }
#@ 
#@ 
#@ #----------------------------------------------------------------------
#@ define_proc_attributes ::pwr::remove_stdcell_powerhookup     -info "Remove power hookup for the current design"     -define_args {
#@       {-net_names "Remove the given pwr/gnd connections. Default is '*'" net_name string optional}
#@       {-within "Remove only within or intersecting the area. Default is entire design" polygon string optional}
#@     }
#@ 
#@ 
#@ 
#@ ##########################################################################
#@ # Procedure   : pwr::get_pwr_hookup_via_settings
#@ #
#@ # Description : get settings for power hookup vias - master,
#@ #               height/width per layer
#@ # Inputs      :
#@ #
#@ # Returns     :
#@ ##########################################################################
#@ proc ::pwr::get_pwr_hookup_via_settings { args } {
#@   parse_proc_arguments -args $args opts
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   global INTEL_PWR_HOOKUP_LAYERS INTEL_PWR_HOOKUP_VIA_GND_MASTER
#@   global INTEL_PWR_HOOKUP_VIA_PWR_MASTER INTEL_PWR_HOOKUP_VIA_SH_PWR_MASTER
#@ 
#@   set existing_via_masters [get_via_masters]
#@   set existing_master_names [get_attribute -quiet $existing_via_masters name]
#@   if { ([llength $existing_via_masters] > 1) || ([llength $existing_master_names] == 0) } {
#@     # this is an older (pre 2013.03) version of icc returns a list of names
#@     set existing_master_names $existing_via_masters
#@     if { [namespace which -command P_get_techfile_info] ne "" } {
#@       set via_master_info [lsearch -regexp -inline -all [P_get_techfile_info] "^ContactCode .*"]
#@     } else {
#@       # proc to dump/read techfile doesn't exist, don't allow changes
#@       set via_master_info {}
#@     }
#@   } else {
#@     # this is newer (2013.03+) version of icc; returns a collection
#@   }
#@ 
#@   # get min resolution (the round about method for icc)
#@   redirect -variable unit_vars {report_mw_lib -unit_range [current_mw_lib]}
#@   regexp -line {^length.*} $unit_vars length_units
#@   set resolution [expr 1.0 / ([lindex $length_units 2] + 0.0)]
#@   set precision [format "%.0f" [expr abs(log10($resolution))]]
#@ 
#@   # treat polycont special - don't need lower enclosure
#@   set polycont [get_attribute -quiet [get_layers -filter mask_name==polyCont] name]
#@ 
#@   # get hookup layers
#@   if { [info exists INTEL_PWR_HOOKUP_LAYERS] && $INTEL_PWR_HOOKUP_LAYERS ne "" } {
#@     set hookup_layers $INTEL_PWR_HOOKUP_LAYERS
#@   } else {
#@     set hookup_layers [get_attribute -quiet [get_layers -quiet -filter is_routing_layer==true] name]
#@   }
#@ 
#@   # for p1271/p1273, via definitions come from:
#@   #    INTEL_PWR_HOOKUP_VIA_GND_MASTER
#@   #    INTEL_PWR_HOOKUP_VIA_PWR_MASTER
#@   #    INTEL_PWR_HOOKUP_VIA_SH_PWR_MASTER
#@   # Entries will look like:  INTEL_PWR_HOOKUP_VIA_GND_MASTER(via_layer)
#@   # where via_layer can be:  vcn, v0, v1  (defined in INTEL_PWR_HOOKUP_LAYERS)
#@   #
#@   # for each setting, need via master & height/width of all layers in the via
#@   #
#@   #
#@   set definition_pairs {{bndry_gnd INTEL_PWR_HOOKUP_VIA_GND_MASTER}
#@     {bndry_pwr INTEL_PWR_HOOKUP_VIA_PWR_MASTER}
#@     {polyg_pwr INTEL_PWR_HOOKUP_VIA_SH_PWR_MASTER}}
#@   foreach def_set $definition_pairs {
#@     set via_type [lindex $def_set 0]
#@     set hookup_parameter [lindex $def_set 1]
#@ 
#@     unset -nocomplain via_type_masters via_type_w via_type_h
#@     foreach gvar_key [array names $hookup_parameter] {
#@       set via_arg [join [split [regsub -all {[^A-Za-z0-9]+} $gvar_key { }]]]
#@       set is_xn [expr [lsearch -exact [string tolower $via_arg] "xn"] != -1]
#@       if { [info exists INTEL_XN_LIBRARY] && [string is true -strict $INTEL_XN_LIBRARY] } {
#@         if { ! $is_xn } {
#@           continue
#@         }
#@         set v_layer [lminus $via_arg "xn"]
#@       } else {
#@         if { $is_xn } {
#@           continue
#@         }
#@         set v_layer $via_arg
#@       }
#@       set via_lookup ${hookup_parameter}($gvar_key)
#@       if { [info exists $via_lookup] } {
#@         set master [expr $$via_lookup]
#@       } else {
#@         set master ""
#@       }
#@ 
#@       # make sure the via master exists - get parameters
#@       if { [lsearch -exact $existing_master_names $master] == -1 } {
#@         P_msg_warn "Ignoring specified via_master=$master from ${hookup_parameter}($gvar_key) since the via master doesn't exist"
#@         continue
#@       } elseif { [info exists via_master_info] } {
#@         if { [llength $via_master_info] == 0 } {
#@           # older version with no dump of the techfile, ignore changes
#@           P_msg_warn "Ignoring specified via_master=$master from ${hookup_parameter}($gvar_key) since unable to get information no the via - proc P_get_techfile_info not available for dumping the techfile"
#@           continue
#@         }
#@         # this is an older version of icc, parse the techfile info
#@         unset -nocomplain cut_info
#@         set cut_info [lrange [lsearch -inline -regexp $via_master_info "^ContactCode $master .*"] 2 end]
#@         set lo       [lindex [lsearch -regexp -inline $cut_info "^lowerLayer .*"] end]
#@         set lo_enc_h [lindex [lsearch -regexp -inline $cut_info "^lowerLayerEncHeight .*"] end]
#@         set lo_enc_w [lindex [lsearch -regexp -inline $cut_info "^lowerLayerEncWidth .*"] end]
#@         set up       [lindex [lsearch -regexp -inline $cut_info "^upperLayer .*"] end]
#@         set up_enc_h [lindex [lsearch -regexp -inline $cut_info "^upperLayerEncHeight .*"] end]
#@         set up_enc_w [lindex [lsearch -regexp -inline $cut_info "^upperLayerEncWidth .*"] end]
#@         set cut      [lindex [lsearch -regexp -inline $cut_info "^cutLayer .*"] end]
#@         set cut_h    [lindex [lsearch -regexp -inline $cut_info "^cutHeight .*"] end]
#@         set cut_w    [lindex [lsearch -regexp -inline $cut_info "^cutWidth .*"] end]
#@       } else {
#@         set v_master [get_via_masters -quiet $master]
#@         set lo       [get_attribute -quiet $v_master lower_layer]
#@         set lo_enc_h [get_attribute -quiet $v_master lower_layer_enc_height]
#@         set lo_enc_w [get_attribute -quiet $v_master lower_layer_enc_width]
#@         set up       [get_attribute -quiet $v_master upper_layer]
#@         set up_enc_h [get_attribute -quiet $v_master upper_layer_enc_height]
#@         set up_enc_w [get_attribute -quiet $v_master upper_layer_enc_width]
#@         set cut      [get_attribute -quiet $v_master via_layer]
#@         set cut_h    [get_attribute -quiet $v_master via_layer_height]
#@         set cut_w    [get_attribute -quiet $v_master via_layer_width]
#@       }
#@       # make sure the via master uses the expected cut layer
#@       if { $v_layer ne $cut } {
#@         P_msg_warn "Ignoring specified via_master=$master from ${hookup_parameter}($gvar_key) since the cut layer ($cut) for the via master doesn't match"
#@         continue
#@       }
#@       # make sure the via master is a hookup layer
#@       if { [lsearch -exact $hookup_layers $cut] == -1 } {
#@         P_msg_warn "Ignoring specified via_master=$master from ${hookup_parameter}($gvar_key) since the cut layer ($cut) isn't a specified hookup layer from INTEL_PWR_HOOKUP_LAYERS"
#@         continue
#@       }
#@ 
#@       # change metal -> m   and  via -> v
#@       set cut [regsub -nocase {via} $cut {v}]
#@       set lo  [regsub -nocase {metal} $lo {m}]
#@       set up  [regsub -nocase {metal} $up {m}]
#@ 
#@       # default any missing parameters
#@       if { $cut_h eq "" }    { set cut_h 0 }
#@       if { $cut_w eq "" }    { set cut_w 0 }
#@       if { $lo_enc_h eq "" } { set lo_enc_h 0 }
#@       if { $lo_enc_w eq "" } { set lo_enc_w 0 }
#@       if { $up_enc_h eq "" } { set up_enc_h 0 }
#@       if { $up_enc_w eq "" } { set up_enc_w 0 }
#@ 
#@       # set parameters for the layer
#@       set via_type_masters($cut) $master
#@       set via_type_w($cut) $cut_w
#@       set via_type_h($cut) $cut_h
#@       set via_type_h(${cut}.${up}) [format "%.${precision}f" [expr $cut_h + 2 * $up_enc_h]]
#@       set via_type_w(${cut}.${up}) [format "%.${precision}f" [expr $cut_w + 2 * $up_enc_w]]
#@       if { $v_layer eq $polycont } {
#@         # skip lower enclosure
#@         continue
#@       }
#@       set via_type_h(${cut}.${lo}) [format "%.${precision}f" [expr $cut_h + 2 * $lo_enc_h]]
#@       set via_type_w(${cut}.${lo}) [format "%.${precision}f" [expr $cut_w + 2 * $lo_enc_w]]
#@ 
#@     }
#@ 
#@     if { [llength [array names via_type_h]] > 0 } {
#@       set return_value(${via_type}_via_h) [array get via_type_h]
#@     }
#@     if { [llength [array names via_type_w]] > 0 } {
#@       set return_value(${via_type}_via_w) [array get via_type_w]
#@     }
#@     if { [llength [array names via_type_masters]] > 0 } {
#@       set return_value(${via_type}_via_master) [array get via_type_masters]
#@     }
#@ 
#@     unset -nocomplain via_type_masters via_type_w via_type_h
#@   }
#@ 
#@   return [array get return_value]
#@ }
#@ 
#@ #----------------------------------------------------------------------
#@ define_proc_attributes ::pwr::get_pwr_hookup_via_settings     -info "Get settings for power hookup vias - master, height/width per layer"
#@ 
#@ 
#@ 
#@ 
#@ ##########################################################################
#@ ##########################################################################
#@ #
#@ # Reduced section of block_level_stdcell_power_hookup to allow
#@ # for cleanup of hookup vias/shapes without power hookup attributes
#@ #
#@ ##########################################################################
#@ ##########################################################################
#@ 
#@ 
#@ namespace eval ::process:: { }
#@ 
#@ proc ::process::override_design_attributes {args} {
#@   parse_proc_arguments -args $args opts
#@ 
#@   global INTEL_MW_POWER_NET INTEL_MW_GROUND_NET INTEL_VA_GROUND
#@   global INTEL_PROCESS_NAME INTEL_PWR_HOOKUP_GRID_COUNT
#@ 
#@   # Get power net name...
#@   if { [info exists opts(-vcc_name)] } {
#@     set vccgt $opts(-vcc_name)
#@   } elseif { [info proc  ::proj_get_main_power_nets] != "" } {
#@     set vccgt [::proj_get_main_power_nets]
#@   } else {
#@     #HD set vccgt vccgt
#@     set vccgt vcc
#@   }
#@ 
#@   # Get ground net name...
#@   if { [info proc ::apr_query_voltage_pgnet] != "" } {
#@     if { [info exists INTEL_MW_POWER_NET] && ($INTEL_MW_POWER_NET ne "") && [info exists INTEL_MW_GROUND_NET] && ($INTEL_MW_GROUND_NET ne "") } {
#@       apr_query_voltage_pgnet $INTEL_MW_POWER_NET $INTEL_MW_GROUND_NET
#@     }
#@   }
#@   if {[array names INTEL_VA_GROUND] ne ""} {
#@     # INTEL_VA_GROUND is an array with ground net per voltage_area
#@     # expect all voltage_areas to have the same ground net
#@     set vssgt {}
#@     foreach va [array names INTEL_VA_GROUND] {
#@       lappend vssgt $INTEL_VA_GROUND($va)
#@     }
#@     set vssgt [lsort -unique $vssgt]
#@     if { [llength $vssgt] eq 0 } {
#@       unset -nocomplain vssgt
#@     }
#@   }
#@   if { ! [info exists vssgt] } {
#@     if { [info exists INTEL_MW_GROUND_NET] && $INTEL_MW_GROUND_NET ne "" } {
#@       set vssgt $INTEL_MW_GROUND_NET
#@     } else {
#@       set vssgt "vss"
#@     }
#@   }
#@ 
#@   if { [info commands apr_override_design_attributes_for_std_pwrhookup] ne "" } {
#@     apr_override_design_attributes_for_std_pwrhookup -vcc_name $vccgt -vss_name $vssgt
#@ 
#@     set possible_grid_pitch ""
#@     if { [info exists INTEL_PWR_HOOKUP_GRID_COUNT] } {
#@       set possible_grid_pitch $INTEL_PWR_HOOKUP_GRID_COUNT
#@     }
#@     if { [string is integer -strict $possible_grid_pitch] } {
#@       # for script based approach only allow the grid pitch to be at least a minimum of 3 tracks
#@       # smaller values will lead to spacing violations
#@       if { $possible_grid_pitch > 2 } {
#@         set ::process::pwr_hookup_grid_pitch      $possible_grid_pitch
#@         P_msg_info "Stdcell power hookup using override grid pitch of INTEL_PWR_HOOKUP_GRID_COUNT = $possible_grid_pitch."
#@       } else {
#@         P_msg_warn "Stdcell power hookup INTEL_PWR_HOOKUP_GRID_COUNT value of $possible_grid_pitch ignored, using default value of $::process::pwr_hookup_grid_pitch.  Override value must be greater than or equal to 3"
#@       }
#@     }
#@ 
#@   } else {
#@     P_msg_warn "Stdcell power hookup does not support this process $INTEL_PROCESS_NAME in current kit version"
#@   }
#@ 
#@   set ::process::debug_mode   0
#@ 
#@ }
#@ 
#@ define_proc_attributes ::process::override_design_attributes    -info "Override/Set design attributes for Power-Hookup"     -define_args {
#@       {"-vcc_name"     "Do power hookup in the specified vcc domain" "" string optional}
#@     }
#@ 
#@ 
#@ 
#@ ##################################################################################################################
#@ # Removing PowerHookup on entire design takes a lot of memory,  this proc uses a divide and conqure approach by
#@ # splitting a design into multiple smaller bboxes
#@ ##################################################################################################################
#@ proc ::process::remove_stdcell_power_hookup {args} {
#@   # Remove existing power hookup
#@   parse_proc_arguments -args $args opts
#@   set time_start [clock seconds]
#@   set mem_start [mem]
#@ 
#@   puts "-I- Starting stdcell block level power hookup cleanup  at [clock format [clock seconds]]"
#@ 
#@   if { [info exists opts(-bbox)] } {
#@     set bbox $opts(-bbox)
#@   } else {
#@     set bbox [get_attribute [get_core_area] bbox]
#@   }
#@ 
#@   if { [info exists opts(-vcc_name)] } {
#@     redirect /dev/null {
#@       ::process::_init
#@       ::process::override_design_attributes -vcc_name $opts(-vcc_name)
#@       ::process::_init_vars_from_design
#@     }
#@   } else {
#@     redirect /dev/null {
#@       ::process::_init
#@       ::process::override_design_attributes
#@       ::process::_init_vars_from_design
#@     }
#@   }
#@ 
#@   scan [join $bbox] "%f %f %f %f" llx lly urx ury
#@ 
#@   set mlayers [::process::_get_pwr_hookup_metals]
#@   set vlayers [::process::_get_pwr_hookup_vias]
#@   set nets [concat $::process::nets(power) $::process::nets(ground)]
#@ 
#@   if { [info exists opts(-cells)] } {
#@     ::process::clean_up_block_level_power_hookup -metal_layers $mlayers -via_layers $vlayers -nets $nets -cells $opts(-cells)
#@   } else {
#@     if { [info exists opts(-num_splits)] } {
#@       set num_splits $opts(-num_splits)
#@     } else {
#@       set num_splits 4
#@     }
#@ 
#@     set incr_y [expr ( $ury - $lly ) / $num_splits]
#@ 
#@     set split_lly $lly
#@     set split_ury $lly
#@     while { $split_ury <= $ury } {
#@       set split_ury [expr $split_lly + $incr_y]
#@       if { $split_ury >= $ury } {
#@         set split_ury $ury
#@         break
#@       }
#@       set split_bbox "$llx $split_lly $urx $split_ury"
#@       ::process::clean_up_block_level_power_hookup -metal_layers $mlayers -via_layers $vlayers -nets $nets -bbox $split_bbox
#@       set split_lly $split_ury
#@     }
#@ 
#@     # Run at block level once
#@     ::process::clean_up_block_level_power_hookup -metal_layers $mlayers -via_layers $vlayers -nets $nets -bbox $bbox
#@   }
#@   set time_end [clock seconds]
#@   set mem_end [mem]
#@   set time_spent [expr ($time_end - $time_start)/ 60.00]
#@   set mem_spent [expr ($mem_end - $mem_start)/1000.00]
#@   puts "-I- Time taken for stdcell block level power hookup cleanup  at [format {%.2f} $time_spent] mins"
#@   puts "-I- Mem  taken for stdcell block level power hookup cleanup  at [format {%.2f} $mem_spent] MB"
#@ 
#@ }
#@ define_proc_attributes ::process::remove_stdcell_power_hookup     -info "Clean standard cell level power hookup"     -define_args {
#@       {"-bbox"         "Do power hookup cleanup in the specified bbox. Default is the entire design" "" list optional}
#@       {"-cells"        "Do power hookup cleanup for the specified cells. Default is the entire design" "" list optional}
#@       {"-vcc_name"     "Do power hookup in the specified vcc domain" "" string optional}
#@       {"-num_splits"   "Do power hookup cleanup in the specified bbox. Default is the entire design" num_splits string optional}
#@     }
#@ 
#@ #-------------------------------------------
#@ # Internal initializations
#@ #-------------------------------------------
#@ proc ::process::_init {} {
#@   # Methodology initializations
#@   set ::process::polyGridBasedCellBloat      1  ;# When pruning the vias in global poly grid based method, bloat cellBBoxes by this number of poly pitches on each side
#@   set ::process::pointBloat              0.001  ;# When create rectangles for points or lines, bloat by this number (um) on each side
#@   set ::process::drawViaBloat            0.025  ;# When drawing vias in points as rectangles, bloat via points by this number (um) in all dimensions
#@   set ::process::drawSingleViaLayer   "marker"  ;# The layer for drawing single vias (vias that are not one-poly-track adjacent to any other vias). Used in preview mode.
#@   set ::process::drawOneTrackViaLayer    "gcn"  ;# The layer for drawing one-track vias (vias that are one-poly-track adjacent to another via). Used in preview mode.
#@ 
#@   set ::process::createViasThruDef           1  ;# Write out vias through def file or through ICC commands
#@   set ::process::batchWrite                  1  ;# Write out def file in chunkSize instead of line by line
#@   set ::process::chunkSize              100000  ;# Number of entries to be written out through def file at a time. VCC and VSS plus 3 vias per entry.
#@ 
#@   # Internal data structure initializations
#@   set ::process::design_bbox                ""
#@   set ::process::hookup_vcc                  1
#@   set ::process::hookup_vss                  1
#@ 
#@   # Cell Bboxes
#@   set ::process::sh_bboxes               [list]
#@   set ::process::dh_bboxes               [list]
#@   set ::process::physical_only_dh_bboxes [list]
#@   set ::process::blk_sh_pwr_bboxes       [list] ; # Maintain a list of locations for some special cells (d04qfd01) which doesn't allow a single_height power connection on the boundary
#@   set ::process::macro_bboxes            [list]
#@   set ::process::rp_bboxes               [list]
#@   set ::process::block_bboxes            [list] ; # Maintain a list of locations for some special cells (b05ltn1g/d04ltn1g) which has some tracks which need to be blocked for PowerHookup
#@ 
#@   # Via Landing areas
#@   set ::process::tcnGndLoc               [list]
#@   set ::process::gcnPwrLoc_tb            [list]
#@   set ::process::gcnPwrLoc_lr            [list]
#@   set ::process::tcnFloatLoc             [list]
#@   set ::process::gcnFloatLoc             [list]
#@   set ::process::m0PwrLoc                [list]
#@   set ::process::m0GndLoc                [list]
#@ 
#@   array unset ::process::power_tracks
#@   array set ::process::power_tracks      [list]
#@ 
#@   array unset ::process::nets
#@   set ::process::nets(power)             [list]
#@   set ::process::nets(ground)            [list]
#@ 
#@   array unset ::process::tcn_shapes
#@   array unset ::process::gcn_shapes
#@   array unset ::process::m0_shapes
#@   array unset ::process::all_vias
#@   array unset ::process::landed_vias
#@   array unset ::process::unlanded_vias
#@ 
#@ 
#@ }
#@ 
#@ #----------------------------------------------------------
#@ # Unset Internal initializations After runnign PowerHookup
#@ #----------------------------------------------------------
#@ proc ::process::_unset {} {
#@   # Methodology initializations
#@   unset ::process::polyGridBasedCellBloat
#@   unset ::process::pointBloat
#@   unset ::process::drawViaBloat
#@   unset ::process::drawSingleViaLayer
#@   unset ::process::drawOneTrackViaLayer
#@ 
#@   unset ::process::createViasThruDef
#@   unset ::process::batchWrite
#@   unset ::process::chunkSize
#@ 
#@   # Internal data structure initializations
#@   unset ::process::design_bbox
#@   unset ::process::hookup_vcc
#@   unset ::process::hookup_vss
#@ 
#@   # Cell Bboxes
#@   unset ::process::sh_bboxes
#@   unset ::process::dh_bboxes
#@   unset ::process::physical_only_dh_bboxes
#@   unset ::process::blk_sh_pwr_bboxes
#@   unset ::process::macro_bboxes
#@   unset ::process::rp_bboxes
#@   unset ::process::block_bboxes
#@ 
#@   # Via Landing areas
#@   unset ::process::tcnGndLoc
#@   unset ::process::gcnPwrLoc_tb
#@   unset ::process::gcnPwrLoc_lr
#@   unset ::process::tcnFloatLoc
#@   unset ::process::gcnFloatLoc
#@   unset ::process::m0PwrLoc
#@   unset ::process::m0GndLoc
#@ 
#@   array unset ::process::power_tracks
#@   array unset ::process::nets
#@   array unset ::process::tcn_shapes
#@   array unset ::process::gcn_shapes
#@   array unset ::process::m0_shapes
#@   array unset ::process::all_vias
#@   array unset ::process::landed_vias
#@   array unset ::process::unlanded_vias
#@ 
#@ }
#@ 
#@ 
#@ proc ::process::_init_vars_from_design {} {
#@   if { ![info exists ::process::techname] || $::process::techname == ""} {
#@     puts "-E- Please define ::process::techname"
#@     return -1
#@   }
#@ 
#@   set design_bbox [get_attribute [get_core_area] bbox]
#@ 
#@   if { ![info exists ::process::poly_pitch] || $::process::poly_pitch == ""} {
#@     set ::process::poly_pitch [get_attribute [get_core_area] tile_width]
#@   }
#@ 
#@   if { ![info exists ::process::pwr_hookup_grid_xl] || $::process::pwr_hookup_grid_xl == ""} {
#@     set ::process::pwr_hookup_grid_xl [lindex [lindex $design_bbox 0] 0]   ;# xl of core
#@   }
#@ 
#@   if { ![info exists ::process::pwr_hookup_grid_xh] || $::process::pwr_hookup_grid_xh == ""} {
#@     set ::process::pwr_hookup_grid_xh [lindex [lindex $design_bbox 1] 0]   ;# xh of core
#@   } else {
#@     # get core area Xh and subtract the offset
#@     set core_xh [lindex [lindex $design_bbox 1] 0]
#@     set ::process::pwr_hookup_grid_xh [expr $core_xh - $::process::pwr_hookup_grid_xh]
#@   }
#@ 
#@   if { ![info exists ::process::pwr_hookup_grid_pitch] || $::process::pwr_hookup_grid_pitch == ""} {
#@     puts "-E- Please define ::process::pwr_hookup_grid_pitch"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::vertical_layers] || $::process::vertical_layers == ""} {
#@     puts "-E- Please define ::process::vertical_layers"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::metal_pairs_for_via] || [array names ::process::metal_pairs_for_via] == 0} {
#@     puts "-E- Please define ::process::metal_pairs_for_via"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::stacked_metals_for_power] || $::process::stacked_metals_for_power == ""} {
#@     puts "-E- Please define ::process::stacked_metals_for_power"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::stacked_metals_for_ground] || $::process::stacked_metals_for_ground == ""} {
#@     puts "-E- Please define ::process::stacked_metals_for_ground"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::stacked_vias_for_power] || $::process::stacked_vias_for_power == ""} {
#@     puts "-E- Please define ::process::stacked_vias_for_power"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::stacked_vias_for_ground] || $::process::stacked_vias_for_ground == ""} {
#@     puts "-E- Please define ::process::stacked_vias_for_ground"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::masterVia_for_power] || $::process::masterVia_for_power == ""} {
#@     puts "-E- Please define ::process::masterVia_for_power"
#@     return -1
#@   }
#@ 
#@   # don't care if DH master is defined - if not, then ignore DH via differences
#@   #if { ![info exists ::process::DHmasterVia_for_power] || $::process::DHmasterVia_for_power == ""} {
#@   #   puts "-E- Please define ::process::DHmasterVia_for_power"
#@   #   return -1
#@   #}
#@ 
#@   if { ![info exists ::process::masterVia_for_ground] || $::process::masterVia_for_ground == ""} {
#@     puts "-E- Please define ::process::masterVia_for_ground"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::via_size_for_power] || $::process::via_size_for_power == ""} {
#@     puts "-E- Please define ::process::via_size_for_power"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::via_size_for_ground] || $::process::via_size_for_ground == ""} {
#@     puts "-E- Please define ::process::via_size_for_ground"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::offset_from_power_via1] || $::process::offset_from_power_via1 == ""} {
#@     puts "-E- Please define ::process::offset_from_power_via1"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::offset_from_ground_via1] || $::process::offset_from_ground_via1 == ""} {
#@     puts "-E- Please define ::process::offset_from_ground_via1"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::metal_overhang_via_power] || $::process::metal_overhang_via_power == ""} {
#@     puts "-E- Please define ::process::metal_overhang_via_power"
#@     return -1
#@   }
#@ 
#@   if { [info exists ::process::DHmasterVia_for_power] && $::process::DHmasterVia_for_power != ""} {
#@     # only check for dh overhang is DH master via is defined
#@     if { ![info exists ::process::metal_overhang_dh_via_power] || $::process::metal_overhang_dh_via_power == ""} {
#@       puts "-E- Please define ::process::metal_overhang_dh_via_power"
#@       return -1
#@     }
#@   } else {
#@     # if a DH master is not defined, then make sure dh overhang is also undefined
#@     unset -nocomplain ::process::metal_overhang_dh_via_power
#@   }
#@ 
#@   if { ![info exists ::process::metal_overhang_via_ground] || $::process::metal_overhang_via_ground == ""} {
#@     puts "-E- Please define ::process::metal_overhang_via_ground"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::bridging_via_layer] || $::process::bridging_via_layer == ""} {
#@     puts "-E- Please define ::process::bridging_via_layer"
#@     return -1
#@   }
#@ 
#@   if { ![info exists ::process::bridging_wire_length] || $::process::bridging_wire_length == ""} {
#@     set ::process::bridging_wire_length $::process::poly_pitch
#@   }
#@ 
#@   if { ![info exists ::process::design_bbox] || $::process::design_bbox == ""} {
#@     set ::process::design_bbox $design_bbox
#@   }
#@ 
#@   set ::process::pwr_hookup_layer_dir "horizontal"    ;# this var currently doesn't allow override. the implementation only works on horizontal power rails
#@ 
#@   # Initialize power tracks. Only obtain the ones that intersect design_bbox
#@   if { [::process::_init_power_tracks] == -1 } {
#@     return -1
#@   }
#@ 
#@   set cell_list "all"
#@   if { [info exists ::process::hookup_cells] } {
#@     set cell_list $::process::hookup_cells
#@   }
#@ 
#@ 
#@   # Initialize cell bboxes - sh_bboxes and dh_bboxes are done in  _get_power_hookup_locn_fr_cells
#@   if { [info procs ::process::get_macro_insts_bboxes] ne "" } {
#@     set ::process::macro_bboxes [::process::get_macro_insts_bboxes]
#@   }
#@   if { [info procs ::process::get_rp_bboxes] ne "" } {
#@     set ::process::rp_bboxes    [::process::get_rp_bboxes]
#@   }
#@ 
#@   # Set Via sizes for via-masters. It calls it multiple times,  better to store it as a variable
#@   array unset  ::process:via_size
#@   foreach netType [list "power" "power2" "ground"] {
#@     set stackedViaL [::process::_get_stacked_vias_for_net_type $netType]
#@     array unset viaMasterViaArr
#@     array set viaMasterViaArr [::process::_get_master_via $netType]
#@ 
#@     foreach via $stackedViaL {
#@       set masterVia $viaMasterViaArr($via)
#@       set viaSize_w [lindex [::process::_get_via_size $via $netType] 0]
#@       set viaSize_h [lindex [::process::_get_via_size $via $netType] 1]
#@       set ::process::via_size($masterVia) [list $viaSize_w $viaSize_h]
#@     }
#@   }
#@ 
#@ }
#@ 
#@ 
#@ proc ::process::_init_power_tracks {} {
#@   scan [join [join $::process::design_bbox]] "%f %f %f %f" xl yl xh yh
#@ 
#@   array unset ::process::power_tracks
#@   array set ::process::power_tracks [list]
#@ 
#@   if { ![info exists ::process::pwr_hookup_grid_patterns] || $::process::pwr_hookup_grid_patterns == ""} {
#@     if { ![info exists ::process::pwr_hookup_layer] } {
#@       puts "-E- Please define ::process::pwr_hookup_grid_patterns"
#@       puts "-E- Otherwise define ::process::pwr_hookup_layer, so that power grids will be automatically derived from design"
#@       return -1
#@     }
#@ 
#@     if { $::process::hookup_vcc == 1 } {
#@       if { ![info exists ::process::power_nets] || $::process::power_nets == "" } {
#@         puts "-E- Please define ::process::pwr_hookup_grid_patterns"
#@         puts "-E- Otherwise define ::process::power_nets, so that power grids will be automatically derived from design"
#@         return -1
#@       }
#@     }
#@ 
#@     if { $::process::hookup_vss == 1 } {
#@       if { ![info exists ::process::ground_nets] || $::process::ground_nets == "" } {
#@         puts "-E- Please define ::process::pwr_hookup_grid_patterns"
#@         puts "-E- Otherwise define ::process::ground_nets, so that power grids will be automatically derived from design"
#@         return -1
#@       }
#@     }
#@ 
#@     # Derive power grids
#@     set range [list $yl $yh]
#@ 
#@     if { $::process::hookup_vcc == 1 } {
#@       foreach netname $::process::power_nets {
#@ 
#@         set ::process::power_tracks(power,$netname) [::process::get_power_tracks -layer $::process::pwr_hookup_layer -dir $::process::pwr_hookup_layer_dir -net $netname -range $range]
#@       }
#@     }
#@ 
#@     if { $::process::hookup_vss == 1 } {
#@       foreach netname $::process::ground_nets {
#@         set ::process::power_tracks(ground,$netname) [::process::get_power_tracks -layer $::process::pwr_hookup_layer -dir $::process::pwr_hookup_layer_dir -net $netname -range $range]
#@       }
#@     }
#@   } else {
#@     # Power grid pattern is specified
#@     foreach pattern $::process::pwr_hookup_grid_patterns {
#@       scan $pattern "%s %s %f %f %i"  net_type net_name start pitch flip
#@ 
#@       if {$net_type != "power" && $net_type != "ground"} {
#@         puts "-E- Detected invalid net type, $net_type, in ::process::pwr_hookup_grid_patterns"
#@         return -1
#@       }
#@ 
#@       if {$::process::hookup_vcc == 0 && $net_type == "power"}  { continue }
#@       if {$::process::hookup_vss == 0 && $net_type == "ground"} { continue }
#@ 
#@       set tracks [list]
#@       set jump_start [expr ceil(($yl - $start) / $pitch) * $pitch + $start]
#@ 
#@       for { set i $jump_start } { $i <= $yh } { set i [expr $i + $pitch] } {
#@         lappend tracks $i
#@       }
#@ 
#@       if { [info exists ::process::power_tracks($net_type,$net_name)] } {
#@         set ::process::power_tracks($net_type,$net_name) [concat $::process::power_tracks($net_type,$net_name) $tracks]
#@       } else {
#@         set ::process::power_tracks($net_type,$net_name) $tracks
#@       }
#@     }
#@ 
#@     # Sort tracks
#@     foreach net [array names ::process::power_tracks] {
#@       set ::process::power_tracks($net) [lsort -unique -real $::process::power_tracks($net)]
#@     }
#@   }
#@ 
#@   # Initialize net information
#@   array unset ::process::nets
#@   set ::process::nets(power) [list]
#@   set ::process::nets(ground) [list]
#@ 
#@   foreach net [array names ::process::power_tracks] {
#@     scan [split $net ","] "%s %s" type name
#@     lappend ::process::nets($type) $name
#@   }
#@ }
#@ 
#@ 
#@ #------------------------------------------------
#@ # API for removing existing power hookups
#@ #------------------------------------------------
#@ proc ::process::clean_up_block_level_power_hookup { args } {
#@ 
#@   parse_proc_arguments -args $args opts
#@ 
#@   if { $opts(-nets) == "" || $opts(-metal_layers) == "" || $opts(-via_layers) == "" } {
#@     puts "-E- Please specify -nets, -metal_layers, and -via_layers"
#@     return
#@   }
#@ 
#@   set bbox [get_attribute [get_die_area] bbox]
#@   if { [info exists opts(-bbox)] } {
#@     set bbox $opts(-bbox)
#@   }
#@ 
#@   # Set this variable to medium .. otherwise it causes hangs during cleanup
#@   set orig_collection_deletion_effort $::collection_deletion_effort
#@   set ::collection_deletion_effort low
#@ 
#@   set start_time [clock seconds]
#@ 
#@   set v_net_shapes ""
#@   catch {unset minBBox}
#@   catch {unset cellBBoxes}
#@   if { [info exists opts(-cells)] } {
#@     puts " -I- cleanup cell size is [sizeof_collection $opts(-cells)]"
#@     if { ![info exists cellBBoxes] || ![info exists minBBox] } {
#@       set cellBBoxes [get_attribute [get_cells $opts(-cells)] bbox]
#@       if { [sizeof_collection [get_cells $opts(-cells)]] == 1 } {
#@         set singleBBox $cellBBoxes
#@         set cellBBoxes [list]
#@         lappend cellBBoxes $singleBBox
#@       }
#@       set tempBBoxes [list]
#@       foreach bbox $cellBBoxes {
#@         lappend tempBBoxes [join $bbox]
#@       }
#@       set cellBBoxesH [::process::merge_bboxes -bboxes $tempBBoxes -dir horizontal]
#@       set cellBBoxes [::process::merge_bboxes -bboxes $cellBBoxesH -dir vertical]
#@       set minBBox [::process::min_bbox $cellBBoxes]
#@     }
#@   }
#@   foreach lyr $opts(-metal_layers) {
#@     foreach net $opts(-nets) {
#@       if { ![sizeof_collection [get_net_shapes -quiet -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr"]] } { continue }
#@       if { [info exists opts(-cells)] } {
#@         if { ![info exists cellBBoxes] || ![info exists minBBox] } {
#@           set cellBBoxes [get_attribute [get_cells $opts(-cells)] bbox]
#@           set tempBBoxes [list]
#@           foreach bbox $cellBBoxes {
#@             lappend tempBBoxes [join $bbox]
#@           }
#@           set cellBBoxesH [::process::merge_bboxes -bboxes $tempBBoxes -dir horizontal]
#@           set cellBBoxes [::process::merge_bboxes -bboxes $cellBBoxesH -dir vertical]
#@           set minBBox [::process::min_bbox $cellBBoxes]
#@         }
#@         set all_net_shapes {}
#@         append_to_collection all_net_shapes [get_net_shapes -quiet -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr" -within $minBBox]
#@         append_to_collection all_net_shapes [get_net_shapes -quiet -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr" -intersect $minBBox]
#@         if { ![sizeof_collection $all_net_shapes] } { continue }
#@         catch {array unset nsBBoxMap}
#@         array set nsBBoxMap {}
#@         ::process::create_bbox_to_object_map $all_net_shapes nsBBoxMap
#@         if { [sizeof_collection $all_net_shapes] > 1 } {
#@           set nsBBoxes [get_attribute $all_net_shapes bbox]
#@         } else {
#@           set nsBBoxes [list]
#@           lappend nsBBoxes [get_attribute $all_net_shapes bbox]
#@         }
#@         set resultBBox [list]
#@         ::process::get_rectangles_from_polygonset [::process::_get_objbboxes_intersecting_bbox $nsBBoxes $cellBBoxes] resultBBox
#@         set v_net_shapes_iter [::process::bbox_map_to_collection $resultBBox nsBBoxMap]
#@         append_to_collection v_net_shapes $v_net_shapes_iter
#@ 
#@       } else {
#@         redirect /dev/null { append_to_collection v_net_shapes [get_net_shapes -quiet -intersect $bbox -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr"] }
#@         redirect /dev/null { append_to_collection v_net_shapes [get_net_shapes -quiet -within $bbox -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr"] }
#@       }
#@     }
#@   }
#@   set v_rm_shapes [remove_from_collection $v_net_shapes [get_net_shapes -quiet $v_net_shapes -filter "route_type == \"Signal Route\""]]
#@   echo "deleting [sizeof_collection $v_rm_shapes] netshapes"
#@   redirect /dev/null { remove_net_shape $v_rm_shapes }
#@ 
#@   unset v_rm_shapes
#@   unset v_net_shapes
#@   set end_time [clock seconds]
#@   set elapsed_time [expr ($end_time - $start_time)/ 60.0]
#@   puts "-I- Done removing metals in [format {%.2f} $elapsed_time] mins. Current time [date]"
#@ 
#@ 
#@   foreach lyr $opts(-via_layers) {
#@     foreach net $opts(-nets) {
#@       set v_net_shapes ""
#@       set v_vias ""
#@       # vcn is a net-shape if expandVcn is specified
#@       if { $lyr == "$::process::bridging_via_layer" && $::process::expandVcn == 1 } {
#@         if { ![sizeof_collection [get_net_shapes -quiet -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr" ]] } { continue }
#@         if { [info exists opts(-cells)] } {
#@           if { ![info exists cellBBoxes] || ![info exists minBBox] } {
#@             set cellBBoxes [get_attribute [get_cells $opts(-cells)] bbox]
#@             set tempBBoxes [list]
#@             foreach bbox $cellBBoxes {
#@               lappend tempBBoxes [join $bbox]
#@             }
#@             set cellBBoxesH [::process::merge_bboxes -bboxes $tempBBoxes -dir horizontal]
#@             set cellBBoxes [::process::merge_bboxes -bboxes $cellBBoxesH -dir vertical]
#@             set minBBox [::process::min_bbox $cellBBoxes]
#@           }
#@           set all_net_shapes {}
#@           append_to_collection all_net_shapes [get_net_shapes -quiet -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr" -within $minBBox]
#@           append_to_collection all_net_shapes [get_net_shapes -quiet -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr" -intersect $minBBox]
#@           if { ![sizeof_collection $all_net_shapes] } { continue }
#@           catch {array unset nsBBoxMap}
#@           array set nsBBoxMap {}
#@           ::process::create_bbox_to_object_map $all_net_shapes nsBBoxMap
#@           if { [sizeof_collection $all_net_shapes] > 1 } {
#@             set nsBBoxes [get_attribute $all_net_shapes bbox]
#@           } else {
#@             set nsBBoxes [list]
#@             lappend nsBBoxes [get_attribute $all_net_shapes bbox]
#@           }
#@           set resultBBox [list]
#@           ::process::get_rectangles_from_polygonset [::process::_get_objbboxes_intersecting_bbox $nsBBoxes $cellBBoxes] resultBBox
#@           set v_net_shapes_iter [::process::bbox_map_to_collection $resultBBox nsBBoxMap]
#@           puts "debug: fetched [sizeof_collection $v_net_shapes_iter]"
#@           append_to_collection v_net_shapes $v_net_shapes_iter
#@           #foreach_in_collection cell [get_cells $opts(-cells)] {
#@           #  set cell_bbox [get_attribute $cell bbox]
#@           #  redirect /dev/null { append_to_collection v_net_shapes [get_net_shapes -quiet -intersect $cell_bbox -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr"] }
#@           #  redirect /dev/null { append_to_collection v_net_shapes [get_net_shapes -quiet -within $cell_bbox -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr"] }
#@           #}
#@         } else {
#@           redirect /dev/null { append_to_collection v_net_shapes [get_net_shapes -quiet -intersect $bbox -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr"] }
#@           redirect /dev/null { append_to_collection v_net_shapes [get_net_shapes -quiet -within $bbox -of_objects [get_nets -quiet -all $net] -filter "layer == $lyr"] }
#@         }
#@         set v_rm_shapes [remove_from_collection $v_net_shapes [get_net_shapes -quiet $v_net_shapes -filter "route_type == \"Signal Route\""]]
#@         echo "deleting [sizeof_collection $v_rm_shapes] $::process::bridging_via_layer objects"
#@         redirect /dev/null { remove_net_shape $v_rm_shapes }
#@         unset v_rm_shapes
#@         unset v_net_shapes
#@       } else {
#@         if { ![sizeof_collection [get_vias -quiet -of_objects [get_nets -quiet -all $net] -filter "via_layer == $lyr"]] } { continue }
#@         if { [info exists opts(-cells)] } {
#@           if { ![info exists cellBBoxes] || ![info exists minBBox] } {
#@             set cellBBoxes [get_attribute [get_cells $opts(-cells)] bbox]
#@             set tempBBoxes [list]
#@             foreach bbox $cellBBoxes {
#@               lappend tempBBoxes [join $bbox]
#@             }
#@             set cellBBoxesH [::process::merge_bboxes -bboxes $tempBBoxes -dir horizontal]
#@             set cellBBoxes [::process::merge_bboxes -bboxes $cellBBoxesH -dir vertical]
#@             set minBBox [::process::min_bbox $cellBBoxes]
#@           }
#@ 
#@           set all_net_shapes {}
#@           append_to_collection all_net_shapes [get_vias -quiet -of_objects [get_nets -quiet -all $net] -filter "via_layer == $lyr" -within $minBBox]
#@           append_to_collection all_net_shapes [get_vias -quiet -of_objects [get_nets -quiet -all $net] -filter "via_layer == $lyr" -intersect $minBBox]
#@           if { ![sizeof_collection $all_net_shapes] } { continue }
#@           catch {array unset nsBBoxMap}
#@           array set nsBBoxMap {}
#@           ::process::create_bbox_to_object_map $all_net_shapes nsBBoxMap
#@           if { [sizeof_collection $all_net_shapes] > 1 } {
#@             set nsBBoxes [get_attribute $all_net_shapes bbox]
#@           } else {
#@             set nsBBoxes [list]
#@             lappend nsBBoxes [get_attribute $all_net_shapes bbox]
#@           }
#@           set resultBBox [list]
#@           ::process::get_rectangles_from_polygonset [::process::_get_objbboxes_intersecting_bbox $nsBBoxes $cellBBoxes] resultBBox
#@           set v_net_shapes_iter [::process::bbox_map_to_collection $resultBBox nsBBoxMap]
#@           append_to_collection v_vias $v_net_shapes_iter
#@           #foreach_in_collection cell [get_cells $opts(-cells)] {
#@           #  set cell_bbox [get_attribute $cell bbox]
#@           #  redirect /dev/null { append_to_collection v_vias [get_vias -quiet -intersect $cell_bbox -of_objects [get_nets -quiet -all $net] -filter "via_layer == $lyr"] }
#@           #  redirect /dev/null { append_to_collection v_vias [get_vias -quiet -within $cell_bbox -of_objects [get_nets -quiet -all $net] -filter "via_layer == $lyr"] }
#@           #}
#@         } else {
#@           redirect /dev/null { append_to_collection v_vias [get_vias -quiet -intersect $bbox -of_objects [get_nets -quiet -all $net] -filter "via_layer == $lyr"] }
#@           redirect /dev/null { append_to_collection v_vias [get_vias -quiet -within $bbox -of_objects [get_nets -quiet -all $net] -filter "via_layer == $lyr"] }
#@         }
#@         set v_rm_vias [remove_from_collection $v_vias [get_vias -quiet $v_vias -filter "route_type == \"Signal Route\" || route_type==\"Clk Ring\""]]
#@         echo "deleting [sizeof_collection $v_rm_vias] vias in layer $lyr "
#@         redirect /dev/null { remove_via $v_rm_vias }
#@ 
#@         unset v_vias
#@         unset v_rm_vias
#@       }
#@     }
#@   }
#@ 
#@   set end_time [clock seconds]
#@   set elapsed_time [expr ($end_time - $start_time)/ 60.0]
#@   puts "-I- Done removing block level power hookup in $bbox in [format {%.2f} $elapsed_time] mins"
#@ 
#@   # Reset the value to original value
#@   set ::collection_deletion_effort $orig_collection_deletion_effort
#@ }
#@ 
#@ define_proc_attributes ::process::clean_up_block_level_power_hookup     -info "Clean up existing block level standard cell power hookup"     -define_args {
#@       {"-nets"          "A list of vcc and vss net names" "" list}
#@       {"-via_layers"    "A list of via layers where existing power hookups are at" "" list}
#@       {"-metal_layers"  "A list of metal layers where existing power hookups are at" "" list}
#@       {"-bbox"          "Clean up power hookup in the specified bbox. Default is the entire design" "" list optional}
#@       {"-cells"         "Clean up power hookup for the specified cells. Default is the entire design" "" list optional}
#@     }
#@ 
#@ 
#@ #
#@ # returns layer direction
#@ #
#@ proc ::process::get_layer_direction { layer } {
#@   if { [lsearch -exact $::process::vertical_layers $layer] >= 0 } {
#@     return "vertical"
#@   } else {
#@     return "horizontal"
#@   }
#@ }
#@ 
#@ #
#@ # given a via layer and nettype return via size
#@ # power and ground via cuts have different dimensions due to different widths
#@ #
#@ proc ::process::_get_via_size {via netType} {
#@   if { ! [string match -nocase "power*" $netType] } {
#@     foreach {v w h} [join $::process::via_size_for_ground] {
#@       if {$v == $via} {
#@         return [list $w $h]
#@       }
#@     }
#@     puts "Error in ::process::_get_via_size API! incorrect via size specified. Invalid return"
#@   } else {
#@     foreach {v w h} [join $::process::via_size_for_power] {
#@       if {$v == $via} {
#@         return [list $w $h]
#@       }
#@     }
#@     puts "Error in ::process::_get_via_size API! incorrect via size specified. Invalid return"
#@   }
#@ 
#@   return;
#@ }
#@ 
#@ 
#@ #
#@ # get all the metal layers that make up the power hookup
#@ #
#@ proc ::process::_get_pwr_hookup_metals {} {
#@   set mL $::process::stacked_metals_for_ground
#@   lappend mL $::process::stacked_metals_for_power
#@ 
#@   return [lsort -uniq [join $mL] ];
#@ }
#@ 
#@ #
#@ # get all the via layers that make up the power hookup
#@ #
#@ proc ::process::_get_pwr_hookup_vias {} {
#@   set vL $::process::stacked_vias_for_ground
#@   lappend vL $::process::stacked_vias_for_power
#@ 
#@   return [lsort -uniq [join $vL] ];
#@ }
#@ 
#@ #
#@ # returns the stacked via layers (ie v0 v1 for eg)
#@ #
#@ proc ::process::_get_stacked_vias_for_net_type {netType} {
#@   set viaL $::process::stacked_vias_for_power
#@ 
#@   if { ! [string match -nocase "power*" $netType] } {
#@     set viaL $::process::stacked_vias_for_ground
#@   }
#@   return $viaL;
#@ }
#@ 
#@ #
#@ # returns the stacked via Master Via names (ie VIA1D for v1 for eg)
#@ #
#@ proc ::process::_get_master_via {netType} {
#@   set mviaL [join $::process::masterVia_for_power]
#@ 
#@   if { ! [string match -nocase "power*" $netType] } {
#@     set mviaL [join $::process::masterVia_for_ground]
#@   }
#@   if { [string equal -nocase "power2" $netType] && [info exists ::process::DHmasterVia_for_power] && ($::process::DHmasterVia_for_power != "") } {
#@     set mviaL [join $::process::DHmasterVia_for_power]
#@   }
#@ 
#@   return $mviaL;
#@ }
#@ 
#@ 
#@ #-------------------------------------------
#@ # Generic helper functions
#@ # (no dependency on any process variables)
#@ #-------------------------------------------
#@ proc ::process::get_power_tracks { args } {
#@   parse_proc_arguments -args $args opts
#@ 
#@   # Get net shapes
#@   set shapes [list]
#@ 
#@   if { [info exists opts(-net)] && $opts(-net) != "" } {
#@     if { [info exists opts(-width)] && $opts(-width) != "" } {
#@       set shapes [get_net_shapes * -quiet -filter "owner_net == $opts(-net) && layer == $opts(-layer) && width == $opts(-width)"]
#@     } else {
#@       set shapes [get_net_shapes * -quiet -filter "owner_net == $opts(-net) && layer == $opts(-layer)"]
#@     }
#@   } else {
#@     if { [info exists opts(-vcc)] && [info exists opts(-vss)] } {
#@       if { [info exists opts(-width)] && $opts(-width) != "" } {
#@         set shapes [get_net_shapes * -quiet -filter "(net_type == Power || net_type == Ground) && layer == $opts(-layer) && width == $opts(-width)"]
#@       } else {
#@         set shapes [get_net_shapes * -quiet -filter "(net_type == Power || net_type == Ground) && layer == $opts(-layer)"]
#@       }
#@     } elseif { [info exists opts(-vcc)] } {
#@       if { [info exists opts(-width)] && $opts(-width) != "" } {
#@         set shapes [get_net_shapes * -quiet -filter "net_type == Power && layer == $opts(-layer) && width == $opts(-width)"]
#@       } else {
#@         set shapes [get_net_shapes * -quiet -filter "net_type == Power && layer == $opts(-layer)"]
#@       }
#@     } elseif { [info exists opts(-vss)] } {
#@       if { [info exists opts(-width)] && $opts(-width) != "" } {
#@         set shapes [get_net_shapes * -quiet -filter "net_type == Ground && layer == $opts(-layer) && width == $opts(-width)"]
#@       } else {
#@         set shapes [get_net_shapes * -quiet -filter "net_type == Ground && layer == $opts(-layer)"]
#@       }
#@     } else {
#@       puts "-W- No -net, -vcc or -vss specified"
#@     }
#@   }
#@ 
#@   if {$shapes == ""} {
#@     return ""
#@   }
#@ 
#@   # Calculate tracks
#@   set all_tracks [list]
#@ 
#@   if {$opts(-dir) == "horizontal"} {
#@     foreach_in_collection wire $shapes {
#@       lappend all_tracks [expr ([get_attribute $wire bbox_lly] + [get_attribute $wire bbox_ury]) / 2]
#@     }
#@   } elseif {$opts(-dir) == "vertical"} {
#@     foreach_in_collection wire $shapes {
#@       lappend all_tracks [expr ([get_attribute $wire bbox_llx] + [get_attribute $wire bbox_urx]) / 2]
#@     }
#@   }
#@ 
#@   if {$all_tracks == ""} {
#@     return ""
#@   }
#@ 
#@   # Parse range option
#@   set range_low   -9999999
#@   set range_high  9999999
#@   if { [info exists opts(-range)] } {
#@     if { [llength $opts(-range)] == 1 } {
#@       set range_low [lindex $opts(-range) 0]
#@     } elseif { [llength $opts(-range)] == 2 } {
#@       set range_low  [lindex $opts(-range) 0]
#@       set range_high [lindex $opts(-range) 1]
#@     }
#@     if {$range_low > $range_high} {
#@       set tmp $range_low
#@       set range_low $range_high
#@       set range_high $tmp
#@     }
#@   }
#@ 
#@   # Filter tracks with specified range
#@   set tracks [list]
#@   foreach track $all_tracks {
#@     if {$track >= $range_low && $track <= $range_high} {
#@       lappend tracks $track
#@     }
#@   }
#@ 
#@   return [lsort -unique -real $tracks]
#@ }
#@ 
#@ define_proc_attributes ::process::get_power_tracks     -info "Returns power tracks in a list of x or y locations"     -define_args {
#@       {"-layer"   "The layer that the user wants to get power tracks on." "" string}
#@       {"-dir"     "Direction of the layer. Either horizontal or vertical." "" string}
#@       {"-width"   "Width of the P/G Net." "" string optional}
#@       {"-net"     "Get power tracks of the net." "" string optional}
#@       {"-vcc"     "Get all vcc tracks if -net is not used. Default is false" "" boolean optional}
#@       {"-vss"     "Get all vss tracks if -net is not used. Default is false." "" boolean optional}
#@       {"-range"   "Get only the tracks within the specified range. Format is a list of low point and high point" "" list optional}
#@     }
#@ 
#@ 
#@ #-------------------------------------------
#@ # Time stamp & print procs
#@ #-------------------------------------------
#@ proc ::process::set_mark {} {
#@   set ::process::cputime_mark  [cputime -self -child]
#@   set ::process::time_mark [clock seconds]
#@   set ::process::mem_mark  [mem]
#@ }
#@ 
#@ proc ::process::timestamp {str} {
#@   set cur_cputime  [cputime -self -child]
#@   set cur_time     [clock seconds]
#@   set cur_mem      [mem]
#@   set time_t       [expr ($cur_time - $::process::time_mark) / 60.00]
#@   set cputime_t    [expr ($cur_cputime - $::process::cputime_mark) / 60.00]
#@   set mem_t        [expr ($cur_mem  - $::process::mem_mark) / 1000]
#@ 
#@   set str_len      [string length $str]
#@   set space_tail   [expr 20 - $str_len]
#@   set str_pad      [string repeat " " $space_tail]
#@   puts " -I- TIMESTAMP - $str $str_pad: Elapsed Time [format {%.2f} $time_t] mins ; Elapsed CPU Time [format {%.2f} $cputime_t] mins; Mem used $mem_t MB"
#@ }
#@ 
#@ proc ::process::print_header { args } {
#@ 
#@   set args_length [llength $args]
#@ 
#@   if {$args_length == 0} {
#@     puts "-E- One argument required"
#@   } elseif {$args_length == 1} {
#@     set heading [lindex $args 0]
#@   } else {
#@     puts "-I- Only one argument is allowed"
#@   }
#@ 
#@   set hashz_len 75
#@   set hashz [string repeat "-" $hashz_len]
#@   set heading_len [string length $heading]
#@ 
#@   set space_length_hash [expr {($hashz_len - $heading_len)/2}]
#@   set space_length_head [expr {($heading_len - $hashz_len)/2}]
#@   set space_hash [string repeat " " $space_length_hash]
#@   set space_head [string repeat " " $space_length_head]
#@ 
#@   #print to a screen; and can be tee'd off to file
#@   echo "$space_head $hashz $space_head"
#@   echo "$space_hash $heading $space_hash"
#@   echo "$space_head $hashz $space_head"
#@ 
#@ }; # end da_print_header
#@ 
#@ #-----------------------------------------------------------------------------------------------------
#@ #  Author:        Lin Zhou
#@ #  Proc Name:     get_track_location
#@ #  Description :  Get a list of location of tracks for specific layer. it could base on width. The default is defaultWidth
#@ #  Return Value:  A list of tracks for specific layer
#@ #-----------------------------------------------------------------------------------------------------
#@ proc ::process::get_track_location { args } {
#@   parse_proc_arguments -args $args opts
#@ 
#@   if { [::process::get_layer_direction $opts(-layer)] == "vertical"} {
#@     set dir "X"
#@   } else {
#@     set dir "Y"
#@   }
#@ 
#@   set layer $opts(-layer)
#@ 
#@   set width [get_attribute -class layer $layer defaultWidth]
#@ 
#@   if { [info exist opts(-width) ] } {
#@     set width $opts(-width)
#@   }
#@ 
#@   set all 0
#@ 
#@   if { [info exist opts(-all)] } {
#@     set all 1
#@     array unset track_all_list
#@   }
#@ 
#@   redirect -variable lines { report_rule_based_track -dir $dir -layer $layer }
#@ 
#@   if { $lines == 1 } {
#@     puts "-E- Tracks for $opts(-layer) dir $dir is not defined in the design"
#@     return -1
#@   }
#@ 
#@   set lines [split $lines "\n"]
#@   set i 0
#@   set track_list [list]
#@   while { $i < [llength $lines] } {
#@     set line [string trim [lindex $lines $i] ]
#@     set prefix m
#@     if { [string equal [lindex $line 5] "usr"] || ([regexp "^${prefix}" $line] && [llength $line] == 5) } {
#@       set track_width [get_attribute -class layer $layer defaultWidth]
#@     } else {
#@       set track_width [lindex [split [lindex $line 5] "=" ] 1]
#@     }
#@ 
#@     if { [regexp "^${prefix}" $line] } {
#@       set start [lindex $line 2]
#@       set tracks [lindex $line 3]
#@       set pitch [lindex $line 4]
#@ 
#@       if { $width == 0 } {
#@         for { set j 0 } { $j < $tracks } { incr j } {
#@           lappend track_list [expr $start + $j * $pitch]
#@         }
#@       } elseif { !$all && [expr abs($track_width - $width)] < 0.00001 } {
#@         for { set j 0 } { $j < $tracks } { incr j } {
#@           lappend track_list [expr $start + $j * $pitch]
#@         }
#@       } elseif { $all } {
#@         for { set j 0 } { $j < $tracks } { incr j } {
#@           lappend track_all_list($track_width) [expr $start + $j * $pitch]
#@         }
#@       }
#@     }
#@ 
#@     incr i
#@   }
#@ 
#@   if { !$all } {
#@     return [lsort -real -uniq $track_list]
#@   } else {
#@     foreach w [lsort [array name track_all_list]] {
#@       lappend track_list [list $w [lsort -real -uniq $track_all_list($w)]]
#@     }
#@     return $track_list
#@   }
#@ }
#@ 
#@ define_proc_attributes ::process::get_track_location     -info "Return a list of track location for specify layer"     -define_args {
#@       {-layer "Specify layer" layer string required}
#@       {-width "Specify the width for the track. The default is defaultWidth for the layer" width float optional}
#@       {-all   "Get tracks of specified layer for all width. Return width and list of locations" "" boolean optional}
#@     }
#@ 
#@ 
#@ ##########################################################################
#@ #
#@ # _description: Check whether the metal layer is vertical layer
#@ #
#@ ##########################################################################
#@ 
#@ proc ::process::is_vertical_layer { args } {
#@   parse_proc_arguments -args $args opts
#@   set layer $opts(-layer)
#@   if { ![regexp {^metal|^m} $layer] } {
#@     puts "-I- Could not check the layer $layer"
#@     return
#@   }
#@ 
#@   regexp {(\D+)(\d+)} $layer match name num
#@ 
#@   if { [expr $num%2] == 1 } {
#@     return 1
#@   } else {
#@     return 0
#@   }
#@ }
#@ 
#@ define_proc_attributes ::process::is_vertical_layer     -info "Identify if the layer is a vertical layer"     -define_args {
#@       {-layer "Specify layer" layer string required}
#@     }
#@ 
#@ 
#@ ###########################################################
#@ # Keep track of memory and runtime
#@ ###########################################################
#@ proc ::process::stopwatch {args} {
#@ 
#@   global sh_dev_null
#@ 
#@   if { ![info exists ::process::start_stopwatch] } {
#@     return
#@   }
#@ 
#@   parse_proc_arguments -args $args results
#@ 
#@   set stopwatch_log "stopwatch.[pid].log"
#@ 
#@   # namespaces let us save information across multiple calls to
#@   # stopwatch, *and* ensure that someone else doesn't accidentally
#@   # use the same variable name in another procedure
#@   namespace eval stopwatch {}
#@ 
#@   # note we can check to see if this argument was passed or not by
#@   # using "info exists"
#@   if {[info exists results(info)]} {
#@     set infomsg "StopWatch - ${results(info)}"
#@   } else {
#@     set infomsg "StopWatch"
#@   }
#@ 
#@   set len_infomsg [string length $infomsg]
#@   set hashz [string repeat "=" [expr $len_infomsg + 50]]
#@   # puts "[exec /usr/users/a4fs/skondapu/mem_pid.csh [pid] $infomsg]"
#@   # when we run for the first time, just because we declared variables
#@   # in our namespace above, doesn't mean that they actually exist yet;
#@   # this is why we can use this check to know if it was the first time
#@   # we've been invoked
#@   if {[info exists stopwatch::last_cputime]} {
#@     redirect -append $stopwatch_log {echo "$hashz"}
#@     redirect -append $stopwatch_log {echo "$infomsg"}
#@     redirect -append $stopwatch_log {echo ""}
#@     redirect -append $stopwatch_log {echo "  - Wall clock time is currently [date]."}
#@     redirect -append $stopwatch_log {echo "  - Memory used since beginning of process is [expr [mem]/1000] MB."}
#@     redirect -append $stopwatch_log {echo "  - CPU time used since beginning of process is [cputime]."}
#@     redirect -append $stopwatch_log {echo ""}
#@     redirect -append $stopwatch_log {echo "  - Wall clock time used since last stopwatch is [format  {%.2f} [expr [expr [clock seconds] - $stopwatch::last_walltime] / 60.00]] mins." }
#@     redirect -append $stopwatch_log {echo "  - CPU time used since last stopwatch is [expr [cputime] - $stopwatch::last_cputime]."}
#@     redirect -append $stopwatch_log {echo "  - Memory used since last stopwatch is [expr [expr [mem] - $stopwatch::last_mem]/ 1000.00]MB."}
#@     redirect -append $stopwatch_log {echo ""}
#@   } else {
#@     puts "-I- Start Capturing Runtime/Memory in $stopwatch_log"
#@     redirect $stopwatch_log { echo "" }
#@     redirect -append $stopwatch_log {echo "$hashz"}
#@     redirect -append $stopwatch_log {echo "$infomsg"}
#@     redirect -append $stopwatch_log {echo ""}
#@     redirect -append $stopwatch_log {echo "  - Wall clock time is currently [date]."}
#@     redirect -append $stopwatch_log {echo "  - CPU time used since beginning of process is [cputime]."}
#@     redirect -append $stopwatch_log {echo "  - Memory used since beginning of process is [expr [mem]/1000] MB."}
#@     redirect -append $stopwatch_log {echo ""}
#@   }
#@   redirect -append $stopwatch_log {echo $hashz}
#@   redirect $sh_dev_null {set stopwatch::last_walltime [clock seconds]}
#@   redirect $sh_dev_null {set stopwatch::last_cputime [cputime]}
#@   redirect $sh_dev_null {set stopwatch::last_mem [mem]}
#@ }
#@ 
#@ define_proc_attributes ::process::stopwatch     -info "gives CPU time/memory consumed since the last stopwatch"     -define_args     {
#@       { info "optional info message" "info" string optional }
#@     }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : adv_polygon_check #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  adv_polygon_check
#@ # __description:  check condition 'option' on polygon
#@ #                 polygons can be polygon_set, simple polygon, complex polygon,
#@ #                                 rectArray, compressed polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result ---
#@ #                       simple  = 1 if simple polygon as defined above, else 0
#@ #                       complex = 1 if complex polygon as defined above, else 0
#@ #                       defined_set = 1 if polygon_set as defined above, else 0
#@ #                       rectArray = 1 if rectArray as defined above, else 0
#@ #                       compressed = 1 if compressed polygon as defined above,
#@ #                                    else 0
#@ #                       polygon = 1 if any of simple/complex/defined_set/
#@ #                                   rectArray/compressed, else 0
#@ #                       empty = 1 if the polygon is empty, else 0
#@ #                       rectangle = 1 if polygon is a single rectangle, else 0
#@ #                       identical = 1 if polygon matches other_polygon, else 0
#@ # __required_args:  option (one of): simple complex defined_set rectArray
#@ #                                    compressed empty rectangle identical
#@ #                   polygon: polygon_set, simple/complex/compressed polygon,
#@ #                            or rectArray
#@ # __optional_args:  other_polygon: used only for identical (defaults to polygon)
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc adv_polygon_check { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set poly_args {}
#@   set poly_cnt 1
#@ 
#@   if { [string equal $option "identical"] } {
#@     if { [info exists inputs(other_polygon)] } {
#@       incr poly_cnt
#@     }
#@   } elseif { [string equal $option "polygon"] } {
#@     if { [info exists inputs(other_polygon)] &&  [string equal -nocase "$inputs(other_polygon)" "-list"]} {
#@       set option "return_expression"
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   # store as list for each polygon { name_or_NULL is_simple_polygon
#@   #                                  is_polygon is_rect_array
#@   #                                  is_compressed_set complex_polygon_list }
#@   #    where name_or_NULL = name of defined polygon set if valid, else {}
#@   #          is_simple_polygon    = 1 if a simple polygon, else 0
#@   #          is_polygon           = 1 if a polygon, else 0
#@   #          is_rect_array        = 1 if paired coordinates for rect, else 0
#@   #          is_compressed_set    = 1 if a compressed polygon set, else 0
#@   #          complex_polygon_list = polygon value as a complex polygon list
#@   set polygon_info {}
#@   for { set i 1 } { $i <= $poly_cnt } { incr i } {
#@     if { $i == 1 } {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(polygon)
#@       set item $inputs(polygon)
#@     } else {
#@       set source_polygon ::polygon_ops::polygon_sets::$inputs(other_polygon)
#@       set item $inputs(other_polygon)
#@     }
#@     # check if the polygon is defined in a polygon set
#@     if { [info exists $source_polygon] } {
#@       set polygon_set [expr $$source_polygon]
#@       lappend polygon_info [list $item 0 1 0 0 $polygon_set]
#@       continue
#@     }
#@ 
#@     # check to see if the cell is either a simple/complex polygon or rectArray
#@     #    or a compressed polygon set
#@ 
#@     # First ensure that coordinates if paired are at consistent level
#@     # - first ensure that a double coordinate value is in the expected levels
#@     # - max levels to first double = 3
#@     # -    complex_polygon = { simple_polygon_1 ... simple_polygon_n }
#@     # -    simple_polygon  = { list_of_coordinates }
#@     # -    coordinate      = { x y }
#@     if { ! [string is double -strict [lindex [lindex [lindex $item 0] 0] 0]] } {
#@       # may be that this is an empty list
#@       if { [llength $item] == 0 } {
#@         lappend polygon_info [list {} 1 1 1 1 {}]
#@       } else {
#@         lappend polygon_info [list {} 0 0 0 0 {}]
#@       }
#@       continue
#@     }
#@ 
#@     # while the length of list is one, strip the nesting level
#@     while { [llength $item] == 1 } {
#@       set item [lindex $item 0]
#@     }
#@ 
#@     # do a quick check to see if the polygon pairs were completed flattened
#@     # if this is the case, then quickly rebuild the pairs
#@     unset -nocomplain paired_list
#@     if { [string is double -strict [lindex $item 0]] } {
#@       # list must be all real numbers
#@       if { [catch { lsort -real $item } catch_result] != 0 } {
#@         # not a list of real/double numbers
#@       } elseif { ([llength $item] > 4) && (([llength $item] % 2) == 0) } {
#@         # for this one case see if same start+end and common x or y
#@         # in this case then an empty set (must be at least 5 pairs)
#@         foreach {x1 y1 x2 y2} $item { break }
#@         if { (($x1==$x2) || ($y1==$y2)) && (($x1!=$x2) || ($y1!=$y2)) } {
#@           set paired_list {}
#@           foreach {x1 y1} $item {
#@             lappend paired_list [list $x1 $y1]
#@           }
#@           set item $paired_list
#@         }
#@       }
#@     }
#@ 
#@     # - find up one level from the first double coordinate x or y value
#@     # - ensure that the level is always consistent
#@     set paired 1
#@     if { [string is double -strict [lindex $item 0]] } {
#@       # only a single level - this can only be a rectArray or compressedSet
#@       set is_simple_polygon 0
#@       set is_rectArray 1
#@       set is_compressedSet 1
#@       set is_polygon 0
#@       # all items can only be double floats and must be paired set of coords
#@       # this means the length must be a multiple of 4
#@       if { ([llength $item] % 4) == 0 } {
#@         # run a quick check to see if all numbers are double
#@         if { [catch { lsort -real $item } catch_result] != 0 } {
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         set paired 0
#@       }
#@     } else {
#@       if { [string is double -strict [lindex [lindex $item 0] 0]] } {
#@         # this can only be a list of coordinate pairs
#@         # which can be either a compressedSet, rectArray, or simple polygon
#@         set is_simple_polygon 1
#@         set is_compressedSet 1
#@         set is_polygon 1
#@         # for rectArray, must have an even number of points
#@         set is_rectArray [expr ([llength $item] % 2) == 0]
#@ 
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         if { ([lsearch -glob $item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         } elseif { [llength $item] > 4 } {
#@           # for this one case see if same start+end and common x or y
#@           # in this case then an empty set (must be at least 5 pairs)
#@           foreach {x1 y1} [lindex $item 0] { break }
#@           foreach {x2 y2} [lindex $item end] { break }
#@           if { ($x1 == $x2) && ($y1 == $y2) } {
#@             if { [llength [lsort -real -unique -index 0 $item]] eq 1 } {
#@               # fixed x, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             } elseif { [llength [lsort -real -unique -index 1 $item]] eq 1 } {
#@               # fixed y, same start/stop, >= 5 points. ==> empty polygon
#@               lappend polygon_info [list {} 1 1 1 1 {}]
#@               continue
#@             }
#@           }
#@         }
#@         # normalize the level of the polygon
#@         set polygon [list $item]
#@       } else {
#@         # with the levels involved this can only be a complex polygon
#@         set is_simple_polygon 0
#@         set is_compressedSet 0
#@         set is_polygon 1
#@         set is_rectArray 0
#@         # check that all coordinates are paired sets of real/double
#@         # discard trivial shapes of <3 coordinates
#@         set polygon {}
#@         foreach shape $item {
#@           if { [llength $shape] < 3 } {
#@             # ignore trivial shapes
#@             continue
#@           }
#@           lappend polygon $shape
#@         }
#@         # check that the full set only consists of pairs
#@         # first check ensures that no members of joined item >2, second check finds any < 2
#@         # for checks members cannot be empty {}, i.e. they must contain a non-space char
#@         set joined_item [join $item]
#@         if { ([lsearch -glob $joined_item [list ?* ?* ?*]] != -1) || ([lsearch -not -glob $joined_item [list ?* ?*]] != -1) } {
#@           # not valid coordinate pairs
#@           set paired 0
#@         } elseif { [catch { lsort -real [join $joined_item] } catch_result] != 0 } {
#@           # run a quick check to see if all numbers are double
#@           # not a list of real/double numbers
#@           set paired 0
#@         }
#@         unset -nocomplain joined_item
#@       }
#@ 
#@     }
#@     if { ! $paired } {
#@       # bad pairing of coordinates found, this is a bad polygon
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@       continue
#@     }
#@ 
#@ 
#@     # step through the actual shapes and check to see if a valid polygon
#@     set rectArray {}
#@     if { $is_rectArray } {
#@       foreach {xl yl xu yu} [join [join [join $polygon]]] {
#@         if { ($xl<$xu) && ($yl<$yu) } {
#@           lappend rectArray [list [list $xl $yl] [list $xl $yu] [list $xu $yu] [list $xu $yl] [list $xl $yl]]
#@         } else {
#@           set is_rectArray 0
#@           break
#@         }
#@       }
#@     }
#@ 
#@     if { $is_compressedSet } {
#@       set compressedSet {}
#@       set partialSet {}
#@       # can only be a length of 1
#@       set joined_polygon [join [join [join $polygon]]]
#@       set shifted_polygon [join [list [lrange $joined_polygon 2 end] 0 0]]
#@       unset -nocomplain x0 y0
#@       foreach {x1 y1} $joined_polygon {x2 y2} $shifted_polygon {
#@         lappend partialSet [list $x1 $y1]
#@         if { [info exists x0] } {
#@           if { ($x0==$x1) && ($y0==$y1) } {
#@             # shape valid if both x & y have more than one value (there is size to the shape)
#@             if { ([llength [lsort -unique -real -index 0 $partialSet]] > 1) && ([llength [lsort -unique -real -index 1 $partialSet]] > 1) } {
#@               lappend compressedSet $partialSet
#@             }
#@             set partialSet {}
#@             unset -nocomplain x0 y0
#@             continue
#@           }
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         } else {
#@           if { ($x1==$x2) && ($y1==$y2) } {
#@             continue
#@           }
#@           if { ($x1==$x2) || ($y1==$y2) } {
#@             set x0 $x1
#@             set y0 $y1
#@           } else {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@       }
#@       if { [info exists x0] } {
#@         # didn't complete the final polygon shape
#@         set is_simple_polygon 0
#@         set is_polygon 0
#@         set is_compressedSet 0
#@       }
#@     } elseif { $is_polygon } {
#@       set new_polygon {}
#@       foreach shape $polygon {
#@         # check that first/last coordinate match
#@         foreach {x0 y0} [join [lindex $shape 0]] { break }
#@         foreach {xend yend} [join [lindex $shape end]] { break }
#@         if { ($x0!= $xend) || ($y0 != $yend) } {
#@           set is_simple_polygon 0
#@           set is_polygon 0
#@           break
#@         }
#@         set joined_shape [join [join $shape]]
#@         set joined_shape1 [lrange $joined_shape 0 end-2]
#@         set joined_shape2 [lrange $joined_shape 2 end]
#@         foreach {x1 y1} $joined_shape1 {x2 y2} $joined_shape2 {
#@           if { ($x1!=$x2) && ($y1!=$y2) } {
#@             set is_simple_polygon 0
#@             set is_polygon 0
#@             set is_compressedSet 0
#@             break
#@           }
#@         }
#@         if { ! $is_polygon } {
#@           break
#@         }
#@         # shape is valid if both x & y have more than one value (there is size to the shape)
#@         if { ([llength [lsort -unique -real -index 0 $shape]] > 1) && ([llength [lsort -unique -real -index 1 $shape]] > 1) } {
#@           lappend new_polygon $shape
#@         }
#@       }
#@       set polygon $new_polygon
#@     }
#@ 
#@     if { $is_rectArray } {
#@       lappend polygon_info [list {} 0 0 1 0 $rectArray]
#@     } elseif { $is_polygon && (! $is_compressedSet) } {
#@       lappend polygon_info [list {} $is_simple_polygon 1 0 0 $polygon]
#@     } elseif { $is_compressedSet } {
#@       set is_simple_polygon [expr [llength $compressedSet] < 2]
#@       lappend polygon_info [list {} $is_simple_polygon $is_simple_polygon 0 [expr ! $is_simple_polygon] $compressedSet]
#@     } else {
#@       lappend polygon_info [list {} 0 0 0 0 {}]
#@     }
#@   }
#@ 
#@   set is_polygon [expr [lindex [lindex $polygon_info 0] 2] ||                       [lindex [lindex $polygon_info 0] 3] ||                       [lindex [lindex $polygon_info 0] 4] ||                       ([llength [lindex [lindex $polygon_info 0] 0]] > 0)]
#@   switch -exact -- $option {
#@     simple      {
#@       set is_simple           [expr [lindex [lindex $polygon_info 0] 1]  && ([llength [lindex                                                                        [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_simple
#@     }
#@     complex     {
#@       set is_complex           [expr (! [lindex [lindex $polygon_info 0] 1]) && ([llength [lindex                                                                           [lindex $polygon_info 0] 0]]== 0) && [lindex [lindex $polygon_info 0] 2]]
#@       return $is_complex
#@     }
#@     defined_set {
#@       return [expr [llength [lindex [lindex $polygon_info 0] 0]] > 0]
#@     }
#@     rectArray   {
#@       return [expr [lindex [lindex $polygon_info 0] 3] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     compressed  {
#@       return [expr [lindex [lindex $polygon_info 0] 4] && ([llength [lindex [lindex $polygon_info 0] 0]]== 0)]
#@     }
#@     polygon     {
#@       return $is_polygon
#@     }
#@     default     {
#@       if { ! $is_polygon } {
#@         P_msg_error "'${func_name} $option': polygon \"$inputs(polygon)\" is not a valid polygon."
#@         return
#@       }
#@       set is_polygon [expr                           [lindex [lindex $polygon_info end] 2] || [lindex [lindex $polygon_info end] 3] ||                           [lindex [lindex $polygon_info end] 4] || ([llength [lindex [lindex $polygon_info end] 0]] > 0)]
#@       if { (! $is_polygon) && [string equal $option "identical"] && ([llength $polygon_info] > 1) } {
#@         P_msg_error "'${func_name} $option': other_polygon \"$inputs(other_polygon)\" is not a valid polygon."
#@         return
#@       }
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (if so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_help]
#@ 
#@   # simplify polygon structure
#@   set check_empty [string equal $option "empty"]
#@   if { [llength [lindex [lindex $polygon_info 0] 0]] == 0 } {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@ 
#@     # merge polygon
#@     # (see if compute_polygons works for lists of polygons - avail in icc)
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $polygon [lindex $polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set polygon {}
#@       } else {
#@         set polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $polygon $i] [lindex $polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set polygon [lreplace [lreplace $polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set polygon [lindex [lindex $polygon_info 0] 5]
#@   }
#@ 
#@   if { $check_empty } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $polygon] < 1]
#@   }
#@ 
#@   if { [string equal $option "return_expression"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $polygon
#@   }
#@ 
#@ 
#@   # determine if the polygon is now only a single rectangle
#@   if { [string equal $option "rectangle"] } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr ([llength $polygon]==1) && ([llength [lindex $polygon 0]]==5)]
#@   }
#@ 
#@   # ONLY CHECK remaining is "identical"
#@ 
#@   # simplify other_polygon structure for performing "identical" check
#@   if { [llength [lindex [lindex $polygon_info end] 0]] == 0 } {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@ 
#@     # merge other_polygon
#@     if { ! $simple_polygons } {
#@       # compute_polygons takes a list of polygons
#@       unset -nocomplain in_polygon
#@       redirect /dev/null {
#@         catch {set in_polygon [compute_polygons -boolean or $other_polygon [lindex $other_polygon 0]]}
#@       }
#@       if { [string equal $in_polygon "0"] } {
#@         set other_polygon {}
#@       } else {
#@         set other_polygon $in_polygon
#@       }
#@     } else {
#@       # compute_polygons doesn't take a list of more than 1 polygon
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $other_polygon] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $other_polygon $i] [lindex $other_polygon $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set other_polygon [lreplace [lreplace $other_polygon $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   } else {
#@     set other_polygon [lindex [lindex $polygon_info end] 5]
#@   }
#@ 
#@   # simple check is if one empty, then they both must be empty
#@   if { ([llength $polygon] == 0) && ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 1
#@   } elseif { ([llength $polygon] == 0) || ([llength $other_polygon] == 0) } {
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return 0
#@   }
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   if { ! $simple_polygons } {
#@     # compute_polygons takes a list of polygons
#@     unset -nocomplain xor_polygon
#@     redirect /dev/null {
#@       catch {set xor_polygon [compute_polygons -boolean xor $polygon $other_polygon]}
#@     }
#@     if { $xor_polygon == "0" } {
#@       set xor_polygon {}
#@     }
#@ 
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return [expr [llength $xor_polygon] == 0]
#@   }
#@ 
#@   # otherwise to be identical,
#@   # each piece of polygon must have a corresponding piece of other_polygon
#@   foreach shape $polygon {
#@     set poly_and {}
#@     set poly_xor $polygon
#@     for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@       set other_shape [lindex $other_polygon $i]
#@       set poly_and [compute_polygons -boolean and $shape $other_shape]
#@       if { [llength $poly_and] != 0 } {
#@         set poly_xor [compute_polygons -boolean xor $shape $other_shape]
#@         break
#@       }
#@     }
#@     if { [llength $poly_xor] != 0 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return 0
#@     }
#@     set other_polygon [lreplace $other_polygon $i $i]
#@   }
#@ 
#@   # polygon is identical if no remaining portions of other_polygon to match
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return [expr [llength $other_polygon] == 0]
#@ 
#@ }
#@ define_proc_attributes adv_polygon_check     -info "check condition 'option' on polygon"     -define_args {
#@       {option "check option" option one_of_string { required value_help {values { simple complex defined_set rectArray compressed polygon empty rectangle identical }}}}
#@       {polygon "polygon" polygon string required}
#@       {other_polygon "second polygon -> only used for identical check" other_polygon string optional}}
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : adv_polygon_get #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  adv_polygon_get
#@ # __description:  get 'option' from polygon
#@ #                 polygon can be polygon_set, simple polygon, complex polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result --- (dependent on option: float or (list of) rectangle
#@ #                       area       = return area of the polygon
#@ #                       bound      = return bounding rectangle of the polygon
#@ #                       rectangles = return list of rectangles of the polygon
#@ # __required_args:  option (one of): area bbox bound rectangles
#@ #                   polygon:         polygon_set, simple or complex polygon
#@ # __optional_args:  -size
#@ #                   if size, then post size the rectangles
#@ #                   (i.e. using 'size' can create overlaps or gaps)
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc adv_polygon_get { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # check size argument to see if valid
#@   if { [info exists inputs(-size)] } {
#@     set size $inputs(-size)
#@     # allow for separate x,y size
#@     # if only a single value, then x,y default to that value
#@     set xsize [lindex $size 0]
#@     set ysize [lindex $size end]
#@     if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@       P_msg_error "$func_name: size value \"$size\" is not a float or pair of floats."
#@       unset size xsize ysize
#@     }
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     P_msg_error "'${func_name} $option': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # perform area calculation if "area" option, return result
#@   if { [string equal $option "area"] } {
#@     set area 0.0
#@ 
#@     # see if polygon lists are accepted or only simple polygons
#@     redirect -variable get_polygon_area_help {get_polygon_area -help}
#@     set simple_polygons [regexp -- {points list of } $get_polygon_area_help]
#@ 
#@     if { $simple_polygons } {
#@       foreach poly_segment $polygon {
#@         set area [expr $area + [get_polygon_area $poly_segment]]
#@       }
#@     } elseif { [llength $polygon] > 0 } {
#@       set area [expr $area + [get_polygon_area $polygon]]
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     return $area
#@   }
#@ 
#@   # perform bound check if "bound" option, return resulting rectangle
#@   if { [string equal $option "bbox"] || [string equal $option "bound"] } {
#@     # see if polygon is empty
#@     if { [llength $polygon] < 1 } {
#@       set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@       return {}
#@     }
#@ 
#@     set joined_polygon [join $polygon]
#@ 
#@     # get x extents using a list sort
#@     set x_sort [lsort -index 0 -increasing -real $joined_polygon]
#@     set xll [lindex [lindex $x_sort 0] 0]
#@     set xur [lindex [lindex $x_sort end] 0]
#@ 
#@     # get y extents using a list sort
#@     set y_sort [lsort -index 1 -increasing -real $joined_polygon]
#@     set yll [lindex [lindex $y_sort 0] 1]
#@     set yur [lindex [lindex $y_sort end] 1]
#@ 
#@     # optionally size the box
#@     if { [info exists xsize] && [info exists ysize] } {
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@         return {}
#@       }
#@     }
#@     set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@     if { [string equal $option "bbox"] } {
#@       return [list [list $xll $yll] [list $xur $yur]]
#@     } else {
#@       return [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@   }
#@ 
#@   ### only option left is "rectangles"
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable convert_from_polygon_help {convert_from_polygon -help}
#@   set simple_polygons [regexp -- {points list of } $convert_from_polygon_help]
#@ 
#@   # create list of rectangles
#@   if { $simple_polygons } {
#@     set rectangles {}
#@     foreach poly_segment $polygon {
#@       foreach rect [convert_from_polygon -format polygon $poly_segment] {
#@         lappend rectangles $rect
#@       }
#@     }
#@   } else {
#@     if { [llength $polygon] == 0 } {
#@       set rectangles {}
#@     } else {
#@       set rectangles [convert_from_polygon -format polygon $polygon]
#@     }
#@     if { $rectangles == "0" } {
#@       set rectangles {}
#@     }
#@   }
#@ 
#@   # optionally size the box
#@   if { [info exists xsize] && [info exists ysize] } {
#@     set sized_rects {}
#@     foreach rect $rectangles {
#@       set x_sort [lsort -index 0 -increasing -real $rect]
#@       set xll [lindex [lindex $x_sort 0] 0]
#@       set xur [lindex [lindex $x_sort end] 0]
#@       set y_sort [lsort -index 1 -increasing -real $rect]
#@       set yll [lindex [lindex $y_sort 0] 1]
#@       set yur [lindex [lindex $y_sort end] 1]
#@ 
#@       # apply sizing
#@       set xll [expr $xll - $xsize]
#@       set yll [expr $yll - $ysize]
#@       set xur [expr $xur + $xsize]
#@       set yur [expr $yur + $ysize]
#@       if { ($xll >= $xur) | ($yll >= $yur) } {
#@         continue
#@       }
#@       lappend  sized_rects [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@     }
#@     set rectangles $sized_rects
#@   }
#@ 
#@   # return list of rectangles
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   return $rectangles
#@ 
#@ }
#@ define_proc_attributes adv_polygon_get     -info "get 'option' information from polygon"     -define_args {
#@       {option "get option" option one_of_string { required value_help {values { area bbox bound rectangles }}}}
#@       {polygon "polygon" polygon string required}
#@       {"-size" "size (+grow / -shrink)" "" string optional}}
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : adv_polygon_logic #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  adv_polygon_logic
#@ # __description:  perform logic 'option' between polygons
#@ #                 polygons can be polygon_set, simple polygon, complex polygon,
#@ #                                 rectArray, compressed polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result --- (written to polygon, unless -list)
#@ #                       copy    = copy polygon_b to polygon_a
#@ #                       or      = logical "OR"  => polygon_a or  polygon_b
#@ #                       and     = logical "AND" => polygon_a and polygon_b
#@ #                       not     = logical "NOT" => polygon_a not polygon_b
#@ #                       xor     = logical "XOR" => polygon_a xor polygon_b
#@ #                       select  = select polygon_a which overlaps polygon_b
#@ # __required_args:  option (one of): copy or and not xor select
#@ #                   polygon_a: polygon_set, simple/complex/compressed polygon,
#@ #                              or rectArray
#@ #                   polygon_b: polygon_set, simple/complex/compressed polygon,
#@ #                              or rectArray
#@ # __optional_args:  -list
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc adv_polygon_logic { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set operation $inputs(operation)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   set copy_set   [string equal $operation "copy"]
#@   set or_set     [string equal $operation "or"]
#@   set and_set    [string equal $operation "and"]
#@   set not_set    [string equal $operation "not"]
#@   set xor_set    [string equal $operation "xor"]
#@   set select_set [string equal $operation "select"]
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon_a)])]
#@   if { $copy_set && $return_expression } {
#@     P_msg_error "'$func_name copy': polygon \"$inputs(polygon_a)\" is not a defined_set."
#@   } else {
#@     set return_expression [expr $return_expression || [info exists inputs(-list)]]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {adv_polygon_check polygon $inputs(polygon_a) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_a)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_a)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_a)"
#@     }
#@     P_msg_error "'${func_name} $operation': polygon_a \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@   set bad_polygon [catch {adv_polygon_check polygon $inputs(polygon_b) -list} other_polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon_b)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon_b)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon_b)"
#@     }
#@     P_msg_error "'${func_name} $operation': polygon_b \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # return if copy
#@   if { $copy_set } {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $other_polygon
#@     return {}
#@   }
#@ 
#@   # do simple cases where either polygon is empty
#@   unset -nocomplain final_polygon
#@   if { [llength $polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon {}
#@     } elseif { $xor_set } {
#@       set final_polygon $other_polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   } elseif { [llength $other_polygon] == 0 } {
#@     if { $or_set } {
#@       set final_polygon $polygon
#@     } elseif { $and_set } {
#@       set final_polygon {}
#@     } elseif { $not_set } {
#@       set final_polygon $polygon
#@     } elseif { $xor_set } {
#@       set final_polygon $polygon
#@     } elseif { $select_set } {
#@       set final_polygon {}
#@     }
#@   }
#@   if { [info exists final_polygon] } {
#@     if { $return_expression } {
#@       return $final_polygon
#@     } else {
#@       set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@       return {}
#@     }
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # see if polygon lists are accepted or only simple polygons
#@   redirect -variable compute_polygons_help {compute_polygons -help}
#@   set simple_polygons [regexp -- {points list of } $compute_polygons_help]
#@ 
#@ 
#@   # first see if compute_polygons works for lists of polygons
#@   # can do all operations except select which requires 2 steps
#@   unset -nocomplain final_polygon
#@   if { $select_set } { set op "and" } else { set op $operation }
#@   unset -nocomplain or_polygon
#@ 
#@   if { ! $simple_polygons } {
#@     redirect /dev/null {
#@       catch {set final_polygon [compute_polygons -boolean $op $polygon $other_polygon]}
#@     }
#@     if { (! [info exists final_polygon]) || [string equal $final_polygon "0"] } {
#@       # compute_polygons didn't take the list of polygons
#@       set final_polygon {}
#@     } elseif { $select_set } {
#@       if { [llength $final_polygon] < [llength $other_polygon] } {
#@         set other_polygon $final_polygon
#@       }
#@       unset -nocomplain final_polygon
#@     }
#@   }
#@ 
#@   # perform OR operation if needed ("or" & "xor")
#@   set or_polygon {}
#@   if { [info exists final_polygon] } {
#@     set or_polygon $final_polygon
#@   } elseif { $or_set || $xor_set } {
#@     set or_polygon [concat $polygon $other_polygon]
#@     # merge or_polygon
#@     for { set i 0 } { $i < [llength $or_polygon] } {incr i} {
#@       for { set j [expr $i + 1] } { $j < [llength $or_polygon] } {incr j} {
#@         set new [compute_polygons -boolean or [lindex $or_polygon $i] [lindex $or_polygon $j]]
#@         if { [llength $new] > 1 } {
#@           continue
#@         }
#@         set or_polygon [lreplace [lreplace $or_polygon $i $i [lindex $new 0]] $j $j]
#@         incr i -1
#@         break
#@       }
#@     }
#@   }
#@ 
#@   # perform AND operation if needed ("and" "not" "xor" "select")
#@   set and_polygon {}
#@   set select_polygon {}
#@   if { [info exists final_polygon] } {
#@     set and_polygon $final_polygon
#@   } elseif { $select_set && (! $simple_polygons) } {
#@     if { [llength $other_polygon] != 0 } {
#@       # evaluating select in subsets of from 20-50 tend to give best runtimes
#@       set incr_value 30
#@       for { set i 0 } { $i < [llength $polygon] } { incr i $incr_value } {
#@         set sub_range [lrange $polygon $i [expr $i + $incr_value]]
#@         set sub_range_and [compute_polygons -boolean and $sub_range $other_polygon]
#@         if { ($sub_range_and == "0") || ([llength $sub_range_and] == 0) } {
#@           # no intersection, skip this subset of polygons
#@           continue
#@         } elseif { [llength $sub_range] == 1 } {
#@           lappend select_polygon [lindex $sub_range 0]
#@           continue
#@         } elseif { [llength $sub_range_and] > [llength $other_polygon] } {
#@           # try to minimize the number of shapes being worked with
#@           set sub_range_and $other_polygon
#@         }
#@         foreach shape $sub_range {
#@           set shape_and [compute_polygons -boolean and $shape $sub_range_and]
#@           if { ($shape_and != "0") && ([llength $shape_and] != 0) } {
#@             lappend select_polygon $shape
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $and_set || $not_set || $xor_set || $select_set } {
#@     foreach shape $polygon {
#@       set poly_and {}
#@       for { set i 0 } { $i < [llength $other_polygon] } {incr i} {
#@         set other_shape [lindex $other_polygon $i]
#@         set poly_and [compute_polygons -boolean and $shape $other_shape]
#@         if { [llength $poly_and] != 0 } {
#@           if { $select_set } {
#@             lappend select_polygon $shape
#@             break
#@           } else {
#@             foreach and_item $poly_and {
#@               lappend and_polygon $and_item
#@             }
#@           }
#@         }
#@       }
#@     }
#@   } elseif { $or_set } {
#@     set and_polygon $or_polygon
#@   }
#@ 
#@   # perform NOT operation if needed ("not" "xor")
#@   if { (! [info exists final_polygon]) && ($not_set || $xor_set) } {
#@     if { $not_set } {
#@       set final_polygon $polygon
#@       set not_polygon   $other_polygon
#@     } else {
#@       set final_polygon $or_polygon
#@       set not_polygon   $and_polygon
#@     }
#@     foreach other_shape $not_polygon {
#@       set new_final_polygon {}
#@       foreach shape $final_polygon {
#@         foreach not_poly [compute_polygons -boolean not $shape $other_shape] {
#@           lappend new_final_polygon $not_poly
#@         }
#@       }
#@       set final_polygon $new_final_polygon
#@     }
#@   } elseif { $or_set } {
#@     set final_polygon $or_polygon
#@   } elseif { $select_set } {
#@     set final_polygon $select_polygon
#@   } elseif { $and_set } {
#@     set final_polygon $and_polygon
#@   } elseif { ! [info exists final_polygon] } {
#@     set final_polygon {}
#@   }
#@ 
#@   # return polygon or set value in defined_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final_polygon
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon_a) $final_polygon
#@     return {}
#@   }
#@ 
#@ }
#@ define_proc_attributes adv_polygon_logic     -info "perform logic 'operation' between polygons"     -define_args {
#@       {operation "logic operation" operation one_of_string { required value_help {values { copy or and not xor select }}}}
#@       {polygon_a "polygon_a" polygon_a string required}
#@       {polygon_b "polygon_b" polygon_b string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : adv_polygon_report #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  adv_polygon_report
#@ # __description:  print existing polygon_sets and segments in each
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ # __required_args:
#@ # __optional_args:
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc adv_polygon_report { args } {
#@   if { [llength $args] != 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set poly_namespace ::polygon_ops::polygon_sets
#@ 
#@   namespace eval $poly_namespace { }
#@   namespace eval ::polygon_ops { }
#@   set namespace_len [string length ${poly_namespace}::]
#@ 
#@   # get list of all polygon variables
#@   set all_polygons {}
#@   set max_name_length 0
#@   set max_number_shapes 0
#@   set max_number_segments 0
#@   foreach polygon_var [info vars ${poly_namespace}::*] {
#@     set polygon_name [string range $polygon_var $namespace_len end]
#@     set name_length [string length $polygon_name]
#@     if { $name_length > $max_name_length } {
#@       set max_name_length $name_length
#@     }
#@     if { [regexp {::} $polygon_name] } {
#@       # ignore - extra :: indicates object is part of a nested namespace
#@       continue
#@     }
#@     set polygon [expr $$polygon_var]
#@ 
#@     # step through to count segments
#@     set segment_count 0
#@     foreach shape $polygon {
#@       set segment_count [expr $segment_count + [llength $shape] - 1]
#@     }
#@     if { $segment_count == 0 } {
#@       set shape_count 0
#@     } else {
#@       set shape_count [llength $polygon]
#@     }
#@     if { $shape_count > $max_number_shapes } {
#@       set max_number_shapes $shape_count
#@     }
#@     if { $segment_count > $max_number_segments } {
#@       set max_number_segments $segment_count
#@     }
#@     lappend all_polygons [list $polygon_name $shape_count $segment_count]
#@   }
#@ 
#@   # format report
#@   if { $max_name_length < 4 } {
#@     set max_name_length 4
#@   }
#@   if { $max_number_shapes > 0 } {
#@     set shape_string_length [expr int(log10($max_number_shapes)) + 1]
#@   } else {
#@     set shape_string_length 1
#@   }
#@   if { $shape_string_length < 6 } {
#@     set shape_string_length 6
#@   }
#@   if { $max_number_segments > 0 } {
#@     set segment_string_length [expr int(log10($max_number_segments)) + 1]
#@   } else {
#@     set segment_string_length 1
#@   }
#@   if { $segment_string_length < 8 } {
#@     set segment_string_length 8
#@   }
#@   set dash_string "----------------------------------------"
#@   puts "======== Polygon Report ========"
#@   puts [format "%-${max_name_length}s  %${shape_string_length}s  %${segment_string_length}s" name shapes segments]
#@   puts -nonewline "[string range $dash_string 1 $max_name_length]  "
#@   puts -nonewline "[string range $dash_string 1 $shape_string_length]  "
#@   puts "[string range $dash_string 1 $segment_string_length]"
#@   foreach item $all_polygons {
#@     set name   [lindex $item 0]
#@     set shapes [lindex $item 1]
#@     set count  [lindex $item 2]
#@     puts [format "%-${max_name_length}s  %${shape_string_length}d  %${segment_string_length}d" $name $shapes $count]
#@   }
#@   puts ""
#@ 
#@   return
#@ 
#@ }
#@ define_proc_attributes adv_polygon_report     -info "print existing polygon_sets and segments in each"
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : adv_polygon_set #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  adv_polygon_set
#@ # __description:  set 'option' of polygon
#@ #                 polygon can be polygon_set only
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                 result --- {}
#@ #                       clear      = clear contents of polygon
#@ #                       create     = create polygon, clear contents
#@ #                       delete     = remove polygon
#@ #                       delete_all = remove all polygons
#@ # __required_args:  option (one of): clear create delete delete_all
#@ #                   polygon:         polygon_set (ignored for delete_all)
#@ # __optional_args:
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc adv_polygon_set { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   set option $inputs(option)
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   if { [llength $inputs(polygon)] == 0 } {
#@     P_msg_error "'$func_name $option': no polygon specified (empty list)"
#@   }
#@ 
#@   set missing_polygon {}
#@   foreach polygon $inputs(polygon) {
#@     if { ! [info exists ::polygon_ops::polygon_sets::$polygon] } {
#@       lappend missing_polygon $polygon
#@     }
#@   }
#@ 
#@   if { [string equal $option "delete_all"] } {
#@     namespace delete ::polygon_ops::polygon_sets
#@     namespace eval ::polygon_ops::polygon_sets { }
#@   } elseif { (! [string equal $option "create"]) && ([llength $missing_polygon] > 0) } {
#@     # print a warning - the polygon_set(s) don't exist
#@     if { [llength $missing_polygon] == 1 } {
#@       P_msg_error "'$func_name $option': polygon \"$missing_polygon\" is not a valid polygon."
#@     } else {
#@       P_msg_error "'$func_name $option': polygons \{$missing_polygon\} are not valid polygons."
#@     }
#@   } elseif { [string equal $option "delete"] } {
#@     foreach polygon $inputs(polygon) {
#@       unset ::polygon_ops::polygon_sets::$polygon
#@     }
#@   } else {
#@     foreach polygon $inputs(polygon) {
#@       set ::polygon_ops::polygon_sets::$polygon {}
#@     }
#@   }
#@ 
#@   return {}
#@ 
#@ }
#@ define_proc_attributes adv_polygon_set     -info "set 'option' of polygon"     -define_args {
#@       {option "set option" option one_of_string { required value_help {values { clear create delete delete_all}}}}
#@       {polygon "polygon (can be a list of polygons)" polygon string required}}
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : adv_polygon_size #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  adv_polygon_size
#@ # __description:  grow/shrink a polygon
#@ #                 polygon can be polygon_set, simple polygon, complex polygon,
#@ #                                rectArray, compressed polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result --- (written to polygon, unless -list)
#@ # __required_args:  polygon:  polygon_set, simple/complex/compressed polygon,
#@ #                             or rectArray
#@ #                   size:     single or list (x y) pair of float
#@ # __optional_args:  -list
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc adv_polygon_size { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon)]) || [info exists inputs(-list)]]
#@ 
#@   # get size argument, see if valid
#@   set size $inputs(size)
#@ 
#@   # allow for separate x,y size
#@   # if only a single value, then x,y default to that value
#@   set xsize [lindex $size 0]
#@   set ysize [lindex $size end]
#@   if { ([llength $size] > 2) || (! [string is double $xsize]) || (! [string is double $ysize]) } {
#@     P_msg_error "$func_name: size value \"$size\" is not a float or pair of floats."
#@     unset size xsize ysize
#@   }
#@ 
#@   set no_sizing 0
#@   set single_resize 1
#@   set directional_resize 0
#@   if { $xsize == $ysize } {
#@     set simple_size 1
#@     set size $xsize
#@     if { $xsize == 0 } {
#@       set no_sizing 1
#@     } else {
#@       redirect -variable resize_help {resize_polygon -help}
#@       set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     }
#@   } else {
#@     set simple_size 0
#@     redirect -variable resize_help {resize_polygon -help}
#@     set single_resize [regexp -- {points list of a polygon} $resize_help]
#@     set directional_resize [regexp -- {-size_left} $resize_help]
#@   }
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     P_msg_error "'${func_name}': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # suppress message MWUI-087 when downsizing removes a polygon
#@   set no_MWUI_087_suppress 0
#@   if { (! $single_resize) && (($xsize < 0) || ($ysize < 0)) } {
#@     redirect -variable suppress_chk_str {print_suppressed_messages}
#@     if { [lsearch -exact [split [regsub -all {[\{\},\s]+} $suppress_chk_str { }]] {MWUI-087}] == -1 } {
#@       set no_MWUI_087_suppress 1
#@       suppress_message {MWUI-087}
#@     }
#@   }
#@ 
#@   # go through sizing scenarios
#@   if { $no_sizing || ([llength $polygon] < 1) } {
#@     # no sizing or no polygon - nothing to do
#@     set final $polygon
#@   } elseif { $simple_size && $single_resize } {
#@     # use simple sizing function
#@     set final {}
#@     foreach shape $polygon {
#@       foreach sized_poly [resize_polygon -size $size $shape] {
#@         # ensure a valid polygon was returned
#@         # - some Synopsys versions return '0' rather than {} if empty
#@         if { [llength $sized_poly] > 3 } {
#@           lappend final $sized_poly
#@         }
#@       }
#@     }
#@   } elseif { $simple_size } {
#@     set final [resize_polygon -size $size $polygon]
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } elseif { $directional_resize } {
#@     if { (($xsize < 0) && ($ysize < 0)) || (($xsize > 0) && ($ysize > 0)) } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize -size_top $ysize -size_bottom $ysize $polygon]
#@     } elseif { $ysize < 0 } {
#@       set pre_final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $xsize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_left $xsize -size_right $xsize $pre_final]
#@       }
#@     } elseif { $xsize < 0 } {
#@       set pre_final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@       if { $no_MWUI_087_suppress } {
#@         set no_MWUI_087_suppress 0
#@         unsuppress_message {MWUI-087}
#@       }
#@       if { ($pre_final == 0) || ([llength $pre_final] == 0) } {
#@         set final {}
#@       } elseif { $ysize == 0 } {
#@         set final $pre_final
#@       } else {
#@         set final [resize_polygon -size_top $ysize -size_bottom $ysize $pre_final]
#@       }
#@     } elseif { $ysize == 0 } {
#@       set final [resize_polygon -size_left $xsize -size_right $xsize $polygon]
#@     } elseif { $xsize == 0 } {
#@       set final [resize_polygon -size_top $ysize -size_bottom $ysize $polygon]
#@     } else {
#@       set final $polygon
#@     }
#@     if { $final == 0 } {
#@       set final {}
#@     }
#@   } else {
#@     # first perform any necessary shrink
#@     if { ($xsize < 0) || ($ysize < 0) } {
#@       # to avoid issues with breaking apart during shrink,
#@       # the shrink is done as an inverse image using a grow
#@       #   expand_bound = (expand BOUND(polygon) by size)
#@       #   shrink_poly = expand_bound NOT
#@       #         (expand (poly_to_rects(expand_bound NOT polygon)) by shrink)
#@       set shrunk_poly {}
#@ 
#@       # expand by 0.1 more than smallest negative value
#@       set ovrsize [expr ($xsize < $ysize) ? (0.1 - $xsize) : (0.1 - $ysize)]
#@       set rect_shrink_factor_x [expr ($xsize<0) ?  abs($xsize) : 0]
#@       set rect_shrink_factor_y [expr ($ysize<0) ?  abs($ysize) : 0]
#@ 
#@       foreach shape $polygon {
#@         # get x extents using a list sort
#@         set x_sort [lsort -index 0 -increasing -real $shape]
#@         set xll [expr [lindex [lindex $x_sort 0] 0] - $ovrsize]
#@         set xur [expr [lindex [lindex $x_sort end] 0] + $ovrsize]
#@ 
#@         # get y extents using a list sort
#@         set y_sort [lsort -index 1 -increasing -real $shape]
#@         set yll [expr [lindex [lindex $y_sort 0] 1] - $ovrsize]
#@         set yur [expr [lindex [lindex $y_sort end] 1] + $ovrsize]
#@ 
#@         set expand_bound [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         set inv_polygon [compute_polygons -boolean not $expand_bound $shape]
#@ 
#@         # create inverse sized polygon
#@         set inv_sized_polygon {}
#@         foreach inv_shape $inv_polygon {
#@           foreach rect [convert_from_polygon -format polygon $inv_shape] {
#@             # get x extents using a list sort
#@             set x_sort [lsort -index 0 -increasing -real $rect]
#@             set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_shrink_factor_x]
#@             set xur [expr [lindex [lindex $x_sort end] 0] + $rect_shrink_factor_x]
#@ 
#@             # get y extents using a list sort
#@             set y_sort [lsort -index 1 -increasing -real $rect]
#@             set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_shrink_factor_y]
#@             set yur [expr [lindex [lindex $y_sort end] 1] + $rect_shrink_factor_y]
#@ 
#@             lappend inv_sized_polygon [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@           }
#@         }
#@ 
#@         # merge inverse sized polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain merge_polygon
#@         redirect /dev/null {
#@           catch {set merge_polygon [compute_polygons -boolean or $inv_sized_polygon [lindex $inv_sized_polygon 0]]}
#@         }
#@         if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set inv_sized_polygon $merge_polygon
#@           unset -nocomplain merge_polygon
#@         } else {
#@           for { set i 0 } { $i < [llength $inv_sized_polygon] } {incr i} {
#@             for { set j [expr $i + 1] } { $j < [llength $inv_sized_polygon] } {incr j} {
#@               set new [compute_polygons -boolean or [lindex $inv_sized_polygon $i] [lindex $inv_sized_polygon $j]]
#@               if { [llength $new] > 1 } {
#@                 continue
#@               }
#@               set inv_sized_polygon [lreplace [lreplace $inv_sized_polygon $i $i [lindex $new 0]] $j $j]
#@               incr i -1
#@               break
#@             }
#@           }
#@         }
#@ 
#@         # re-invert the polygon
#@         # first see if compute_polygons works for lists of polygons
#@         unset -nocomplain re_inv_polygon
#@         redirect /dev/null {
#@           catch {set re_inv_polygon [compute_polygons -boolean not [list $expand_bound] $inv_sized_polygon]}
#@         }
#@         if { [info exists re_inv_polygon] && (! [string equal $re_inv_polygon "0"]) } {
#@           # compute_polygons took the list of polygons
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         } else {
#@           set re_inv_polygon [list $expand_bound]
#@           foreach inv_shape $inv_sized_polygon {
#@             set new_shrink {}
#@             foreach re_shape $re_inv_polygon {
#@               foreach poly_not [compute_polygons -boolean not $re_shape $inv_shape] {
#@                 lappend new_shrink $poly_not
#@               }
#@             }
#@             set re_inv_polygon $new_shrink
#@           }
#@           set shrunk_poly [concat $shrunk_poly $re_inv_polygon]
#@         }
#@       }
#@     } else {
#@       set shrunk_poly $polygon
#@     }
#@ 
#@     # then perform any necessary grow
#@     set final {}
#@     if { ($xsize > 0) || ($ysize > 0) } {
#@       # the grow is a directional grow on the rectangles of the polygon
#@       set rect_grow_factor_x [expr ($xsize>0) ?  $xsize : 0]
#@       set rect_grow_factor_y [expr ($ysize>0) ?  $ysize : 0]
#@ 
#@       foreach shape $shrunk_poly {
#@         foreach rect [convert_from_polygon -format polygon $shape] {
#@           # get x extents using a list sort
#@           set x_sort [lsort -index 0 -increasing -real $rect]
#@           set xll [expr [lindex [lindex $x_sort 0] 0] - $rect_grow_factor_x]
#@           set xur [expr [lindex [lindex $x_sort end] 0] + $rect_grow_factor_x]
#@ 
#@           # get y extents using a list sort
#@           set y_sort [lsort -index 1 -increasing -real $rect]
#@           set yll [expr [lindex [lindex $y_sort 0] 1] - $rect_grow_factor_y]
#@           set yur [expr [lindex [lindex $y_sort end] 1] + $rect_grow_factor_y]
#@ 
#@           lappend final [list [list $xll $yll] [list $xur $yll] [list $xur $yur] [list $xll $yur] [list $xll $yll]]
#@         }
#@       }
#@     } else {
#@       set final $shrunk_poly
#@     }
#@   }
#@ 
#@   if { $no_MWUI_087_suppress } {
#@     set no_MWUI_087_suppress 0
#@     unsuppress_message {MWUI-087}
#@   }
#@ 
#@   # merge final polygons
#@   if { ! $no_sizing } {
#@     # first see if compute_polygons works for lists of polygons
#@     unset -nocomplain merge_polygon
#@     redirect /dev/null {
#@       catch {set merge_polygon [compute_polygons -boolean or $final [lindex $final 0]]}
#@     }
#@     if { [info exists merge_polygon] && (! [string equal $merge_polygon "0"]) } {
#@       # compute_polygons took the list of polygons
#@       set final $merge_polygon
#@       unset -nocomplain merge_polygon
#@     } else {
#@       # compute_polygons didn't take the list of polygons
#@       for { set i 0 } { $i < [llength $final] } {incr i} {
#@         for { set j [expr $i + 1] } { $j < [llength $final] } {incr j} {
#@           set new [compute_polygons -boolean or [lindex $final $i] [lindex $final $j]]
#@           if { [llength $new] > 1 } {
#@             continue
#@           }
#@           set final [lreplace [lreplace $final $i $i [lindex $new 0]] $j $j]
#@           incr i -1
#@           break
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # return result or assign to polygon_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon) $final
#@     return {}
#@   }
#@ 
#@ }
#@ define_proc_attributes adv_polygon_size     -info "grow/shrink polygon"     -define_args {
#@       {polygon "polygon" polygon string required}
#@       {"size" "size {+grow / -shrink} float or list {x y} of float" "" string required}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : adv_polygon_xform #{{{
#@ # Description :
#@ #-------------------------------------------------------------------
#@ # __start
#@ # __author: jeheidem
#@ # __proc:  adv_polygon_xform
#@ # __description:  transform a polygon between coordinate sets
#@ #                 polygons can be polygon_set, simple polygon, complex polygon,
#@ #                                 rectArray, compressed polygon
#@ #                 where polygon_set = defined by variable in
#@ #                                         namespace ::polygon_ops::polygon_sets
#@ #                       simple polygon = list of points with either X or Y
#@ #                                        changing on each point (not both)
#@ #                                        which ends at the starting point
#@ #                       complex polygon = a list of simple polygons
#@ #                       rectArray = a single list of coordinates for ll,ur
#@ #                                   of rectangles forming a polygon.
#@ #                                   i.e. {ll_1 ur_1 ll_2 ur_2 ... }
#@ #                                   where each ll,ur is composed of {x y}
#@ #                       compressed polygon = a simple polygon or single list
#@ #                                            of a complex polygon,
#@ #                                            i.e. join {complex_polygon}
#@ #                 result --- (written to polygon, unless -list)
#@ # __required_args:  polygon:  polygon_set, simple/complex/compressed polygon,
#@ #                             or rectArray
#@ #                   x:        float, x offset
#@ #                   y:        float, y offset
#@ #                   rotation (one of):  N S W E FN FS FW FE
#@ # __optional_args:  -inverse  -list
#@ # __end
#@ #-------------------------------------------------------------------
#@ proc adv_polygon_xform { args } {
#@   if { [llength $args] == 0 } {
#@     parse_proc_arguments -args "-help" inputs
#@   }
#@   parse_proc_arguments -args $args inputs
#@   set func_name [string range [lindex [info level [info level]] 0] 2 end]
#@ 
#@   namespace eval ::polygon_ops { }
#@   namespace eval ::polygon_ops::polygon_sets { }
#@ 
#@   # return an expression if -list given or polygon is not a defined_set
#@   set return_expression [expr (! [info exists ::polygon_ops::polygon_sets::$inputs(polygon)]) || [info exists inputs(-list)]]
#@ 
#@   # get transform x,y,rotation
#@   set x_offset $inputs(x)
#@   set y_offset $inputs(y)
#@   set rotation $inputs(rotation)
#@ 
#@   # check for -inverse flag
#@   set inverse [info exists inputs(-inverse)]
#@ 
#@ 
#@   # parse polygon information
#@   set bad_polygon [catch {adv_polygon_check polygon $inputs(polygon) -list} polygon]
#@   if {$bad_polygon != 0} {
#@     if { [string length "$inputs(polygon)"] > 50 } {
#@       regexp {(.*)\s\S+} [string range "$inputs(polygon)" 0 49] junk prnt_str
#@       set prnt_str "$prnt_str ..."
#@     } else {
#@       set prnt_str "$inputs(polygon)"
#@     }
#@     P_msg_error "'${func_name}': polygon \"${prnt_str}\" is not a valid polygon."
#@     return {}
#@   }
#@ 
#@   # see if extra_braces are used (is so, temporarily disable)
#@   if { [info exists ::mw_attr_value_extra_braces] } {
#@     set orig_mw_attr_value_extra_braces $::mw_attr_value_extra_braces
#@     set ::mw_attr_value_extra_braces false
#@   } else {
#@     set orig_mw_attr_value_extra_braces true
#@   }
#@ 
#@   # get transform parameters
#@ 
#@   # -----------------------------  -------------------------------------
#@   #     Equivalent rotations          Description
#@   # -----------------------------  -------------------------------------
#@   #  N NE   0                        0 deg. ccw rot
#@   #  W WN  90        CW270 CCW90    90 deg. ccw rot
#@   #  S SW 180        CW180 CCW180  180 deg. ccw rot
#@   #  E ES 270        CW90  CCW270  270 deg. ccw rot
#@   # FN NW   0-mirror FLIPX           0 deg. ccw rot + reflect on y-axis
#@   # FW WS  90-mirror                90 deg. ccw rot + reflect on x-axis
#@   # FS SE 180-mirror FLIPY         180 deg. ccw rot + reflect on y-axis
#@   # FE EN 270-mirror               270 deg. ccw rot + reflect on x-axis
#@   # -----------------------------  -------------------------------------
#@ 
#@   #--------------------------
#@   #- transform descriptions -
#@   #--------------------------
#@   #     -rot-  --------xform---------      ------inv-xform-------
#@   #       N    xt=+xi+xo,   yt=+yi+yo      xi=+xt-xo,   yt=+yf-yo
#@   #       S    xt=-xi+xo,   yt=-yi+yo      xi=-xt+xo,   yt=-yf+yo
#@   #       W    xt=-yi+xo,   yt=+xi+yo      xi=+yt-yo,   yt=-xf+xo
#@   #       E    xt=+yi+xo,   yt=-xi+yo      xi=-yt+yo,   yt=+xf-xo
#@   #      FN    xt=-xi+xo,   yt=+yi+yo      xi=-xt+xo,   yt=+yf-yo
#@   #      FS    xt=+xi+xo,   yt=-yi+yo      xi=+xt-xo,   yt=-yf+yo
#@   #      FW    xt=-yi+xo,   yt=-xi+yo      xi=-yt+yo,   yt=-xf+xo
#@   #      FE    xt=+yi+xo,   yt=+xi+yo      xi=+yt-yo,   yt=+xf-xo
#@   #
#@   #      where   xt,yt  = x,y tranformed
#@   #              xi,yi  = x,y initial
#@   #              xo,yo  = x,y offset
#@   #
#@ 
#@   switch -exact -- $rotation {
#@     0       -
#@     NE      -
#@     N       {
#@       set t {{{+1 0 +1 0} {0 +1 0 +1}} {{+1 0 -1 0} {0 +1 0 -1}}}
#@     }
#@     CCW180  -
#@     CW180   -
#@     180     -
#@     SW      -
#@     S       {
#@       set t {{{-1 0 +1 0} {0 -1 0 +1}} {{-1 0 +1 0} {0 -1 0 +1}}}
#@     }
#@     CW270   -
#@     CCW90   -
#@     90      -
#@     WN      -
#@     W       {
#@       set t {{{0 -1 +1 0} {+1 0 0 +1}} {{0 +1 0 -1} {-1 0 +1 0}}}
#@     }
#@     CW90    -
#@     CCW270  -
#@     270     -
#@     ES      -
#@     E       {
#@       set t {{{0 +1 +1 0} {-1 0 0 +1}} {{0 -1 0 +1} {+1 0 -1 0}}}
#@     }
#@     FLIPX   -
#@     0-mirror -
#@     NW      -
#@     FN     {
#@       set t {{{-1 0 +1 0} {0 +1 0 +1}} {{-1 0 +1 0} {0 +1 0 -1}}}
#@     }
#@     FLIPY   -
#@     180-mirror -
#@     SE      -
#@     FS      {
#@       set t {{{+1 0 +1 0} {0 -1 0 +1}} {{+1 0 -1 0} {0 -1 0 +1}}}
#@     }
#@     90-mirror -
#@     WS      -
#@     FW      {
#@       set t {{{0 -1 +1 0} {-1 0 0 +1}} {{0 -1 0 +1} {-1 0 +1 0}}}
#@     }
#@     270-mirror -
#@     EN      -
#@     FE      {
#@       set t {{{0 +1 +1 0} {+1 0 0 +1}} {{0 +1 0 -1} {+1 0 -1 0}}}
#@     }
#@     default {
#@       set error_flag 1
#@     }
#@   }
#@ 
#@   set xform_set [lindex $t $inverse]
#@   foreach {x_xm x_ym x_xo x_yo y_xm y_ym y_xo y_yo} [join [join [join $xform_set]]] { break }
#@ 
#@   set final_x_offset [expr ($x_xo * $x_offset) + ($x_yo * $y_offset)]
#@   set final_y_offset [expr ($y_xo * $x_offset) + ($y_yo * $y_offset)]
#@ 
#@   # now with transform parameters, build the transformed polygon
#@   set final {}
#@   foreach shape $polygon {
#@     set xform_shape {}
#@     foreach {x y} [join $shape] {
#@       set x_xform [expr ($x_xm * $x) + ($x_ym * $y) + $final_x_offset]
#@       set y_xform [expr ($y_xm * $x) + ($y_ym * $y) + $final_y_offset]
#@       lappend xform_shape [list $x_xform $y_xform]
#@     }
#@     lappend final $xform_shape
#@   }
#@ 
#@ 
#@   # return result or assign to polygon_set
#@   set ::mw_attr_value_extra_braces $orig_mw_attr_value_extra_braces
#@   if { $return_expression } {
#@     return $final
#@   } else {
#@     set ::polygon_ops::polygon_sets::$inputs(polygon) $final
#@     return {}
#@   }
#@ 
#@ }
#@ define_proc_attributes adv_polygon_xform     -info "transform a polygon between coordinate sets"     -define_args {
#@       {polygon "polygon" polygon string required}
#@       {x "x offset" x float required}
#@       {y "y offset" y float required}
#@       {rotation "rotation" rotation one_of_string { required value_help {values { N S E W FN FS FE FW NE SW ES WN NW SE EN WS 0 180 270 90 0-mirror 180-mirror 270-mirror 90-mirror CW180 CW90 CW270 FLIPX FLIPY CCW180 CCW270 CCW90 }}}}
#@       {"-inverse" "perform the inverse transform" "" boolean optional}
#@       {"-list" "return polygon list" "" boolean optional}}
#@ #}}}
#@ 
#@ proc apr_query_voltage_pgnet  {default_pwr_net default_gnd_net} {
#@ 
#@   global INTEL_VA_POWER INTEL_VA_GROUND INTEL_AON_POWER
#@ 
#@   # determine if power domains are used in the design
#@   redirect /dev/null {set domains [get_power_domains -hierarchical ] }
#@   # get list of voltage_areas
#@   set va_list {}
#@   foreach_in_collection va [get_voltage_areas] {
#@     set va_name [get_attribute -quiet $va name]
#@     lappend va_list $va_name
#@   }
#@   unset -nocomplain INTEL_VA_POWER INTEL_VA_GROUND INTEL_AON_POWER
#@ 
#@   # determine power & ground nets based on whether domains are present
#@   if { (! [info exists domains]) || ([sizeof_collection $domains]==0) } {
#@     # no power domain is present
#@     # use default power & ground
#@     set INTEL_VA_POWER(DEFAULT_VA) $default_pwr_net
#@     set INTEL_VA_GROUND(DEFAULT_VA) $default_gnd_net
#@     set INTEL_AON_POWER(DEFAULT_VA) $default_pwr_net
#@   } else {
#@     # power domains exist
#@     # determine power & ground supplies for each voltage_area
#@ 
#@     # check power domains for corresponding voltage_area (then pwr/gnd nets)
#@     foreach_in_collection domain $domains {
#@       set domain_name [collection_to_list $domain -no_braces -name_only]
#@       redirect -variable rpt_pd  {report_power_domain $domain}
#@       set va_line [regexp -inline -lineanchor -linestop {^Voltage Area Information:\s+(\S+)} $rpt_pd]
#@ 
#@       if { ! [llength $va_line] } {
#@         continue
#@       } elseif { [string equal "N/A" [lindex $va_line 1]] } {
#@         continue
#@       } else {
#@         set voltage_area [lindex $va_line 1]
#@       }
#@ 
#@       # ensure the voltage_area is defined
#@       if { [lsearch -exact $va_list $voltage_area] < 0 } { continue }
#@ 
#@       # get supply info
#@       set primary_line [regexp -inline -lineanchor -linestop {^Primary:\s+(\S+)(\s+\([^\)]*\))?\s*(\S+)} $rpt_pd]
#@       if { [llength $primary_line] >= 4 } {
#@         set INTEL_VA_POWER($voltage_area) [lindex $primary_line 1]
#@         set INTEL_VA_GROUND($voltage_area) [lindex $primary_line 3]
#@       }
#@       # get AON supply info (if switched)
#@       set switch_line [join [regexp -inline -lineanchor -linestop {^Switch:.*} $rpt_pd]]
#@       if { [llength $switch_line] >= 4 } {
#@         set INTEL_AON_POWER($voltage_area) [lindex $switch_line 2]
#@       } else {
#@         set INTEL_AON_POWER($voltage_area) $INTEL_VA_POWER($voltage_area)
#@       }
#@     }
#@   }
#@ }
#@ 
#@ 
#@ ##########################################################################
#@ # Procedure   : apr_get_va_points
#@ #
#@ # Description : creates a paired (array set) list with voltage_area name
#@ #               and points for the VA.  Corrected for split & nested VA.
#@ #
#@ # Inputs      :
#@ #
#@ # Returns     :
#@ #
#@ # Note        :
#@ #
#@ ##########################################################################
#@ proc apr_get_va_points {args} {
#@   parse_proc_arguments -args $args flag
#@   set func_name [lindex [info level [info level]] 0]
#@ 
#@   # set up error outputs
#@   set puts "puts"
#@   set puts_nnl "puts -nonewline"
#@   set info_stack "\n#INFO-STACK==> $func_name"
#@   set fmt "format \"$puts_nnl \\\"${info_stack}\\n%s-MSG==> \\\" ; $puts \" "
#@   set fmte "format \"$puts \\\"${info_stack} (%s)\\\" ; error \" "
#@ 
#@   # ensure that current_design is open
#@   if { [sizeof_collection [get_mw_cels -quiet -filter {is_open==true}]] == 0 } {
#@     P_msg_error "\"Run stopped ... no cell open.\""
#@     return {}
#@   }
#@   set current_cellname [get_attribute -quiet [current_mw_cel] name]
#@ 
#@   # get die_boundary
#@   set core_area [index_collection [get_core_areas] 0]
#@   set boundary [get_attribute -quiet $core_area boundary]
#@   if { [llength $boundary] == 1 } {
#@     set boundary [lindex $boundary 0]
#@   }
#@ 
#@   # get hierarchy separator
#@   if { [info exists ::hierarchy_separator] } {
#@     set hs $::hierarchy_separator
#@   } else {
#@     set hs "/"
#@   }
#@ 
#@   # get info on voltage_areas
#@   set has_no_va 1
#@   set va_list {}
#@   foreach_in_collection va [get_voltage_areas -quiet -filter "within_ilm==false"] {
#@     set has_no_va 0
#@     set va_name [get_attribute -quiet $va name]
#@     if { [lsearch -exact $va_list $va_name] >= 0 } {
#@       # already got points for the voltage_area
#@       continue
#@     }
#@ 
#@     # break "points" into a list of closed polygons
#@     # each closed polygon is separated by a carriage-return (\n)
#@     set va_points($va_name) {}
#@     set modules_list($va_name) {}
#@     foreach polygon [split [get_attribute -quiet $va points] "\n"] {
#@       foreach and [compute_polygons -boolean and $polygon $boundary] {
#@         lappend va_points($va_name) $and
#@       }
#@     }
#@ 
#@     lappend va_list $va_name
#@   }
#@   # add DEFAULT_VA if no voltage_areas exist
#@   if { [llength $va_list] == 0 } {
#@     set has_no_va 1
#@     set va_name "DEFAULT_VA"
#@     set va_points($va_name) $boundary
#@     set modules_list($va_name) {}
#@     lappend va_list DEFAULT_VA
#@   }
#@   # correct DEFAULT_VA area (can extend to > than core_area that was returned)
#@   if { [info exists va_points(DEFAULT_VA)] } {
#@     set subtract_va_areas {}
#@     foreach va $va_list {
#@       if { [string equal "DEFAULT_VA" $va] } { continue }
#@       foreach pts $va_points($va) {
#@         lappend subtract_va_areas $pts
#@       }
#@     }
#@     set va_points(DEFAULT_VA) [adv_polygon_logic not $boundary $subtract_va_areas]
#@   }
#@ 
#@   # correct all voltage_areas to avoid duplicate points from nested VA
#@   unset -nocomplain modules_list nested_va
#@   # get module names for each VA
#@   foreach va_name $va_list {
#@     set modules_list($va_name) {}
#@     set va [get_voltage_areas -quiet $va_name]
#@     foreach_in_collection module [get_attribute -quiet $va modules] {
#@       set module_ref [get_attribute -quiet $module ref_name]
#@       if { $current_cellname eq $module_ref } {
#@         # this is the default voltage_area
#@         set modules_list($va_name) {}
#@         break
#@       }
#@       lappend modules_list($va_name) [get_attribute -quiet $module full_name]
#@     }
#@   }
#@   # check each VA for nesting
#@   foreach va_name [array names va_points] {
#@     if { (! [info exists modules_list($va_name)]) || ([llength $modules_list($va_name)] == 0) } {
#@       # default voltage_area - already taken care of
#@       continue
#@     }
#@     foreach possible_nested_va_name [array names va_points] {
#@       if { $possible_nested_va_name eq $va_name } {
#@         # ignore same va
#@         continue
#@       }
#@       if { (! [info exists modules_list($possible_nested_va_name)]) || ([llength $modules_list($possible_nested_va_name)] == 0) } {
#@         # default voltage_area - already taken care of
#@         continue
#@       }
#@       foreach module $modules_list($va_name) {
#@         if { [lsearch -glob $modules_list($possible_nested_va_name) "${module}${hs}*"] != -1 } {
#@           lappend nested_va($va_name) $possible_nested_va_name
#@           break
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # check that nested_va are valid (i.e. not recursive)
#@   set recursive_va {}
#@   foreach parent_va_name [array names nested_va] {
#@     foreach nested_va_name $nested_va($parent_va_name) {
#@       if { [info exists nested_va($nested_va_name)] && ([lsearch -exact $nested_va($nested_va_name) $parent_va_name] != -1) } {
#@         lappend recursive_va [lsort [list $nested_va_name $parent_va_name]]
#@       }
#@     }
#@   }
#@   set recursive_va [lsort -unique $recursive_va]
#@   if { [llength $recursive_va] > 0 } {
#@     foreach item $recursive_va {
#@       foreach {va_1 va_2} $item { break }
#@       P_msg_warn "Recursive nested voltage_areas $va_1 and $va_2 detected in design $current_cellname"
#@     }
#@     P_msg_error "Stopping run because of problems with recursive nested voltage_areas"
#@   }
#@ 
#@   # remove the area from the nested_va from the parent_va
#@   foreach parent_va_name [array names nested_va] {
#@     if { ! [info exists va_points($parent_va_name)] } {
#@       # skip if no points exist
#@       continue
#@     }
#@     foreach nested_va_name $nested_va($parent_va_name) {
#@       if { ! [info exists va_points($nested_va_name)] } {
#@         # skip if no points exist
#@         continue
#@       }
#@       set va_points($parent_va_name) [adv_polygon_logic not $va_points($parent_va_name) $va_points($nested_va_name)]
#@     }
#@   }
#@ 
#@   # more thorough check that avoids any voltage_areas that completely overlap
#@   foreach parent_va_name [array names va_points] {
#@     if { ($parent_va_name eq "DEFAULT_VA") || ([llength $va_points($parent_va_name)] == 0) } {
#@       # ignore DEFAULT_VA or empty parent area
#@       continue
#@     }
#@     foreach nested_va_name [array names va_points] {
#@       if { ($nested_va_name eq "DEFAULT_VA") || ($nested_va_name eq $parent_va_name) } {
#@         # ignore DEFAULT_VA and if same VA or no area
#@         continue
#@       }
#@       set nested_area_minus_parent [adv_polygon_logic not $va_points($nested_va_name) $va_points($parent_va_name)]
#@       if { [llength $nested_area_minus_parent] == 0 } {
#@         # the nested area is completely inside the parent VA
#@         # remove the nested area from the parent
#@         set va_points($parent_va_name) [adv_polygon_logic not $va_points($parent_va_name) $va_points($nested_va_name)]
#@       }
#@     }
#@   }
#@ 
#@ 
#@   return [array get va_points]
#@ }
#@ 
#@ define_proc_attributes apr_get_va_points     -info "return paired list with voltage_area name/points corrected for split & nested VA"
#@ 
#@ 
#@ #-----------------------------------------------------
#@ #
#@ # Design attribute setting for p1273 for std cell power hookup
#@ #
#@ #-----------------------------------------------------
#@ proc apr_override_design_attributes_for_std_pwrhookup { args } {
#@   parse_proc_arguments -args $args opts
#@   set vccgt $opts(-vcc_name)
#@   set vssgt $opts(-vss_name)
#@ 
#@   # Process attributes
#@   set ::process::techname                   p1273.0
#@ 
#@   if {[info exists INTEL_XN_LIBRARY] && $INTEL_XN_LIBRARY == "1" } {
#@     set ::process::poly_pitch                 0.084
#@   } else {
#@     set ::process::poly_pitch                 0.070
#@   }
#@ 
#@   # General metal and via layer attributes
#@   set ::process::vertical_layers            "m1 m3 m5 m7 m9"  ;# List of vertical layer names
#@ 
#@   # Global power hookup grid (poly grid) attributes
#@   set ::process::pwr_hookup_grid_xl         ""  ;# [Optional] X coordinate of where the poly grid starts. Default is xl of the core
#@   if {[info exists INTEL_XN_LIBRARY] && $INTEL_XN_LIBRARY == "1" } {
#@     set ::process::pwr_hookup_grid_xl [lindex [::process::get_track_location -width 0.056 -layer m1] 0]
#@   } else {
#@     set ::process::pwr_hookup_grid_xl [lindex [::process::get_track_location -width 0.042 -layer m1] 0]
#@   }
#@ 
#@   set ::process::pwr_hookup_grid_xh         ""  ;# [Optional] X offset from die boundary to indicate where the poly grid ends. Default is right halo margin
#@   set ::process::pwr_hookup_grid_pitch      4
#@ 
#@ 
#@   # In the format of [list $pattern1 $pattern2].
#@   # Patterns are defined in the format of {netType netName start pitch flip}
#@   set ::process::pwr_hookup_grid_patterns   [list "power $vccgt 0.399 0.798 0"  "ground $vssgt 0.058 0.798 0" "ground $vssgt 0.740 0.798 1"]  ;# netType netName start pitch flip
#@ 
#@   array unset ::process::metal_pairs_for_via                  ;# Key is via layer name. For each via layer, specify lower layer name and upper layer name as a list
#@   array set ::process::metal_pairs_for_via  [list]
#@   set ::process::metal_pairs_for_via(vcn)   [list gcn m0]
#@   set ::process::metal_pairs_for_via(v0)    [list m0 m1]
#@   set ::process::metal_pairs_for_via(v1)    [list m1 m2]
#@ 
#@   array unset ::process::metal_layer_widths_arr               ;# Default metal width of each layer
#@   array set ::process::metal_layer_widths_arr [list]
#@   set ::process::metal_layer_widths_arr(gcn) 0.032
#@   set ::process::metal_layer_widths_arr(tcn) 0.028
#@   set ::process::metal_layer_widths_arr(m0)  0.028
#@   #HD set ::process::metal_layer_widths_arr(m1)  0.042
#@   if {[info exists INTEL_XN_LIBRARY] && $INTEL_XN_LIBRARY == "1" } {
#@     set ::process::metal_layer_widths_arr(m1)  0.056
#@   } else {
#@     set ::process::metal_layer_widths_arr(m1)  0.042
#@   }
#@ 
#@   set ::process::metal_layer_widths_arr(m2)  0.028
#@   #HD This should handle minlength of gcn ... issue fixed before
#@   array set ::process::metal_layer_minlen_arr [list]
#@   set ::process::metal_layer_minlen_arr(gcn) 0.090
#@ 
#@   # VCC and VSS stack information
#@   set ::process::stacked_metals_for_ground  [list tcn m0 m1]  ;# List of power hookup metal stacks for ground, in layer names
#@   set ::process::stacked_metals_for_power   [list gcn m0 m1]  ;# List of power hookup metal stacks for power, in layer names
#@   set ::process::stacked_vias_for_ground    [list vcn v0 v1]  ;# List of power hookup via stacks for ground, in layer names
#@   set ::process::stacked_vias_for_power     [list vcn v0 v1]  ;# List of power hookup via stacks for power, in layer names
#@ 
#@   if {[info exists INTEL_XN_LIBRARY] && $INTEL_XN_LIBRARY == "1" } {
#@     set ::process::masterVia_for_ground       [list {vcn VCNAX} {v0 VIA0AY} {v1 VIA1F_XN}] ;# List of power hookup metal stacks for ground
#@     set ::process::masterVia_for_power        [list {vcn VCNB} {v0 VIA0BW} {v1 VIA1HL}]   ;# List of via layer and master via pairs
#@     set ::process::via_size_for_ground        [list {vcn 0.042 0.028} {v0 0.056 0.028} {v1 0.036 0.040}] ;# List of {via layer, x dimensions, y dimension of master via} for ground connection
#@     set ::process::via_size_for_power         [list {vcn 0.042 0.046} {v0 0.056 0.046} {v1 0.036 0.074}] ;# List of {via layer, x dimensions, y dimension of master via} for power connection
#@     set ::process::dfm_metal_bridging_gap     0.350 ; # gap size to bridge m0 for dfm
#@   } else {
#@     set ::process::masterVia_for_ground       [list {vcn VCNAX} {v0 VIA0AX} {v1 VIA1F}] ;# List of power hookup metal stacks for ground
#@     set ::process::masterVia_for_power        [list {vcn VCNB} {v0 VIA0B} {v1 VIA1HL}]   ;# List of via layer and master via pairs
#@     set ::process::via_size_for_ground        [list {vcn 0.042 0.028} {v0 0.042 0.028} {v1 0.036 0.040}] ;# List of {via layer, x dimensions, y dimension of master via} for ground connection
#@     set ::process::via_size_for_power         [list {vcn 0.042 0.046} {v0 0.042 0.046} {v1 0.036 0.074}] ;# List of {via layer, x dimensions, y dimension of master via} for power connection
#@     set ::process::dfm_metal_bridging_gap     0.420 ; # gap size to bridge m0 for dfm
#@   }
#@ 
#@ 
#@   # Although vias are stacked, their centers can be slightly offset
#@   # Specify offset from the center of via1
#@   set ::process::offset_from_ground_via1    [list {vcn 0 0.04} {v0 0 0.04} {v1 0 0}] ;# List of {via layer, x offset, y offset}
#@   set ::process::offset_from_power_via1     [list {vcn 0 0} {v0 0 0} {v1 0 0}]       ;# List of {via layer, x offset, y offset}
#@ 
#@   # End of line enclosures from EDGE of via (not center)
#@   # Keep it as 0 if you dont want metal enclosures
#@   # set ::process::metal_overhang_via_ground  [list {vcn m0 0.00 } {v0 m1 0.00 }  {v1 m2 0.00}] ;# List of {via layer, upper metal layer, metal overhang}
#@   set ::process::metal_overhang_via_ground  [list {vcn m0 0.00 } {v0 m1 0.00 }  {v1 m1 0.017} {v1 m2 0.00}] ;# List of {via layer, upper metal layer, metal overhang} ; # extends m1 on vss connections to align to m1 in stdcells
#@   set ::process::metal_overhang_via_power   [list {vcn gcn 0.024} {vcn m0 0.000} {v0 m1 0.00} {v1 m2 0.00}] ;# List of {via layer, upper metal layer, metal overhang}
#@ 
#@   # Bridging via information
#@   # When two vias being one-poly-track apart, create only one via stack and bridge another via stack with metal connection
#@   set ::process::bridge_two_track_apart_vias 1       ; # enable for p1273
#@   set ::process::bridging_via_layer         "vcn"    ;# Via layer (and its lower metal layer) for bridging. For example, if vcn is specified, gcn wire will be extended from vcn via for bridging
#@   set ::process::tcn_landing_length         "0.294"  ;# Length of bridging wire. Length is measured from the center of the via that is being created
#@   if {[info exists INTEL_XN_LIBRARY] && $INTEL_XN_LIBRARY == "1" } {
#@     set ::process::bridging_wire_length       "0.102"  ;# Length of bridging wire. Length is measured from the center of the via that is being created
#@     set ::process::bridge_extend_two_site_m0  "0.112"
#@   } else {
#@     set ::process::bridging_wire_length       "0.088"  ;# Length of bridging wire. Length is measured from the center of the via that is being created
#@     set ::process::bridge_extend_two_site_m0  "0.098"
#@   }
#@   set ::process::gcn_extension_length       "0.024"  ;# Extension of gcn from vcn boundary
#@   set ::process::bridging_offset_from_ground_via1    [list {gcn -0.009 0.068} {m0 0 0.04}] ; # offset of gcn from bottom of cell
#@   set ::process::bridging_offset_from_power_via1     [list {gcn -0.009 0} {m0 0 0}] ; # offset of gcn from bottom of cell
#@ 
#@   set ::process::expandVcn                   1   ; #Expand vcn as metal-shapes instead of writing it as a ContactCode,  this caused fatals globally on route_zrt_eco
#@ 
#@   set ::process::pwr_hookup_tap             "d04tap02.*"   ; #Give a list of tap cells (ref_names) which require PowerHookup. For BDWGfx we use 5 site tap-cell which does not need PowerHookup, for Skylake it is 3-site wide and it would require a PowerHookup.
#@   # set ::process::pwr_hookup_addl_refs       "*spc* *bdc*ln* *bdc*wn* *bdc*nn* *bdc*un* *bdc*xn* *dcp*ln* *dcp*wn* *dcp*nn* *dcp*un* *dcp*xn*"   ; #List of additional (typically physical_only) cells that require pwr_hookup, can override with INTEL_PWR_HOOKUP_ADDL_REFS
#@   set ::process::pwr_hookup_addl_refs       "*d04qfd02*"   ; #List of additional (typically physical_only) cells that require pwr_hookup, can override with INTEL_PWR_HOOKUP_ADDL_REFS
#@ 
#@   set ::process::pwr_hookup_refs_block_sh_pwr  "*d04qfd01*"   ; #List of ref cells that block single height pwr_hookup (gcn spacing), can override with INTEL_PWR_HOOKUP_REFS_BLOCK_SH_PWR
#@ 
#@   set ::process::shift_two_site_via_to_center "0"
#@ 
#@   set ::process::landed_vcn_check_dist      "0.021"
#@ 
#@   # Used by B/C coloring procs
#@   set ::process::vcc_stripe_width(m2)       "0.074"
#@   set ::process::vss_stripe_width(m2)       "0.040"
#@ 
#@   set ::process::vcc_stripe_width(m3)       [list 0.046 0.064 0.072]
#@   set ::process::vss_stripe_width(m3)       [list 0.046 0.064]
#@ 
#@   set ::process::cid_layer(m0)              "73:137"   ;# Temporarily stream out 78:137 to 241:127 ..ICC doesnt allow 241:137 to be used
#@   set ::process::cid_layer(m2)              "112:137"
#@   set ::process::cid_layer(m3)              "113:137"
#@ 
#@   set ::process::bid_layer(m0)              "74:135"   ;# Temporarily stream otu 74:135 to 55:135 .. mapping 55:135 as id layer causes shorts
#@   set ::process::bid_layer(m2)              "64:135"
#@   set ::process::bid_layer(m3)              "18:135"
#@ 
#@ }
#@ 
#@ define_proc_attributes  apr_override_design_attributes_for_std_pwrhookup     -info "Overrdie/Set design attributes for Power-Hookup"     -define_args {
#@       {"-vcc_name"     "Do power hookup in the specified vcc domain" "" string required}
#@       {"-vss_name"     "Do power hookup in the specified vss domain" "" string required}
#@     }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : rdt_convert_seconds
#@ # Description : This is a conversion utility seconds to hh:mm:ss
#@ #
#@ proc rdt_convert_seconds {secs} {
#@ 
#@   set h [expr {$secs/3600}]
#@   incr secs [expr {$h*-3600}]
#@   set m [expr {$secs/60}]
#@   set s [expr {$secs%60}]
#@   format "%02.2d:%02.2d:%02.2d" $h $m $s
#@ 
#@ }
#@ 
#@ 
#@ ##########################################################################
#@ # Procedure   : rdt_get_scr_proc_name
#@ #
#@ # Description :
#@ #
#@ # Inputs      :
#@ #
#@ # Returns     : TCL_OK if successful
#@ #
#@ # Note        :
#@ #
#@ ##########################################################################
#@ proc rdt_get_scr_proc_name { args } {
#@ 
#@   set all [string match "*-all*" $args]
#@   # Start with the current script
#@   set proc_list "[file tail [info script]]"
#@ 
#@   set start 1
#@   set end [info level]
#@ 
#@   # Special cases
#@   if {$end == 1} {
#@     # Called from script?
#@     if {$proc_list != ""} {
#@       return "$proc_list"
#@       # Interactive call
#@     } else {
#@       return "<interactive>"
#@     }
#@   } elseif {$end >= 2} {
#@     # Don't consider the last procedure (which is get_scr_proc_name)
#@     incr end -1
#@   }
#@ 
#@   for {set i $start} {$i <= $end} {incr i} {
#@     set proc_name [lindex [info level $i] 0]
#@     lappend proc_list $proc_name
#@   }
#@   # Return all if all was specified
#@   set len_proc_list [llength $proc_list]
#@   if {!$all && $len_proc_list > 2} {
#@     # Get the name of the last two procedures
#@     # or script & procedure
#@     # or script only
#@     # or procedure only
#@     set proc_list [lrange $proc_list [expr {$len_proc_list - 2}] end]
#@   }
#@ 
#@   # Return values joined by "<-" to make it one string
#@   return [join $proc_list "<-"]
#@ };
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/block_level_stdcell_power_hookup_runset.tcl

#@ 
#@ ### Check Disk Space
#@ P_run_CheckDiskSpace
#@ 
#@ # Initialize the user_defined var for flow/steps.
#@ P_source_if_exists initialize_mw_cel_user_vars.tcl -require
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/initialize_mw_cel_user_vars.tcl

#@ ##############################################################################
#@ # Purpose: define all the user vars on -classes mw_cel so that things can be check after closing and reopening icc
#@ 
#@ redirect /dev/null {define_user_attribute -class mw_cel -type string completed_steps -quiet }
#@ foreach step $INTEL_APR_STEPS {
#@   redirect /dev/null {define_user_attribute -class mw_cel -type string step:${step} -quiet }
#@   redirect /dev/null {define_user_attribute -class mw_cel -type string completed_substeps:${step} -quiet}
#@   foreach substep $INTEL_APR_SUBSTEPS($step) {
#@     redirect /dev/null {define_user_attribute -class mw_cel -type string step_${step}:${substep} -quiet}
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/initialize_mw_cel_user_vars.tcl

#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/apr/dot3/d04/run.tcl

#@ runICC -start import_design
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/import_design.tcl

#@ ##############################################################################
#@ 
#@ 
#@ # Find the current MW lib and cel
#@ set default_suppress_errors $suppress_errors
#@ set suppress_errors "$suppress_errors MWUI-003 MWUI-225"
#@ set suppress_errors $default_suppress_errors
#@ 
#@ if {[info exists INTEL_DDC] && $INTEL_DDC} {
#@   set ddc "inputs/${INTEL_DESIGN_NAME}.syn.ddc"
#@   if {[file exists $ddc] } {
#@     import_designs -top $INTEL_DESIGN_NAME -format ddc ./inputs/${INTEL_DESIGN_NAME}.syn.ddc
#@   } else {
#@     P_msg_fatal "Input ./inputs/${INTEL_DESIGN_NAME}.syn.ddc file not found. Exiting..."
#@   }
#@ } elseif {![info exists INTEL_DDC] || $INTEL_DDC == 0 } {
#@   if {[info exists INTEL_INPUT_NETLIST] && $INTEL_INPUT_NETLIST != "" } {
#@     set netlist $INTEL_INPUT_NETLIST
#@   } else {
#@     set netlist "inputs/${INTEL_DESIGN_NAME}.syn.vg"
#@   }
#@   if {[file exists $netlist] } {
#@     P_msg_info "Reading netlist $netlist"
#@     import_designs $netlist -top $INTEL_DESIGN_NAME -format verilog
#@ 
#@     # Load UPF
#@     if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@       if {[info exists INTEL_INPUT_UPF] && $INTEL_INPUT_UPF != ""} {
#@         load_upf $INTEL_INPUT_UPF
#@       } else {
#@         load_upf ./inputs/upf/${INTEL_DESIGN_NAME}.syn.upf
#@       }
#@       if { [info exists INTEL_UPF_VERSION] && $INTEL_UPF_VERSION >= 2.0 } {
#@         load_upf ./inputs/upf/${INTEL_DESIGN_NAME}.supply_net.upf
#@       }
#@       # Needed for report_isolation_cell to work, but yet report_level_shifter is OK.
#@       associate_mv_cells -isolation_cells
#@     }
#@   } else {
#@     P_msg_fatal "Input verilog netlist $netlist not found. Exiting..."
#@   }
#@   if {[info exists INTEL_SPG_DEF ] && $INTEL_SPG_DEF} {
#@     P_msg_info "Checking for SPG DEF file.."
#@     if {![file exists ./inputs/floorplan/${INTEL_DESIGN_NAME}.syn.def]} {
#@       P_msg_fatal "INTEL_SPG_DEF has been set to 1. Expecting def file ./inputs/floorplan/${INTEL_DESIGN_NAME}.syn.def for seed placement. Exiting..."
#@     } else {
#@       P_msg_info "SPG DEF file existence: ${INTEL_DESIGN_NAME}.syn.def exists. Will be used for seed placement."
#@     }
#@   }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ ##########################
#@ # Set tluplus files
#@ ##########################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1} {
#@ } else {
#@   if {[file exists $INTEL_MAX_TLUPLUS_EMUL_FILE] && [file exists $INTEL_MIN_TLUPLUS_EMUL_FILE]} {
#@     set_tlu_plus_files         -max_tluplus $INTEL_MAX_TLUPLUS_FILE         -min_tluplus $INTEL_MIN_TLUPLUS_FILE         -tech2itf_map $INTEL_TLUPLUS_MAP_FILE         -max_emulation_tluplus $INTEL_MAX_TLUPLUS_EMUL_FILE         -min_emulation_tluplus $INTEL_MIN_TLUPLUS_EMUL_FILE
#@   } else {
#@     set_tlu_plus_files         -max_tluplus $INTEL_MAX_TLUPLUS_FILE         -min_tluplus $INTEL_MIN_TLUPLUS_FILE         -tech2itf_map $INTEL_TLUPLUS_MAP_FILE
#@   }
#@   check_tlu_plus_files
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/import_design.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/read_constraints.tcl

#@ ##############################################################################
#@ 
#@ #############################
#@ # List of procs used in this script
#@ # None
#@ ############################
#@ 
#@ ##########################
#@ #Set Operating Condition
#@ ##########################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1} {
#@ } else {
#@   #Setting Operating Condition of best_case_worst_case analysis
#@   set cmd "set_operating_conditions -analysis_type bc_wc"
#@   if {[info exists INTEL_MIN_OPCON]} {set cmd [concat $cmd "-min $INTEL_MIN_OPCON"]}
#@   if {[info exists INTEL_MAX_OPCON]} {set cmd [concat $cmd "-max $INTEL_MAX_OPCON"]}
#@   if  {![eval $cmd] } {
#@     puts "==>FATAL: Setting Operating Conditions failed... Exiting..."
#@     exit
#@   } else {
#@     puts "==>INFORMATION: Setting default Operating Conditions\n$cmd "
#@   }
#@ }
#@ 
#@ ########################
#@ # Design Constraints
#@ ########################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1} {
#@ } else {
#@   if {[info exists INTEL_SDC_FILE] && $INTEL_SDC_FILE==1} {
#@     if {[info exists INTEL_INPUT_SDC] && $INTEL_INPUT_SDC != ""} {
#@       read_sdc $INTEL_INPUT_SDC
#@     } elseif {[file exists ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc]} {
#@       read_sdc ./inputs/constraints/${INTEL_DESIGN_NAME}.sdc
#@     } else {
#@       puts "==>FATAL: $INTEL_DESIGN_NAME.sdc does not exists in ./inputs/constraints... Exiting..."
#@       exit
#@     }
#@   } else {
#@ 
#@     #CLOCKS
#@     #-------
#@     if {[file exists  ./inputs/constraints/${INTEL_DESIGN_NAME}.clocks.tcl]} {
#@       puts "==>INFORMATION: Sourcing the ${INTEL_DESIGN_NAME}.clocks.tcl file"
#@       source -echo -verbose ./inputs/constraints/${INTEL_DESIGN_NAME}.clocks.tcl
#@     } else {
#@       puts "==>FATAL: Your $INTEL_DESIGN_NAME.clocks.tcl file does not exists in ./inputs/constraints/ dir... Exiting..."
#@       exit
#@     }
#@ 
#@     #IO, Loading Constraints, Timing Exception File
#@     #------------------------------------------------
#@     if {[file exists  ./inputs/constraints/${INTEL_DESIGN_NAME}.constraints.tcl]} {
#@       puts "==>INFORMATION: Sourcing the design constraints file"
#@       source -echo -verbose ./inputs/constraints/${INTEL_DESIGN_NAME}.constraints.tcl
#@     } else {
#@       puts "==>FATAL: DESIGN CONSTRAINTS file does not exists... Exiting..."
#@       exit
#@     }
#@   }
#@ }
#@ # -- Starting source ./inputs/constraints/fdkex.clocks.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ 
#@ # This is a TEMPLATE file for CLOCK CONSTRAINTS FILE
#@ # create_clock -name pxclk -period 6666.67 -waveform {0 3333.33} [get_ports {pxclk}]
#@ # set_input_transition 150 -max [ get_ports pxclk ]
#@ # set_input_transition 75 -min [ get_ports pxclk ]
#@ 
#@ 
#@ # create_clock -name xtclk_13p5 -period 73337 -waveform {0 36668.5} [get_ports {xtclk_13p5}]
#@ # set_input_transition 150 -max [ get_ports xtclk_13p5 ]
#@ # set_input_transition 75 -min [ get_ports xtclk_13p5 ]
#@ 
#@ # Make sure all combinations are here
#@ # for n clocks, there should be n^2 max clock uncertainty lines and n^2 min clock uncertainty
#@ # set_clock_uncertainty -hold 300 -from pxclk -to pxclk
#@ # set_clock_uncertainty -hold 300 -from pxclk -to xtclk_13p5
#@ # set_clock_uncertainty -hold 300 -from xtclk_13p5 -to pxclk
#@ # set_clock_uncertainty -hold 300 -from xtclk_13p5 -to xtclk_13p5
#@ 
#@ # set_clock_uncertainty -setup 235 -from pxclk -to pxclk
#@ # set_clock_uncertainty -setup 235 -from pxclk -to xtclk_13p5
#@ # set_clock_uncertainty -setup 235 -from xtclk_13p5 -to pxclk
#@ # set_clock_uncertainty -setup 235 -from xtclk_13p5 -to xtclk_13p5
#@ 
#@ # clock insertion delay
#@ # This is the same as specified for CTS in APR
#@ # set_clock_latency <number> [get_clocks {pxclk}]
#@ # set_clock_latency <number> [get_clocks {xtclk_13p5}]
#@ 
#@ #GENERATED CLOCKS
#@ #create_generated_clock -name GEN_CLK -source [get_pins clk_div2_ckcorediv2/clockdivff_cknameout/ffout_reg/ck] -divide_by 2 [get_pins clk_div2_ckcorediv2/clockdivff_cknameout/ffout_reg/o]
#@ 
#@ #VIRTUAL CLOCKS
#@ #create_clock -name  VIRTUAL_CLK   -period  1088   -waveform {0.000 0544}
#@ 
#@ 
#@ create_clock -name clk -period 500 -waveform {0 250} [get_ports {clk}]
#@ set_clock_uncertainty -setup 50 [get_clocks clk]
#@ set_clock_uncertainty -hold  50 [get_clocks clk]
#@ # -- End source ./inputs/constraints/fdkex.clocks.tcl

#@ # -- Starting source ./inputs/constraints/fdkex.constraints.tcl

#@ ##############################################################################
#@ ## Intel Top Secret                                                         ##
#@ ##############################################################################
#@ ## Copyright (C) 2012, Intel Corporation.  All rights reserved.             ##
#@ ##                                                                          ##
#@ ## This is the property of Intel Corporation and may only be utilized       ##
#@ ## pursuant to a written Restricted Use Nondisclosure Agreement             ##
#@ ## with Intel Corporation.  It may not be used, reproduced, or              ##
#@ ## disclosed to others except in accordance with the terms and              ##
#@ ## conditions of such agreement.                                            ##
#@ ##                                                                          ##
#@ ## All products, processes, computer systems, dates, and figures            ##
#@ ## specified are preliminary based on current expectations, and are         ##
#@ ## subject to change without notice.                                        ##
#@ ##############################################################################
#@ 
#@ 
#@ ###############################
#@ # Default Loading Constraints
#@ ###############################
#@ #User should copy this file in ./inputs/constraints/${G_DESIGN_NAME}.constraints.tcl and overwrite the actual value
#@ 
#@ #Default setting input_delay & output_delay of 2/3rd  of fastest clock
#@ #-----------------------------------------------------------------------
#@ set delay_value [expr [lindex [lsort -real -decreasing [get_attribute [get_clocks ] period]] end] * 2/3]
#@ 
#@ set clock_name [get_clocks clk]
#@ set_input_delay  -clock $clock_name $delay_value [remove_from_collection [all_inputs] [get_ports clk]]
#@ set_output_delay -clock $clock_name $delay_value [all_outputs]
#@ 
#@ 
#@ #Default input transition or loading cons
#@ #-----------------------------------------
#@ 
#@ set my_driving_cell d04bfn00ln0b0
#@ if {[get_lib_cells */$my_driving_cell -quiet] != ""} {
#@    set_driving_cell -lib_cell $my_driving_cell [all_inputs]
#@    puts "==>INFORMATION: Setting driving cell to $my_driving_cell"
#@ } else {
#@    set_input_transition 50 [all_inputs]
#@    puts "==>INFORMATION: Specified driving cell $my_driving_cell was not found. Setting default input transition as 50"
#@ }
#@ 
#@ 
#@ set_load 10 [all_outputs]
#@ set_max_transition 350 *
#@ set_max_fanout 30 [get_designs *]
#@ set_max_area 0
#@ 
#@ 
#@ # -- End source ./inputs/constraints/fdkex.constraints.tcl

#@ 
#@ ##  ########################################################
#@ # Set voltages for supply nets when running in UPF mode
#@ ########################################################
#@ 
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   if {$synopsys_program_name == "de_shell"}  {
#@     puts "==>INFORMATION: UPF flow is not supported in Design Explorer"
#@   } else {
#@     source -echo -verbose ./inputs/upf/${INTEL_DESIGN_NAME}.set_voltage.tcl
#@   }
#@ }
#@ 
#@ ################
#@ #Read SAIF file
#@ ################
#@ 
#@ if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@   if {![info exists INTEL_SAIF_INSTANCE] || $INTEL_SAIF_INSTANCE == ""} {
#@     set INTEL_SAIF_INSTANCE ${INTEL_DESIGN_NAME}
#@     puts "==>INFORMATION: setting INTEL_SAIF_INSTANCE to ${INTEL_DESIGN_NAME} since user hasn't set INTEL_SAIF_INSTANCE varible"
#@   } else {
#@     puts "==>INFORMATION: INTEL_SAIF_INSTANCE has been set to $INTEL_SAIF_INSTANCE by the user"
#@   }
#@   set saif_file ./inputs/constraints/${INTEL_DESIGN_NAME}.saif
#@   read_saif -auto_map_names -input $saif_file -instance $INTEL_SAIF_INSTANCE -verbose
#@   puts "==>INFORMATION: read_saif -auto_map_names -input ${INTEL_DESIGN_NAME}.saif -instance $INTEL_SAIF_INSTANCE -verbose"
#@   redirect ./reports/${INTEL_DESIGN_NAME}.rtl_saif.rpt { report_saif -hier -missing -annotated_flag -type rtl }
#@ }
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/read_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_scenarios.tcl

#@ ##############################################################################
#@ 
#@ #Requirements:
#@ # 1: Update library.tcl to include libraries needed for each scenario.
#@ # 2: Update project_setup.tcl/block_setup.tcl $INTEL_MCMM_* to create and setup scenarios.
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM} {
#@ 
#@   ##Cleanup before creating scenarios
#@   remove_scenario -all
#@ 
#@   foreach scenario $INTEL_MCMM_SCENARIOS {
#@     P_msg_info "Creating scenario $scenario."
#@     create_scenario $scenario
#@ 
#@     ####
#@     #  Set scenario specific link_libraries (OPTIONAL).
#@     #  Only required if tool has difficulty determining which PVT is needed for the given scenario.
#@     if {[info exists INTEL_MCMM_LINK_LIBRARY_SUBSET($scenario)] && $INTEL_MCMM_LINK_LIBRARY_SUBSET($scenario) != ""} {
#@       set_link_library_subset $INTEL_MCMM_LINK_LIBRARY_SUBSET($scenario) -top
#@     }
#@ 
#@     ####
#@     #Set scenario options
#@     P_msg_info "Setting scenario $scenario options to $INTEL_MCMM_SCENARIO_OPTIONS($scenario)"
#@     eval $INTEL_MCMM_SCENARIO_OPTIONS($scenario)
#@ 
#@     ####
#@     # Report scenario options
#@     P_msg_info "Scenario $scenario is created."
#@     report_scenario_options
#@ 
#@     ####
#@     # Setting TLU+
#@     P_msg_info "Setting tlu+ model for scenario ${scenario}..."
#@     if {[file exists $INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE($scenario)]} {
#@       set_tlu_plus_files           -tech2itf_map $INTEL_TLUPLUS_MAP_FILE           -max_tluplus $INTEL_MCMM_MAX_TLUPLUS_FILE($scenario)           -min_tluplus $INTEL_MCMM_MIN_TLUPLUS_FILE($scenario)           -max_emulation_tluplus $INTEL_MCMM_MAX_TLUPLUS_EMUL_FILE($scenario)           -min_emulation_tluplus $INTEL_MCMM_MIN_TLUPLUS_EMUL_FILE($scenario)
#@     } else {
#@       set_tlu_plus_files           -tech2itf_map $INTEL_TLUPLUS_MAP_FILE           -max_tluplus $INTEL_MCMM_MAX_TLUPLUS_FILE($scenario)           -min_tluplus $INTEL_MCMM_MIN_TLUPLUS_FILE($scenario)
#@     }
#@     check_tlu_plus_files
#@ 
#@     ####
#@     # Setting Operating Conditions
#@     eval $INTEL_MCMM_OPCON($scenario)
#@ 
#@     ####
#@     # If INTEL_SDC_FILE, read SDC files, otherwise source tcl files
#@     if {[info exists INTEL_SDC_FILE] && $INTEL_SDC_FILE==1} {
#@       foreach sdc_file $INTEL_MCMM_CONS_SDC($scenario) {
#@         P_msg_info "Loading sdc file $sdc_file for scenario $scenario"
#@         set auto_link_disable true
#@         read_sdc $sdc_file
#@         set auto_link_disable false
#@       }
#@     } else {
#@       foreach tcl_file $INTEL_MCMM_CONS_TCL($scenario) {
#@         P_msg_info "Loading constraints tcl files $tcl_file for scenario $scenario"
#@         set auto_link_disable true
#@         source $tcl_file
#@         set auto_link_disable false
#@       }
#@     }
#@ 
#@     ####
#@     # In UPF mode, load scenario specific set_volatage files.
#@     if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@       source -echo -verbose $INTEL_MCMM_UPF_SET_VOLTAGE($scenario)
#@     }
#@ 
#@   }
#@ 
#@   ####
#@   # Enable default scenario
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ 
#@   # Flow assumes that all created scenarios are active.
#@   set_active_scenarios [all_scenarios]
#@   report_scenarios
#@ 
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_scenarios.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_path_group.tcl

#@ ##############################################################################
#@ 
#@ ###################################
#@ # List of procs used in this script
#@ # None
#@ ###############################
#@ 
#@ #------------------------
#@ #Create Paths groups
#@ #-----------------------
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM==1 && $synopsys_program_name != "pt_shell"} {
#@   set_active_scenarios [all_scenarios]
#@   foreach scenario $INTEL_MCMM_SCENARIOS {
#@     current_scenario $scenario
#@     puts "==> For scenario $scenario..."
#@ 
#@     set nonclockports [all_inputs]
#@     foreach_in_collection ck [all_clocks] {
#@       redirect /dev/null { set nonclockports [remove_from_collection $nonclockports [ get_ports [ get_object_name $ck ]]] }
#@     }
#@     redirect  /dev/null {group_path -name INPUTS -from $nonclockports}
#@ 
#@     group_path -name OUTPUTS -to [all_outputs]
#@     group_path -name COMB -from [all_inputs] -to [all_outputs]
#@ 
#@     if {[sizeof_collection [all_registers]] !=0} {
#@       group_path -name REG2REG -from [all_registers -clock_pins] -to [all_registers -data_pins]
#@     }
#@ 
#@     if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@       set hard_macro_cells ""
#@       set mc_pin  ""
#@       foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@         set hard_macro_cells [get_attribute  [get_cells -hierarchical -quiet -filter ref_name==$hard_macro_name] full_name]
#@         foreach hard_macro_cell $hard_macro_cells {
#@           set mc_pin [add_to_collection $mc_pin [get_pins -quiet ${hard_macro_cell}/* ]]
#@         }
#@       }
#@       group_path -name MACRO -from $mc_pin -to  [all_registers -data_pins]
#@       group_path -name MACRO -from  [all_registers -clock_pins]  -to $mc_pin
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ 
#@ } else {
#@ 
#@   set nonclockports [all_inputs]
#@   foreach_in_collection ck [all_clocks] {
#@     redirect /dev/null { set nonclockports [remove_from_collection $nonclockports [ get_ports [ get_object_name $ck ]]] }
#@   }
#@   redirect  /dev/null {group_path -name INPUTS -from $nonclockports}
#@ 
#@   group_path -name OUTPUTS -to [all_outputs]
#@   group_path -name COMB -from [all_inputs] -to [all_outputs]
#@ 
#@   if {[sizeof_collection [all_registers]] !=0} {
#@     group_path -name REG2REG -from [all_registers -clock_pins] -to [all_registers -data_pins]
#@   }
#@ 
#@   if {[info exists INTEL_HARD_MACRO_NAME] && $INTEL_HARD_MACRO_NAME != ""} {
#@     set hard_macro_cells ""
#@     set mc_pin  ""
#@     foreach hard_macro_name $INTEL_HARD_MACRO_NAME {
#@       set hard_macro_cells [get_attribute  [get_cells -hierarchical -quiet -filter ref_name==$hard_macro_name] full_name]
#@       foreach hard_macro_cell $hard_macro_cells {
#@         set mc_pin [add_to_collection $mc_pin [get_pins -quiet ${hard_macro_cell}/* ]]
#@       }
#@     }
#@     group_path -name MACRO -from $mc_pin -to  [all_registers -data_pins]
#@     group_path -name MACRO -from  [all_registers -clock_pins]  -to $mc_pin
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/create_path_group.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ ##############################################################################
#@ #Script: tool_constraints.tcl
#@ # List of procs used by this tcl
#@ # 1. P_lminus
#@ # 2. P_msg_info
#@ # 3. get_completed_steps
#@ 
#@ # Density screening
#@ #
#@ # set_congestion_options
#@ #       [-max_util value]: Specifies the layer name whose availability is reduced.
#@ #       [-layer name]: Specifies the availability of the routing resource for the layer
#@ #       [-availability value]: Specifies the availability of the routing resource for the layer
#@ #       [-coordinate {X1 Y1 X2 Y2}]: Specifies the lower left and upper right coordinates
#@ #                                    for which the congestion options will apply.
#@ #                                    The numbers are in microns.
#@ # Example: set_congestion_options -max_util 0.5 -coordinate {0 0 2560 155}
#@ 
#@ 
#@ # Soft blockage (0% utilization during initial place, but allows for buffering later)
#@ #
#@ # create_placement_blockage
#@ #       -bbox rectangle: Specifies the coordinates of the bounding box of the blockage.
#@ #                        rectangle  x1 y1 x2 y2
#@ #       -type soft: Specifies the type of blockage to be created as soft.
#@ #                   With a soft blockage, the placer tries not to place standard cells
#@ #                   or hard macros in the specified region but will do so if the congestion
#@ #                   is too high.
#@ #       [-name blockage_name]: Specifies the optional name of the blockage.
#@ #                              If you  specify  a name  for  the blockage,
#@ #                              you can use it later in the flow to get the blockage by name.
#@ # Example: create_placement_blockage -name hot_corner_plcmnt_blkg_1 -bbox {{4066 259.2} {4096 459.2}} -type soft
#@ # Example: create_placement_blockage -name KO_idv4 -bbox { 540.4 1094.56 579.6  1225.28} -type soft
#@ 
#@ 
#@ # Cells inserted during each flow will have a prefix of the flow name. For ex. placement will have "place" prefix
#@ # If Intel flow variables are not defined, then the default prefix will be used
#@ if {[lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0] != ""} {
#@   set_app_var compile_instance_name_prefix [lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0]
#@ }
#@ 
#@ # Enables congestion removal with the global router
#@ set_app_var placer_enable_enhanced_router true
#@ 
#@ #To prevent side load on output ports
#@ set_isolate_ports -type buffer [filter_collection [all_outputs] "direction=~out"]
#@ 
#@ # Congestion removal effort during coarse placement
#@ set_app_var placer_enable_high_effort_congestion true
#@ 
#@ # Congestion effort during place_opt (default is auto)
#@ # Setting to medium/high, ICC always uses the Zroute global route for congestion-driven placement
#@ set_app_var placer_congestion_effort medium
#@ 
#@ # Prints out Zroute global routing information during congestion-driven placement
#@ set_app_var placer_show_zroutegr_output true
#@ 
#@ # Ensure cells are placed close together for low-utilization blocks
#@ # Recommended setings are somewhere between 0.5 and 0.65
#@ set_app_var placer_max_cell_density_threshold 0.6
#@ 
#@ # Set critical range
#@ set_critical_range $INTEL_CRITICAL_RANGE [get_designs]
#@ 
#@ # Pre-route area and power critical range values
#@ if {[info exists INTEL_AREA_CRITICAL_RANGE] && $INTEL_AREA_CRITICAL_RANGE!="not_set"} {
#@   set_app_var physopt_area_critical_range $INTEL_AREA_CRITICAL_RANGE
#@ }
#@ if {[info exists INTEL_POWER_CRITICAL_RANGE] && $INTEL_POWER_CRITICAL_RANGE != "not_set" } {
#@   set_app_var physopt_power_critical_range $INTEL_POWER_CRITICAL_RANGE
#@ }
#@ 
#@ # Avoid excessive buffering
#@ set_buffer_opt_strategy -effort medium
#@ 
#@ # Set auto high fanout synthesis options
#@ set_ahfs_options     -constant_nets true     -port_map_file outputs/${INTEL_DESIGN_NAME}_ahfs_port_map.txt
#@ 
#@ # Set routing layers
#@ remove_ignored_layers -all
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS
#@ }
#@ P_msg_info "Setting min_routing_layer: $min_routing_layer"
#@ P_msg_info "Setting max_routing_layer: $max_routing_layer"
#@ P_msg_info "Setting rc_ignore_layer:   $rc_ignore_layer"
#@ set_ignored_layers      -min_routing_layer $min_routing_layer     -max_routing_layer $max_routing_layer     -rc_congestion_ignored_layers $rc_ignore_layer
#@ 
#@ 
#@ # Setting default Toggle Rate and Static Probability for power optmization in the absence of SAIF
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@     P_msg_info "Input saif file will be used for dynamic power optmization"
#@   } else {
#@     P_msg_info "Setting default toggle rate $INTEL_POWER_TR and default static probability $INTEL_POWER_SP for dynamic power optimization"
#@     set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@     set_app_var power_default_static_probability $INTEL_POWER_SP
#@   }
#@ }
#@ 
#@ # Power optimization options (turn on dynamic power opt if INTEL_DYNAMIC_POWER is set to 1)
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement true
#@ } else {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement false
#@ }
#@ 
#@ #Enable DRC on constant nets
#@ set_auto_disable_drc_nets -constant false
#@ 
#@ #Ensure the tool observes max_cap constraints during tie-off optimization
#@ set_app_var physopt_new_fix_constants true
#@ 
#@ # Enable via resistance estimation
#@ set_app_var physopt_enable_via_res_support true
#@ 
#@ # Uses alternate name styles to solve name mismatching issues in read_def
#@ set_app_var def_enable_no_legalize_name true
#@ 
#@ # Set multiple port nets options
#@ #        [-feedthroughs]        (fix feedthroughs)
#@ #        [-outputs]             (fix multiple output port nets)
#@ #        [-buffer_constants]    (buffer constants driving multiple ports)
#@ # Without this option, feedthrough ports can be connected directly to each other
#@ # and create text short error in LVS.
#@ set_fix_multiple_port_nets -feedthroughs -outputs -buffer_constants
#@ 
#@ ################################
#@ # Placement
#@ ################################
#@ # Use Zrouter to drive peroute optimization.
#@ if { $::sh_product_version > {I-2013.12-ICC-SP2} } {
#@   set_place_opt_strategy -consider_routing true
#@ }
#@ 
#@ ####################################
#@ # Setting Delay Calculation Options
#@ ####################################
#@ P_msg_info "Setting Delay Calculation as follows :\n Pre-route : Elmore\n Routed Clock : Arnoldi\n Post-route : Arnoldi"
#@ set_delay_calculation_options -preroute elmore -routed_clock arnoldi -postroute arnoldi
#@ 
#@ ####################################
#@ # CTS
#@ ####################################
#@ # The following are used to force CTS to fix more max_cap drcs.
#@ set         ctdn_enable_ccs_low_cap true
#@ set_app_var cto_enable_drc_fixing   true
#@ set         cts_low_power           false
#@ 
#@ ####################################
#@ # Extraction Options
#@ ####################################
#@ 
#@ if { [lsearch -exact [get_completed_steps] fill] > 0} {
#@   set_extraction_options       -real_metalfill_extraction FLOATING       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ } else {
#@   set_extraction_options       -real_metalfill_extraction none       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/init_floorplan.tcl

#@ ##############################################################################
#@ # Script: init_floorplan.tcl
#@ # Description: initial floorplan based on user specified parameters
#@ # List of procs used by this script
#@ # 1. P_msg_error
#@ # 2. P_msg_info
#@ # 3. P_msg_warn
#@ # 4. P_add_bonuscore_core2h_rows
#@ 
#@ # initialize floorplan
#@ set_fp_strategy -unit_tile_name $INTEL_STDCELL_TILE
#@ set ::no_row_gap 1
#@ 
#@ ################################################################################################
#@ # If $INTEL_FP_INPUT == DEF , inputs/floorplan/$INTEL_DESIGN_NAME.floorplan.def must contain:
#@ # DIEAREA: Defines partition size (supports rectilinear shapes)
#@ # COMPONENTS: Defines macro locations.  If no macros in the design, ignore.
#@ # PINS: Defines locations of input and output ports
#@ # Any TRACKS or ROW is ignored and reset.
#@ ################################################################################################
#@ # If $INTEL_FP_INPUT  == FP_TCL, inputs/floorplan/$INTEL_DESIGN_NAME.floorplan.tcl must contain:
#@ # create_boundary or create_die_area: Defines partition size (supports rectilinear shapes)
#@ # create_voltage_area(optional): for UPF designs
#@ # set_attribute <macro> orientation|origin|is_placed...: Defines macro locations.  If no macro in the design, ignore.
#@ # set_attribute <terminal> bbox|layer|access_direction...: Defines locations of input and output ports
#@ # Any create_track or add_row is ignored and reset.
#@ #################################################################################################
#@ 
#@ #############################################
#@ ### Check if more than one input is defined
#@ #############################################
#@ if {[info exists INTEL_DESIGN_WIDTH] && $INTEL_DESIGN_WIDTH != "" &&         [info exists INTEL_DESIGN_HEIGHT] && $INTEL_DESIGN_HEIGHT != "" &&         [info exists INTEL_FP_BOUNDARY] && $INTEL_FP_BOUNDARY != ""} {
#@   P_msg_error "Both INTEL_DESIGN_WIDTH/INTEL_DESIGN_HEIGHT and INTEL_FP_BOUNDARY are defined"
#@ }
#@ 
#@ ######################################################
#@ # Create floorplan according to input type defined
#@ ######################################################
#@ 
#@ if { [info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT=="DEF" } {
#@   if { [info exists INTEL_INPUT_DEF] && $INTEL_INPUT_DEF != "" } {
#@     read_def -allow_physical -verbose $INTEL_INPUT_DEF
#@   } else {
#@     read_def -allow_physical -verbose "inputs/floorplan/${INTEL_DESIGN_NAME}.floorplan.def"
#@   }
#@   if { [sizeof_collection [get_site_rows -quiet]] != 0 } {
#@     remove_site_row *
#@   }
#@ } elseif { [info exists INTEL_FP_INPUT] && $INTEL_FP_INPUT=="FP_TCL" } {
#@   source "inputs/floorplan/${INTEL_DESIGN_NAME}.floorplan.tcl"
#@ } else {
#@   if {[info exists INTEL_DESIGN_WIDTH] && $INTEL_DESIGN_WIDTH != "" &&           [info exists INTEL_DESIGN_HEIGHT] && $INTEL_DESIGN_HEIGHT != ""} {
#@     create_boundary -coordinate "{0 0} {$INTEL_DESIGN_WIDTH $INTEL_DESIGN_HEIGHT}"
#@   } elseif { [info exists INTEL_FP_BOUNDARY] && $INTEL_FP_BOUNDARY != ""} {
#@     create_boundary -poly $INTEL_FP_BOUNDARY
#@   } else {
#@     P_msg_error "Neither INTEL_DESIGN_WIDTH/INTEL_DESIGN_HEIGHT nor INTEL_FP_BOUNDARY is defined"
#@   }
#@ }
#@ 
#@ #######################################################################################
#@ # Re-create floorplan for DEF/TCL and create_floorplan for floorplanning from scratch
#@ #######################################################################################
#@ redirect $::sh_dev_null { set die_area [get_die_area] }
#@ set init_fp_keep_opt {}
#@ if { [sizeof_collection [get_terminals -quiet *]] > 0 } {
#@   append init_fp_keep_opt { -keep_io_place}
#@ }
#@ if { [sizeof_collection [filter_collection [all_macro_cells] {is_placed == true}]] > 0 } {
#@    append init_fp_keep_opt { -keep_macro_place}
#@ }
#@ set left_offset 0;  set right_offset 0
#@ if {[info exists INTEL_XN_LIBRARY]&&$INTEL_XN_LIBRARY&&[info exists INTEL_HALO_INTERFACE]&&[regexp "d2xn" $INTEL_HALO_INTERFACE]} {
#@   set left_offset 0.042;  set right_offset 0.042
#@ }
#@ if { [sizeof_collection $die_area] == 0 } {
#@   P_msg_error "Missing die area (partition) boundary to create floorplan!"
#@ } elseif { [llength [get_attribute $die_area boundary]] > 5 } {
#@    eval initialize_rectilinear_block -use_current_boundary -left_io2core $left_offset -right_io2core $right_offset -top_io2core 0 -bottom_io2core 0 $init_fp_keep_opt
#@ } else {
#@    eval create_floorplan -control_type boundary -left_io2core $left_offset -right_io2core $right_offset -top_io2core 0 -bottom_io2core 0 $init_fp_keep_opt
#@ }
#@ 
#@ ######################################
#@ # Read in VA tcl in case of UPF mode
#@ ######################################
#@ 
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   if {[file exists  ./inputs/floorplan/${INTEL_DESIGN_NAME}.voltage_area.tcl]} {
#@     P_msg_info "Sourcing voltage area creation file"
#@     source -echo -verbose ./inputs/floorplan/${INTEL_DESIGN_NAME}.voltage_area.tcl
#@   } else {
#@     P_msg_warn "Design is in UPF mode and no voltage area creation file is present"
#@   }
#@ }
#@ 
#@ ###########################################
#@ # Add extra placement sites for all tiles
#@ ###########################################
#@ set add_rows_cmd "P_add_bonuscore_core2h_rows -unit_tile $INTEL_STDCELL_TILE"
#@ if {[info exists INTEL_STDCELL_BONUS_GATEARRAY_TILE] && $INTEL_STDCELL_BONUS_GATEARRAY_TILE != ""} {
#@   set add_rows_cmd "$add_rows_cmd -bonus_tile $INTEL_STDCELL_BONUS_GATEARRAY_TILE"
#@ }
#@ if {[info exists INTEL_STDCELL_CORE2H_TILE] && $INTEL_STDCELL_CORE2H_TILE != ""} {
#@   set add_rows_cmd "$add_rows_cmd -unit_2h_tile $INTEL_STDCELL_CORE2H_TILE"
#@ }
#@ eval $add_rows_cmd
#@ set ::physopt_check_site_array_overlap false
#@ set_parameter -module place -name legalUnitTiles -value $INTEL_STDCELL_TILE -type string
#@ 
#@ ####################################
#@ # Remove existing stdcell placement
#@ ####################################
#@ remove_placement -object_type standard_cell
#@ 
#@ #########################################################################################################
#@ # Delete default M2 & M3 terminals so that they won't interfere with boundary halo cells & power straps.
#@ #########################################################################################################
#@ if { [lsearch -exact $init_fp_keep_opt {-keep_io_place}] < 0 } {
#@   set terms [get_terminals -quiet *]
#@   if { [sizeof_collection $terms] > 0 } {
#@     P_msg_info "Deleting [sizeof_collection $terms] default terminals of layers '[lsort -unique [get_attribute $terms layer]]' created by create_floorplan"
#@     remove_terminal $terms
#@   }
#@ }
#@ 
#@ ############################################################################################################
#@ # Re-setting min-max layers. Already being set in tool_constraints.tcl. Tool resets during create_floorplan
#@ ############################################################################################################
#@ 
#@ remove_ignored_layers -all
#@ set_ignored_layers      -min_routing_layer $INTEL_MIN_ROUTING_LAYER     -max_routing_layer $INTEL_MAX_ROUTING_LAYER     -rc_congestion_ignored_layers $INTEL_RC_IGNORE_LAYERS
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/init_floorplan.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/set_wiretracks.tcl

#@ ##############################################################################
#@ # Script: set_wiretracks.tcl
#@ # Description : define track patterns across the design
#@ # List of procs used by this script
#@ # 1. P_set_repeating_custom_tracks
#@ ##############################################################################
#@ 
#@ ###########################################################
#@ # Create rule based tracks for non-uniform signal routing
#@ ###########################################################
#@ 
#@ ### Rule Based Track -  non-uniform signal routing
#@ # m0
#@ remove_track -layer m0
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.035 -dir Y -space 0.798 -width 0.042 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.098 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.154 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.210 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.266 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.328 -dir Y -space 0.798 -width 0.040 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.399 -dir Y -space 0.798 -width 0.046 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.470 -dir Y -space 0.798 -width 0.040 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.532 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.588 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.644 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.700 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m0 -coord 0.763 -dir Y -space 0.798 -width 0.042 }
#@ 
#@ # m1
#@ remove_track -layer m1
#@ redirect /dev/null { create_rule_based_track -layer m1 -coord 0.000 -dir X -space 0.070 -width 0.042 }
#@ 
#@ # m2
#@ remove_track -layer m2
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.000 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.058 -dir Y -space 0.798 -width 0.040 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.116 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.168 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.220 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.272 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.324 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.399 -dir Y -space 0.798 -width 0.074 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.474 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.526 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.578 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.630 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.682 -dir Y -space 0.798 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.740 -dir Y -space 0.798 -width 0.040 }
#@ redirect /dev/null { create_rule_based_track -layer m2 -coord 0.798 -dir Y -space 0.798 -width 0.028 }
#@ 
#@ # m3
#@ remove_track -layer m3
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.000 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.052 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.104 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.156 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.208 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.260 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.312 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.392 -dir X -space 1.68 -width 0.084 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.472 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.524 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.576 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.628 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.680 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.732 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.786 -dir X -space 1.68 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.840 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.894 -dir X -space 1.68 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 0.948 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.000 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.052 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.104 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.156 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.208 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.288 -dir X -space 1.68 -width 0.084 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.368 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.420 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.472 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.524 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.576 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.628 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m3 -coord 1.680 -dir X -space 1.68 -width 0.028 }
#@ 
#@ # m4
#@ remove_track -layer m4
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.000 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.056 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.112 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.168 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.224 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.302 -dir Y -space 1.596 -width 0.076 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.380 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.436 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.492 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.548 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.604 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.660 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.716 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.798 -dir Y -space 1.596 -width 0.084 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.880 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.936 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 0.992 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.048 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.104 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.160 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.216 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.294 -dir Y -space 1.596 -width 0.076 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.372 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.428 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.484 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.540 -dir Y -space 1.596 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m4 -coord 1.596 -dir Y -space 1.596 -width 0.032 }
#@ 
#@ # m5
#@ remove_track -layer m5
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.000 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.052 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.104 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.156 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.208 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.260 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.312 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.392 -dir X -space 1.68 -width 0.084 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.472 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.524 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.576 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.628 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.680 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.732 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.786 -dir X -space 1.68 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.840 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.894 -dir X -space 1.68 -width 0.032 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 0.948 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.000 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.052 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.104 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.156 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.208 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.288 -dir X -space 1.68 -width 0.084 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.368 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.420 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.472 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.524 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.576 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.628 -dir X -space 1.68 -width 0.028 }
#@ redirect /dev/null { create_rule_based_track -layer m5 -coord 1.680 -dir X -space 1.68 -width 0.028 }
#@ 
#@ # m6
#@ remove_track -layer m6
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.042  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.126  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.210  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.336  -dir Y -space 1.596 -width 0.108 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.462  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.546  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.630  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.714  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.798  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.882  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 0.966  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 1.050  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 1.134  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 1.260  -dir Y -space 1.596 -width 0.108 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 1.386  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 1.470  -dir Y -space 1.596 -width 0.044 }
#@ redirect /dev/null { create_rule_based_track -layer m6 -coord 1.554  -dir Y -space 1.596 -width 0.044 }
#@ 
#@ # m7
#@ remove_track -layer m7
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.056   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.168   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.280   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.392   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.504   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.616   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.728   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 0.896   -dir X -space 3.36 -width 0.168 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.064   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.176   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.288   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.400   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.512   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.624   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.736   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.848   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 1.960   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.072   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.184   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.296   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.464   -dir X -space 3.36 -width 0.168 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.632   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.744   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.856   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 2.968   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 3.080   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 3.192   -dir X -space 3.36 -width 0.056 }
#@ redirect /dev/null { create_rule_based_track -layer m7 -coord 3.304   -dir X -space 3.36 -width 0.056 }
#@ 
#@ # m8
#@ remove_track -layer m8
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 0.170   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 0.798   -dir Y -space 6.384 -width 0.714 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 1.426   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 1.766   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 2.080   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 2.394   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 2.708   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 3.022   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 3.362   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 3.676   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 3.990   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 4.304   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 4.618   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 4.958   -dir Y -space 6.384 -width 0.140 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 5.586   -dir Y -space 6.384 -width 0.714 }
#@ redirect /dev/null { create_rule_based_track -layer m8 -coord 6.214   -dir Y -space 6.384 -width 0.140 }
#@ 
#@ # m9
#@ remove_track -layer m9
#@ redirect /dev/null { create_rule_based_track -layer m9 -coord 0.000  -dir X -space 1.68 -width 1.080 }
#@ 
#@ if { [info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR==1} {
#@   P_msg_info "Creating NDR Wiretracks"
#@   # m6
#@   redirect /dev/null { create_rule_based_track -layer m6 -coord 0.000 -dir Y -space 1.596 -width 0.108 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m6 -coord 0.168 -dir Y -space 1.596 -width 0.108 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m6 -coord 0.504 -dir Y -space 1.596 -width 0.108 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m6 -coord 0.672 -dir Y -space 1.596 -width 0.108 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m6 -coord 1.092 -dir Y -space 1.596 -width 0.108 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m6 -coord 1.428 -dir Y -space 1.596 -width 0.108 -reserved_for_width true}
#@ 
#@   # m7
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 0.000 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 0.224 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 0.448 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 0.672 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 1.120 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 1.344 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 1.568 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 1.792 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 2.016 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 2.240 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 2.688 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 2.912 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@   redirect /dev/null { create_rule_based_track -layer m7 -coord 3.136 -dir X -space 3.360 -width 0.150 -reserved_for_width true}
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/set_wiretracks.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/macro_placement.tcl

#@ ##############################################################################
#@ # This script will auto-place macros in the design
#@ # Can be used during early exploration stage
#@ # 2 step process for xllp blocks inside digital block
#@ # 1. snap digital macros to user-grid ($INTEL_MD_GRID_X , $INTEL_MD_GRID_Y )
#@ # 2. shift macro by (-0.042, 0)
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ # Check: Are there any macro cells?
#@ if {[sizeof_collection [all_macro_cells]] == 0} {
#@   P_msg_info "There are no macro cells in this design"
#@   return
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/macro_placement.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/halo_d04.tcl

#@ ##############################################################################
#@ 
#@ # Utility script for halo placement in a channel design for hierarchy or full chip level
#@ # ================
#@ # Dependencies: requires FDK common procs (procs.tcl) and FDK common vars (project_setup.tcl) to be sourced
#@ # List of procs used by halo.tcl
#@ # 1. P_get_abutted_cells
#@ # 2. P_get_boundary_polygon
#@ # 3. P_lcount
#@ # 4. P_find_direction
#@ # 5. P_place_halo
#@ 
#@ ############################################
#@ # Checking for existense of halo cells
#@ ############################################
#@ 
#@ foreach halo "$INTEL_halo_b_horiz $INTEL_halo_c_horiz $INTEL_halo_b_corner $INTEL_halo_c_corner $INTEL_halo_b_inside_corner $INTEL_halo_c_inside_corner $INTEL_halo_side" {
#@   set halo_cell [get_physical_lib_cells $halo]
#@   if {[sizeof_collection $halo_cell] > 0} {
#@     set halo_widths($halo) [lindex [lindex [get_attribute [lindex $halo_cell 0] bbox] 1] 0]
#@   } else {
#@     puts "##ERROR- Halo cell $halo is missing from the library. Please make sure you have included the halo library in"
#@     puts "##ERROR-    the appropriate library setup variable in the block_setup.tcl file. "
#@     return 0
#@   }
#@ }
#@ set halo_height  [lindex [lindex [get_attribute [lindex [get_physical_lib_cells $INTEL_halo_side] 0] bbox] 1] 1]
#@ 
#@ suppress_message {PSYN-294}
#@ 
#@ ############################################
#@ # Setting up vars used during insertion
#@ ############################################
#@ 
#@ set halo_counter 0
#@ set diehalo_width 0
#@ set diehalo_height 0
#@ 
#@ set halo_orient_N ""
#@ set halo_orient_FN ""
#@ set halo_orient_S ""
#@ set halo_orient_FS ""
#@ 
#@ #########################################################################################################################################################
#@ # Two Step process to perform
#@ #  1. first get the inner boundary of the Core excluding all the macros touching them
#@ #  2. Compute the merged polygon of all the abutted macros and stand alone macros that are completely inside the core region and not abutting the Core
#@ #########################################################################################################################################################
#@ 
#@ ######################################################################################
#@ # Lets perform Step 1
#@ #  1. first get the inner boundary of the Core excluding all the macros touching them
#@ ######################################################################################
#@ 
#@ set boundary_abutted_macros_boundary ""
#@ set boundary_abutted_macros ""
#@ set boundary_abutted_macros_grouped ""
#@ 
#@ set boundary_cells [get_cells -all -intersect [get_attribute [get_core_area] bbox] -quiet]
#@ 
#@ if {[sizeof_collection $boundary_cells] > 0} {
#@   set boundary_abutted_macros_grouped [P_get_abutted_cells $boundary_cells]
#@ 
#@   if {[info exists boundary_abutted_macros_grouped]} {
#@     foreach each_group $boundary_abutted_macros_grouped {
#@       lappend boundary_abutted_macros_boundary [P_get_boundary_polygon $each_group]
#@     }
#@   }
#@ 
#@   set die_boundary [list [get_attribute [get_core_area] boundary]]
#@   set c 1;
#@ 
#@   if {[info exists boundary_abutted_macros_boundary]} {
#@     foreach each_boundary_abut_macros $boundary_abutted_macros_boundary {
#@       if {$c == 1} {
#@         set new_die_boundary [compute_polygons -boolean not "$die_boundary" "$each_boundary_abut_macros"]
#@         set die_boundary $new_die_boundary;
#@         set c 0;
#@       } else {
#@         set die_boundary [ compute_polygons -boolean not "$new_die_boundary" "$each_boundary_abut_macros"]
#@         set new_die_boundary $die_boundary;
#@       }
#@     }
#@   }
#@ 
#@   set inner_list ""
#@   set inner_list $die_boundary;
#@ } else {
#@   set inner_list  [list [get_attribute [get_core_area] boundary]];
#@ }
#@ 
#@ ##############################################################################
#@ # Lets perform Step 2
#@ #  2. Compute the merged polygon of all the abutted macros and stand alone macros that are completely inside the core region and not abutting the Core
#@ ##############################################################################
#@ 
#@ set grouped_element_all [P_get_abutted_cells [all_macro_cells]]
#@ 
#@ if {[info exists boundary_abutted_macros_grouped]} {
#@   set grouped_element [lminus $grouped_element_all $boundary_abutted_macros_grouped]
#@ } else {
#@   set grouped_element  $grouped_element_all
#@ }
#@ 
#@ set mergedBoxes ""
#@ foreach each_group $grouped_element {
#@   lappend mergedBoxes [P_get_boundary_polygon $each_group]
#@ }
#@ 
#@ ####################################################################################
#@ # Split the inner and outer boundary if there is a complete donut shaped floorplan #
#@ ####################################################################################
#@ set outer_list ""
#@ foreach sann $mergedBoxes  {
#@   set san [lindex $sann 0]
#@   set nam [lrange $san 1 [expr [llength $san] -2 ]]
#@   set repeated_coordinate [P_lcount $nam]
#@   if {[llength $repeated_coordinate] == 2 } {
#@     set range [lsearch -all $nam $repeated_coordinate]
#@     set inner [lrange $nam [expr [lindex  $range 0] + 1] [expr [lindex $range 1] - 1]]
#@     set outer [lminus $san $inner]
#@     if { [info exists inner] } {
#@       if {$inner != ""} {
#@         lappend inner_list $inner;
#@       }
#@     }
#@     if { [info exists outer] } {
#@       if {$outer != ""} {
#@         lappend outer_list $outer;
#@       }
#@     }
#@   } else {
#@     lappend outer_list $san;
#@   }
#@ 
#@   set repeated_coordinate "";
#@ }
#@ 
#@ ####################################################################################
#@ # If Inner list exists (Inner donut region) then , excute the halo partition script#
#@ ####################################################################################
#@ 
#@ if  {[info exists inner_list]} {
#@   if {$inner_list != ""} {
#@     #puts "Inner"
#@     set var 0
#@     set allBox ""
#@     set instBox ""
#@     set inst ""
#@     set blockPtrs ""
#@ 
#@     set each_boundary ""
#@     set boundary ""
#@ 
#@     #Ignore this message
#@     #Warning: Setting default orientation 'North' on the object 'halo_h923'. (PSYN-294)
#@ 
#@     foreach each_boundary $inner_list {
#@       set boundary [lindex [compute_polygons -boolean or "$each_boundary" "$each_boundary"] 0]
#@       #puts "#INFO-MSG==>  Boundary is $boundary"
#@ 
#@       # first determine the direction from the last point to the first point
#@       set startpoint [lindex $boundary end-1]
#@       set endpoint [lindex $boundary 0]
#@       set prev_direction [P_find_direction $startpoint $endpoint]
#@       #puts "#INFO-MSG==>  Initial startpoint $startpoint"
#@       #puts "#INFO-MSG==>  Initial endpoint $endpoint"
#@       #puts "#INFO-MSG==>  Initial direction is $prev_direction"
#@ 
#@       set startpoint [lindex $boundary 0]
#@       foreach endpoint $boundary {
#@         #find the direction from $startpoint to $endpoint
#@         #is it going up, down, left, or right
#@         set direction [P_find_direction $startpoint $endpoint]
#@         set startx [lindex $startpoint 0]
#@         set starty [lindex $startpoint 1]
#@         set endx [lindex $endpoint 0]
#@         set endy [lindex $endpoint 1]
#@ 
#@         #puts "#INFO-MSG==>  Current startpoint ($startx, $starty)"
#@         #puts "#INFO-MSG==>  Current endpoint ($endx, $endy)"
#@         #puts "#INFO-MSG==>  Previous direction is $prev_direction"
#@         #puts "#INFO-MSG==>  Current direction is $direction"
#@ 
#@         if {$direction == "nochange"} {
#@           #Do nothing, move on!
#@           #puts "#INFO-MSG==>  Ignore"
#@         } elseif {$direction == "left"} {
#@           if {$prev_direction == "down"} {
#@             #              v down
#@             #             V|
#@             #             V|
#@             #             V|
#@             #   HHHHHHHHHHC|
#@             #  <-----------+
#@             # left
#@             P_place_halo $INTEL_halo_b_inside_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_b_inside_corner)] $starty FN
#@             set x [expr $startx-$halo_widths($INTEL_halo_b_inside_corner)]
#@             set halo $INTEL_halo_b_horiz
#@             set endx [format "%.3f" [expr $endx+$halo_widths($INTEL_halo_b_horiz)]]
#@           } elseif {$prev_direction == "up"} {
#@             #
#@             #   HHHHHHHHHHHHI
#@             #  <-----------+V
#@             # left         |V
#@             #              |V
#@             #              |V
#@             #              ^up
#@             # This is a rectilinear inside corner
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter $startx [expr $starty-$halo_height] N
#@             P_place_halo $INTEL_halo_b_corner halo_c$halo_counter $startx $starty FN
#@             set x $startx
#@             set halo $INTEL_halo_b_horiz
#@             set endx [format "%.3f" [expr $endx+$halo_widths($INTEL_halo_b_horiz)]]
#@           } else {
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@           # format the result to round the math to 3 sig digits. Do an internet search for
#@           #   "What Every Computer Scientist Should Know About Floating-Point Arithmetic" to get more details.
#@           while {$x > $endx} {
#@             # gotta round to sig digits due to float point numbers not exact
#@             P_place_halo $halo halo_h$halo_counter [expr $x-$halo_widths($halo)] $starty FN
#@             set x [format "%.3f" [expr $x-$halo_widths($halo)]]
#@           }
#@           unset halo
#@           set prev_direction $direction
#@         } elseif {$direction == "down"} {
#@           if {$prev_direction == "right"} {
#@             # right>-----------+
#@             #        HHHHHHHHHC|
#@             #                 V|
#@             #                 V|
#@             #                 V|
#@             #                  v down
#@             P_place_halo $INTEL_halo_c_inside_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_c_inside_corner)] [expr $starty-$halo_height] FN
#@             set y [expr $starty-$halo_height-$halo_height]
#@           } elseif {$prev_direction == "left"} {
#@             #    IHHHHHHHHHH
#@             #    V+-----------<left
#@             #    V|
#@             #    V|
#@             #    V|
#@             #    V|
#@             #     v down
#@             # This is a rectilinear inside corner
#@             P_place_halo $INTEL_halo_b_horiz halo_h$halo_counter $startx $starty N
#@             P_place_halo $INTEL_halo_b_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_b_corner)] $starty N
#@             set y [expr $starty-$halo_height]
#@           } else {
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@           while {$y >= [expr $endy+$halo_height-0.001]} {
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter [expr $startx-$halo_widths($INTEL_halo_side)] $y FN
#@             set y [expr $y-$halo_height]
#@           }
#@           set prev_direction $direction
#@         } elseif {$direction == "right"} {
#@           if {$prev_direction == "up"} {
#@             # +-----------> right
#@             # |CHHHHHHHHHH
#@             # |V
#@             # |V
#@             # |V
#@             # |V
#@             # ^up
#@             P_place_halo $INTEL_halo_c_inside_corner halo_c$halo_counter $startx [expr $starty-$halo_height] N
#@             set x [expr $startx+$halo_widths($INTEL_halo_c_inside_corner)]
#@             set halo $INTEL_halo_c_horiz
#@             set endx [format "%.3f" [expr $endx-$halo_widths($INTEL_halo_c_horiz)]]
#@           } elseif {$prev_direction == "down"} {
#@             #  v down
#@             # V|
#@             # V|
#@             # V|
#@             # V|
#@             # V+----------> right
#@             # IHHHHHHHHHHH
#@             # This is a rectilinear inside corner
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter [expr $startx-$halo_widths($INTEL_halo_side)] $starty FN
#@             P_place_halo $INTEL_halo_c_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_c_corner)] [expr $starty-$halo_height] N
#@             set x $startx
#@             set halo $INTEL_halo_c_horiz
#@             set endx [format "%.3f" [expr $endx-$halo_widths($INTEL_halo_c_horiz)]]
#@           } else {
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@           # format the result to round the math to 3 sig digits. Do an internet search for
#@           #   "What Every Computer Scientist Should Know About Floating-Point Arithmetic" to get more details.
#@           while {$x < $endx} {
#@             P_place_halo $halo halo_h$halo_counter $x [expr $starty-$halo_height] N
#@             set x [format "%.3f" [expr $x+$halo_widths($halo)]]
#@           }
#@           set prev_direction $direction
#@           unset halo
#@         } elseif {$direction == "up"} {
#@           if {$prev_direction == "left"} {
#@             #  ^ up
#@             #  |V
#@             #  |V
#@             #  |V
#@             #  |CHHHHHHHHH
#@             #  +-----------<left
#@             P_place_halo $INTEL_halo_b_inside_corner halo_c$halo_counter $startx $starty N
#@             set y [expr $starty+$halo_height]
#@           } elseif {$prev_direction == "right"} {
#@             #                  ^ up
#@             #                  |V
#@             #                  |V
#@             #                  |V
#@             #  right>----------+V
#@             #          HHHHHHHHHI
#@             # This is a rectilinear inside corner
#@             P_place_halo $INTEL_halo_c_horiz halo_h$halo_counter [expr $startx-$halo_widths($INTEL_halo_c_horiz)] [expr $starty-$halo_height] FN
#@             P_place_halo $INTEL_halo_c_corner halo_c$halo_counter $startx [expr $starty-$halo_height] FN
#@             set y $starty
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter $startx $y N
#@             set y [expr $y+$halo_height]
#@           } else {
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@           while {$y <= [expr $endy-$halo_height-$halo_height+0.001]} {
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter $startx $y N
#@             set y [expr $y+$halo_height]
#@           }
#@           set prev_direction $direction
#@         } else {
#@           puts "#ERROR-MSG==>  Cannot interpret direction \"$direction\""
#@         }
#@         set startpoint $endpoint
#@       }
#@ 
#@       #
#@       #Now running the actual ICC command
#@       #The variable $create_*cell contains all halo cell instances that are being created
#@       #
#@       if {[llength $halo_orient_N] > 0} {
#@         #puts "#INFO-MSG==>  Setting orientation for N HALO cells"
#@         rotate_objects -to N [get_cells -all $halo_orient_N] -ignore_fixed
#@       }
#@       if {[llength $halo_orient_FN] > 0} {
#@         #puts "#INFO-MSG==>  Setting orientation for FN HALO cells"
#@         rotate_objects -to FN [get_cells -all $halo_orient_FN] -ignore_fixed
#@       }
#@       if {[llength $halo_orient_S] > 0} {
#@         #puts "#INFO-MSG==>  Setting orientation for S HALO cells"
#@         rotate_objects -to S [get_cells -all $halo_orient_S] -ignore_fixed
#@       }
#@       if {[llength $halo_orient_FS] > 0} {
#@         #puts "#INFO-MSG==>  Setting orientation for FS HALO cells"
#@         rotate_objects -to FS [get_cells -all $halo_orient_FS] -ignore_fixed
#@       }
#@       #puts "#INFO-MSG==>  Marking all HALO cells to fixed"
#@       suppress_message {MWUI-031}
#@       set_attribute [get_cells -all halo_*] is_fixed true
#@       unsuppress_message {MWUI-031}
#@ 
#@       unsuppress_message {PSYN-294}
#@     }
#@   }
#@ }
#@ 
#@ ###########################################################################
#@ # Outer loop starts here
#@ # Walk though the boundary in clockwise direction
#@ # Find the direction and the previous direction, and determine placement of
#@ # vertical/horizontal/corner/inside halo cells
#@ ###########################################################################
#@ 
#@ set var 0
#@ set allBox ""
#@ set instBox ""
#@ set inst ""
#@ set blockPtrs ""
#@ 
#@ if  {[info exists outer_list]} {
#@   if {$outer_list != ""} {
#@ 
#@     suppress_message {PSYN-294}
#@ 
#@     set var 0
#@     set allBox ""
#@     set instBox ""
#@     set inst ""
#@     set blockPtrs ""
#@     set boundary ""
#@     set boundary1 ""
#@     set boundary2 ""
#@ 
#@     set o ""
#@ 
#@     foreach each_boundary $outer_list {
#@       set boundary_plain [lindex [compute_polygons -boolean or "$each_boundary" "$each_boundary"] 0]
#@       # these are globals (used by P_place_halo as globals)
#@       set halo_orient_N ""
#@       set halo_orient_FN ""
#@       set halo_orient_S ""
#@       set halo_orient_FS ""
#@ 
#@       set boundary2 $boundary_plain
#@       set o ""
#@       set boundary ""
#@ 
#@       set NOC [llength $boundary2]
#@       set i [expr $NOC -1]
#@       while {$i > -1} {
#@         lappend boundary [lindex $boundary2 $i]
#@         set i [expr $i -1]
#@       }
#@ 
#@       # first determine the direction from the last point to the first point
#@       set startpoint [lindex $boundary end-1]
#@       set endpoint [lindex $boundary 0]
#@       set prev_direction [P_find_direction $startpoint $endpoint]
#@ 
#@       set startpoint [lindex $boundary 0]
#@       foreach endpoint $boundary {
#@         #find the direction from $startpoint to $endpoint
#@         #is it going up, down, left, or right
#@         set direction [P_find_direction $startpoint $endpoint]
#@         set startx [lindex $startpoint 0]
#@         set starty [lindex $startpoint 1]
#@         set endx [lindex $endpoint 0]
#@         set endy [lindex $endpoint 1]
#@ 
#@         if {$direction == "nochange"} {
#@           #Do nothing, move on!
#@         } elseif {$direction == "left"} {
#@           if {$prev_direction == "down"} {
#@             #              v down
#@             #              |
#@             #              |
#@             #              |
#@             #   HHHHHHHHHHC|
#@             #  <-----------+
#@             # left
#@             P_place_halo $INTEL_halo_b_inside_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_b_inside_corner)] $starty FN
#@             set x [expr $startx-$halo_widths($INTEL_halo_b_inside_corner)]
#@             set halo $INTEL_halo_b_horiz
#@             set endx [format "%.3f" [expr $endx+$halo_widths($INTEL_halo_b_horiz)]]
#@           } elseif {$prev_direction == "up"} {
#@             #
#@             #   HHHHHHHHHHHHI
#@             #  <-----------+V
#@             # left         |
#@             #              |
#@             #              |
#@             #              ^up
#@             # This is a rectilinear inside corner
#@ 
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter $startx [expr $starty-$halo_height] N
#@             P_place_halo $INTEL_halo_b_corner halo_c$halo_counter $startx $starty FN
#@             set x $startx
#@             set halo $INTEL_halo_b_horiz
#@             set endx [format "%.3f" [expr $endx+$halo_widths($INTEL_halo_b_horiz)]]
#@           } else {
#@             # puts "Touching Core Boundary"
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@ 
#@           while {$x > $endx} {
#@             P_place_halo $halo halo_h$halo_counter [expr $x-$halo_widths($halo)] $starty FN
#@             set x [format "%.3f" [expr $x-$halo_widths($halo)]]
#@           }
#@ 
#@           unset halo
#@ 
#@           set prev_direction $direction
#@         } elseif {$direction == "down"} {
#@           if {$prev_direction == "right"} {
#@             # right>-----------+
#@             #                 C|
#@             #                 V|
#@             #                 V|
#@             #                 V|
#@             #                  v down
#@ 
#@             P_place_halo $INTEL_halo_c_inside_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_c_inside_corner)] [expr $starty-$halo_height] FN
#@             set y [expr $starty-$halo_height-$halo_height]
#@ 
#@           } elseif {$prev_direction == "left"} {
#@             #    IH
#@             #    V+-----------<left
#@             #    V|
#@             #    V|
#@             #    V|
#@             #    V|
#@             #     v down
#@             # This is a rectilinear inside corner
#@ 
#@             # set check  [ P_check_boundary_contact [expr $startx+5*$halo_hwidth] $starty ]
#@             # if {!$check} {
#@             # P_place_halo $INTEL_HALO_CELL_HOR halo_h$halo_counter [expr $startx+5*$halo_hwidth] $starty $o
#@             # } else {
#@             # puts "Touching Core Boundary"
#@             # }
#@ 
#@             # incr halo_counter
#@ 
#@             P_place_halo $INTEL_halo_b_horiz halo_h$halo_counter $startx $starty N
#@             P_place_halo $INTEL_halo_b_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_b_corner)] $starty N
#@             set y [expr $starty-$halo_height]
#@ 
#@           } else {
#@             #puts "I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@           while {$y >= [expr $endy+$halo_height-0.001]} {
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter [expr $startx-$halo_widths($INTEL_halo_side)] $y FN
#@             set y [expr $y-$halo_height]
#@             #flip the orientation every other row
#@           }
#@ 
#@           set prev_direction $direction
#@         } elseif {$direction == "right"} {
#@           if {$prev_direction == "up"} {
#@             # +-----------> right
#@             # |CHHHHHHHHHH
#@             # |
#@             # |
#@             # |
#@             # ^up
#@ 
#@             P_place_halo $INTEL_halo_c_inside_corner halo_c$halo_counter $startx [expr $starty-$halo_height] N
#@             set x [expr $startx+$halo_widths($INTEL_halo_c_inside_corner)]
#@             set halo $INTEL_halo_c_horiz
#@             set endx [format "%.3f" [expr $endx-$halo_widths($INTEL_halo_c_horiz)]]
#@           } elseif {$prev_direction == "down"} {
#@             #  v down
#@             #  |
#@             #  |
#@             #  |
#@             #  |
#@             # V+----------> right
#@             # IHHHHHHHHHHH
#@             # This is a rectilinear inside corner
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter [expr $startx-$halo_widths($INTEL_halo_side)] $starty FN
#@             P_place_halo $INTEL_halo_c_corner halo_c$halo_counter [expr $startx-$halo_widths($INTEL_halo_c_corner)] [expr $starty-$halo_height] N
#@             set x $startx
#@             set halo $INTEL_halo_c_horiz
#@             set endx [format "%.3f" [expr $endx-$halo_widths($INTEL_halo_c_horiz)]]
#@           } else {
#@             #puts "I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@ 
#@           # use 32-wide horizontal halo if it fits
#@           while {$x < $endx} {
#@             P_place_halo $halo halo_h$halo_counter $x [expr $starty-$halo_height] N
#@             set x [format "%.3f" [expr $x+$halo_widths($halo)]]
#@           }
#@ 
#@           set prev_direction $direction
#@           unset halo
#@         } elseif {$direction == "up"} {
#@           if {$prev_direction == "left"} {
#@             #  ^ up
#@             #  |V
#@             #  |V
#@             #  |V
#@             #  |C
#@             #  +-----------<left
#@             P_place_halo $INTEL_halo_b_inside_corner halo_c$halo_counter $startx $starty N
#@             set y [expr $starty+$halo_height]
#@ 
#@           } elseif {$prev_direction == "right"} {
#@             #                  ^ up
#@             #                  |V
#@             #                  |V
#@             #                  |V
#@             #  right>----------+V
#@             #                  HI
#@             # This is a rectilinear inside corner
#@ 
#@             P_place_halo $INTEL_halo_c_horiz halo_h$halo_counter [expr $startx-$halo_widths($INTEL_halo_c_horiz)] [expr $starty-$halo_height] FN
#@             P_place_halo $INTEL_halo_c_corner halo_c$halo_counter $startx [expr $starty-$halo_height] FN
#@             set y $starty
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter $startx $y N
#@             set y [expr $y+$halo_height]
#@           } else {
#@             #puts "I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@             puts "#ERROR-MSG==>  I DONT KNOW WHAT THIS IS : direction $direction, previous direction $prev_direction"
#@           }
#@           while {$y <= [expr $endy-$halo_height-$halo_height+0.001]} {
#@             P_place_halo $INTEL_halo_side halo_v$halo_counter $startx $y N
#@             set y [expr $y+$halo_height]
#@             #flip the orientation every other row
#@             #puts "Orientation is $o, and Y is $y, ENDY is $endy"
#@           }
#@ 
#@           set prev_direction $direction
#@         } else {
#@           #puts "Cannot interpret direction \"$direction\""
#@           are          puts "#ERROR-MSG==>  Cannot interpret direction \"$direction\""
#@         }
#@         set startpoint $endpoint
#@       }
#@ 
#@       #
#@       #Now running the actual ICC command
#@       #The variable $create_*cell contains all halo cell instances that are being created
#@       #
#@       if {[llength $halo_orient_N] > 0} {
#@         rotate_objects -to N [get_cells -all $halo_orient_N] -ignore_fixed
#@       }
#@       if {[llength $halo_orient_FN] > 0} {
#@         rotate_objects -to FN [get_cells -all $halo_orient_FN] -ignore_fixed
#@       }
#@       if {[llength $halo_orient_S] > 0} {
#@         #puts "#INFO-MSG==>  Setting orientation for S HALO cells"
#@         rotate_objects -to S [get_cells -all $halo_orient_S] -ignore_fixed
#@       }
#@       if {[llength $halo_orient_FS] > 0} {
#@         #puts "#INFO-MSG==>  Setting orientation for FS HALO cells"
#@         rotate_objects -to FS [get_cells -all $halo_orient_FS] -ignore_fixed
#@       }
#@       suppress_message {MWUI-031}
#@       set_attribute [get_cells -all halo_*] is_fixed true
#@       unsuppress_message {MWUI-031}
#@       unsuppress_message {PSYN-294}
#@     }
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/halo_d04.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/create_power_straps.tcl

#@ ##############################################################################
#@ # Script: create_power_straps.tcl
#@ # Description : Creates Power Straps for the design
#@ # List of procs used by this scripts
#@ # 1. P_macro_route_guide_cmd
#@ # 2. P_msg_info
#@ # 3. P_strap_cmd
#@ ##############################################################################
#@ 
#@ ###########################
#@ # Get design boundaries
#@ ###########################
#@ 
#@ set bound_llx [lindex [lindex [get_attribute [get_die_area ] bbox] 0] 0]
#@ set bound_lly [lindex [lindex [get_attribute [get_die_area ] bbox] 0] 1]
#@ set bound_urx [lindex [lindex [get_attribute [get_die_area ] bbox] 1] 0]
#@ set bound_ury [lindex [lindex [get_attribute [get_die_area ] bbox] 1] 1]
#@ 
#@ ####################################################################
#@ # Create blockages around partition if no halo cells are available
#@ ####################################################################
#@ # Set to true if NO Halo Cells available
#@ if {0} {
#@   set blk_top_edge_keepout "{$bound_llx [expr $bound_ury - 0.798]} {$bound_urx $bound_ury}"
#@   set blk_bottom_edge_keepout "{$bound_llx $bound_lly} {$bound_urx [expr $bound_lly + 0.798]}"
#@   set blk_left_edge_keepout "{$bound_llx $bound_lly} {[expr $bound_llx + 0.360] $bound_ury}"
#@   set blk_right_edge_keepout "{[expr $bound_urx - 0.360] $bound_lly} {$bound_urx $bound_ury}"
#@ 
#@   #Create blockages until we get halo cells
#@   create_placement_blockage -type hard -bbox $blk_top_edge_keepout -name placeblk_top_keepout
#@   create_placement_blockage -type hard -bbox $blk_bottom_edge_keepout -name placeblk_bottom_keepout
#@   create_placement_blockage -type hard -bbox $blk_left_edge_keepout -name placeblk_left_keepout
#@   create_placement_blockage -type hard -bbox $blk_right_edge_keepout -name placeblk_right_keepout
#@ }
#@ 
#@ ###########################################
#@ # Define vias to be used for PG straps
#@ ###########################################
#@ 
#@ set_preroute_advanced_via_rule -contact_codes VIA2O -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@ set_preroute_advanced_via_rule -contact_codes VIA3S -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@ set_preroute_advanced_via_rule -contact_codes VIA4O -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@ set_preroute_advanced_via_rule -contact_codes VIA7D -size_by_array_dimensions "1 3" -move_via_to_center -rotation_mode off
#@ set_preroute_advanced_via_rule -contact_codes VIA8A -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@ 
#@ set preroute_ContactSizeSelection 2
#@ 
#@ ############################################################################################
#@ # Create route guides around partition for correct PG pullback of rectilinear partitions
#@ ############################################################################################
#@ 
#@ set boundary [get_attribute [get_die_area] boundary]
#@ set top_layer 6
#@ set count 0
#@ set lcount 0
#@ set v_start 2
#@ set h_start 3
#@ foreach point $boundary {
#@   if {$lcount != 0} {
#@     if {[lindex $point 0] == [lindex $prev 0]} {
#@       # Create vertical route guides (M2, M4, M6)
#@       set y1 [lindex $prev 1]
#@       set y2 [lindex $point 1]
#@ 
#@       for {set i $v_start} {[expr $i <= $top_layer]} {incr i 2} {
#@         switch -exact -- $i {
#@           2  { create_route_guide -no_signal_layers m2 -no_preroute_layers m2 -coordinate [list [expr [lindex $point 0] - 0.004] $y1 [expr [lindex $point 0] +0.004] $y2] -name pgblkg_cutout_m2_${count}
#@           }
#@           4  { create_route_guide -no_signal_layers m4 -no_preroute_layers m4 -coordinate [list [expr [lindex $point 0] - 0.004] $y1 [expr [lindex $point 0] +0.004] $y2] -name pgblkg_cutout_m4_${count}
#@           }
#@           6  { create_route_guide -no_signal_layers m6 -no_preroute_layers m6 -coordinate [list [expr [lindex $point 0] - 0.004] $y1 [expr [lindex $point 0] +0.004] $y2] -name pgblkg_cutout_m6_${count}
#@           }
#@         }
#@       }
#@     } else {
#@       # Create horizontal route guides (M3)
#@       set x1 [lindex $prev 0]
#@       set x2 [lindex $point 0]
#@ 
#@       for {set i $h_start} {[expr $i <= $top_layer]} {incr i 2} {
#@         switch -exact -- $i {
#@           3  { create_route_guide -no_signal_layers m3 -no_preroute_layers m3 -coordinate [list $x1 [expr [lindex $point 1] - 0.004] $x2 [expr [lindex $point 1] +0.004]] -name pgblkg_cutout_m3_${count}
#@           }
#@           5  { create_route_guide -no_signal_layers m5 -no_preroute_layers m5 -coordinate [list $x1 [expr [lindex $point 1] - 0.004] $x2 [expr [lindex $point 1] +0.004]] -name pgblkg_cutout_m5_${count}
#@           }
#@         }
#@       }
#@     }
#@   }
#@   incr count
#@   incr lcount
#@   set prev $point
#@ }
#@ 
#@ ##############################
#@ # Create Power Straps
#@ ##############################
#@ 
#@ set pg_layers [lrange $INTEL_METAL_LAYERS 0 [lsearch $INTEL_METAL_LAYERS $INTEL_MAX_PG_LAYER]];
#@ 
#@ foreach layer $pg_layers {
#@ 
#@   P_macro_route_guide_cmd $layer
#@ 
#@   if {$layer=="m9"} {
#@     #m9
#@     P_msg_info "Creating power straps for m9..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m8 -max_layer tm1
#@     #---------- layer  direction net          width start_at step  pullback
#@     P_strap_cmd m9 vertical  $INTEL_MW_POWER_NET  1.080  8.40    13.44 0.00
#@     P_strap_cmd m9 vertical  $INTEL_MW_POWER_NET  1.080  5.04    13.44 0.00
#@     P_strap_cmd m9 vertical  $INTEL_MW_GROUND_NET 1.080  1.68    13.44 0.00
#@     P_strap_cmd m9 vertical  $INTEL_MW_GROUND_NET 1.080  11.76   13.44 0.00
#@   }
#@ 
#@   if {$layer=="m8"} {
#@     #m8
#@     P_msg_info "Creating power straps for m8..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m7 -max_layer m9
#@     #---------- layer  direction  net          width start_at step  pullback
#@     P_strap_cmd m8 horizontal $INTEL_MW_POWER_NET  0.714 5.586   12.768 0.00
#@     P_strap_cmd m8 horizontal $INTEL_MW_POWER_NET  0.714 7.182   12.768 0.00
#@     P_strap_cmd m8 horizontal $INTEL_MW_GROUND_NET 0.714 0.798   12.768 0.00
#@     P_strap_cmd m8 horizontal $INTEL_MW_GROUND_NET 0.714 11.97   12.768 0.00
#@   }
#@ 
#@   if {$layer=="m7"} {
#@     #m7
#@     P_msg_info "Creating power straps for m7..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m6 -max_layer m8
#@     #---------- layer  direction net          width start_at step  pullback
#@     P_strap_cmd m7 vertical  $INTEL_MW_POWER_NET  0.168 2.464    6.720 0.00
#@     P_strap_cmd m7 vertical  $INTEL_MW_POWER_NET  0.168 4.256    6.720 0.00
#@     P_strap_cmd m7 vertical  $INTEL_MW_GROUND_NET 0.168 0.896    6.720 0.00
#@     P_strap_cmd m7 vertical  $INTEL_MW_GROUND_NET 0.168 5.824    6.720 0.00
#@   }
#@ 
#@   if {$layer=="m6"} {
#@     #m6
#@     P_msg_info "Creating power straps for m6..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m5 -max_layer m7
#@     #---------- layer  direction  net          width start_at step  pullback
#@     P_strap_cmd m6 horizontal $INTEL_MW_POWER_NET  0.108 1.260    3.192 0.04
#@     P_strap_cmd m6 horizontal $INTEL_MW_POWER_NET  0.108 1.932    3.192 0.04
#@     P_strap_cmd m6 horizontal $INTEL_MW_GROUND_NET 0.108 0.336    3.192 0.04
#@     P_strap_cmd m6 horizontal $INTEL_MW_GROUND_NET 0.108 2.856    3.192 0.04
#@   }
#@ 
#@   if {$layer=="m5"} {
#@     #m5
#@     P_msg_info "Creating power straps for m5..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m4 -max_layer m6
#@     #---------- layer  direction net          width start_at step  pullback
#@     P_strap_cmd m5 vertical  $INTEL_MW_POWER_NET  0.084 1.288    1.680 0.028
#@     P_strap_cmd m5 vertical  $INTEL_MW_GROUND_NET 0.084 0.392    1.680 0.028
#@   }
#@ 
#@   if {$layer=="m4"} {
#@     #m4
#@     P_msg_info "Creating power straps for m4..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m3 -max_layer m5
#@     #---------- layer  direction  net          width start_at step  pullback
#@     set_preroute_advanced_via_rule -contact_codes VIA3O -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@     P_strap_cmd m4 horizontal $INTEL_MW_POWER_NET  0.084 0.798    3.192 0.028
#@     set_preroute_advanced_via_rule -contact_codes VIA3S -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@     P_strap_cmd m4 horizontal $INTEL_MW_POWER_NET  0.076 1.898    3.192 0.028
#@     P_strap_cmd m4 horizontal $INTEL_MW_POWER_NET  0.076 2.890    3.192 0.028
#@ 
#@     P_strap_cmd m4 horizontal $INTEL_MW_GROUND_NET 0.076 0.302    3.192 0.028
#@     P_strap_cmd m4 horizontal $INTEL_MW_GROUND_NET 0.076 1.294    3.192 0.028
#@     set_preroute_advanced_via_rule -contact_codes VIA3O -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@     P_strap_cmd m4 horizontal $INTEL_MW_GROUND_NET 0.084 2.394    3.192 0.028
#@   }
#@ 
#@   if {$layer=="m3"} {
#@     #m3
#@     P_msg_info "Creating power straps for m3..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m2 -max_layer m4
#@     #---------- layer  direction net          width start_at step  pullback
#@     P_strap_cmd m3 vertical  $INTEL_MW_POWER_NET  0.084 1.288    1.680 0.028
#@     P_strap_cmd m3 vertical  $INTEL_MW_GROUND_NET 0.084 0.392    1.680 0.028
#@   }
#@ 
#@   if {$layer=="m2"} {
#@     #m2
#@     P_msg_info "Creating power straps for m2..."
#@     set_preroute_drc_strategy -ignore_onGrid_rule -ignore_discrete_metal_width_rule -min_layer m2 -max_layer m3 -ignore_std_cells
#@     #---------- layer  direction  net          width start_at step  pullback
#@     P_strap_cmd m2 horizontal $INTEL_MW_POWER_NET  0.074 0.399    0.798 0.028
#@     P_strap_cmd m2 horizontal $INTEL_MW_GROUND_NET 0.040 0.058    0.798 0.028
#@     P_strap_cmd m2 horizontal $INTEL_MW_GROUND_NET 0.040 0.740    0.798 0.028
#@   }
#@ }
#@ 
#@ #######################################
#@ ## Drop vias to hhb/hhc halo m2 pins ##
#@ #######################################
#@ 
#@ set_preroute_advanced_via_rule -contact_codes VIA2O -size_by_array_dimensions "1 1" -move_via_to_center -rotation_mode off
#@ set_preroute_drc_strategy -min_layer m2 -max_layer m3 -no_design_rule
#@ create_preroute_vias -nets $INTEL_MW_POWER_NET -from_layer m3 -to_layer m2 -from_object_strap -to_object_std_pin -advanced_via_rules
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/create_power_straps.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/interface_metals.tcl

#@ ##############################################################################
#@ ## To create floating metals at design boundary to avoid DRC's
#@ ## Defines proc which is then sourced at the end of the file
#@ 
#@ ## Proc Definitions
#@ 
#@ proc create_interface_metal {args} {
#@   parse_proc_arguments -args $args ARGS
#@ 
#@   global INTEL_MAX_ROUTING_LAYER
#@   global INTEL_METAL_LAYERS
#@   set v_layer 5
#@   set h_layer 6
#@   set top_layer [string map {m ""} $INTEL_MAX_ROUTING_LAYER]
#@ 
#@   array set tracks [find_tracks [lrange $INTEL_METAL_LAYERS [lsearch $INTEL_METAL_LAYERS m5] [lsearch $INTEL_METAL_LAYERS $INTEL_MAX_ROUTING_LAYER]]]
#@ 
#@ 
#@   set die [get_attribute [get_die_area] boundary]
#@ 
#@   set m [all_macro_cells]
#@   if {[info exists ARGS(-macros)]} {
#@     set m [get_cells -all $ARGS(-macros)]
#@   }
#@ 
#@   if {$m != ""} {
#@     set core [compute_polygons -boolean not $die [convert_to_polygon $m]]
#@   } else {
#@     set core $die
#@   }
#@ 
#@   set t [compute_polygons -boolean xor [resize_polygon -size_top    -1 $core] $core]
#@   set b [compute_polygons -boolean xor [resize_polygon -size_bottom -1 $core] $core]
#@   set r [compute_polygons -boolean xor [resize_polygon -size_right  -1 $core] $core]
#@   set l [compute_polygons -boolean xor [resize_polygon -size_left   -1 $core] $core]
#@ 
#@   # Constants
#@   # ---------
#@ 
#@   set DIMS(m6:grid)   1.68
#@   set DIMS(m6:hete)   0.04
#@   set DIMS(m6:width)  0.044
#@   set DIMS(m6:track)  0.042
#@ 
#@   set DIMS(m8:grid)   [expr 2*1.68]
#@   set DIMS(m8:hete)   0.07
#@   set DIMS(m8:width)  0.140
#@   set DIMS(m8:track)  0.0
#@ 
#@   set DIMS(m5:grid)   1.596
#@   set DIMS(m5:hete)   0.028
#@   set DIMS(m5:width)  0.028
#@   set DIMS(m5:track)  0.0
#@ 
#@   set DIMS(m7:grid)   1.596
#@   set DIMS(m7:hete)   0.045
#@   set DIMS(m7:width)  0.056
#@   set DIMS(m7:track)  0.056
#@ 
#@   #set DIMS(m9:grid)   [expr 4*1.596]
#@   #set DIMS(m9:hete)   0.06
#@   #set DIMS(m9:width)  1.38
#@   #set DIMS(m9:track)  0.96
#@ 
#@   set snap_state [get_object_snap_type -enabled]
#@   set_object_snap_type -enabled false
#@ 
#@   # Horizontal edges
#@   # ----------------
#@ 
#@   foreach what {t b} {
#@ 
#@     foreach p [set $what] {
#@ 
#@       set box [lindex [convert_from_polygon -format rectangle $p] 0]
#@       set x1 [lindex [lindex $box 0] 0]
#@       set y1 [lindex [lindex $box 0] 1]
#@       set x2 [lindex [lindex $box 1] 0]
#@       set y2 [lindex [lindex $box 1] 1]
#@ 
#@       for {set i $h_layer} {[expr $i <= $top_layer]} {incr i 2} {
#@ 
#@         set layer [join "m $i" ""]
#@         set x $x1
#@         set dx [expr $x2-$x1]
#@         set grid $DIMS($layer:grid)
#@ 
#@         if {$grid > $dx} {
#@           set grid $dx
#@         }
#@ 
#@         if {$what == "t"} {
#@           # Find first track below top edge
#@           if {[info exists tracks($layer)]} {
#@             foreach val $tracks($layer) {
#@               if {$val-$y2 > 0.0001} {break}
#@               set y $val
#@             }
#@           }
#@         } else {
#@           # Find first track above bottom edge
#@           if {[info exists tracks($layer)]} {
#@             foreach val $tracks($layer) {
#@               set y $val
#@               if {$val-$y1 > 0.0001} {break}
#@             }
#@           }
#@         }
#@ 
#@         while {$x < $x2-$DIMS($layer:hete)-0.0001} {
#@           set px1 [expr $x+$DIMS($layer:hete)]
#@           if {$x+$grid+0.0001 > $x2} {
#@             set px2 [expr $x2-$DIMS($layer:hete)]
#@           } else {
#@             set px2 [expr $x+$grid-$DIMS($layer:hete)]
#@           }
#@ 
#@           create_user_shape               -route_type user_enter               -width $DIMS($layer:width)               -layer $layer               -type path               -points [list [list $px1 $y] [list $px2 $y]]
#@ 
#@           set x [expr $x+$grid]
#@         }
#@       }
#@     }
#@   }
#@ 
#@   # Vertical edges
#@   # --------------
#@ 
#@   foreach what {l r} {
#@ 
#@     foreach p [set $what] {
#@ 
#@       set box [lindex [convert_from_polygon -format rectangle $p] 0]
#@       set x1 [lindex [lindex $box 0] 0]
#@       set y1 [lindex [lindex $box 0] 1]
#@       set x2 [lindex [lindex $box 1] 0]
#@       set y2 [lindex [lindex $box 1] 1]
#@ 
#@       for {set i $v_layer} {[expr $i <= $top_layer]} {incr i 2} {
#@ 
#@         set layer [join "m $i" ""]
#@         set y $y1
#@         set dy [expr $y2-$y1]
#@         set grid $DIMS($layer:grid)
#@ 
#@         if {$grid > $dy} {
#@           set grid $dy
#@         }
#@ 
#@         if {$what == "r"} {
#@           set x $x2 ;# Default for m5
#@ 
#@           # Find first track to the left of the vertical
#@           if {[info exists tracks($layer)]} {
#@             foreach val $tracks($layer) {
#@               if {$val-$x2 > -0.0001} {break}
#@               set x $val
#@             }
#@           }
#@         } else {
#@           set x $x1 ;# Default for m5
#@ 
#@           # Find first track to the right of the vertical
#@           if {[info exists tracks($layer)]} {
#@             foreach val $tracks($layer) {
#@               set x $val
#@               if {[expr $val-$x1] > 0.0001} {break}
#@             }
#@           }
#@         }
#@ 
#@         while {$y < $y2-$DIMS($layer:hete)-0.0001} {
#@           set py1 [expr $y+$DIMS($layer:hete)]
#@           if {$y+$grid > $y2} {
#@             set py2 [expr $y2-$DIMS($layer:hete)]
#@           } else {
#@             set py2 [expr $y+$grid-$DIMS($layer:hete)]
#@           }
#@ 
#@           create_user_shape               -route_type user_enter               -width $DIMS($layer:width)               -layer $layer               -type path               -points [list [list $x $py1] [list $x $py2]]
#@ 
#@           set y [expr $y+$grid]
#@         }
#@       }
#@     }
#@   }
#@   set_object_snap_type -enabled $snap_state
#@ }
#@ define_proc_attributes create_interface_metal     -info "Generates boundary metal for a partition"     -define_args {
#@       {-macros
#@         "Macros (default all_macro_cells)" string string optional}
#@     }
#@ 
#@ 
#@ proc find_tracks {layers} {
#@   array set all_tracks {}
#@ 
#@   foreach_in_collection layer [get_layers $layers] {
#@     set layer_name [get_object_name $layer]
#@     redirect -variable rule_based_track {report_rule_based_track -layer $layer}
#@     set reserved_tracks [regexp -inline -line -all {.*width} $rule_based_track]
#@     for {set i 0} {$i<[llength $reserved_tracks]} {incr i} {
#@       if {[regexp -inline -line -all {.*reserved_for_width} [lindex $reserved_tracks $i]] == ""} { 
#@         set start [lindex $reserved_tracks $i 2]
#@         set count [lindex $reserved_tracks $i 3]
#@         set space [lindex $reserved_tracks $i 4]
#@         set v $start
#@         for {set j 0} {$j<$count} {incr j} {
#@           lappend all_tracks($layer_name) $v
#@           set v [expr $v+$space]
#@         }
#@       }
#@     }
#@   }
#@ 
#@   foreach layer_name [array names all_tracks] {
#@     set all_tracks($layer_name) [lsort -real $all_tracks($layer_name)]
#@   }
#@ 
#@   return [array get all_tracks]
#@ }
#@ 
#@ ## Call to proc
#@ 
#@ create_interface_metal
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/interface_metals.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/isolated_pin_extension.tcl

#@ ##############################################################################
#@ #
#@ # File        : isolated_pin_extension.tcl
#@ #
#@ # Description : Script used during floorplan to create geometry shapes on
#@ #   accompanying m4 buddy pins to avoid m4 isolate rule/m4_147
#@ #
#@ # Inputs      : Floorplan with HIP's placed
#@ #
#@ # Returns     : Creates m4 shapes on the m4 isolate buddy pins
#@ #
#@ # Note        :
#@ #
#@ ##########################################################################
#@ 
#@ 
#@ #Check if macros exist in the design
#@ if {[sizeof_collection [all_macro_cells]] == 0} {
#@   P_msg_info "There are no macro cells in this design"
#@   return
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/isolated_pin_extension.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/io_placement.tcl

#@ ##############################################################################
#@ # Script: io_placement.tcl
#@ # Description : Places ports in the design
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ # 2. P_msg_warn
#@ 
#@ #############################################
#@ # This is a template/example constraint
#@ #############################################
#@ 
#@ set_fp_pin_constraints -block_level -corner_keepout_num_wiretracks 9
#@ set_pin_physical_constraints [get_ports] -pin_spacing 1 -layers {m6 m7} -exclude_sides {3,4}
#@ 
#@ set my_ports ""
#@ 
#@ ####################################################################
#@ # Make the terminal with min length
#@ # This is to avoid DRC violation if the terminal ends up floating
#@ ####################################################################
#@ 
#@ foreach {metal stub} $INTEL_TERM_LENGTH {
#@   set term_length($metal) $stub
#@ }
#@ 
#@ ############################################
#@ # Create list of ports to be placed
#@ ############################################
#@ 
#@ # Check if DEF/TCL was read-in
#@ if {![info exists INTEL_FP_INPUT] || $INTEL_FP_INPUT == ""} {
#@   P_msg_info "Def file is not present. Placing all the I/O Ports"
#@   set my_ports [get_attribute [get_ports] name ]
#@ }
#@ 
#@ # If DEF/TCL was read-in -> Checking if all the ports were placed correctly, if not add them to list of ports to be placed
#@ if {[info exists INTEL_FP_INPUT] && ($INTEL_FP_INPUT == "DEF" || $INTEL_FP_INPUT == "FP_TCL")} {
#@   foreach port [get_attribute [get_ports] name] {
#@     set layer [get_attribute [get_ports $port] layer]
#@     set bbox [get_attribute [get_ports $port] bbox]
#@     if {$layer == "hilite" || $layer == "no_layer" || $bbox == "no_bbox"} {
#@        P_msg_warn "$port is not placed. Placing it"
#@        set my_ports [concat $my_ports $port]
#@     } else {
#@       set fixed [get_attribute [get_ports $port] is_fixed]
#@       scan [get_attribute [get_terminals -of_objects [get_ports $port]] bbox] "{%f %f} {%f %f}" t_llx t_lly t_urx t_ury
#@       set bbox [get_attribute [get_terminals -of_objects [get_ports $port]] bbox]
#@       set area [expr ($t_urx - $t_llx) * ($t_ury - $t_lly)]
#@       echo "Attributes of $port: $layer $bbox $fixed"
#@       if { [regexp {(^m)(.*)} $layer] && [expr $area <= 0.5 ] && $fixed == "false"  } {
#@         set_attribute [get_ports $port] is_fixed true
#@         P_msg_warn "$port is placed but doesn't have fixed attribute. Fixing it"
#@       } elseif { [expr $area >= 0.5] && $layer != "tm1" } {
#@         P_msg_warn "$port is not placed. Placing it"
#@         set my_ports [concat $my_ports $port]
#@       }
#@     }
#@   }
#@ }
#@ 
#@ ###############################################
#@ # Place ports based on list of ports created
#@ ###############################################
#@ 
#@ if {$my_ports != ""} {
#@   # Creating low effort cell placement for better io placement
#@   create_fp_placement -effort low -optimize_pins
#@   place_fp_pins -block_level -verbose
#@   move_objects -delta {0,0} [get_terminals]
#@ 
#@   foreach my_port $my_ports {
#@     set attr [get_attribute [get_ports -of_objects $my_port] port_type]
#@     if { [regexp Power $attr] || [regexp Ground $attr] } {
#@       ### PG terminals, keep as it is.
#@     } else {
#@       set my_dir [get_attribute [get_terminals $my_port] access_direction]
#@       set my_layer [get_attribute [get_terminals  $my_port] layer]
#@       scan [get_attribute [get_terminals $my_port] bbox] "{%f %f} {%f %f}" t_llx t_lly t_urx t_ury
#@ 
#@       switch -regexp -- $my_dir {
#@         Left {
#@           set newx  [expr $t_llx + $term_length($my_layer)]
#@           set cmd "set_attribute \[get_terminals $my_port \] bbox {$t_llx $t_lly $newx $t_ury}"
#@           eval $cmd
#@         }
#@         Right {
#@           set newx  [expr $t_urx - $term_length($my_layer)]
#@           set cmd "set_attribute \[get_terminals $my_port\] bbox {$newx $t_lly $t_urx $t_ury}"
#@           eval $cmd
#@         }
#@         Up {
#@           set newy  [expr $t_ury - $term_length($my_layer)]
#@           set cmd "set_attribute \[get_terminals $my_port\] bbox {$t_llx $newy $t_urx $t_ury}"
#@           eval $cmd
#@         }
#@         Down {
#@           set newy  [expr $t_lly + $term_length($my_layer)]
#@           set cmd "set_attribute \[get_terminals $my_port\] bbox {$t_llx $t_lly $t_urx $newy}"
#@           eval $cmd
#@         }
#@       }
#@     }
#@   }
#@   snap_objects [get_terminals -of_objects [get_ports $my_ports]]
#@   set_attribute [get_terminals -of_objects [get_ports]] is_fixed true
#@   # Removing temporary standard cell placement created above
#@   remove_placement -object_type standard_cell
#@ }
#@ 
#@ 
#@ #
#@ # Once input/output terminal placements are determined, create a design specific
#@ # file and use it to override this auto pin placement in the default flow.
#@ # You can write out an existing pin placement with
#@ # write_floorplan -placement { terminal }     #                 -no_placement_blockage -no_bound -no_plan_group     #                 -no_voltage_area -no_route_guide -no_create_boundary     #                 scripts/io_placement.tcl
#@ #
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/io_placement.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_tap_cells.tcl

#@ ##############################################################################
#@ # Script: add_tap_cells.tcl
#@ # Description: Add tap cells in the design
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ # 2. P_placement_blockage_move_or_unmove
#@ 
#@ set blockage_bbox_pairs ""
#@ 
#@ if {[sizeof_collection [get_placement_blockages -quiet]] > 0 } {
#@   P_msg_info "Temporarily removing placement blockages before tap cell insertion."
#@   set blockage_bbox_pairs [P_placement_blockage_move_or_unmove move];  ## move placement blockage out of bounds ##
#@ }
#@ 
#@ P_msg_info "Inserting tap cells $INTEL_TAP_CELL";
#@ if {[info exists INTEL_STDCELL_CORE2H_TILE]} {
#@    set_parameter -module place -name legalUnitTiles -value [lindex $INTEL_STDCELL_CORE2H_TILE 0] -type string
#@ } else {
#@    set_parameter -module place -name legalUnitTiles -value $INTEL_STDCELL_TILE -type string
#@ }
#@ set tap_spacing 110.88
#@ if {[info exists INTEL_XN_LIBRARY]&&$INTEL_XN_LIBRARY} {
#@   set tap_spacing 10.888
#@ }
#@ 
#@ add_tap_cell_array -master_cell_name $INTEL_TAP_CELL -pattern normal    -distance $tap_spacing -ignore_soft_blockage true  -skip_fixed_cells true 
#@ 
#@ P_placement_blockage_move_or_unmove $blockage_bbox_pairs;            ## restore original placement blockage   ##
#@ 
#@ set_parameter -module place -name legalUnitTiles -value $INTEL_STDCELL_TILE -type string
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_tap_cells.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/insert_antenna_diodes_on_input.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_error
#@ # 2. P_msg_info
#@ 
#@ # Get lib cells to use for diode insertion.
#@ # The tool requires the specific diode library to be used and for MCMM mode that needs to be the current scenario.
#@ # So for MCMM mode a dummy diode cell is inserted to get the correct lib_cell, once done the dummy diode in removed.
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   if {[sizeof_collection [get_cells -all -filter "ref_name =~ $INTEL_ANTENNA_DIODE"]] == 0} {
#@     create_cell test_diode $INTEL_ANTENNA_DIODE
#@   }
#@   foreach lib [get_object_name [get_libs -scenario [current_scenario]]] {
#@     if {[get_lib_cells -quiet $lib/$INTEL_ANTENNA_DIODE] ne ""} {
#@       set diode_cell_insert [get_object_name [get_lib_cells -quiet $lib/$INTEL_ANTENNA_DIODE]]
#@     }
#@   }
#@   if {[sizeof_collection [get_cells *test_diode*]] > 0} {
#@     remove_cell test_diode
#@   }
#@ } else {
#@   foreach lib [split $target_library] {
#@     set lib [file rootname $lib]
#@     if {[get_lib_cells -quiet ${lib}*/${INTEL_ANTENNA_DIODE}] ne ""} {
#@       set diode_cell_insert [get_object_name [get_lib_cells -quiet ${lib}*/${INTEL_ANTENNA_DIODE}]]
#@     }
#@   }
#@ }
#@ 
#@ # Check if the chosen diode cell to insert exists
#@ if {![info exists diode_cell_insert] || $diode_cell_insert eq ""} {
#@   P_msg_error "No input port diode cell found in library. Please check that $INTEL_ANTENNA_DIODE is set and the cell is available in the library!"
#@   return
#@ }
#@ 
#@ # Insert GNAC diode on all input ports Except Clock Ports and the Ports specified by The User Through Variable INTEL_NO_INPUT_DIODE_PORTS
#@ set clock_ports [get_ports [get_attribute [all_clocks] sources -quiet]]
#@ # Avoid tm1 ports as they are typically pad inputs
#@ set tm1_ports [get_ports -filter {layer == "tm1"}]
#@ set avoid_ports [add_to_collection [add_to_collection $clock_ports $INTEL_NO_INPUT_DIODE_PORTS] $tm1_ports]
#@ if {[get_attribute $diode_cell_insert dont_use] == true} {
#@   remove_attribute $diode_cell_insert dont_use
#@ }
#@ define_user_attribute -class port -type string in_diode
#@ set ports_need_diodes [remove_from_collection [all_inputs] $avoid_ports]
#@ set ports_with_diodes [get_ports -quiet * -filter "in_diode=~*DIODE*"]
#@ set ports_need_diodes [remove_from_collection $ports_need_diodes $ports_with_diodes]
#@ set cmd ""
#@ if { [sizeof_collection $ports_need_diodes] > 0} {
#@   insert_port_protection_diodes -prefix IN_PORT_DIODE -ignore_dont_touch -diode_cell [get_lib_cells $diode_cell_insert] -port $ports_need_diodes
#@   foreach prt [get_object_name $ports_need_diodes] {
#@     set pcells [get_cells -quiet -of [all_connected [get_port $prt]] -filter "full_name=~*_DIODE_*"]
#@     if {[sizeof_collection $pcells]>0} {
#@       set dpin [get_object_name [get_pins -of $pcells]]
#@       set_attribute [get_port $prt] in_diode $dpin
#@       append cmd "disconnect_net \[all_connected $dpin\] ${dpin}; connect_net vss \[get_pin ${dpin}\]; "
#@     }
#@   }
#@ }
#@ if {[sizeof_collection [get_nets -quiet -hier * -filter "net_type==Clock"]]>0} {
#@   foreach_in_collection prt [get_ports -quiet * -filter "in_diode=~*DIODE*"] {
#@     append cmd "disconnect_net \[all_connected \[get_pin [get_attribute $prt in_diode]\]\] \[get_pin [get_attribute $prt in_diode]\] ; "
#@     append cmd "connect_net [get_object_name [all_connected $prt]] \[get_pin [get_attribute $prt in_diode]\] ; "
#@   }
#@ }
#@ eval $cmd
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/insert_antenna_diodes_on_input.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/pre_place_fiducial_d04.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_error
#@ # 2. P_placement_blockage_move_or_unmove
#@ # 3. P_msg_warn
#@ # 4. P_msg_info
#@ 
#@ ## Places 2x local fiducials in staggered fashion
#@ 
#@ ##############################################################################
#@ ## Set default fiducial cells if not defined and check for cell existense
#@ ##############################################################################
#@ 
#@ set fidxcell $INTEL_LOCAL_FIDUCIAL_PREPLACE_CELL
#@ set default_xstep 50.4
#@ set default_ystep 25.536
#@ set default_strtx -25.2
#@ set default_strty -12.768
#@ set prefix "local_fiducial_preplace"
#@ 
#@ redirect -variable warn { set check [get_physical_lib_cells */$fidxcell] }
#@ if {[string match *othing* $warn]} {
#@   P_msg_error "$fidxcell physical_lib_cell not found"; return;
#@ }
#@ 
#@ ###################################################
#@ ## To check is fids already exists in the design
#@ ###################################################
#@ 
#@ set orig_fidcnt [sizeof_collection [get_cells -quiet -all xofiller_${prefix}*]]
#@ 
#@ set oldSnapState [set_object_snap_type -enabled false]
#@ set cnt 0
#@ 
#@ #####################################################
#@ ## Get Fid cell dimensions for calculations
#@ #####################################################
#@ 
#@ scan [get_attribute [get_physical_lib_cells -quiet */$fidxcell]  bbox] "{%f %f} {%f %f}" llx lly urx ury;
#@ 
#@ set fid1width [expr $urx - $llx]
#@ set fid1height [expr $ury - $lly]
#@ 
#@ ## Create gaps 2 times width and height - 0.001 to provide max area for just one cell
#@ set gap1x [expr $fid1width + $fid1width - 0.001]
#@ set gap1y [expr $fid1height + $fid1height - 0.001]
#@ 
#@ set die_area [get_attribute -quiet [get_die_area] bbox]
#@ regexp {\{(\S+) (\S+)\} \{(\S+) (\S+)\}} $die_area match die_llx die_lly die_urx die_ury
#@ 
#@ #####################################################
#@ ## Move existing placement blockage out of bounds
#@ #####################################################
#@ 
#@ set blockage_bbox_pairs [P_placement_blockage_move_or_unmove move]
#@ 
#@ #######################################
#@ ## Start placement of fid cells
#@ #######################################
#@ 
#@ set ystep_cnt 0
#@ set x1 [expr $die_llx + $default_strtx]
#@ set y1 [expr $die_lly + $default_strty]
#@ set x2 $x1
#@ while {$y1<$die_ury} {
#@   set y2 [expr $y1 + $default_ystep - $gap1y]
#@   create_placement_blockage -bbox "$die_llx $y1 $die_urx $y2" -name lfid_${cnt}
#@   incr cnt
#@   incr ystep_cnt
#@   set step $default_xstep
#@   if {[expr $ystep_cnt%2] == 0} {
#@     set offx 0
#@   } else {
#@     set offx [expr $default_xstep/2]
#@   }
#@   set y1 [expr $y1+$default_ystep]; set x1 [expr $die_llx-$offx];
#@   while {$x1<$die_urx} {
#@     set x2 [expr $x1 + $step - $gap1x];
#@     create_placement_blockage -bbox "$x1 $y2 $x2 $y1" -name lfid_${cnt}; incr cnt;
#@     set x1 [expr $x1 + $step];
#@   }
#@ }
#@ set physopt_check_site_array_overlap false
#@ set_parameter  -module  place -name  legalUnitTiles -value $INTEL_STDCELL_TILE -type string
#@ insert_stdcell_filler -cell_without_metal_prefix ${prefix} -cell_without_metal $fidxcell -ignore_soft_placement_blockage
#@ remove_placement_blockage lfid*
#@ 
#@ ###################################################
#@ ## Restore orignal placement blockages in design
#@ ###################################################
#@ 
#@ P_placement_blockage_move_or_unmove $blockage_bbox_pairs
#@ 
#@ ######################################################
#@ ## Print statistics on number of fid cells inserted
#@ ######################################################
#@ 
#@ set fidcnt [expr [sizeof_collection [get_cells -hierarchical -quiet -all xofiller_${prefix}*]] - $orig_fidcnt]
#@ if {$fidcnt>0} { set_attribute [get_cells -quiet -hierarchical -all xofiller_${prefix}*] is_fixed true; };
#@ 
#@ set_object_snap_type -enabled $oldSnapState
#@ 
#@ if {$orig_fidcnt>0} {
#@   P_msg_warn " Design already has $orig_fidcnt xofiller_${prefix}";
#@ }
#@ 
#@ if {$fidcnt>0} { P_msg_info "Added $fidcnt $fidxcell cells" };
#@ if {$fidcnt<1}  { P_msg_warn "No cells were added" };
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/pre_place_fiducial_d04.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/pre_place_bonus_fib_d04.tcl

#@ ##############################################################################
#@ # Opportunistically 1x2 and 2x1 local fiducial cells post route
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ # 2. P_placement_blockage_move_or_unmove
#@ # 3. P_insert_pre_place_cells_blockage
#@ 
#@ # Setting up list of fib and bonus cells to be used
#@ # Please setup this list according to placement requirement. The physical placement of each cell in this list would match the column/row as specified in this list
#@ # Please add empty rows if using double height cells as shown in the default pattern below
#@ set fib_bonus_cell_list(0) "d04bar01nnz64"
#@ set fib_bonus_cell_list(1) "d04bar01nnz64"
#@ set fib_bonus_cell_list(2) "d04qna03nd0d0 d04qna02nd0c7 d04qna02nd0c7"
#@ set fib_bonus_cell_list(3) ""
#@ set fib_bonus_cell_list(4) "d04qbf00nd0h0 d04qbf00nd0o0"
#@ set fib_bonus_cell_list(5) ""
#@ set fib_bonus_cell_list(6) "d04qbf00nd0o0 d04qin00nd0i0 d04qno03nd0d0"
#@ set fib_bonus_cell_list(7) ""
#@ set fib_bonus_cell_list(8) "d04qin00nd0i0 d04qno02nd0c7 d04qin00nd0i0 d04qin00nd0q0"
#@ set fib_bonus_cell_list(9) ""
#@ set fib_bonus_cell_list(10) "d04bar01nnz64"
#@ set fib_bonus_cell_list(11) "d04bar01nnz64"
#@ 
#@ # Setting up distances to be used for fib and bonus cell insertion
#@ set fib_bonus_start_x 43.68
#@ set fib_bonus_start_y 25.536
#@ set fib_bonus_incr_x 110.88
#@ set fib_bonus_incr_y 76.608
#@ 
#@ # Set tile values for calulation
#@ set stdcell_tile_height 0.399
#@ set stdcell_tile_width 0.07
#@ set stdcell_bonus_tile_width 0.28
#@ 
#@ # Temporarily move Placement blockages before insertion
#@ set blockage_bbox_pairs ""
#@ if {[sizeof_collection [get_placement_blockages -quiet]] > 0 } {
#@   P_msg_info "Temporarily removing placement blockages before tap cell insertion."
#@   set blockage_bbox_pairs [P_placement_blockage_move_or_unmove move];  ## move placement blockage out of bounds ##
#@ }
#@ 
#@ set fib_bonusgarray_width 0.0
#@ set fib_bonusgarray_height 0.0
#@ foreach row [lsort -integer [array names fib_bonus_cell_list]] {
#@   set _tmp_width 0.0
#@   foreach c_ref $fib_bonus_cell_list($row) {
#@     scan [get_attribute [ get_physical_lib_cells */$c_ref ]  bbox] "{%f %f} {%f %f}" c_llx c_lly c_urx c_ury
#@     set _tmp_width  [expr $_tmp_width + ($c_urx - $c_llx) ]
#@   }
#@   if { $fib_bonusgarray_width < $_tmp_width } { set fib_bonusgarray_width $_tmp_width }
#@   set fib_bonusgarray_height [expr $fib_bonusgarray_height + $stdcell_tile_height]
#@ }
#@ 
#@ # Need add the space for tap place on the left & right of FIB cells
#@ set fib_bonusgarray_width [expr $fib_bonusgarray_width + 2.0 * $stdcell_bonus_tile_width]
#@ 
#@ P_insert_pre_place_cells_blockage     -x_start $fib_bonus_start_x     -y_start $fib_bonus_start_y     -x_increment $fib_bonus_incr_x     -y_increment $fib_bonus_incr_y     -w_preplace_cell $fib_bonusgarray_width     -h_preplace_cell $fib_bonusgarray_height     -tile bonuscore -stagger     -x_trim $INTEL_MD_GRID_X  -y_trim $INTEL_MD_GRID_Y     -as_blockage -no_flip
#@ 
#@ ### Remove the tap cells inside the area first
#@ unset -nocomplain rm_tap_cmds
#@ foreach_in_collection pblk [get_placement_blockage -quiet _tmp_pre_place_placement_blk_*] {
#@   scan [get_attribute $pblk bbox] "{%f %f} {%f %f}" _llx _lly _urx _ury
#@   set win "{[expr $_llx + 0.001] [expr $_lly + 0.001]} {[expr $_urx - 0.001] [expr $_ury - 0.001]}"
#@   foreach_in_collection c [add_to_collection [get_cells -all -intersect ${win} -filter "is_fixed==true && ref_name==$INTEL_TAP_CELL"]                                [get_cells -all -within ${win} -filter "is_fixed==true && ref_name==$INTEL_TAP_CELL"]] {
#@                                  lappend rm_tap_cmds "remove_cell [get_object_name $c]"
#@                                }
#@ }
#@ if {[info exists rm_tap_cmds]} {
#@   foreach cmd $rm_tap_cmds { eval $cmd }
#@ }
#@ 
#@ ### Now insert in the fib & bonus cells at the -as_blockage location
#@ set prefix "garrayfib"
#@ unset -nocomplain count
#@ set count 0
#@ foreach_in_collection pblk [get_placement_blockage -quiet _tmp_pre_place_placement_blk_*] {
#@   scan [get_attribute $pblk bbox] "{%f %f} {%f %f}" _llx _lly _urx _ury
#@   set orientation N
#@   set loc_x [expr $_llx + $stdcell_bonus_tile_width]
#@   set loc_y $_lly
#@   set va_module_name ""
#@   win_set_select_class {voltage_area}
#@   set c_llx [expr $_llx + 0.5 * $fib_bonusgarray_width]
#@   set c_lly [expr $_lly + 0.5 * $fib_bonusgarray_height]
#@   set va [win_select_objects -at [list $c_llx $c_lly]]
#@   if { [get_attribute -quiet $va object_class]=="voltage_area" } {
#@     set va_module_name [get_object_name [get_attribute -quiet $va modules]]
#@   } elseif { [get_attribute -quiet $va object_class]=="voltage_area_shape" } {
#@     if { [get_attribute -quiet $va owner]!="DEFAULT_VA" } {
#@       set va_module_name [get_object_name [get_attribute -quiet [get_voltage_areas [get_attribute $va owner]] modules]]
#@     }
#@   }
#@ 
#@   foreach row [lsort -integer [array names fib_bonus_cell_list]] {
#@     set col 0
#@     foreach c_ref $fib_bonus_cell_list($row) {
#@       scan [get_attribute [get_physical_lib_cells */$c_ref]  bbox] "{%f %f} {%f %f}" c_llx c_lly c_urx c_ury
#@       set width_cell [expr $c_urx - $c_llx]
#@       set cell_full_name ""
#@       set curcell [format "%s_%d_r%dc%d" $prefix $count $row $col]
#@       if { [llength $va_module_name] > 0 } {
#@         append cell_full_name [lindex $va_module_name 0] "/${curcell}"
#@       } else {
#@         set cell_full_name $curcell
#@       }
#@       create_cell $cell_full_name $c_ref
#@       set_attribute -quiet $cell_full_name orientation $orientation
#@       set_cell_location $cell_full_name -coordinates [list $loc_x $loc_y]
#@       set_attribute -class cell $cell_full_name is_fixed true
#@       set loc_x [expr $loc_x + $width_cell]
#@       incr col
#@     }
#@     set loc_x [expr $_llx + $stdcell_bonus_tile_width]
#@     set loc_y [expr $loc_y + $stdcell_tile_height]
#@     if { $orientation == "FS" } {
#@       set orientation "N"
#@     } elseif { $orientation == "N" } {
#@       set orientation "FS"
#@     }
#@   }
#@   incr count
#@ }
#@ 
#@ remove_placement_blockage _tmp_pre_place_placement_blk_*
#@ 
#@ P_placement_blockage_move_or_unmove $blockage_bbox_pairs;            ## restore original placement blockage   ##
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/pre_place_bonus_fib_d04.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/create_check_grid.tcl

#@ ##############################################################################
#@ #Create diffcheck grid and polycheck grid
#@ # List of procs used by this script
#@ # 1. P_create_diffcheck_grid
#@ # 2. P_create_polycheck_grid
#@ 
#@ set all_macro_ref_names [lsort -unique [get_attribute [all_macro_cells] ref_name]]
#@ 
#@ #EX: P_create_diffcheck_grid  $layer $start $width $step $stop $hard_macro_refs
#@ P_create_diffcheck_grid "diffusiondrawn" "0.028" "0.028" "0.056" "0.028" "$all_macro_ref_names"
#@ 
#@ #EX: P_create_polycheck_grid  $layer $start $width $step $stop $hard_macro_refs
#@ P_create_polycheck_grid "polycheckdrawn" "0.049" "0.042" "0.098" "0.028" "$all_macro_ref_names"
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/create_check_grid.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_floorplan.tcl

#@ ##############################################################################
#@ # Script : check_floorplan.tcl
#@ # Description : check for correctness of floorplanning
#@ # List of procs used by this script
#@ # 1. P_check_partition_dimension
#@ # 2. P_msg_info
#@ # 3. P_msg_error
#@ # 4. P_msg_warn
#@ ##############################################################################
#@ 
#@ 
#@ ### Check if the partition dimension is modular-grid multiple
#@ P_check_partition_dimension
#@ 
#@ ### Check if all macros are placed and fixed
#@ P_msg_info "Checking to make sure all macro cells are placed and fixed..."
#@ foreach_in_collection m [all_macro_cells] {
#@   if {[get_attribute $m is_placed] == "false"} {
#@     P_msg_error "Macro cell [get_object_name $m] is NOT placed"
#@   }
#@   if {[get_attribute $m is_fixed] == "false"} {
#@     P_msg_error "Macro cell [get_object_name $m] is NOT fixed"
#@   }
#@ }
#@ P_msg_info "Done: Checking to make sure all macro cells are placed and fixed..."
#@ 
#@ ### Check if macros are on placement grid
#@ P_msg_info "Checking if macros are placed on the modular grid..."
#@ set x_div $INTEL_MD_GRID_X
#@ set y_div $INTEL_MD_GRID_Y
#@ foreach_in_collection m [all_macro_cells] {
#@   scan [get_location $m] "%f %f" x y
#@   set x [expr $x / $x_div]
#@   set y [expr $y / $y_div]
#@   set int_x [expr round($x)]
#@   set int_y [expr round($y)]
#@   if {([expr $int_x - $x] != 0.0) || ([expr $int_y - $y] != 0.0)} {
#@     P_msg_error "Macro cell [get_object_name $m] is not on the modular grid"
#@     # Don't use P_msg_error here.  It terminates the foreach loop.
#@   }
#@ }
#@ P_msg_info "Done: Checking if macros are placed on the modular grid..."
#@ 
#@ ### Check if all macros are placed in the correct orientation
#@ P_msg_info "Checking to make sure all macro cells have the correct orientation"
#@ foreach_in_collection m [get_cells [all_macro_cells] -filter "(orientation != N) && (orientation != FN) && (orientation != S) && (orientation != FS)" -quiet] {
#@   P_msg_error "The orientation - [get_attribute $m orientation] - of Macro cell [get_object_name $m] is incorrect. Should be either N|S|FN|FS..."
#@ }
#@ 
#@ P_msg_info "Done: Checking to make sure all macro cells have the correct orientation..."
#@ 
#@ ### Check if Voltage areas are on modular-grid
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   P_msg_info "Checking to make sure voltage areas are on the modular grid..."
#@   # Checking for MD Grid * 2 as m7 runs on MD Grid * 2 and we try to align m7 power straps with the power switch
#@   set x_div [expr $INTEL_MD_GRID_X * 2]
#@   set y_div $INTEL_MD_GRID_Y
#@   foreach_in_collection va [get_voltage_areas] {
#@     foreach point [get_attribute [get_voltage_areas $va] points] {
#@       foreach {x y} $point {
#@         set x [expr $x / $x_div]
#@         set y [expr $y / $y_div]
#@         set int_x [expr round($x)]
#@         set int_y [expr round($y)]
#@         if {([expr $int_x - $x] != 0.0) || ([expr $int_y - $y] != 0.0)} {
#@           P_msg_error "Point $point of Voltage area [get_object_name $va] is not on grid"
#@         }
#@       }
#@     }
#@   }
#@   P_msg_info "Done: Checking to make sure voltage areas are on the modular grid..."
#@ }
#@ 
#@ ### Check if any ports are missing terminals
#@ P_msg_info "Checking for missing terminals..."
#@ foreach_in_collection p [get_ports *] {
#@   if {[sizeof_collection [get_terminals -of_objects [get_attribute $p name]]] == 0} {
#@     P_msg_error "Missing terminal for port: [get_object_name $p]"
#@   }
#@ }
#@ P_msg_info "Done: Checking for missing terminals..."
#@ 
#@ ##################################################################################
#@ ## Check if ports are min width and min length                                  ##
#@ ##################################################################################
#@ P_msg_info "Checking for ports that are not min width or min length..."
#@ set pports [get_ports ]
#@ foreach_in_collection port $pports {
#@   scan [get_attribute [get_ports $port] bbox] "{%f %f} {%f %f}" pllx plly purx pury
#@   set player [get_attribute [get_ports $port] layer]
#@   set pname [get_attribute [get_ports $port] name]
#@   switch $player {
#@     "m2"  { set plength [expr $purx - $pllx]; set pwidth [expr $pury - $plly]; set minlength 0.084; set sigwidth 0.028; }
#@     "m3"  { set plength [expr $pury - $plly]; set pwidth [expr $purx - $pllx]; set minlength 0.084; set sigwidth 0.028; }
#@     "m4"  { set plength [expr $purx - $pllx]; set pwidth [expr $pury - $plly]; set minlength 0.084; set sigwidth 0.032; }
#@     "m5"  { set plength [expr $pury - $plly]; set pwidth [expr $purx - $pllx]; set minlength 0.084; set sigwidth 0.028; }
#@     "m6"  { set plength [expr $purx - $pllx]; set pwidth [expr $pury - $plly]; set minlength 0.160; set sigwidth 0.044; }
#@     "m7"  { set plength [expr $pury - $plly]; set pwidth [expr $purx - $pllx]; set minlength 0.204; set sigwidth 0.056; }
#@     "m8"  { set plength [expr $purx - $pllx]; set pwidth [expr $pury - $plly]; set minlength 0.274; set sigwidth 0.140; }
#@     "m9"  { set plength [expr $pury - $plly]; set pwidth [expr $purx - $pllx]; set sigwidth 0.540; }
#@     "tm1"  { set plength [expr $purx - $pllx]; set pwidth [expr $pury - $plly]; set sigwidth_min 5.5; set sigwidth_max 50; }
#@   }
#@ 
#@ 
#@   set plength [format "%0.3f" $plength]
#@   set pwidth  [format "%0.3f" $pwidth]
#@ 
#@   if {($player != "tm1") && [expr $pwidth != $sigwidth]} {
#@     P_msg_error "Port $pname on layer $player has a width not matching the signal route width (signal: $sigwidth, actual: $pwidth)"
#@   } elseif {($player == "tm1") && ([expr $pwidth < $sigwidth_min] || [expr $pwidth > $sigwidth_max])} {
#@     P_msg_error "Port $pname on layer $player has a width falling outside the allowed range (MinWidth: $sigwidth_min, MaxWidth: $sigwidth_max, actual: $pwidth)"
#@   }
#@ 
#@   #Skipping min-length check on tm1 and m9
#@   if {($player != "tm1") && ($player != "m9")} {
#@     if { ([expr $plength < $minlength])} {
#@       P_msg_error "Port $pname on layer $player is not minimum length (min: $minlength, actual: $plength)"
#@     }
#@   }
#@ 
#@ }
#@ P_msg_info "Done: Checking for ports that are not min width or min length..."
#@ 
#@ 
#@ ############################################################################################
#@ ## Check for overlap cells                                                                ##
#@ ############################################################################################
#@ P_msg_info "Checking for cell overlap with check_legality..."
#@ set_app_var legalize_support_phys_only_cell true
#@ set legalize_auto_x_keepout_margin 0; #workaround to ignore false violations around macros
#@ set legalize_auto_y_keepout_margin 0; #workaround to ignore false violations around macros
#@ suppress_message {PSYN-059}; #regular logic cells are still unplaced
#@ check_legality -verbose
#@ unsuppress_message {PSYN-059}
#@ P_msg_info "Done: Checking for cell overlap with check_legality..."
#@ 
#@ 
#@ #############################################################################################
#@ ## Check for off track terminals                                                           ##
#@ #############################################################################################
#@ P_msg_info "Checking for terminals that are off grid..."
#@ #redirect -variable off_track_mesg {catch {set off_track_terms  [check_fp_pin_assignment -block_level -wiretrack -preferred_wiretrack_only]}}
#@ redirect -variable off_track_mesg {catch {set off_track_terms  [check_fp_pin_assignment -block_level -wiretrack ]}}
#@ if { [regexp  {No violation has been found} $off_track_mesg] } {
#@   P_msg_info "All terminals are centered on a wire track"
#@ } else {
#@   foreach_in_collection p $off_track_terms {
#@     set tlayer [get_attribute $p layer]
#@     if {$tlayer != "tm1"} {
#@       P_msg_error "Terminal [get_attribute $p name] is not centered on a wire track - tBBOX: [get_attribute $p bbox]"
#@     }
#@   }
#@ }
#@ P_msg_info "Done: Checking for terminals that are off grid..."
#@ 
#@ 
#@ ##############################################################################################
#@ ## Check if ports are aligned to boundary                                                   ##
#@ ##############################################################################################
#@ P_msg_info "Checking for ports that are not aligned to boundary..."
#@ set pports [get_ports ]
#@ foreach_in_collection port $pports {
#@   set misaligned 0
#@   scan [get_attribute [get_ports $port] bbox] "{%f %f} {%f %f}" pllx plly purx pury
#@   set pname [get_attribute [get_ports $port] name]
#@   set player [get_attribute [get_ports $port] layer]
#@   set pdir [get_attribute [get_layers $player] preferred_direction]
#@   set die_bound [get_attribute [get_die_area] boundary]
#@   set rect_box [convert_from_polygon -format rectangle $die_bound]
#@   if {$player != "tm1"} {
#@     foreach rect $rect_box {
#@       scan $rect "{%f %f} {%f %f}" bllx blly burx bury
#@       if { (($pdir == "horizontal") && [expr $pllx != $bllx && $purx != $burx]) || (($pdir == "vertical") && [expr $plly != $blly && $pury != $bury]) } {
#@         set misaligned 1
#@       } else {
#@         set misaligned 0
#@         break
#@       }
#@     }
#@   }
#@ 
#@   if {$misaligned} {
#@     P_msg_warn "Port $pname is not aligned to the boundary (coord: $pllx, $plly)"
#@   }
#@ }
#@ 
#@ P_msg_info "Done: Checking for ports that are not aligned to boundary..."
#@ 
#@ ################################################################################################
#@ ## Check if ports are shorted                                                                 ##
#@ ################################################################################################
#@ 
#@ set ports [get_ports ]
#@ P_msg_info "Checking for shorted ports ([sizeof_collection $ports])..."
#@ foreach_in_collection port $ports {
#@   if {[sizeof_collection [get_terminals -intersect [get_attribute $port bbox] -filter @layer=="[get_attribute $port layer]"]]>1} {
#@     P_msg_error "Port [get_attribute $port name] is shorted at [get_attribute $port bbox]."
#@   }
#@ }
#@ 
#@ P_msg_info "Done: Checking for shorted ports ([sizeof_collection $ports])..."
#@ 
#@ #################################################################################################
#@ ## Check for unfixed ports                                                                     ##
#@ #################################################################################################
#@ P_msg_info "Checking for ports that are not fixed..."
#@ foreach_in_collection port [get_ports] {
#@   if {![get_attribute $port is_fixed]} {
#@     P_msg_error "Port [get_attribute $port name] is not fixed!"
#@   }
#@ }
#@ P_msg_info "Done: Checking for ports that are not fixed..."
#@ 
#@ 
#@ ##################################################################################################
#@ ## Check for utilization > 75%                                                                  ##
#@ ##################################################################################################
#@ P_msg_info "Checking for standard cell + macro utilization"
#@ redirect -file ./temp_placement_utilization_rpt.txt {report_placement_utilization}
#@ set util [sh grep "Non-fixed only" -B1 ./temp_placement_utilization_rpt.txt | grep -v "Non-fixed" | awk '{print \$4}']
#@ sh rm ./temp_placement_utilization_rpt.txt
#@ set index [expr [string length $util] -1]
#@ set util [expr [string replace $util $index $index]]
#@ set die_area [get_attribute [get_core_area] area]
#@ set stdcell_area [expr ($util/100.00) * $die_area]
#@ 
#@ if {[sizeof_collection [all_macro_cells]] > 0} {
#@   set macro_area [expr 0.000]
#@   foreach_in_collection macro [all_macro_cells] {
#@     scan [get_attribute $macro bbox] "{%f %f} {%f %f}" _llx _lly _urx _ury
#@     set m_area [expr ($_urx - $_llx) * ($_ury - $_lly)]
#@     set macro_area [expr $macro_area + $m_area]
#@   }
#@ } else {
#@   set macro_area [expr 0.000]
#@ }
#@ set total_util [expr (($stdcell_area + $macro_area) / $die_area) * 100]
#@ if {[expr $total_util > 80]} {
#@   P_msg_error "The standard cell + macro utilization is > 80% ([expr round($total_util*100)/100.00]\%)"
#@ } elseif {[expr $total_util > 75]} {
#@   P_msg_warn "The standard cell + macro utilization is > 75% ([expr round($total_util*100)/100.00]\%)"
#@ } else {
#@   P_msg_info "The standard cell + macro utilization is [expr round($total_util*100)/100.00]\%"
#@ }
#@ P_msg_info "Done: Checking for standard cell + macro utilization"
#@ 
#@ 
#@ ##################################################################################################
#@ ## Local Fiducial check (existence & count)                                                     ##
#@ ##################################################################################################
#@ 
#@ set prefix "local_fiducial"
#@ set fidcnt [expr [sizeof_collection [get_cells -quiet -all xofiller_${prefix}*]]]
#@ P_msg_info "Total number of fiducial cells in the design = $fidcnt"
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_floorplan.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ ##############################################################################
#@ #Script: tool_constraints.tcl
#@ # List of procs used by this tcl
#@ # 1. P_lminus
#@ # 2. P_msg_info
#@ # 3. get_completed_steps
#@ 
#@ # Density screening
#@ #
#@ # set_congestion_options
#@ #       [-max_util value]: Specifies the layer name whose availability is reduced.
#@ #       [-layer name]: Specifies the availability of the routing resource for the layer
#@ #       [-availability value]: Specifies the availability of the routing resource for the layer
#@ #       [-coordinate {X1 Y1 X2 Y2}]: Specifies the lower left and upper right coordinates
#@ #                                    for which the congestion options will apply.
#@ #                                    The numbers are in microns.
#@ # Example: set_congestion_options -max_util 0.5 -coordinate {0 0 2560 155}
#@ 
#@ 
#@ # Soft blockage (0% utilization during initial place, but allows for buffering later)
#@ #
#@ # create_placement_blockage
#@ #       -bbox rectangle: Specifies the coordinates of the bounding box of the blockage.
#@ #                        rectangle  x1 y1 x2 y2
#@ #       -type soft: Specifies the type of blockage to be created as soft.
#@ #                   With a soft blockage, the placer tries not to place standard cells
#@ #                   or hard macros in the specified region but will do so if the congestion
#@ #                   is too high.
#@ #       [-name blockage_name]: Specifies the optional name of the blockage.
#@ #                              If you  specify  a name  for  the blockage,
#@ #                              you can use it later in the flow to get the blockage by name.
#@ # Example: create_placement_blockage -name hot_corner_plcmnt_blkg_1 -bbox {{4066 259.2} {4096 459.2}} -type soft
#@ # Example: create_placement_blockage -name KO_idv4 -bbox { 540.4 1094.56 579.6  1225.28} -type soft
#@ 
#@ 
#@ # Cells inserted during each flow will have a prefix of the flow name. For ex. placement will have "place" prefix
#@ # If Intel flow variables are not defined, then the default prefix will be used
#@ if {[lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0] != ""} {
#@   set_app_var compile_instance_name_prefix [lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0]
#@ }
#@ 
#@ # Enables congestion removal with the global router
#@ set_app_var placer_enable_enhanced_router true
#@ 
#@ #To prevent side load on output ports
#@ set_isolate_ports -type buffer [filter_collection [all_outputs] "direction=~out"]
#@ 
#@ # Congestion removal effort during coarse placement
#@ set_app_var placer_enable_high_effort_congestion true
#@ 
#@ # Congestion effort during place_opt (default is auto)
#@ # Setting to medium/high, ICC always uses the Zroute global route for congestion-driven placement
#@ set_app_var placer_congestion_effort medium
#@ 
#@ # Prints out Zroute global routing information during congestion-driven placement
#@ set_app_var placer_show_zroutegr_output true
#@ 
#@ # Ensure cells are placed close together for low-utilization blocks
#@ # Recommended setings are somewhere between 0.5 and 0.65
#@ set_app_var placer_max_cell_density_threshold 0.6
#@ 
#@ # Set critical range
#@ set_critical_range $INTEL_CRITICAL_RANGE [get_designs]
#@ 
#@ # Pre-route area and power critical range values
#@ if {[info exists INTEL_AREA_CRITICAL_RANGE] && $INTEL_AREA_CRITICAL_RANGE!="not_set"} {
#@   set_app_var physopt_area_critical_range $INTEL_AREA_CRITICAL_RANGE
#@ }
#@ if {[info exists INTEL_POWER_CRITICAL_RANGE] && $INTEL_POWER_CRITICAL_RANGE != "not_set" } {
#@   set_app_var physopt_power_critical_range $INTEL_POWER_CRITICAL_RANGE
#@ }
#@ 
#@ # Avoid excessive buffering
#@ set_buffer_opt_strategy -effort medium
#@ 
#@ # Set auto high fanout synthesis options
#@ set_ahfs_options     -constant_nets true     -port_map_file outputs/${INTEL_DESIGN_NAME}_ahfs_port_map.txt
#@ 
#@ # Set routing layers
#@ remove_ignored_layers -all
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS
#@ }
#@ P_msg_info "Setting min_routing_layer: $min_routing_layer"
#@ P_msg_info "Setting max_routing_layer: $max_routing_layer"
#@ P_msg_info "Setting rc_ignore_layer:   $rc_ignore_layer"
#@ set_ignored_layers      -min_routing_layer $min_routing_layer     -max_routing_layer $max_routing_layer     -rc_congestion_ignored_layers $rc_ignore_layer
#@ 
#@ 
#@ # Setting default Toggle Rate and Static Probability for power optmization in the absence of SAIF
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@     P_msg_info "Input saif file will be used for dynamic power optmization"
#@   } else {
#@     P_msg_info "Setting default toggle rate $INTEL_POWER_TR and default static probability $INTEL_POWER_SP for dynamic power optimization"
#@     set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@     set_app_var power_default_static_probability $INTEL_POWER_SP
#@   }
#@ }
#@ 
#@ # Power optimization options (turn on dynamic power opt if INTEL_DYNAMIC_POWER is set to 1)
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement true
#@ } else {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement false
#@ }
#@ 
#@ #Enable DRC on constant nets
#@ set_auto_disable_drc_nets -constant false
#@ 
#@ #Ensure the tool observes max_cap constraints during tie-off optimization
#@ set_app_var physopt_new_fix_constants true
#@ 
#@ # Enable via resistance estimation
#@ set_app_var physopt_enable_via_res_support true
#@ 
#@ # Uses alternate name styles to solve name mismatching issues in read_def
#@ set_app_var def_enable_no_legalize_name true
#@ 
#@ # Set multiple port nets options
#@ #        [-feedthroughs]        (fix feedthroughs)
#@ #        [-outputs]             (fix multiple output port nets)
#@ #        [-buffer_constants]    (buffer constants driving multiple ports)
#@ # Without this option, feedthrough ports can be connected directly to each other
#@ # and create text short error in LVS.
#@ set_fix_multiple_port_nets -feedthroughs -outputs -buffer_constants
#@ 
#@ ################################
#@ # Placement
#@ ################################
#@ # Use Zrouter to drive peroute optimization.
#@ if { $::sh_product_version > {I-2013.12-ICC-SP2} } {
#@   set_place_opt_strategy -consider_routing true
#@ }
#@ 
#@ ####################################
#@ # Setting Delay Calculation Options
#@ ####################################
#@ P_msg_info "Setting Delay Calculation as follows :\n Pre-route : Elmore\n Routed Clock : Arnoldi\n Post-route : Arnoldi"
#@ set_delay_calculation_options -preroute elmore -routed_clock arnoldi -postroute arnoldi
#@ 
#@ ####################################
#@ # CTS
#@ ####################################
#@ # The following are used to force CTS to fix more max_cap drcs.
#@ set         ctdn_enable_ccs_low_cap true
#@ set_app_var cto_enable_drc_fixing   true
#@ set         cts_low_power           false
#@ 
#@ ####################################
#@ # Extraction Options
#@ ####################################
#@ 
#@ if { [lsearch -exact [get_completed_steps] fill] > 0} {
#@   set_extraction_options       -real_metalfill_extraction FLOATING       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ } else {
#@   set_extraction_options       -real_metalfill_extraction none       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ ##############################################################################
#@ # Description: This script enables the application of frequency based max-capacitance values
#@ #              The highest frequency in the design is used for max-capacitance lookup
#@ #Required Vars: INTEL_CMAX_DEFAULT_PERIOD - Clock Period used if minimum clock period could not be derived.
#@ #               INTEL_CMAX_LUT - Full Path to Cmax Lookup Table CSV file
#@ #Procs Used:
#@ #1. P_msg_warn
#@ #2. P_msg_error
#@ #3. P_msg_info
#@ 
#@ # Determine maximum frequency
#@ set minperiod [lindex [lsort -increasing -real [get_attribute [get_clocks] period -quiet]] 0]
#@ 
#@ # As a fail-safe, set a default frequency
#@ if {$minperiod eq ""} {
#@   if {[info exists INTEL_CMAX_DEFAULT_PERIOD] && $INTEL_CMAX_DEFAULT_PERIOD != ""} {
#@     P_msg_warn "Minimum period could not be determined. Defaulting to ${INTEL_CMAX_DEFAULT_PERIOD}ps"
#@     set minperiod $INTEL_CMAX_DEFAULT_PERIOD
#@   } else {
#@     P_msg_error "Minimum period could not be determined. Please provide minimum period to use by setting INTEL_CMAX_DEFAULT_PERIOD variable."
#@     return
#@   }
#@ }
#@ 
#@ # Multiplying by 1000 as lookup table values are in GHz
#@ set fmax [expr [expr 1.0/$minperiod] * 1000]
#@ 
#@ # Read reference file
#@ if {[info exists INTEL_CMAX_LUT] && [file exists $INTEL_CMAX_LUT]} {
#@   P_msg_info "Reading Max-Cap LUT file - $INTEL_CMAX_LUT"
#@   set lut_file $INTEL_CMAX_LUT
#@   set fh [open $lut_file "r"]
#@ } else {
#@   P_msg_warn "Either INTEL_CMAX_LUT variable does not exist (or) $INTEL_CMAX_LUT file cannot be found"
#@   return
#@ }
#@ 
#@ if {[info exists INTEL_SCALE_RV_CMAX] && $INTEL_SCALE_RV_CMAX != ""} {
#@   P_msg_info "RV Cmax scaling enabled. Scaling factor value - $INTEL_SCALE_RV_CMAX - has been used..."
#@   set scaling_factor $INTEL_SCALE_RV_CMAX
#@ } else {
#@   set scaling_factor 1
#@ }
#@ 
#@ P_msg_info "Applying frequency based max-capacitance values..."
#@ set err_cnt 0
#@ while {[gets $fh line] > -1} {
#@   set line_vals [split $line ","]
#@   if {[regexp {^cell} $line]} {
#@     set indices [lrange $line_vals 1 end]
#@   } else {
#@     if {[sizeof_collection [set lib_pin [get_lib_pins */[lindex $line_vals 0] -quiet]]]} {
#@       set i 0
#@       set prev_val ""
#@       set curr_val ""
#@       set prev_index ""
#@       set curr_index ""
#@       set new_cmax_value ""
#@       foreach cmax [lrange $line_vals 1 end] {
#@         set prev_val $curr_val
#@         set curr_val $cmax
#@         set prev_index $curr_index
#@         set curr_index [lindex $indices $i]
#@         if {[expr $fmax >= $curr_index]} {
#@           # continue to next value
#@           if {$i == [expr [llength [lrange $line_vals 1 end]] - 1]} {
#@             set new_cmax_value $cmax
#@             break
#@           }
#@         } elseif {$prev_val eq ""} {
#@           # if "" then this is the first index and the fmax is less than the minimum table value
#@           # set to minimum value
#@           set new_cmax_value $cmax
#@           break
#@         } else {
#@           # at this point we should be between two table values. interpolate.
#@           set index_prop [expr ($fmax - $prev_index)/($curr_index - $prev_index)]
#@           set new_cmax_value [expr $index_prop * ($curr_val - $prev_val) + $prev_val]
#@           set new_cmax_value [expr $new_cmax_value * $scaling_factor]
#@           break
#@         }
#@         incr i
#@       }
#@ 
#@       # Check for new_cmax_value
#@       if {$new_cmax_value eq ""} {
#@         P_msg_error "Cmax value not gathered correctly"
#@         incr err_cnt
#@       } elseif {[lindex [get_attribute $lib_pin pin_direction] 0] eq "in"} {
#@         P_msg_error "Library pin is input. Not setting Cmax. Something is likely wrong with the LUT."
#@         P_msg_error "Lib pin - [lindex [get_object_name $lib_pin] 0]"
#@         incr err_cnt
#@       } else {
#@         suppress_message {MWUI-031}
#@         set_attribute $lib_pin max_capacitance $new_cmax_value
#@         unsuppress_message {MWUI-031}
#@       }
#@     } else {
#@       P_msg_warn "Lib pin [lindex $line_vals 0] could not be found"
#@     }
#@   }
#@ }
#@ close $fh
#@ 
#@ if {$err_cnt == 0} {
#@   P_msg_info "Frequency based max-capacitance values applied successfully!"
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/set_ideal_clock_network.tcl

#@ ##############################################################################
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM} {
#@   foreach scenario [all_active_scenarios] {
#@     current_scenario $scenario
#@     set_ideal_network  [all_fanout -clock_tree -flat]
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ 
#@ } else {
#@   set_ideal_network  [all_fanout -clock_tree -flat]
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/set_ideal_clock_network.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cell_spacing_d04.tcl

#@ ##############################################################################
#@ 
#@ ####################################
#@ ### Define lib cell spacing rules
#@ ####################################
#@ #
#@ # Defining lib cell spacing rules on large buffers and inverters to prevent
#@ # RV IR drop violations.
#@ # Buffers and inverters larger than these are don't use cells.
#@ #
#@ set large_buf_inv_list [list                             "*inn00*d0f7*"                             "*inn00*n0f5*"                             "*inn00*n0h5*"                             "*inn00*n0i5*"                             "*bfn00*n0e0*"                             "*inn00*n0e3*"                             "*inn00*n0f0*"                            ]
#@ 
#@ set large_buf_inv_cells {}
#@ foreach cell $large_buf_inv_list {
#@   append_to_collection large_buf_inv_cells [get_physical_lib_cells */$cell -quiet]
#@ }
#@ 
#@ set_lib_cell_spacing_label -names {SPACING_LARGE_BUFINV} -left_lib_cells $large_buf_inv_cells -right_lib_cells $large_buf_inv_cells
#@ set_spacing_label_rule -labels {SPACING_LARGE_BUFINV SPACING_LARGE_BUFINV} {0 4}
#@ report_spacing_rules -all
#@ 
#@ ####################################
#@ # High Pin Density Cell Spacing
#@ ####################################
#@ 
#@ set hpd_cell_spacing_list [list                                "d04ann04?n0a5"                                "d04ann04?n0b0"                                "d04ann04?n0b5"                                "d04con01?n0b0"                                "d04nab03?n0b0"                                "d04nan02?n0a5"                                "d04nan02?n0b0"                                "d04nan03?n0b0"                                "d04nan04?n0b0"                                "d04non02?n0b0"                                "d04non03?n0b0"                                "d04non04?n0b0"                                "d04orn03?n0a5"                                "d04orn04?n0a5"                                "d04orn04?n0b0"                                "d04orn04?n0b5"                               ]
#@ 
#@ set hpd_cells {}
#@ foreach cell $hpd_cell_spacing_list {
#@   append_to_collection hpd_cells [get_physical_lib_cells */$cell -quiet]
#@ }
#@ 
#@ # This method spaces ONLY HPD to HPD Cells
#@ set_lib_cell_spacing_label -names {HPD} -left_lib_cells $hpd_cells -right_lib_cells $hpd_cells
#@ report_spacing_rules -all
#@ set_spacing_label_rule -labels {HPD HPD} {0 2}
#@ report_spacing_rules -all
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cell_spacing_d04.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/layer_promotion.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ 
#@ if {[info exists INTEL_LAYER_PROMOTION] && $INTEL_LAYER_PROMOTION == 1} {
#@   P_msg_info "RC Layer Promotion enabled"
#@ 
#@   P_msg_info "Creating net search pattern with a length threshold of 100um. Update as per requirements."
#@   set pattern_1 [create_net_search_pattern -net_length_lower_limit 100]
#@   report_net_search_pattern -all
#@ 
#@   set min_layer "$INTEL_MIN_ROUTING_LAYER"
#@   if {$INTEL_MAX_ROUTING_LAYER == "m11"} {
#@     set min_layer "m7"
#@   } elseif {$INTEL_MAX_ROUTING_LAYER == "m10"} {
#@     set min_layer "m7"
#@   } elseif {$INTEL_MAX_ROUTING_LAYER == "m9"} {
#@     set min_layer "m7"
#@   } elseif {$INTEL_MAX_ROUTING_LAYER == "m8"} {
#@     set min_layer "m7"
#@   } elseif {$INTEL_MAX_ROUTING_LAYER == "m7"} {
#@     set min_layer "m6"
#@   }
#@ 
#@   set_net_search_pattern_delay_estimation_options -pattern $pattern_1 -min_layer_name $min_layer -max_layer_name $INTEL_MAX_ROUTING_LAYER
#@   report_net_search_pattern_delay_estimation_options -all
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/layer_promotion.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/place_opt.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ 
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set INTEL_PLACE_CMD "$INTEL_PLACE_CMD -power"
#@ }
#@ 
#@ #If needed, reads scan def and re-orders before running placement.
#@ if { [info exists INTEL_INSERT_SCAN] && $INTEL_INSERT_SCAN } {
#@   if { [info exists INTEL_INPUT_SCANDEF] && $INTEL_INPUT_SCANDEF != "" } {
#@     read_def $INTEL_INPUT_SCANDEF
#@   } else {
#@     read_def "inputs/${INTEL_DESIGN_NAME}.syn.scandef"
#@   }
#@   check_scan_chain
#@   set INTEL_PLACE_CMD "$INTEL_PLACE_CMD -optimize_dft"
#@ }
#@ 
#@ #SPG Support
#@ if { [info exists INTEL_SPG] && $INTEL_SPG } {
#@   if { [info exists INTEL_SPG_DEF] && $INTEL_SPG_DEF } {
#@     set spg_ascii_flow true
#@     read_def "inputs/floorplan/${INTEL_DESIGN_NAME}.syn.def"
#@   }
#@   set INTEL_PLACE_CMD "$INTEL_PLACE_CMD -spg "
#@   P_msg_info "SPG support enabled"
#@ }
#@ 
#@ P_msg_info "Running: $INTEL_PLACE_CMD"
#@ eval $INTEL_PLACE_CMD
#@ # -- Starting source ./.auto_pattern.tcl

#@ remove_net_search_pattern -all -quiet
#@ create_net_search_pattern -quiet -net_length_upper_limit 2
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.970275  -max_vertical_capacitance_scaling_factor 0.970275  -max_horizontal_resistance_scaling_factor 1.16843  -max_vertical_resistance_scaling_factor 1.16843  -via_count_scale 0.95363  -via_resistance 0.0515299 -pattern 1
#@ create_net_search_pattern -quiet -net_length_lower_limit 2 -net_length_upper_limit 5
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.978619  -max_vertical_capacitance_scaling_factor 0.978619  -max_horizontal_resistance_scaling_factor 1.14182  -max_vertical_resistance_scaling_factor 1.14182  -via_count_scale 1.01167  -via_resistance 0.0512652 -pattern 2
#@ create_net_search_pattern -quiet -net_length_lower_limit 5 -net_length_upper_limit 10
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.971715  -max_vertical_capacitance_scaling_factor 0.971715  -max_horizontal_resistance_scaling_factor 1.13064  -max_vertical_resistance_scaling_factor 1.13064  -via_count_scale 1.00118  -via_resistance 0.050856 -pattern 3
#@ create_net_search_pattern -quiet -net_length_lower_limit 10 -net_length_upper_limit 20
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.969143  -max_vertical_capacitance_scaling_factor 0.969143  -max_horizontal_resistance_scaling_factor 1.1032  -max_vertical_resistance_scaling_factor 1.1032  -via_count_scale 1.05332  -via_resistance 0.0511086 -pattern 4
#@ create_net_search_pattern -quiet -net_length_lower_limit 20 -net_length_upper_limit 50
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.947792  -max_vertical_capacitance_scaling_factor 0.947792  -max_horizontal_resistance_scaling_factor 1.04623  -max_vertical_resistance_scaling_factor 1.04623  -via_count_scale 1.13546  -via_resistance 0.051643 -pattern 5
#@ create_net_search_pattern -quiet -net_length_lower_limit 50 -net_length_upper_limit 100
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.918108  -max_vertical_capacitance_scaling_factor 0.918108  -max_horizontal_resistance_scaling_factor 1.02635  -max_vertical_resistance_scaling_factor 1.02635  -via_count_scale 1.00451  -via_resistance 0.0522282 -pattern 6
#@ create_net_search_pattern -quiet -net_length_lower_limit 100 -net_length_upper_limit 200
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.942019  -max_vertical_capacitance_scaling_factor 0.942019  -max_horizontal_resistance_scaling_factor 1.0682  -max_vertical_resistance_scaling_factor 1.0682  -via_count_scale 1.08205  -via_resistance 0.0528877 -pattern 7
#@ create_net_search_pattern -quiet -net_length_lower_limit 200 -net_length_upper_limit 500
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 0.942423  -max_vertical_capacitance_scaling_factor 0.942423  -max_horizontal_resistance_scaling_factor 1.09528  -max_vertical_resistance_scaling_factor 1.09528  -via_count_scale 0.946572  -via_resistance 0.0533794 -pattern 8
#@ create_net_search_pattern -quiet -net_length_lower_limit 500
#@ set_net_search_pattern_delay_estimation_options  -max_horizontal_capacitance_scaling_factor 1  -max_vertical_capacitance_scaling_factor 1  -max_horizontal_resistance_scaling_factor 1  -max_vertical_resistance_scaling_factor 1  -via_count_scale 1  -pattern 9
#@ # -- End source ./.auto_pattern.tcl

#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/place_opt.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_place.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_check_place_overlap
#@ # 2. P_msg_info
#@ # 3. P_check_cells
#@ 
#@ ##############################################################################
#@ ## Flag overlap cells in the design                                         ##
#@ #############################################################################
#@ P_check_place_overlap
#@ 
#@ set clk_logic "d04cgc* d04scb* d04cgm* d04scb* d04gbf* d04gin*"
#@ 
#@ ##############################################################################
#@ ## Dont_use cells except clock cells                                        ##
#@ ##############################################################################
#@ P_msg_info "CHECK_PLACE.tcl: dont_use cells except clock cells"
#@ set ref_list $dont_use_list
#@ set icc_local_dont_use_list [list ]
#@ set clock_cell_dont_use [list ]
#@ 
#@ foreach {cell_types cell_description} $ref_list {
#@   set icc_local_dont_use_list [concat $icc_local_dont_use_list "${cell_types} "]
#@ }
#@ 
#@ foreach cell $clk_logic {
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $cell]
#@ }
#@ 
#@ set clock_cell_dont_use "$INTEL_CTS_CELLS_DEFAULT $INTEL_CTS_CELLS_SIZE $INTEL_CTS_CELLS_DELAY_INSERT $INTEL_CTS_CELL_BOUNDARY"
#@ set icc_local_dont_use_list [lminus $icc_local_dont_use_list $clock_cell_dont_use]
#@ 
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_cells "d04slc* d04swa00* d04swo00* d04pws* d04pws10* d04sc* d04dly0* d04swi00* d04swb00* d04slg* d04sv*"
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $pm_cells]
#@ }
#@ 
#@ set ref_list $icc_local_dont_use_list
#@ set inst_list [get_cells -hierarchical]
#@ set msg "dont_use cell found in design:"
#@ set flag "err"
#@ P_check_cells $ref_list $inst_list $msg $flag
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_place.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ ##############################################################################
#@ 
#@ #####################################
#@ # List of procs used in script
#@ # None
#@ ################################
#@ 
#@ 
#@ ## making the net names case insensitive to avoid false violation from LVS
#@ define_name_rules standard_netnames -case_insensitive -type net
#@ 
#@ if {$synopsys_program_name == "icc_shell" && $INTEL_ECO_TYPE != 0 } {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ } else {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ }
#@ 
#@ 
#@ puts "==>INFORMATION: Running default verilog rule , check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules verilog >> $change_name_log_file
#@ 
#@ puts "==>INFORMATION: Running name rule 'standard_netnames_verilog', check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules standard_netnames >> $change_name_log_file
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ ##############################################################################
#@ #Script: tool_constraints.tcl
#@ # List of procs used by this tcl
#@ # 1. P_lminus
#@ # 2. P_msg_info
#@ # 3. get_completed_steps
#@ 
#@ # Density screening
#@ #
#@ # set_congestion_options
#@ #       [-max_util value]: Specifies the layer name whose availability is reduced.
#@ #       [-layer name]: Specifies the availability of the routing resource for the layer
#@ #       [-availability value]: Specifies the availability of the routing resource for the layer
#@ #       [-coordinate {X1 Y1 X2 Y2}]: Specifies the lower left and upper right coordinates
#@ #                                    for which the congestion options will apply.
#@ #                                    The numbers are in microns.
#@ # Example: set_congestion_options -max_util 0.5 -coordinate {0 0 2560 155}
#@ 
#@ 
#@ # Soft blockage (0% utilization during initial place, but allows for buffering later)
#@ #
#@ # create_placement_blockage
#@ #       -bbox rectangle: Specifies the coordinates of the bounding box of the blockage.
#@ #                        rectangle  x1 y1 x2 y2
#@ #       -type soft: Specifies the type of blockage to be created as soft.
#@ #                   With a soft blockage, the placer tries not to place standard cells
#@ #                   or hard macros in the specified region but will do so if the congestion
#@ #                   is too high.
#@ #       [-name blockage_name]: Specifies the optional name of the blockage.
#@ #                              If you  specify  a name  for  the blockage,
#@ #                              you can use it later in the flow to get the blockage by name.
#@ # Example: create_placement_blockage -name hot_corner_plcmnt_blkg_1 -bbox {{4066 259.2} {4096 459.2}} -type soft
#@ # Example: create_placement_blockage -name KO_idv4 -bbox { 540.4 1094.56 579.6  1225.28} -type soft
#@ 
#@ 
#@ # Cells inserted during each flow will have a prefix of the flow name. For ex. placement will have "place" prefix
#@ # If Intel flow variables are not defined, then the default prefix will be used
#@ if {[lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0] != ""} {
#@   set_app_var compile_instance_name_prefix [lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0]
#@ }
#@ 
#@ # Enables congestion removal with the global router
#@ set_app_var placer_enable_enhanced_router true
#@ 
#@ #To prevent side load on output ports
#@ set_isolate_ports -type buffer [filter_collection [all_outputs] "direction=~out"]
#@ 
#@ # Congestion removal effort during coarse placement
#@ set_app_var placer_enable_high_effort_congestion true
#@ 
#@ # Congestion effort during place_opt (default is auto)
#@ # Setting to medium/high, ICC always uses the Zroute global route for congestion-driven placement
#@ set_app_var placer_congestion_effort medium
#@ 
#@ # Prints out Zroute global routing information during congestion-driven placement
#@ set_app_var placer_show_zroutegr_output true
#@ 
#@ # Ensure cells are placed close together for low-utilization blocks
#@ # Recommended setings are somewhere between 0.5 and 0.65
#@ set_app_var placer_max_cell_density_threshold 0.6
#@ 
#@ # Set critical range
#@ set_critical_range $INTEL_CRITICAL_RANGE [get_designs]
#@ 
#@ # Pre-route area and power critical range values
#@ if {[info exists INTEL_AREA_CRITICAL_RANGE] && $INTEL_AREA_CRITICAL_RANGE!="not_set"} {
#@   set_app_var physopt_area_critical_range $INTEL_AREA_CRITICAL_RANGE
#@ }
#@ if {[info exists INTEL_POWER_CRITICAL_RANGE] && $INTEL_POWER_CRITICAL_RANGE != "not_set" } {
#@   set_app_var physopt_power_critical_range $INTEL_POWER_CRITICAL_RANGE
#@ }
#@ 
#@ # Avoid excessive buffering
#@ set_buffer_opt_strategy -effort medium
#@ 
#@ # Set auto high fanout synthesis options
#@ set_ahfs_options     -constant_nets true     -port_map_file outputs/${INTEL_DESIGN_NAME}_ahfs_port_map.txt
#@ 
#@ # Set routing layers
#@ remove_ignored_layers -all
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS
#@ }
#@ P_msg_info "Setting min_routing_layer: $min_routing_layer"
#@ P_msg_info "Setting max_routing_layer: $max_routing_layer"
#@ P_msg_info "Setting rc_ignore_layer:   $rc_ignore_layer"
#@ set_ignored_layers      -min_routing_layer $min_routing_layer     -max_routing_layer $max_routing_layer     -rc_congestion_ignored_layers $rc_ignore_layer
#@ 
#@ 
#@ # Setting default Toggle Rate and Static Probability for power optmization in the absence of SAIF
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@     P_msg_info "Input saif file will be used for dynamic power optmization"
#@   } else {
#@     P_msg_info "Setting default toggle rate $INTEL_POWER_TR and default static probability $INTEL_POWER_SP for dynamic power optimization"
#@     set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@     set_app_var power_default_static_probability $INTEL_POWER_SP
#@   }
#@ }
#@ 
#@ # Power optimization options (turn on dynamic power opt if INTEL_DYNAMIC_POWER is set to 1)
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement true
#@ } else {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement false
#@ }
#@ 
#@ #Enable DRC on constant nets
#@ set_auto_disable_drc_nets -constant false
#@ 
#@ #Ensure the tool observes max_cap constraints during tie-off optimization
#@ set_app_var physopt_new_fix_constants true
#@ 
#@ # Enable via resistance estimation
#@ set_app_var physopt_enable_via_res_support true
#@ 
#@ # Uses alternate name styles to solve name mismatching issues in read_def
#@ set_app_var def_enable_no_legalize_name true
#@ 
#@ # Set multiple port nets options
#@ #        [-feedthroughs]        (fix feedthroughs)
#@ #        [-outputs]             (fix multiple output port nets)
#@ #        [-buffer_constants]    (buffer constants driving multiple ports)
#@ # Without this option, feedthrough ports can be connected directly to each other
#@ # and create text short error in LVS.
#@ set_fix_multiple_port_nets -feedthroughs -outputs -buffer_constants
#@ 
#@ ################################
#@ # Placement
#@ ################################
#@ # Use Zrouter to drive peroute optimization.
#@ if { $::sh_product_version > {I-2013.12-ICC-SP2} } {
#@   set_place_opt_strategy -consider_routing true
#@ }
#@ 
#@ ####################################
#@ # Setting Delay Calculation Options
#@ ####################################
#@ P_msg_info "Setting Delay Calculation as follows :\n Pre-route : Elmore\n Routed Clock : Arnoldi\n Post-route : Arnoldi"
#@ set_delay_calculation_options -preroute elmore -routed_clock arnoldi -postroute arnoldi
#@ 
#@ ####################################
#@ # CTS
#@ ####################################
#@ # The following are used to force CTS to fix more max_cap drcs.
#@ set         ctdn_enable_ccs_low_cap true
#@ set_app_var cto_enable_drc_fixing   true
#@ set         cts_low_power           false
#@ 
#@ ####################################
#@ # Extraction Options
#@ ####################################
#@ 
#@ if { [lsearch -exact [get_completed_steps] fill] > 0} {
#@   set_extraction_options       -real_metalfill_extraction FLOATING       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ } else {
#@   set_extraction_options       -real_metalfill_extraction none       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ ##############################################################################
#@ # Description: This script enables the application of frequency based max-capacitance values
#@ #              The highest frequency in the design is used for max-capacitance lookup
#@ #Required Vars: INTEL_CMAX_DEFAULT_PERIOD - Clock Period used if minimum clock period could not be derived.
#@ #               INTEL_CMAX_LUT - Full Path to Cmax Lookup Table CSV file
#@ #Procs Used:
#@ #1. P_msg_warn
#@ #2. P_msg_error
#@ #3. P_msg_info
#@ 
#@ # Determine maximum frequency
#@ set minperiod [lindex [lsort -increasing -real [get_attribute [get_clocks] period -quiet]] 0]
#@ 
#@ # As a fail-safe, set a default frequency
#@ if {$minperiod eq ""} {
#@   if {[info exists INTEL_CMAX_DEFAULT_PERIOD] && $INTEL_CMAX_DEFAULT_PERIOD != ""} {
#@     P_msg_warn "Minimum period could not be determined. Defaulting to ${INTEL_CMAX_DEFAULT_PERIOD}ps"
#@     set minperiod $INTEL_CMAX_DEFAULT_PERIOD
#@   } else {
#@     P_msg_error "Minimum period could not be determined. Please provide minimum period to use by setting INTEL_CMAX_DEFAULT_PERIOD variable."
#@     return
#@   }
#@ }
#@ 
#@ # Multiplying by 1000 as lookup table values are in GHz
#@ set fmax [expr [expr 1.0/$minperiod] * 1000]
#@ 
#@ # Read reference file
#@ if {[info exists INTEL_CMAX_LUT] && [file exists $INTEL_CMAX_LUT]} {
#@   P_msg_info "Reading Max-Cap LUT file - $INTEL_CMAX_LUT"
#@   set lut_file $INTEL_CMAX_LUT
#@   set fh [open $lut_file "r"]
#@ } else {
#@   P_msg_warn "Either INTEL_CMAX_LUT variable does not exist (or) $INTEL_CMAX_LUT file cannot be found"
#@   return
#@ }
#@ 
#@ if {[info exists INTEL_SCALE_RV_CMAX] && $INTEL_SCALE_RV_CMAX != ""} {
#@   P_msg_info "RV Cmax scaling enabled. Scaling factor value - $INTEL_SCALE_RV_CMAX - has been used..."
#@   set scaling_factor $INTEL_SCALE_RV_CMAX
#@ } else {
#@   set scaling_factor 1
#@ }
#@ 
#@ P_msg_info "Applying frequency based max-capacitance values..."
#@ set err_cnt 0
#@ while {[gets $fh line] > -1} {
#@   set line_vals [split $line ","]
#@   if {[regexp {^cell} $line]} {
#@     set indices [lrange $line_vals 1 end]
#@   } else {
#@     if {[sizeof_collection [set lib_pin [get_lib_pins */[lindex $line_vals 0] -quiet]]]} {
#@       set i 0
#@       set prev_val ""
#@       set curr_val ""
#@       set prev_index ""
#@       set curr_index ""
#@       set new_cmax_value ""
#@       foreach cmax [lrange $line_vals 1 end] {
#@         set prev_val $curr_val
#@         set curr_val $cmax
#@         set prev_index $curr_index
#@         set curr_index [lindex $indices $i]
#@         if {[expr $fmax >= $curr_index]} {
#@           # continue to next value
#@           if {$i == [expr [llength [lrange $line_vals 1 end]] - 1]} {
#@             set new_cmax_value $cmax
#@             break
#@           }
#@         } elseif {$prev_val eq ""} {
#@           # if "" then this is the first index and the fmax is less than the minimum table value
#@           # set to minimum value
#@           set new_cmax_value $cmax
#@           break
#@         } else {
#@           # at this point we should be between two table values. interpolate.
#@           set index_prop [expr ($fmax - $prev_index)/($curr_index - $prev_index)]
#@           set new_cmax_value [expr $index_prop * ($curr_val - $prev_val) + $prev_val]
#@           set new_cmax_value [expr $new_cmax_value * $scaling_factor]
#@           break
#@         }
#@         incr i
#@       }
#@ 
#@       # Check for new_cmax_value
#@       if {$new_cmax_value eq ""} {
#@         P_msg_error "Cmax value not gathered correctly"
#@         incr err_cnt
#@       } elseif {[lindex [get_attribute $lib_pin pin_direction] 0] eq "in"} {
#@         P_msg_error "Library pin is input. Not setting Cmax. Something is likely wrong with the LUT."
#@         P_msg_error "Lib pin - [lindex [get_object_name $lib_pin] 0]"
#@         incr err_cnt
#@       } else {
#@         suppress_message {MWUI-031}
#@         set_attribute $lib_pin max_capacitance $new_cmax_value
#@         unsuppress_message {MWUI-031}
#@       }
#@     } else {
#@       P_msg_warn "Lib pin [lindex $line_vals 0] could not be found"
#@     }
#@   }
#@ }
#@ close $fh
#@ 
#@ if {$err_cnt == 0} {
#@   P_msg_info "Frequency based max-capacitance values applied successfully!"
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/psynopt.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ 
#@ P_msg_info "Running: $INTEL_POST_PLACE_CMD"
#@ eval $INTEL_POST_PLACE_CMD
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/psynopt.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/insert_spare_kit.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ 
#@ if {[info exists INTEL_INSERT_SPARE_KITS] && $INTEL_INSERT_SPARE_KITS==1} {
#@   scan [get_attribute [get_die_area] bbox] {{%f %f} {%f %f}} LX LY UX UY
#@   P_msg_info "Spacing between kits - $INTEL_DIST_BTW_SPARE_KITS";
#@   set kits_along_x [expr ${UX}/${INTEL_DIST_BTW_SPARE_KITS}];
#@   set kits_along_y [expr ${UY}/${INTEL_DIST_BTW_SPARE_KITS}];
#@   set total_kits [expr round(${kits_along_x}) * round(${kits_along_y})];
#@   insert_spare_cells -lib_cell $INTEL_SPARE_CELLS       -cell_name spares       -tie       -num_instances ${total_kits}
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/insert_spare_kit.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_place.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_check_place_overlap
#@ # 2. P_msg_info
#@ # 3. P_check_cells
#@ 
#@ ##############################################################################
#@ ## Flag overlap cells in the design                                         ##
#@ #############################################################################
#@ P_check_place_overlap
#@ 
#@ set clk_logic "d04cgc* d04scb* d04cgm* d04scb* d04gbf* d04gin*"
#@ 
#@ ##############################################################################
#@ ## Dont_use cells except clock cells                                        ##
#@ ##############################################################################
#@ P_msg_info "CHECK_PLACE.tcl: dont_use cells except clock cells"
#@ set ref_list $dont_use_list
#@ set icc_local_dont_use_list [list ]
#@ set clock_cell_dont_use [list ]
#@ 
#@ foreach {cell_types cell_description} $ref_list {
#@   set icc_local_dont_use_list [concat $icc_local_dont_use_list "${cell_types} "]
#@ }
#@ 
#@ foreach cell $clk_logic {
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $cell]
#@ }
#@ 
#@ set clock_cell_dont_use "$INTEL_CTS_CELLS_DEFAULT $INTEL_CTS_CELLS_SIZE $INTEL_CTS_CELLS_DELAY_INSERT $INTEL_CTS_CELL_BOUNDARY"
#@ set icc_local_dont_use_list [lminus $icc_local_dont_use_list $clock_cell_dont_use]
#@ 
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_cells "d04slc* d04swa00* d04swo00* d04pws* d04pws10* d04sc* d04dly0* d04swi00* d04swb00* d04slg* d04sv*"
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $pm_cells]
#@ }
#@ 
#@ set ref_list $icc_local_dont_use_list
#@ set inst_list [get_cells -hierarchical]
#@ set msg "dont_use cell found in design:"
#@ set flag "err"
#@ P_check_cells $ref_list $inst_list $msg $flag
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_place.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ ##############################################################################
#@ 
#@ #####################################
#@ # List of procs used in script
#@ # None
#@ ################################
#@ 
#@ 
#@ ## making the net names case insensitive to avoid false violation from LVS
#@ define_name_rules standard_netnames -case_insensitive -type net
#@ 
#@ if {$synopsys_program_name == "icc_shell" && $INTEL_ECO_TYPE != 0 } {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ } else {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ }
#@ 
#@ 
#@ puts "==>INFORMATION: Running default verilog rule , check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules verilog >> $change_name_log_file
#@ 
#@ puts "==>INFORMATION: Running name rule 'standard_netnames_verilog', check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules standard_netnames >> $change_name_log_file
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ ##############################################################################
#@ #Script: tool_constraints.tcl
#@ # List of procs used by this tcl
#@ # 1. P_lminus
#@ # 2. P_msg_info
#@ # 3. get_completed_steps
#@ 
#@ # Density screening
#@ #
#@ # set_congestion_options
#@ #       [-max_util value]: Specifies the layer name whose availability is reduced.
#@ #       [-layer name]: Specifies the availability of the routing resource for the layer
#@ #       [-availability value]: Specifies the availability of the routing resource for the layer
#@ #       [-coordinate {X1 Y1 X2 Y2}]: Specifies the lower left and upper right coordinates
#@ #                                    for which the congestion options will apply.
#@ #                                    The numbers are in microns.
#@ # Example: set_congestion_options -max_util 0.5 -coordinate {0 0 2560 155}
#@ 
#@ 
#@ # Soft blockage (0% utilization during initial place, but allows for buffering later)
#@ #
#@ # create_placement_blockage
#@ #       -bbox rectangle: Specifies the coordinates of the bounding box of the blockage.
#@ #                        rectangle  x1 y1 x2 y2
#@ #       -type soft: Specifies the type of blockage to be created as soft.
#@ #                   With a soft blockage, the placer tries not to place standard cells
#@ #                   or hard macros in the specified region but will do so if the congestion
#@ #                   is too high.
#@ #       [-name blockage_name]: Specifies the optional name of the blockage.
#@ #                              If you  specify  a name  for  the blockage,
#@ #                              you can use it later in the flow to get the blockage by name.
#@ # Example: create_placement_blockage -name hot_corner_plcmnt_blkg_1 -bbox {{4066 259.2} {4096 459.2}} -type soft
#@ # Example: create_placement_blockage -name KO_idv4 -bbox { 540.4 1094.56 579.6  1225.28} -type soft
#@ 
#@ 
#@ # Cells inserted during each flow will have a prefix of the flow name. For ex. placement will have "place" prefix
#@ # If Intel flow variables are not defined, then the default prefix will be used
#@ if {[lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0] != ""} {
#@   set_app_var compile_instance_name_prefix [lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0]
#@ }
#@ 
#@ # Enables congestion removal with the global router
#@ set_app_var placer_enable_enhanced_router true
#@ 
#@ #To prevent side load on output ports
#@ set_isolate_ports -type buffer [filter_collection [all_outputs] "direction=~out"]
#@ 
#@ # Congestion removal effort during coarse placement
#@ set_app_var placer_enable_high_effort_congestion true
#@ 
#@ # Congestion effort during place_opt (default is auto)
#@ # Setting to medium/high, ICC always uses the Zroute global route for congestion-driven placement
#@ set_app_var placer_congestion_effort medium
#@ 
#@ # Prints out Zroute global routing information during congestion-driven placement
#@ set_app_var placer_show_zroutegr_output true
#@ 
#@ # Ensure cells are placed close together for low-utilization blocks
#@ # Recommended setings are somewhere between 0.5 and 0.65
#@ set_app_var placer_max_cell_density_threshold 0.6
#@ 
#@ # Set critical range
#@ set_critical_range $INTEL_CRITICAL_RANGE [get_designs]
#@ 
#@ # Pre-route area and power critical range values
#@ if {[info exists INTEL_AREA_CRITICAL_RANGE] && $INTEL_AREA_CRITICAL_RANGE!="not_set"} {
#@   set_app_var physopt_area_critical_range $INTEL_AREA_CRITICAL_RANGE
#@ }
#@ if {[info exists INTEL_POWER_CRITICAL_RANGE] && $INTEL_POWER_CRITICAL_RANGE != "not_set" } {
#@   set_app_var physopt_power_critical_range $INTEL_POWER_CRITICAL_RANGE
#@ }
#@ 
#@ # Avoid excessive buffering
#@ set_buffer_opt_strategy -effort medium
#@ 
#@ # Set auto high fanout synthesis options
#@ set_ahfs_options     -constant_nets true     -port_map_file outputs/${INTEL_DESIGN_NAME}_ahfs_port_map.txt
#@ 
#@ # Set routing layers
#@ remove_ignored_layers -all
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS
#@ }
#@ P_msg_info "Setting min_routing_layer: $min_routing_layer"
#@ P_msg_info "Setting max_routing_layer: $max_routing_layer"
#@ P_msg_info "Setting rc_ignore_layer:   $rc_ignore_layer"
#@ set_ignored_layers      -min_routing_layer $min_routing_layer     -max_routing_layer $max_routing_layer     -rc_congestion_ignored_layers $rc_ignore_layer
#@ 
#@ 
#@ # Setting default Toggle Rate and Static Probability for power optmization in the absence of SAIF
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@     P_msg_info "Input saif file will be used for dynamic power optmization"
#@   } else {
#@     P_msg_info "Setting default toggle rate $INTEL_POWER_TR and default static probability $INTEL_POWER_SP for dynamic power optimization"
#@     set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@     set_app_var power_default_static_probability $INTEL_POWER_SP
#@   }
#@ }
#@ 
#@ # Power optimization options (turn on dynamic power opt if INTEL_DYNAMIC_POWER is set to 1)
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement true
#@ } else {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement false
#@ }
#@ 
#@ #Enable DRC on constant nets
#@ set_auto_disable_drc_nets -constant false
#@ 
#@ #Ensure the tool observes max_cap constraints during tie-off optimization
#@ set_app_var physopt_new_fix_constants true
#@ 
#@ # Enable via resistance estimation
#@ set_app_var physopt_enable_via_res_support true
#@ 
#@ # Uses alternate name styles to solve name mismatching issues in read_def
#@ set_app_var def_enable_no_legalize_name true
#@ 
#@ # Set multiple port nets options
#@ #        [-feedthroughs]        (fix feedthroughs)
#@ #        [-outputs]             (fix multiple output port nets)
#@ #        [-buffer_constants]    (buffer constants driving multiple ports)
#@ # Without this option, feedthrough ports can be connected directly to each other
#@ # and create text short error in LVS.
#@ set_fix_multiple_port_nets -feedthroughs -outputs -buffer_constants
#@ 
#@ ################################
#@ # Placement
#@ ################################
#@ # Use Zrouter to drive peroute optimization.
#@ if { $::sh_product_version > {I-2013.12-ICC-SP2} } {
#@   set_place_opt_strategy -consider_routing true
#@ }
#@ 
#@ ####################################
#@ # Setting Delay Calculation Options
#@ ####################################
#@ P_msg_info "Setting Delay Calculation as follows :\n Pre-route : Elmore\n Routed Clock : Arnoldi\n Post-route : Arnoldi"
#@ set_delay_calculation_options -preroute elmore -routed_clock arnoldi -postroute arnoldi
#@ 
#@ ####################################
#@ # CTS
#@ ####################################
#@ # The following are used to force CTS to fix more max_cap drcs.
#@ set         ctdn_enable_ccs_low_cap true
#@ set_app_var cto_enable_drc_fixing   true
#@ set         cts_low_power           false
#@ 
#@ ####################################
#@ # Extraction Options
#@ ####################################
#@ 
#@ if { [lsearch -exact [get_completed_steps] fill] > 0} {
#@   set_extraction_options       -real_metalfill_extraction FLOATING       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ } else {
#@   set_extraction_options       -real_metalfill_extraction none       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ ##############################################################################
#@ # Description: This script enables the application of frequency based max-capacitance values
#@ #              The highest frequency in the design is used for max-capacitance lookup
#@ #Required Vars: INTEL_CMAX_DEFAULT_PERIOD - Clock Period used if minimum clock period could not be derived.
#@ #               INTEL_CMAX_LUT - Full Path to Cmax Lookup Table CSV file
#@ #Procs Used:
#@ #1. P_msg_warn
#@ #2. P_msg_error
#@ #3. P_msg_info
#@ 
#@ # Determine maximum frequency
#@ set minperiod [lindex [lsort -increasing -real [get_attribute [get_clocks] period -quiet]] 0]
#@ 
#@ # As a fail-safe, set a default frequency
#@ if {$minperiod eq ""} {
#@   if {[info exists INTEL_CMAX_DEFAULT_PERIOD] && $INTEL_CMAX_DEFAULT_PERIOD != ""} {
#@     P_msg_warn "Minimum period could not be determined. Defaulting to ${INTEL_CMAX_DEFAULT_PERIOD}ps"
#@     set minperiod $INTEL_CMAX_DEFAULT_PERIOD
#@   } else {
#@     P_msg_error "Minimum period could not be determined. Please provide minimum period to use by setting INTEL_CMAX_DEFAULT_PERIOD variable."
#@     return
#@   }
#@ }
#@ 
#@ # Multiplying by 1000 as lookup table values are in GHz
#@ set fmax [expr [expr 1.0/$minperiod] * 1000]
#@ 
#@ # Read reference file
#@ if {[info exists INTEL_CMAX_LUT] && [file exists $INTEL_CMAX_LUT]} {
#@   P_msg_info "Reading Max-Cap LUT file - $INTEL_CMAX_LUT"
#@   set lut_file $INTEL_CMAX_LUT
#@   set fh [open $lut_file "r"]
#@ } else {
#@   P_msg_warn "Either INTEL_CMAX_LUT variable does not exist (or) $INTEL_CMAX_LUT file cannot be found"
#@   return
#@ }
#@ 
#@ if {[info exists INTEL_SCALE_RV_CMAX] && $INTEL_SCALE_RV_CMAX != ""} {
#@   P_msg_info "RV Cmax scaling enabled. Scaling factor value - $INTEL_SCALE_RV_CMAX - has been used..."
#@   set scaling_factor $INTEL_SCALE_RV_CMAX
#@ } else {
#@   set scaling_factor 1
#@ }
#@ 
#@ P_msg_info "Applying frequency based max-capacitance values..."
#@ set err_cnt 0
#@ while {[gets $fh line] > -1} {
#@   set line_vals [split $line ","]
#@   if {[regexp {^cell} $line]} {
#@     set indices [lrange $line_vals 1 end]
#@   } else {
#@     if {[sizeof_collection [set lib_pin [get_lib_pins */[lindex $line_vals 0] -quiet]]]} {
#@       set i 0
#@       set prev_val ""
#@       set curr_val ""
#@       set prev_index ""
#@       set curr_index ""
#@       set new_cmax_value ""
#@       foreach cmax [lrange $line_vals 1 end] {
#@         set prev_val $curr_val
#@         set curr_val $cmax
#@         set prev_index $curr_index
#@         set curr_index [lindex $indices $i]
#@         if {[expr $fmax >= $curr_index]} {
#@           # continue to next value
#@           if {$i == [expr [llength [lrange $line_vals 1 end]] - 1]} {
#@             set new_cmax_value $cmax
#@             break
#@           }
#@         } elseif {$prev_val eq ""} {
#@           # if "" then this is the first index and the fmax is less than the minimum table value
#@           # set to minimum value
#@           set new_cmax_value $cmax
#@           break
#@         } else {
#@           # at this point we should be between two table values. interpolate.
#@           set index_prop [expr ($fmax - $prev_index)/($curr_index - $prev_index)]
#@           set new_cmax_value [expr $index_prop * ($curr_val - $prev_val) + $prev_val]
#@           set new_cmax_value [expr $new_cmax_value * $scaling_factor]
#@           break
#@         }
#@         incr i
#@       }
#@ 
#@       # Check for new_cmax_value
#@       if {$new_cmax_value eq ""} {
#@         P_msg_error "Cmax value not gathered correctly"
#@         incr err_cnt
#@       } elseif {[lindex [get_attribute $lib_pin pin_direction] 0] eq "in"} {
#@         P_msg_error "Library pin is input. Not setting Cmax. Something is likely wrong with the LUT."
#@         P_msg_error "Lib pin - [lindex [get_object_name $lib_pin] 0]"
#@         incr err_cnt
#@       } else {
#@         suppress_message {MWUI-031}
#@         set_attribute $lib_pin max_capacitance $new_cmax_value
#@         unsuppress_message {MWUI-031}
#@       }
#@     } else {
#@       P_msg_warn "Lib pin [lindex $line_vals 0] could not be found"
#@     }
#@   }
#@ }
#@ close $fh
#@ 
#@ if {$err_cnt == 0} {
#@   P_msg_info "Frequency based max-capacitance values applied successfully!"
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/cts_ndr_rules.tcl

#@ ##############################################################################
#@ 
#@ #############################################
#@ # NDR RULE : ndr_defaultW_3T_noSh
#@ #############################################
#@ remove_routing_rules ndr_defaultW_3T_noSh
#@ 
#@ P_msg_info "Defining NDR rule : ndr_defaultW_3T_noSh"
#@ 
#@ define_routing_rule ndr_defaultW_3T_noSh -default_reference_rule -snap_to_track     -widths {m6 0.044 m7 0.056 m8 0.140}     -spacings {m6 0.080 m7 0.112 m8 0.328}
#@ 
#@ report_routing_rules
#@ 
#@ #############################################
#@ # NDR RULE : ndr_defaultW_3T_noSh_Lth
#@ #############################################
#@ remove_routing_rules ndr_defaultW_3T_noSh_Lth
#@ 
#@ P_msg_info "Defining NDR rule : ndr_defaultW_3T_noSh_Lth"
#@ 
#@ define_routing_rule ndr_defaultW_3T_noSh_Lth -default_reference_rule -snap_to_track     -widths {m6 0.044 m7 0.056 m8 0.140}     -spacings {m6 0.080 m7 0.112 m8 0.328}     -spacing_length_thresholds {m6 1.0 m7 1.0 m8 1.0}
#@ 
#@ report_routing_rules
#@ 
#@ #############################################
#@ # NDR RULE : ndr_defaultW_3T_Sh
#@ #############################################
#@ remove_routing_rules ndr_defaultW_3T_Sh
#@ 
#@ P_msg_info "Defining NDR rule : ndr_defaultW_3T_Sh"
#@ 
#@ define_routing_rule ndr_defaultW_3T_Sh -default_reference_rule -snap_to_track     -widths {m6 0.044 m7 0.056 m8 0.140}     -spacings {m6 0.040 m7 0.056 m8 0.140}     -shield_widths {m0 0.00 m1 0.00 m2 0.00 m3 0.00 m4 0.00 m5 0.00 m6 0.044 m7 0.056 m8 0.140} 
#@ report_routing_rules
#@ 
#@ #############################################
#@ # NDR RULE : ndr_wideW_m6_m7_noSh
#@ #############################################
#@ remove_routing_rules ndr_wideW_m6_m7_noSh
#@ 
#@ P_msg_info "Defining NDR rule : ndr_wideW_m6_m7_noSh"
#@ 
#@ define_routing_rule ndr_wideW_m6_m7_noSh -default_reference_rule -snap_to_track     -widths {m6 0.108 m7 0.150 }
#@ 
#@ report_routing_rules
#@ 
#@ #############################################
#@ # NDR RULE : ndr_wideW_m6_m7_Sh
#@ #############################################
#@ remove_routing_rules ndr_wideW_m6_m7_Sh
#@ 
#@ P_msg_info "Defining NDR rule : ndr_wideW_m6_m7_Sh"
#@ 
#@ define_routing_rule ndr_wideW_m6_m7_Sh -default_reference_rule -snap_to_track     -widths {m6 0.108 m7 0.150 }     -shield_widths {m0 0.00 m1 0.00 m2 0.00 m3 0.00 m4 0.00 m5 0.00 m6 0.044 m7 0.056 }
#@ 
#@ report_routing_rules
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/cts_ndr_rules.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cts_options.tcl

#@ ##############################################################################
#@ # Script: cts_options.tcl
#@ ##############################################################################
#@ 
#@ ##############################################################################
#@ # List of procs used by this scripts
#@ # 1. P_msg_info
#@ ##############################################################################
#@ 
#@ # List out all the clocks.  Override with INTEL_CTS_NETS if exist
#@ if {[info exist INTEL_CTS_NETS] && $INTEL_CTS_NETS != ""} {
#@   set clock_list $INTEL_CTS_NETS
#@ } else {
#@   set clock_list [get_object_name [get_clocks]]
#@ }
#@ 
#@ # set the CTS references (this may be too much...)
#@ P_msg_info "Setting clock tree references"
#@ foreach cts_cell_class {INTEL_CTS_CELLS_DEFAULT INTEL_CTS_CELLS_SIZE INTEL_CTS_CELLS_DELAY_INSERT INTEL_CTS_CELL_BOUNDARY} {
#@   set cell_list ""
#@   foreach cell [expr $$cts_cell_class] { set cell_list [add_to_collection $cell_list [get_lib_cells */$cell]]}
#@   set cts_cell_class [join [lrange [split $cts_cell_class _] 3 end] _]
#@   set cts_cells($cts_cell_class) ""
#@   foreach_in_collection pins [get_lib_pins -of_objects $cell_list -filter {pin_direction==out} -quiet] {
#@     if {[get_attribute $pins max_capacitance]!= 0} {
#@       set cts_cells($cts_cell_class) [add_to_collection $cts_cells($cts_cell_class) [get_lib_cells -of_objects $pins]]
#@     } else {
#@       set zeroMC [get_attribute $pins full_name];
#@       P_msg_info "$zeroMC has zero max capacitance value. Cell will not be used during CTS"
#@     }
#@   }
#@ }
#@ 
#@ 
#@ set_clock_tree_references -references $cts_cells(DEFAULT)
#@ set_clock_tree_references -references $cts_cells(SIZE) -sizing_only
#@ set_clock_tree_references -references $cts_cells(DELAY_INSERT) -delay_insertion_only
#@ set_clock_tree_references -references $cts_cells(BOUNDARY) -boundary_cell_only
#@ 
#@ ########## If individual clock tree references needs to be specified, use these commands.###
#@ #set_clock_tree_references -clock_trees $clock_list -references $cts_cells(DEFAULT)
#@ #set_clock_tree_references -clock_trees $clock_list -references $cts_cells(SIZE) -sizing_only
#@ #set_clock_tree_references -clock_trees $clock_list -references $cts_cells(DELAY_INSERT) -delay_insertion_only
#@ #set_clock_tree_references -clock_trees $clock_list -references $cts_cells(BOUNDARY) -boundary_cell_only
#@ 
#@ ######################################################
#@ ## Check for NDR track availability if NDR is enabled
#@ ######################################################
#@ 
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   set ndr_track_avail 0
#@   foreach layer {m5 m6 m7 m8 m9} {
#@     redirect -variable rule_based_track {report_rule_based_track -layer $layer}
#@     set reserved_tracks [regexp -inline -line -all {.*reserved_for_width} $rule_based_track]
#@     if {[llength $reserved_tracks] > 0} {
#@       set ndr_track_avail 1
#@     }
#@   }
#@   if { $ndr_track_avail == 0 } {
#@     P_msg_error "NDR has been enabled and no wide wire tracks are available. Please create wide wire NDR tracks as per expectation"
#@   }
#@ }
#@ 
#@ #
#@ # Apply Non Default Routing rules as specified by user
#@ #
#@ reset_clock_tree_options -all
#@ reset_clock_tree_optimization_options -all
#@ 
#@ foreach clock $clock_list {
#@ 
#@   ### Get max_tran constraint for clock ###
#@   set clock_period [get_attribute [get_clocks $clock] period]
#@   set ctran_val [expr {( $clock_period*.1 > 125) ? 125 : $clock_period*.1}]
#@   P_msg_info "Constraining CTS max transition on clock $clock to ${ctran_val}ps"
#@ 
#@   # Define common clock tree options
#@   set clk_options "set_clock_tree_options -use_default_routing_for_sinks 1 -insert_boundary_cell true -gate_relocation true -max_fanout $INTEL_CTS_MAX_FANOUT -max_transition $ctran_val [list -layer_list_for_sinks [list $INTEL_CTS_LEAF_MIN_LAYER $INTEL_CTS_LEAF_MAX_LAYER]] -use_leaf_routing_rule_for_sinks 1"
#@   set clock_tree_opt_cmd "set_clock_tree_optimization_options -gate_relocation true -area_recovery true"
#@ 
#@   if { [info exists INTEL_CTS_ADVANCED_DRC_FIXING] && $INTEL_CTS_ADVANCED_DRC_FIXING !="" } {
#@     if { $::sh_product_version > {I-2013.12} } {
#@       set clk_options "$clk_options -advanced_drc_fixing $INTEL_CTS_ADVANCED_DRC_FIXING"
#@     }
#@   }
#@ 
#@   P_msg_info "Setting clock tree options for : $clock"
#@   if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR && [info exists INTEL_CTS_NDR_RULE($clock)] && $INTEL_CTS_NDR_RULE($clock)!=""} {
#@     P_msg_info "Setting routing rule for $clock : $INTEL_CTS_NDR_RULE($clock)"
#@     set clk_options "$clk_options -routing_rule $INTEL_CTS_NDR_RULE($clock)"
#@ 
#@   } elseif {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR && [info exists INTEL_CTS_NDR_RULE(DEFAULT)] && $INTEL_CTS_NDR_RULE(DEFAULT)!=""} {
#@     P_msg_info "Default NDR rule $INTEL_CTS_NDR_RULE(DEFAULT) has been defined and will be applied to $clock";
#@     P_msg_info "Setting routing rule for $clock : $INTEL_CTS_NDR_RULE(DEFAULT)";
#@     set clk_options "$clk_options -routing_rule $INTEL_CTS_NDR_RULE(DEFAULT)"
#@ 
#@   } else {
#@     P_msg_info "Neither a default NDR rule nor a clock specific NDR rule is defined for $clock...";
#@     P_msg_info "Clock $clock will use default routing rule";
#@   }
#@ 
#@   if {[info exists INTEL_CTS_MIN_ROUTING_LAYER($clock)] && $INTEL_CTS_MIN_ROUTING_LAYER($clock)!="" && [info exists INTEL_CTS_MAX_ROUTING_LAYER($clock)] && $INTEL_CTS_MAX_ROUTING_LAYER($clock)!=""} {
#@     set layer_list [list -layer_list [list $INTEL_CTS_MIN_ROUTING_LAYER($clock) $INTEL_CTS_MAX_ROUTING_LAYER($clock)]]
#@     P_msg_info "Clock specific min-max layers are defined for $clock and will be used"
#@     set clk_options "$clk_options -clock_trees $clock $layer_list"
#@   } else {
#@     set layer_list [list -layer_list [list $INTEL_CTS_MIN_ROUTING_LAYER(DEFAULT) $INTEL_CTS_MAX_ROUTING_LAYER(DEFAULT)]]
#@     P_msg_info "Clock specific min-max layer is not defined. Default clock min-max layer setting will be used for $clock"
#@     set clk_options "$clk_options -clock_trees $clock $layer_list"
#@   } 
#@ 
#@   P_msg_info "Setting clock tree optimization options for : $clock"
#@   eval $clk_options
#@   set clock_tree_opt_cmd "$clock_tree_opt_cmd -clock_trees $clock"
#@   eval $clock_tree_opt_cmd
#@ }
#@ 
#@ # To balance mutliple clocks (optional)
#@ #reset_inter_clock_delay_options -all
#@ #set_inter_clock_delay_options     #   -balance_group $clock_list
#@ 
#@ # Define clock spacing rules for IR/EM
#@ # X and Y Values defined here are 2 cell rows apart
#@ if {[info exists INTEL_ENABLE_CLOCK_SPACING] && $INTEL_ENABLE_CLOCK_SPACING==1} {
#@   remove_clock_cell_spacing -all
#@   P_msg_info "Setting clock spacing rules...";
#@   foreach_in_collection cell [filter_collection [get_lib_cells "*/d04*" -quiet] -regexp {name=~"d04(cgc|cdc|cis|cpd|gan|gam|gbc|gbf|gin|gmx|gor)\w.*"}] {
#@     set_clock_cell_spacing -lib_cells [get_attribute $cell full_name] -x_spacing [expr 0.07 * 4] -y_spacing 0.399
#@   }
#@   report_clock_cell_spacing
#@ }
#@ 
#@ report_net_routing_rules *
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cts_options.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/create_route_guides.tcl

#@ ##############################################################################
#@ ##############################################################################
#@ # List of procs used by this scripts
#@ # 1. P_create_route_guide
#@ ##############################################################################
#@ 
#@ # P_create_route_guide
#@ # -Creates route guides on the edges of a boundary/polygon,
#@ #  up to a specified top metal layer
#@ # -Relies on upvar $rbcount to uniquify route guide names
#@ 
#@ # Remove route guides if it exists before re-creating them
#@ if {[sizeof_collection [get_route_guides -quiet rtguide_boundary_*]] != 0} {
#@   remove_route_guide rtguide_boundary_*
#@ }
#@ 
#@ proc P_create_route_guide {boundary top_layer} {
#@   upvar rbcount count
#@   set lcount 0
#@   set v_start 3
#@   set h_start 2
#@   foreach point $boundary {
#@     if {$lcount != 0} {
#@       if {[lindex $point 0] == [lindex $prev 0]} {
#@         # Create vertical route guides (M3, 5, 7, 9)
#@         set y1 [lindex $prev 1]
#@         set y2 [lindex $point 1]
#@ 
#@         for {set i $v_start} {[expr $i <= $top_layer]} {incr i 2} {
#@           switch -exact -- $i {
#@             3 { create_route_guide -no_signal_layers m3 -coordinate [list [expr [lindex $point 0] - 0.066] $y1 [expr [lindex $point 0] +0.066] $y2] -name rtguide_boundary_metal3_${count}
#@             }
#@             5 { create_route_guide -no_signal_layers m5 -coordinate [list [expr [lindex $point 0] - 0.106] $y1 [expr [lindex $point 0] +0.106] $y2] -name rtguide_boundary_metal5_${count}
#@             }
#@             7 { create_route_guide -no_signal_layers m7 -coordinate [list [expr [lindex $point 0] - 0.056] $y1 [expr [lindex $point 0] + 0.056] $y2] -name rtguide_boundary_metal7_${count}
#@             }
#@             9 { create_route_guide -no_signal_layers m9 -coordinate [list [expr [lindex $point 0] - 0.080] $y1 [expr [lindex $point 0] + 0.080] $y2] -name rtguide_boundary_metal9_${count}
#@             }
#@           }
#@         }
#@       } else {
#@         # Create horizontal route guides (M2, 4, 6, 8)
#@         set x1 [lindex $prev 0]
#@         set x2 [lindex $point 0]
#@ 
#@         for {set i $h_start} {[expr $i <= $top_layer]} {incr i 2} {
#@           switch -exact -- $i {
#@             2  { create_route_guide -no_signal_layers m2  -coordinate [list $x1 [expr [lindex $point 1] - 0.066] $x2 [expr [lindex $point 1] +0.066]] -name rtguide_boundary_metal2_${count}
#@             }
#@             4  { create_route_guide -no_signal_layers m4  -coordinate [list $x1 [expr [lindex $point 1] - 0.070] $x2 [expr [lindex $point 1] +0.070]] -name rtguide_boundary_metal4_${count}
#@             }
#@             6  { create_route_guide -no_signal_layers m6  -coordinate [list $x1 [expr [lindex $point 1] - 0.056] $x2 [expr [lindex $point 1] + 0.056]] -name rtguide_boundary_metal6_${count}
#@             }
#@             8  { create_route_guide -no_signal_layers m8  -coordinate [list $x1 [expr [lindex $point 1] - 0.084] $x2 [expr [lindex $point 1] + 0.084]] -name rtguide_boundary_metal8_${count}
#@             }
#@           }
#@         }
#@       }
#@     }
#@     incr count
#@     incr lcount
#@     set prev $point
#@   }
#@ }
#@ 
#@ ###
#@ # Create route guide at the block boundary to avoid DRC violations from
#@ # via3/via4/via5/via6 placed too close to the block boundary.
#@ # These route guides should be removed before starting the metal/via fill.
#@ ###
#@ 
#@ # Route Guides need to be removed before fill goes in
#@ 
#@ set rbcount 0
#@ set top_layer $INTEL_MAX_ROUTING_LAYER
#@ if {$top_layer == "tm1" || $top_layer == "c4b"} {
#@   set top_layer m9
#@ }
#@ P_create_route_guide [get_attribute [get_die_area] boundary] [string map {m ""} $top_layer]
#@ 
#@ foreach_in_collection macro [all_macro_cells] {
#@   set pins [get_pins -all -of_objects $macro]
#@   set layers [get_attribute $pins layer]
#@   # flatten list of lists
#@   set layers [join $layers]
#@   set top_layer [lindex [lsort -unique -dictionary $layers] end]
#@   # Check and avoid creating route guides on layers with pins to avoid pins getting blocked out. If pins exist on tm1 or c4b, create route guides on m9 and below.
#@   if {$top_layer == "tm1" || $top_layer == "c4b"} {
#@     set top_layer m9
#@   }
#@   # Keep decrementing $top_layer till we hit the layer below the lowest pin-layer to avoid creating route guides on pin layers.
#@   while { [lsearch $layers $top_layer] > -1} {
#@     set top_layer [concat m[expr [string map {m ""} $top_layer] - 1]]
#@   }
#@   P_create_route_guide [get_attribute $macro boundary] [string map {m ""} $top_layer]
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/create_route_guides.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/remove_ideal_clock_network.tcl

#@ ##############################################################################
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   set_active_scenarios [all_scenarios]
#@   foreach SCENARIO $INTEL_MCMM_SCENARIOS {
#@     current_scenario $SCENARIO
#@     remove_ideal_network [all_fanout -flat -clock_tree]
#@     remove_ideal_network -all
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ } else {
#@   remove_ideal_network [all_fanout -flat -clock_tree]
#@   remove_ideal_network -all
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/remove_ideal_clock_network.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cts.tcl

#@ ##############################################################################
#@ ##############################################################################
#@ # List of procs used by this scripts
#@ # 1. P_msg_info
#@ ##############################################################################
#@ 
#@ ###################################################
#@ # Clock tree synthesis - Only CTS
#@ ###################################################
#@ 
#@ # List out all clocks
#@ if {[info exist INTEL_CTS_NETS] && $INTEL_CTS_NETS != ""} {
#@   set clock_list $INTEL_CTS_NETS
#@ } else {
#@   set clock_list [get_object_name [get_clocks]]
#@ }
#@ 
#@ # Identify clock gating circuitry
#@ identify_clock_gating
#@ 
#@ # Remove existing clock buffers (optional)
#@ #P_msg_info "Removing existing clock buffers";
#@ #remove_clock_tree -clock_trees $clock_list
#@ 
#@ # Split ICG (optional)
#@ #P_msg_info "Splitting ICG"
#@ #split_clock_net -objects $clock_list -gate_sizing -gate_relocation
#@ 
#@ # For each clock, run compile_clock_tree (optional)
#@ # run this or the clock_opt command that follows
#@ #foreach clk $clock_list {
#@ #   P_msg_info "Running CTS for $clk"
#@ #   compile_clock_tree -clock_trees $clk
#@ #}
#@ 
#@ P_msg_info "Running CTS for all clocks"
#@ eval $INTEL_CLK_OPT_CMD
#@ 
#@ # Balance inter-clock delay (optional)
#@ #P_msg_info "Balancing inter-clock insertion delay"
#@ #balance_inter_clock_delay
#@ 
#@ # Update latencies of clock objects after clock tree synthesis
#@ update_clock_latency
#@ 
#@ remove_ideal_network [all_fanout -flat -clock_tree]
#@ 
#@ ###################################################
#@ # Set up for hold-fix on all dominate scenarios
#@ ###################################################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   foreach scenario [all_active_scenarios] {
#@     current_scenario $scenario
#@     set_fix_hold [all_clocks]
#@     P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@     set min_delay_cells ""
#@     foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@       set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@     }
#@     if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@       set_prefer -min $min_delay_cells
#@       set_fix_hold_options -default
#@       set_fix_hold_options -preferred_buffer
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ } else {
#@   set_fix_hold [all_clocks]
#@   P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@   set min_delay_cells ""
#@   foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@     set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@   }
#@   if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@     set_prefer -min $min_delay_cells
#@     set_fix_hold_options -default
#@     set_fix_hold_options -preferred_buffer
#@   }
#@ }
#@ 
#@ 
#@ #Post-CTS hold fix
#@ P_msg_info "Running post CTS hold fix optimization"
#@ eval $INTEL_POST_CTS_OPT_CMD
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cts.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_pg_hookup.tcl

#@ ##############################################################################
#@ # script : add_pg_hookup.tcl
#@ # description : Add PG hookup for cells in the design
#@ ##############################################################################
#@ 
#@ 
#@ # Runset based PG Hookup
#@ ::pwr::create_stdcell_powerhookup -powerhookup_cells_area
#@ # -- Starting source /p/fdk/fdk73/builds/pdk733_r1.7/fill/icv/flexfill/templates/dtDfmFillMetalICV.tcl

#@ # -------------------------------------------------------------------
#@ # --- dtDfmFillMetalICV.tcl
#@ # -------------------------------------------------------------------
#@ #               Proprietary Information of Intel Corp.               
#@ # -------------------------------------------------------------------
#@ #   This listing is supplied under the terms of a license agreement  
#@ #   with Intel Corp. and may not be copied nor disclosed except in   
#@ #   accordance with the terms of the agreement.                      
#@ # -------------------------------------------------------------------
#@ #                     (c) 2012-2014 Intel Corp.                          
#@ # -------------------------------------------------------------------
#@ 
#@ # -------------------------------------------------------------------
#@ # --- Header
#@ # -------------------------------------------------------------------
#@ #
#@ # Note.  This section makes sure dependency packages are loaded into 
#@ # Tcl interpreter.  In case the packages could not be loaded 
#@ # (e.g. cist) the corresponding helper functions are instantiated 
#@ # instead.  
#@ #
#@ # The helper functions are taken from dtDfmFillMetalICV_header.tcl 
#@ # which actually takes them from /p/kits/intel/flows/rdt/parseOpt
#@ # package.  
#@ # -------------------------------------------------------------------
#@ 
#@ if { [info command open_mw_lib ] != "" } {
#@   set ICV_MFILL_FOR_ICC 1
#@ } elseif { [info command pa_top_macro ] != "" } {
#@   set ICV_MFILL_FOR_PARADE 1
#@ }
#@ 
#@ 
#@ if { [info exists ICV_MFILL_FOR_PARADE] } {
#@   if {![info exists env(CADPAX_DIR)]} {
#@         #set env(CADPAX_DIR) $env(CAD_ROOT)/cadpax/9.1_shPseOpt64
#@         set env(CADPAX_DIR) $env(CAD_ROOT)/cadpax/9.2.p2_shPseOpt64
#@   }
#@   lappend auto_path $env(CADPAX_DIR)
#@   package require cist
#@   package require param_mgr
#@ }
#@ 
#@ 
#@ #
#@ # Check if parseOpt package can be loaded and CmdSpec + parseOptions procs get defined 
#@ #
#@ if { [info exists ICV_MFILL_FOR_ICC] } {
#@    if { [catch {package require parseOpt}] } {
#@       # error - package was not found in auto_path - try to locate it in the kit
#@       # try to find the package in a valid kit common path
#@       unset -nocomplain __flexfill_orig_auto_path __flexfill_rdt_common
#@       set __flexfill_orig_auto_path $::auto_path
#@       set __flexfill_rdt_common(dirs) ""
#@       if { [file readable /p/kits/intel/flows/rdt] } {
#@          # use the 'ls' builtin from icc_shell
#@          set __flexfill_rdt_common(dirs) [concat $__flexfill_rdt_common(dirs) [ls -1 -dt /p/kits/intel/flows/rdt/*.*.*]]
#@       }
#@       if { [file readable /p/hdk/cad/kits_common] } {
#@          # use the 'ls' builtin from icc_shell
#@          set __flexfill_rdt_common(dirs) [concat $__flexfill_rdt_common(dirs) [ls -1 -dt /p/hdk/cad/kits_common/*.*.*]]
#@       }
#@ 
#@       # order possible common kits by version (major.sub.minor release)
#@       set __flexfill_rdt_common(sort_dirs) {}
#@       foreach __flexfill_rdt_common(elem) $__flexfill_rdt_common(dirs) {
#@          set __flexfill_rdt_common(version) [split [lindex [file split $__flexfill_rdt_common(elem)] end] {.}]
#@          if { [llength $__flexfill_rdt_common(version)] != 3 } {
#@             # not of form major.sub.minor release
#@             continue
#@          }
#@          if { [catch { lsort -real $__flexfill_rdt_common(version) } __flexfill_rdt_common(catch_result)] != 0 } {
#@             # list or {major sub minor} not all integers - ignore
#@             continue
#@          }
#@          lappend __flexfill_rdt_common(sort_dirs) [concat $__flexfill_rdt_common(version) $__flexfill_rdt_common(elem)]
#@       }
#@       set __flexfill_rdt_common(sort_dirs) [lsort -integer -decreasing -index 0 [lsort -integer -decreasing -index 1 [lsort -integer -decreasing -index 2 $__flexfill_rdt_common(sort_dirs)]]]
#@ 
#@ 
#@       # prepend if RDT_COMMON_PATH is set
#@       if { [info exists ::env(RDT_COMMON_PATH)] } {
#@          set __flexfill_rdt_common(sort_dirs) [linsert $__flexfill_rdt_common(sort_dirs) 0 $::env(RDT_COMMON_PATH)]
#@       }
#@ 
#@       # cycle through until parseOpt package is found
#@       foreach __flexfill_rdt_common(elem) $__flexfill_rdt_common(sort_dirs) {
#@          set __flexfill_rdt_common(elem) [lindex ${__flexfill_rdt_common(elem)} end]
#@          if { [file isdirectory ${__flexfill_rdt_common(elem)}/common/pkgs/parseOpt] &&  [file readable ${__flexfill_rdt_common(elem)}/common/pkgs/parseOpt] } {
#@             lappend ::auto_path  ${__flexfill_rdt_common(elem)}/common/pkgs
#@             break
#@          }
#@       }
#@       unset -nocomplain __flexfill_rdt_common
#@       if { $__flexfill_orig_auto_path ne $::auto_path } {
#@          package require parseOpt
#@       }
#@       set ::auto_path $__flexfill_orig_auto_path
#@       unset -nocomplain __flexfill_orig_auto_path
#@ 
#@       if { [lsearch -exact [package names] parseOpt] == -1 } {
#@          puts "Error: unable to find parseOpt package.  Please append ::auto_path to include it or set ::env(RDT_COMMON_PATH) to a valid path"
#@       }
#@    }
#@ }
#@ 
#@ 
#@ #
#@ # If running icc and CmdSpec + parseOptions don't exist, then create the helper functions
#@ #
#@ if { [info exists ICV_MFILL_FOR_ICC] && ([info commands ::CmdSpec] eq "") && ([info commands ::parseOptions] eq "") } {
#@ 
#@ # -------------------------------------------------------------------
#@ # --- CmdSpec
#@ # -------------------------------------------------------------------
#@ proc CmdSpec { args } {
#@       # pre-parse options to make friendly for ::parseOpt::cmdSpec
#@       # Getting procedure full name
#@       set procName [::parseOpt::varPop args]
#@ 
#@       # will check that all opts arguments only use valid options
#@       set validOpt {"optname" "type" "default" "default_from_pg" "help" "required" "values" "filter" "singel_selection" "radio_grp" "hidden"}
#@ 
#@       array set procInfo [::parseOpt::varPop args]
#@       # goal is to remove / reformat invalid opt names
#@       foreach obj [array names procInfo] {
#@          if { ! [regexp -nocase {\-opt} $obj] } {
#@             # skip other arguments, only want to update opts
#@             continue
#@          }
#@          set updated_procInfo_obj {}
#@          set updated_opts {}
#@ 
#@          # Going over the list of options
#@          foreach option $procInfo($obj) {
#@             set updated_option {}
#@             unset -nocomplain type qualifiers
#@             while { [llength $option] > 0 } {
#@                set option_name_full [::parseOpt::varPop option]
#@                regsub {^\-} $option_name_full {} option_name
#@ 
#@                # Ignore epmty variables
#@                if { [regexp {^[[:space:]]*$} $option_name] } { continue }
#@ 
#@                # Check that this is a valid option
#@                if { [lsearch -exact $validOpt $option_name] < 0 } {
#@                   # this is an unknown option so ignore
#@                   # i.e. this could be:  -proc -qualifiers or other.
#@                   if { $option_name eq "qualifiers" } {
#@                      # record qualifier - swap to one_of_string later
#@                      set qualifiers [lindex [::parseOpt::varPop option] 1]
#@                   }
#@                   continue
#@                }
#@ 
#@                set value [::parseOpt::varPop option]
#@ 
#@                if { $option_name eq "type" } {
#@                   set type $value
#@                } else {
#@                   lappend updated_option $option_name_full $value
#@                }
#@             }
#@             if { [info exists type] && $type eq "string" && [info exists qualifiers] } {
#@                lappend updated_option "-type" "one_of_string" "-values" $qualifiers
#@             } elseif { [info exists type] } {
#@                lappend updated_option "-type" $type
#@             }
#@             lappend updated_procInfo_obj $updated_option
#@          }
#@          set procInfo($obj) $updated_procInfo_obj
#@ 
#@       }
#@ 
#@       # uplevel & run the equivalent ::parseOpt::cmdSpec command
#@       # (parseOpt shouldn't actually need the uplevel)
#@       set ::__flexfill_procName $procName
#@       set ::__flexfill_procInfo [array get procInfo]
#@       uplevel 1 { ::parseOpt::cmdSpec $::__flexfill_procName $::__flexfill_procInfo}
#@ 
#@       unset -nocomplain ::__flexfill_procName ::__flexfill_procInfo
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- parseOptions
#@ # -------------------------------------------------------------------
#@ proc parseOptions { args } {
#@       # allow for embedded call to ::parseOpt::parseOptions
#@       # parseOptions takes: args ?caller?
#@       #    args is a single argument that give the list of arguments
#@       #    ?caller? is optional giving the name of the calling proc
#@       unset -nocomplain ::__flexfill_parseOpts_opts __flexfill_parseOpts_args
#@       unset -nocomplain ::__flexfill_procName
#@       set ::__flexfill_procName "parseOptions"
#@       set proc_level [info level]
#@ 
#@       if { [lsearch -exact [lindex $args 0] "-help"] != -1 } {
#@          set print_help 1
#@       } elseif { [lsearch -exact $args "-help"] != -1 } {
#@          set args [lsearch -exact -all -inline -not $args "-help"]
#@          set print_help 1
#@       }
#@ 
#@       # check for ?caller?
#@       if { [llength $args] > 2 } {
#@          unset -nocomplain ::__flexfill_procName
#@          uplevel 1 {error {wrong # args: should be "parseOptions args ?caller?"}}
#@       } elseif { [llength $args] == 2 } {
#@          set ::__flexfill_procName [namespace which [lindex $args 1]]
#@          if { $::__flexfill_procName eq "" } {
#@             set ::__flexfill_procName [lindex $args 1]
#@          }
#@          set args [lindex $args 0]
#@       } elseif { $proc_level < 2 } {
#@          # not in a proc the caller is considered parseOptions
#@       } else {
#@          set ::__flexfill_procName [namespace which [lindex [info level [expr $proc_level - 1]] 0]]
#@          # make sure that the package was defined.
#@          # May need to strip leading :: from the command/namespace
#@          if { ![info exist parseOpt::procInfo(${::__flexfill_procName}:Init)] } {
#@             set ::__flexfill_procName [regsub {^::} $::__flexfill_procName {}]
#@          }
#@           
#@       }
#@ 
#@       if { [info exists print_help] } {
#@          uplevel 1 {
#@             unset -nocomplain opts
#@             ::parseOpt::parseOpts $::__flexfill_procName ::__flexfill_parseOpts_opts "-help"
#@             unset -nocomplain ::__flexfill_procName :: __flexfill_parseOpts_opts
#@             return -code return 1
#@          }
#@       }
#@ 
#@       set ::__flexfill_parseOpts_args $args
#@       set parseOpt_return [uplevel 1 {unset -nocomplain opts ; ::parseOpt::parseOpts $::__flexfill_procName ::__flexfill_parseOpts_opts $::__flexfill_parseOpts_args }]
#@ 
#@       upvar opts return_opts
#@ 
#@       # remove leading '-' in returned opts
#@       foreach opt_name [array names ::__flexfill_parseOpts_opts] {
#@          set return_opts([regsub -- {^-} $opt_name {}]) $::__flexfill_parseOpts_opts($opt_name)
#@       }
#@       unset -nocomplain ::__flexfill_parseOpts_opts ::__flexfill_parseOpts_args
#@ 
#@       if { ! $parseOpt_return } {
#@          uplevel 1 { error "parseOptions - incorrect procedure arguments for $::__flexfill_procName"}
#@       }
#@       unset -nocomplain ::__flexfill_procName
#@ 
#@       return $parseOpt_return
#@ 
#@ }
#@ # end of 'proc parseOptions { args } '
#@ 
#@ }
#@ # end of 'if { [info exists ICV_MFILL_FOR_ICC] && ([info commands ::CmdSpec] eq "")'
#@ 
#@ # -------------------------------------------------------------------
#@ # --- End Header
#@ # -------------------------------------------------------------------
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- ::dtDfm namespace
#@ # -------------------------------------------------------------------
#@ namespace eval ::dtDfm {
#@ }
#@ 
#@ 
#@ CmdSpec ::dtDfm::read_stm {
#@     -help "::dtDfm::read_stm -from_cell test_fill -to_cell test -layers {metal1 metal2 metal3} ... "
#@     -opts {
#@         {-optname     from_cell
#@             -type     string
#@             -default  ""
#@             -help     "name of STM cell from which contents need to be read"
#@         }
#@         {-optname     from_view
#@             -type     string
#@             -default  "stm"
#@             -help     "view name of from_cell"
#@         }
#@         {-optname     to_cell
#@             -type     string
#@             -default  ""
#@             -help     "name of cell into which contents need to be read"
#@         }
#@         {-optname     to_view
#@             -type     string
#@             -default  "lnf"
#@             -help     "view name of the to_cell"
#@         }
#@         {-optname     layers
#@             -type     string
#@             -default  ""
#@             -help     "list of fill layers"
#@         }
#@         {-optname     path
#@             -type     string
#@             -default  ""
#@             -help     "path to the input STM file"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  "1272"
#@             -help     "Techname of the cell"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "net to be assigned to stubs; by default the stubs are assigned syn* nets"
#@         }
#@         {-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "propery to be assigned to fill metal"
#@         }
#@         {-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "propery to be assigned to stubs"
#@         }
#@         {-optname     rename_nets
#@             -type     string
#@             -default  ""
#@             -help     "nets are renamed as per these specs\n\t\t\t\texample { {drv_floatiss_ floatiss_} {near_floatiss_ floatiss_} {far_floatiss_ flaotiss_} }"
#@         }
#@         {-optname     netname_for_untexted_objects
#@             -type     string
#@             -default  "floatiss_"
#@             -help     "netname for untexted objects"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::read_stm { args } {
#@   global env
#@   parseOptions $args
#@   set layers $opts(layers)
#@   set from_cell $opts(from_cell)
#@   set from_view $opts(from_view)
#@   set to_cell $opts(to_cell)
#@   set to_view $opts(to_view)
#@   set from_path $opts(path)
#@   set to_tech p$opts(techname)
#@   set stubnet $opts(stubnet)
#@   set property $opts(property)
#@   set stub_property $opts(stub_property)
#@   set rename_nets $opts(rename_nets)
#@   set netname_for_untexted_objects $opts(netname_for_untexted_objects)
#@  
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view] != "" } {
#@     cell_mgr_rem_cell [cell_mgr_get_mgr] "{$from_cell,$from_view}"
#@   }
#@ 
#@   set cmd "Read -cellname $from_cell -viewname $from_view -nowindow 1"
#@   if { $from_path != "" } {
#@     if {[file exists $from_path] != 0} {
#@       append cmd " -path $from_path"
#@     } else {
#@       ::dtDfm::fill_metal_icv_print_error "Cound not find file $from_path"
#@       return "0"
#@     }
#@   }
#@ 
#@   set openret [eval $cmd]
#@   if { $openret == 0 } {
#@     puts "Fail to open $from_cell, $from_view."
#@     return "0"
#@   }
#@ 
#@   set src [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view]
#@   if { "" == $src } {
#@     puts "Fail to load in ISS result stream file."
#@     return "0"
#@   }
#@ 
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $to_cell $to_view] == "" } {
#@     puts "did not find $to_cell,$to_view"
#@     set cell_boundary [cell_get_boundary "{$from_cell,$from_view}"]
#@     if { [cell_create $to_cell $to_tech $cell_boundary $to_view] == "" } {
#@       puts "failed to create $to_cell,$to_view"
#@       return "0"
#@     }
#@     puts "created $to_cell,$to_view"
#@     Display -cellname $to_cell -viewname $to_view
#@   }
#@ 
#@ 
#@   set objIdList [::dtDfm::copyFromSTMToTop $from_cell                                            $from_view                                            $to_cell                                            $to_view                                            $layers                                            $stubnet                                            $property                                            $stub_property                                            $netname_for_untexted_objects                                            $rename_nets]
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view ] != "" } {
#@     cell_mgr_rem_cell [cell_mgr_get_mgr] "{$from_cell,$from_view}"
#@   }
#@ 
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_run_streamlined ###########################################
#@ proc ::dtDfm::runFillFlow { cellname                             flowname                             stminputdir                             stmoutputdir                             uininputdir                             icv_options                             use_lnf_input                             use_pds 			    launch_script                             nbpool                             nbclass                             nbslot                             perlFlowLogPath                             {background 1}                             {explicit_parallel 0} } {
#@   global env
#@   set fillFlowPlPath ""
#@   set flowfile "fillflow.pl"
#@   if { $explicit_parallel >= 1 } {
#@     set flowfile "fillflow_snap.pl"
#@   }
#@ 
#@ 
#@   if {[info exists  env(MY_DFM_DIR)] && [file exists "$env(MY_DFM_DIR)/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(MY_DFM_DIR)/$flowfile"
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists "$env(PDS_ISS_OVRRD)/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(PDS_ISS_OVRRD)/flexfill/templates/$flowfile"
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists "$env(PDS_ISS_OVRRD)/DTS/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(PDS_ISS_OVRRD)/DTS/flexfill/templates/$flowfile"
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists "$env(CDS_ISS_OVRRD)/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(CDS_ISS_OVRRD)/flexfill/templates/$flowfile"
#@   } 
#@ 
#@   #
#@   # Runset Directory
#@   #
#@ 
#@   set runsetDir {}
#@ 
#@   if {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/flexfill] != 0} {
#@     set runsetDir $env(PDS_ISS_OVRRD)
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/DTS/flexfill] != 0} {
#@     set runsetDir $env(PDS_ISS_OVRRD)/DTS
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/flexfill] != 0} {
#@     set runsetDir $env(CDS_ISS_OVRRD)
#@   }
#@ 
#@ 
#@   #
#@   # Return pid = 0 to indicate error
#@   #
#@   if {$runsetDir == {}} {
#@     ::dtDfm::fill_metal_icv_print_error "ISS runset directory could not be set. Please check your environment settings."
#@     return 0
#@   }
#@ 
#@ 
#@   #
#@   # PXL Directory
#@   #
#@ 
#@   set pxlDir {}
#@   if {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/PXL] != 0} {
#@     set pxlDir $env(PDS_ISS_OVRRD)/PXL
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/DTS/PXL] != 0} {
#@     set pxlDir $env(PDS_ISS_OVRRD)/DTS/PXL
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/PXL] != 0} {
#@     set pxlDir $env(CDS_ISS_OVRRD)/PXL
#@   }
#@ 
#@   #
#@   # Return pid = 0 to indicate error
#@   #
#@   if {$pxlDir == {}} {
#@     ::dtDfm::fill_metal_icv_print_error "PXL directory could not be set. Please check your environment settings."
#@     return 0
#@   }
#@ 
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@   set noclean ""
#@   if { $save_workdir } {
#@     set noclean "--noclean"
#@   }
#@ 
#@   set cmd ""
#@   set runmode "local"
#@   if { $nbpool != "" } {
#@     set runmode "netbatch"
#@   }
#@ 
#@   if { $fillFlowPlPath != "" } {
#@        if { $explicit_parallel >= 1 } {
#@           set opt_nbpool  ""
#@           set opt_nbclass ""
#@           set opt_nbslot  ""
#@           if { $nbpool != "" } {
#@             regsub -all "\'" $nbclass "\"" nbclass
#@             set opt_nbpool  "--nb_pool $nbpool"
#@             set opt_nbclass "--nb_class $nbclass"
#@             set opt_nbslot  "--nb_slot $nbslot"
#@           }
#@           set cmd "$fillFlowPlPath  --layout $cellname --layout_path ${stminputdir} --work_uin $uininputdir --max_jobs $explicit_parallel --output_path ${stmoutputdir} $opt_nbpool $opt_nbclass $opt_nbslot $noclean >& $perlFlowLogPath "
#@        } else {
#@           set cmd "$fillFlowPlPath $cellname                                 $flowname                                 ${stminputdir}                                 ${stmoutputdir}                                 $uininputdir                                 $runsetDir                                 $pxlDir                                 \"$icv_options\"                                 $use_lnf_input                                 $use_pds                                 $runmode                                 \"$launch_script\"                                 $nbpool                                 $nbclass                                 $nbslot >& $perlFlowLogPath " 
#@         }
#@ 
#@         
#@       if { $background == 1 } {
#@           set cmd "$cmd &"
#@       }
#@       
#@       ::dtDfm::fill_metal_icv_print_info "$cmd"
#@       
#@       set pid [eval exec "$cmd"]
#@       return $pid
#@      
#@  } else {
#@     ::dtDfm::fill_metal_icv_print_error "flexfill runset not found -- Please get help from DFM owner"
#@     return 0
#@  }
#@ }
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv_run_streamlined {
#@     -help "::dtDfm::fill_metal_icv -layer {metal1 metal2 metal3 ...} "
#@     -opts {
#@         {-optname     layers
#@             -type     string
#@             -default  ""
#@             -help     "list of fill layers"
#@         }
#@         {-optname     layer_opts
#@             -type     string
#@             -default  ""
#@             -help     "list of opts for each layer"
#@         }
#@         {-optname     prune_cells_lists
#@             -type     string
#@             -default  ""
#@             -help     "list of cells to be pruned each layer"
#@         }
#@         {-optname     tiling_opts
#@             -type     string
#@             -default  ""
#@             -help     "list of tiling opts for each layer"
#@         }
#@    }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_run_streamlined {args} {
#@   global env
#@   parseOptions $args
#@   set layers $opts(layers)
#@   set layer_opts $opts(layer_opts)
#@   set prune_cells_lists $opts(prune_cells_lists)
#@   set tiling_opts $opts(tiling_opts)
#@ 
#@   if { $layers == "" } {
#@     puts "::dtDfm::fill_metal_icv_run_streamlined: empty layers list"
#@     return 0
#@   }
#@ 
#@   set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@   set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@   set fillinmw [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@   set fillincelview [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@   set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@   set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@ 
#@   set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@   set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@   set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@   set techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@   set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@   set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@   set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@   set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@   set explicit_parallel [::dtDfm::keylget ::dtDfm::fill_metal_icv_data EXPLICIT_PARALLEL]
#@   set text_extensions [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TEXT_EXTENSIONS]
#@   set do_final_texting [::dtDfm::keylget ::dtDfm::fill_metal_icv_data DO_FINAL_TEXTING]
#@   set skip_dummy_250 [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SKIP_DUMMY_250]
#@   set no_tracks_file [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NO_TRACKS_FILE]
#@   set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@   set launch_script [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@   if { $explicit_parallel >= 1 } {
#@     set use_pds false
#@   }
#@ 
#@   set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@   set flowname fill_layers
#@   set uinfilename "${cellname}_${flowname}.uin"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   set writeuin_success [::dtDfm::fill_metal_icv_streamlined_writeuin $cellname                                                 $layers                                                 $techname                                                 $uinfilepath                                                 $fillinmw                                                 $fillincelview                                                 $mwoutpath                                                 $mwlibrary                                                 $icvtopworkarea                                                 $write_stm_output                                                 $layer_opts                                                 $tiling_opts                                                 $prune_cells_lists                                                 $text_extensions                                                 $do_final_texting                                                 $skip_dummy_250                                                 $no_tracks_file ]
#@ 
#@   if { $writeuin_success == 0 } {
#@     puts "writeuin failed"
#@     return 1
#@   }
#@   
#@     if { $only_write_uin } {
#@ 	#puts "Writing uin file ${cellname}_fill_layers.uin."
#@ 	return ""
#@     }
#@ 
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@ 
#@   if { [file exists $icvworkarea] != 0 } {
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   foreach  fillLayer $layers {
#@     if { $fillLayer == "poly" } {
#@       set layer_uin_extension "_polyfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_polyfill.rs
#@     } elseif { $fillLayer == "polycon" } {
#@       set layer_uin_extension "_polyconfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_polyconfill.rs
#@     } elseif { $fillLayer == "diffusion" } {
#@       set layer_uin_extension "_diffusionfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_diffusionfill.rs
#@     } elseif { $fillLayer == "libdfmg" } {
#@       set layer_uin_extension "_libdfmgfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_libdfmgfill.rs
#@     } elseif { $fillLayer == "diffcon" } {
#@       set layer_uin_extension "_diffconfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_diffconfill.rs
#@     } elseif { $fillLayer == "tv0" } {
#@       set layer_uin_extension "_tv0fill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_tv0fill.rs
#@     } elseif { $fillLayer == "viat" } {
#@       set layer_uin_extension "_vcgfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_vfillvcg.rs
#@     } elseif { $fillLayer == "viag" } {
#@       set layer_uin_extension "_vctfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_vfillvct.rs
#@     } else {
#@       set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@       if { $result != 0 } {
#@         set layer_uin_extension "_fill${level}"
#@         set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@         set layer_uinfilepath "$uindir/$layer_uinfilename"
#@         file copy -force $layer_uinfilepath ./flexuin_fill${level}.rs
#@       } else {
#@         set result [regexp {via(\d+)} $fillLayer fullstring level]
#@         if { $result != 0 } {
#@           set layer_uin_extension "_vfill${level}"
#@           set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@           set layer_uinfilepath "$uindir/$layer_uinfilename"
#@           file copy -force $layer_uinfilepath ./flexuin_vfill${level}.rs
#@         } else {
#@           set result [regexp {tm(\d+)} $fillLayer fullstring level]
#@           if { $result != 0 } {
#@             set layer_uin_extension "_filltm1"
#@             set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@             set layer_uinfilepath "$uindir/$layer_uinfilename"
#@             file copy -force $layer_uinfilepath ./flexuin_filltm1.rs
#@           } else {
#@             set result [regexp {rdl} $fillLayer fullstring level]
#@             if { $result != 0 } {
#@               set layer_uin_extension "_fillrdl"
#@               set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@               set layer_uinfilepath "$uindir/$layer_uinfilename"
#@               file copy -force $layer_uinfilepath ./flexuin_fillrdl.rs
#@             }
#@           }
#@         }
#@       }
#@     }
#@   }
#@   file copy -force $uinfilepath ./flexuin_fill_layers.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@     cd $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set background 1
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath                              $background                              $explicit_parallel ]
#@ 
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   set interrupted 0
#@   if { $use_pds } {
#@     ::dtDfm::wait_on_pds_job $cellname                              "flexfill"
#@   } else {
#@     set remainingProcesses  [list $pid]   
#@     set pidsover [getTerminatedProcess $remainingProcesses]
#@     if { $pidsover == "" } {
#@ 	   set interrupted 1
#@     }
#@     if { $interrupted == 1 } {
#@       puts "job interrupted"
#@       set cmd "kill SIGKILL {$remainingProcesses}"
#@       puts "$cmd"
#@       catch { eval $cmd }
#@     }
#@   }
#@ 
#@   cd $old_dir
#@ 
#@   if { $interrupted == 1 } {
#@     puts "skipping ::dtDfm::fill_metal_icv_readresults"
#@     return 0
#@   }
#@ 
#@ 
#@   set jobInfo ""
#@   set container_extension "_fill"
#@ 
#@   # ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $layers
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@ 
#@   # ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   if { [::dtDfm::fill_metal_icv_readresults $jobInfo $save_workdir ] == 0 } {
#@           puts "mfill failed for $layers"
#@   }
#@ 
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_streamlined_writeuin { cellname                                                     layers                                                     techname                                                     uinfilepath                                                     fillinmw                                                     fillincelview                                                     mwoutpath                                                     mwlibrary                                                     icvtopworkarea                                                     write_stm_output                                                     layer_opts                                                     tiling_opts                                                     prune_cells_lists                                                     text_extensions 													do_final_texting                                                     skip_dummy_250                                                     no_tracks_file } {
#@   set f [open "$uinfilepath" w]
#@ 
#@   set write_milkyway_output $fillinmw
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fillincelview                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set dfm_via_fast_density [::dtDfm::keylget ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY]
#@   if {$dfm_via_fast_density} {
#@       puts $f "#define DFM_VIA_FAST_DENSITY"
#@   } else {
#@       puts $f "//#define DFM_VIA_FAST_DENSITY"
#@   }
#@ 
#@   set i 0
#@   foreach  fillLayer $layers {
#@     set my_opts [lindex $layer_opts $i]
#@     set my_tiling_opts [lindex $tiling_opts $i]
#@     if { $fillLayer == "poly" } {
#@       puts $f "#define DFM_POLYFILL"
#@     } elseif { $fillLayer == "polycon" } {
#@       puts $f "#define DFM_POLYCONFILL"
#@     } elseif { $fillLayer == "diffusion" } {
#@       puts $f "#define DFM_DIFFUSIONFILL"
#@     } elseif { $fillLayer == "diffcon" } {
#@       puts $f "#define DFM_DIFFCONFILL"
#@     } elseif { $fillLayer == "tv0" } {
#@       puts $f "#define DFM_TV0FILL"
#@     } elseif { $fillLayer == "viat" } {
#@       puts $f "#define DFM_VCTFILL"
#@     } elseif { $fillLayer == "viag" } {
#@       puts $f "#define DFM_VCGFILL"
#@     } else {
#@       set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@       if { $result != 0 } {
#@         puts $f "#define DFM_M${level}FILL $my_opts"
#@         if { $my_tiling_opts != "" } {
#@           puts $f "#define DFM_M${level}FILL_TILE $my_tiling_opts"
#@         }
#@       } else {
#@         set result [regexp {via(\d+)} $fillLayer fullstring level]
#@         if { $result != 0 } {
#@           puts $f "#define DFM_V${level}FILL $my_opts"
#@         } else {
#@           set result [regexp {tm(\d+)} $fillLayer fullstring level]
#@           if { $result != 0 } {
#@            puts $f "#define DFM_TM1FILL $my_opts"
#@           } else {
#@             ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@             return 0
#@           }
#@         }
#@       }
#@     }
#@     incr i
#@   }
#@ 
#@   set i 0
#@   foreach  fillLayer $layers {
#@     set prune_cells_list [lindex $prune_cells_lists $i]
#@     set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@     if { $result != 0 } {
#@       set cell_list_option_name "m${level}_prune_cells_list";
#@       ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $prune_cells_list;
#@     }
#@     incr i
#@   }
#@ 
#@   puts $f "text_extensions = $text_extensions;";
#@   puts $f "do_final_texting = $do_final_texting;";
#@   if { $skip_dummy_250 } {
#@     puts $f "#define SKIP_DUMMY_250";
#@   }
#@   if { $no_tracks_file } {
#@     puts $f "#define NO_TRACKS_FILE";
#@   }
#@   puts $f "process_name = \"$techname\";"
#@ 
#@   close $f
#@   return 1
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_init ######################################################
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv_init {
#@     -help "::dtDfm::fill_metal_icv -cellname abc"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell on which fill is to be performed"
#@         }
#@         {-optname     outputcellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell where fill results should be placed"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  "lnf"
#@             -help     "Viewname of the cell"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  "1272"
#@             -help     "Techname of the cell"
#@         }
#@         {-optname  skip_output
#@          -type     bool
#@          -default  false
#@          -help     "Skip STM output"
#@         }
#@         {-optname  use_lnf_input
#@          -type     bool
#@          -default  false
#@          -help     "Uses LNF from disk as input format for the flow"
#@         }
#@         {-optname  save_workdir
#@          -type     bool
#@          -default  false
#@          -help     "Saves ICV work directory for debugging purpose"
#@         }
#@         {-optname  only_write_uin
#@          -type     bool
#@          -default  false
#@          -help     "When this option is used fill_metal_icv only writes out UIN file"
#@         }
#@         {-optname  streamlined
#@          -type     bool
#@          -default  false
#@          -help     "Do necessary setup to run streamlined metal/via fill\n\t\t\t\tAutomatically turns ON only_write_uin"
#@         }
#@         {-optname  text_extensions
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use real net names for the extensions on the wires of top level nets; only used gy streamlined mode at present"
#@         }
#@         {-optname  do_final_texting
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "do_final_texting for streamlined flow"
#@         }
#@         {-optname  skip_dummy_250
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "skips writing dummy-fill on data-type 250"
#@         }
#@         {-optname  no_tracks_file
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "skips writing tracks files"
#@         }
#@         {-optname  explicit_parallel
#@          -type     int
#@          -default  0
#@          -help     "Run streamlined explicitly parallel (multiple ICV jobs) with specified max number of LOCAL jobs"
#@         }
#@         {-optname  launch_script
#@          -type     string
#@          -default  "null"
#@          -help     "Specify a launch script for particular ICV version"
#@         }
#@         {-optname  nbpool
#@          -type     string
#@          -default  ""
#@          -help     "Enable Netbatch on -explict_parallel max number of Netbatch jobs using pool specified (ie: pdx_dts)"
#@         }
#@         {-optname  nbslot
#@          -type     string
#@          -default  "null"
#@          -help     "Submit netbatch jobs to this specified queue slot (ie: cds)"
#@         }
#@         {-optname  nbclass
#@          -type     string
#@          -default  "SLES10_EM64T_16G"
#@          -help     "Request this type of netbatch machine (default: SLES10_EM64T_16G)"
#@         }
#@         {-optname  uindir
#@          -type     string
#@          -default  "default"
#@          -help     "Location to save UIN files, default location $env(WORK_AREA_ROOT_DIR)/pds/uins"
#@         }
#@         {-optname  stream
#@          -type     string
#@          -default  ""
#@          -help     "Path to an existing stream file, skips generating a new stream file"
#@         }
#@         {-optname  fillinmw
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW"
#@         }
#@         {-optname  fillincelview
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW CEL view"
#@         }
#@         {-optname  mwoutpath
#@          -type     string
#@          -default  ""
#@          -help     "ICC specific option: directory in which MW library resides"
#@         }
#@         {-optname  mwlibrary
#@          -type     string
#@          -default  ""
#@          -help     "ICC specific option: MW library name"
#@         }
#@         {-optname     layer_map_for_mw
#@             -type     string
#@             -default  ""
#@             -help     "ICC specific option: layer map for MW"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "Genesys specific option: net name to be used for stubs\n\t\t\t\tOtherwise stubs are created on syn* nets"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  "Dmi:none:Dmi"
#@             -help     "Genesys specific option: fill metal property info"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  "Stub:Stub:test"
#@             -help     "Genesys specific option: stub property info"
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of options to be used with ICV"
#@         }
#@         {-optname     rename_nets
#@             -type     string
#@             -default  ""
#@             -help     "List of nets to be renamed { {from1 to1} {from2 to2} ... }"
#@         }
#@         {-optname     netname_for_untexted_objects
#@             -type     string
#@             -default  "floatiss_"
#@             -help     "netname for untexted objects"
#@         }
#@         {-optname  skip_result_stm_output
#@          -type     bool
#@          -default  false
#@          -help     "Skip writing final/result layout in GDSII/STM (default output format; only useful when in MW mode)"
#@         }
#@         {-optname  use_pds
#@          -type     bool
#@          -default  false
#@          -help     "Use PDS to launch ICV job; required to support netbatch in non -explict_parallel mode"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_init {args} {
#@   global env
#@   parseOptions $args
#@   set cellname $opts(cellname)
#@ 
#@   set outputcellname $opts(outputcellname)
#@   if {$outputcellname == ""} {
#@     set outputcellname $cellname
#@   }
#@ 
#@   set layer_map_for_mw $opts(layer_map_for_mw)
#@   set fillinmw $opts(fillinmw)
#@   set fillincelview $opts(fillincelview)
#@   set mwoutpath $opts(mwoutpath)
#@   set mwlibrary $opts(mwlibrary)
#@   set skip_output $opts(skip_output)
#@   set use_lnf_input $opts(use_lnf_input)
#@   if { $use_lnf_input } {
#@     set skip_output true
#@   } 
#@   set use_pds $opts(use_pds)
#@   set nbpool  $opts(nbpool)
#@   set nbclass $opts(nbclass)
#@   set nbslot  $opts(nbslot)
#@   set launch_script $opts(launch_script)
#@   set save_workdir $opts(save_workdir)
#@   set uindir $opts(uindir)
#@   set only_write_uin $opts(only_write_uin)
#@   set streamlined $opts(streamlined)
#@   set text_extensions $opts(text_extensions)
#@   set do_final_texting $opts(do_final_texting)
#@   set skip_dummy_250 $opts(skip_dummy_250)
#@   set no_tracks_file $opts(no_tracks_file)
#@   set explicit_parallel $opts(explicit_parallel)
#@   set viewname $opts(viewname)
#@   set techname $opts(techname)
#@   set stubnet $opts(stubnet)
#@   set property $opts(property)
#@   set stub_property $opts(stub_property)
#@   set icv_options $opts(icv_options)
#@   set rename_nets $opts(rename_nets)
#@   set netname_for_untexted_objects $opts(netname_for_untexted_objects)
#@   set stream $opts(stream)
#@   set write_stm_output true
#@   if { $opts(skip_result_stm_output) } {
#@     set write_stm_output false
#@   }
#@ 
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   if { $uindir == "default" } {
#@     set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     if { ![file exists $uindir] } {
#@       puts "$uindir does not exist"
#@       return 0
#@     }
#@     if { [file type $uindir] != "directory" } {
#@       puts "$uindir is not a directory"
#@       return 0
#@     }
#@   }
#@ 
#@   set pid [pid]
#@ 
#@   set icvtopworkarea $env(PDSWORKROOT)/$env(USER).${cellname}.${pid}.iss
#@ 
#@   set ::dtDfm::fill_metal_icv_data ""
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA $icvtopworkarea
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data SAVEWORKDIR    $save_workdir
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data INITIALIZED 1
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLINMW $fillinmw
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLINCELVIEW $fillincelview
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data MWOUTPATH $mwoutpath
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data MWLIBRARY $mwlibrary
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data UINDIR $uindir
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data CELLNAME $cellname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data VIEWNAME $viewname
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TECHNAME $techname
#@   set techname [::dtDfm::fill_metal_icv_get_tech $techname] 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TECHNAME $techname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STUBNET $stubnet
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PROPERTY $property
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME $outputcellname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY false
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data RENAME_NETS $rename_nets
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT $write_stm_output
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data USE_LNF_INPUT $use_lnf_input
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data USE_PDS $use_pds
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBPOOL  $nbpool
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBCLASS $nbclass
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBSLOT  $nbslot
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT  $launch_script
#@ 
#@   
#@ 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STREAMLINED $streamlined
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TEXT_EXTENSIONS $text_extensions
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DO_FINAL_TEXTING $do_final_texting
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data SKIP_DUMMY_250 $skip_dummy_250
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NO_TRACKS_FILE $no_tracks_file
#@   # ED
#@   #if { $streamlined } {
#@   #  set only_write_uin true
#@   #}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ONLYWRITEUIN $only_write_uin
#@ 
#@   if { $streamlined } {
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data EXPLICIT_PARALLEL $explicit_parallel
#@   } elseif { $explicit_parallel >= 1 } {
#@     ::dtDfm::fill_metal_icv_print_error "Explicit_Parallel mode only valid in Streamlined mode"
#@   }
#@ 
#@   if { $streamlined && $explicit_parallel == 0 && $icv_options == "" } {
#@     set icv_options "-ndg -turbo"
#@   } 
#@ 
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@ 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVOPTIONS $icv_options
#@   
#@   # set ::dtDfm::fill_metal_icv_icvtopworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${pid}.iss"
#@   # set ::dtDfm::fill_metal_icv_jobs {}
#@   # set ::dtDfm::fill_metal_icv_correctly 1
#@ 
#@   if { [file exists $icvtopworkarea ] != 0 } {
#@     file delete -force $icvtopworkarea
#@   }
#@   # puts "creating $icvtopworkarea"
#@   file mkdir $icvtopworkarea
#@   file mkdir $icvtopworkarea/input
#@   # file mkdir $icvtopworkarea/output
#@ 
#@   if { $use_pds } {
#@     set stminputdir $env(PDSSTM)
#@   } else {
#@     set stminputdir $icvtopworkarea/input
#@   }
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STMINPUTDIR $stminputdir
#@ 
#@   if { $stream != "" } {
#@     set skip_output 1
#@     if { ([file exists $stream ] != 0) } {
#@       file copy -force $stream $stminputdir
#@       puts "copying file from $stream to $stminputdir"
#@     }
#@   }
#@ 
#@   if { !$skip_output } {
#@     set old_dir [pwd]
#@     cd $icvtopworkarea/input
#@     # set saveret [::dtDfm::fill_metal_icv_saveas $cellname stm $icvtopworkarea/input/${cellname}.stm $layer_map_for_mw]
#@     set saveret [::dtDfm::fill_metal_icv_saveas $cellname stm $stminputdir/${cellname}.stm $layer_map_for_mw]
#@     if { $saveret == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Save Failed"
#@       ::dtDfm::keylset ::dtDfm::fill_metal_icv_data INITIALIZED 0
#@       # set ::dtDfm::fill_metal_icv_correctly 0
#@     }
#@     cd $old_dir
#@   }
#@ 
#@ }
#@ 
#@ set ::dtDfm::region_grids_legal_option_names {region grid_pattern                                               offset                                               period                                               relative_offset                                               break_pattern                                               break_offset                                               break_period                                               break_min_length \    
#@                                               break_pattern_offset_increment                                               far_fill_ete_distance                                               far_fill_sts_distance                                               fill_non_preferred                                               transition_pattern                                               transition_offset                                               transition_period                                               far_fill_ete_distance                                               far_fill_sts_distance                                               is_grating_hole_violation_risk_pattern }
#@ 
#@ 
#@ #
#@ # NOTE: when changing metal or via fill options, keep the 
#@ # the documentation for customers in sync on this Wiki:
#@ #
#@ # https://intelpedia.intel.com/PD-DFM/internal/antares_sg
#@ #
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv {
#@     -help "::dtDfm::fill_metal_icv -cellname abc -viewname -lnf -techname 1272.0 -layer metal2 -offset 0.012 -pattern VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.038C"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "\tName of the cell on which fill is to be performed\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     outputcellname
#@             -type     string
#@             -default  ""
#@             -help     "\tName of the cell where fill is to be placed"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  ""
#@             -help     "Viewname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  ""
#@             -help     "Techname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "Fill metal property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "Stub property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "Genesys specific feature: net name to be used for stubs\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Metal layer to fill - i.e. metal2"
#@         }
#@         {-optname  do_ungridded_fill
#@          -type     bool
#@          -default  false
#@          -help     "Do ungridded fill"
#@         }
#@         {-optname  hybrid
#@          -type     bool
#@          -default  false
#@          -help     "Do hybrid fill"
#@         }
#@         {-optname     pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Pattern has the format triplet1:triplet2:.....\n\t\t\t\twhere triplet has the format netname:width:spacing\n\t\t\t\twidth and spacing are specified in microns\n\t\t\t\twidth may also have a B or C suffix\n\t\t\t\tPattern must be complete including power lines\n\t\t\t\tIn absence of pattern and region_grids ungridded (KLM style) fill is performed"
#@         }
#@ 	{-optname     offset
#@             -type     float
#@             -default  0.0
#@             -help     "Fill pattern offset wrt left/bottom boundary of the cell"
#@         }
#@         {-optname     break_pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Break pattern for the fill wires\n\t\t\t\tWorks with both gridded as well as ungridded fill modes\n\t\t\t\tFormat: pair1:pair2:.....\n\t\t\t\twhere pair has the format wire_length:ete_spacing\n\t\t\t\twire_length and ete_spacing are specified in microns\n\t\t\t\tIn absence of break_pattern wires are broken every fill_length"
#@         }
#@ 	{-optname     break_offset
#@             -type     float
#@             -default  0.0
#@             -help     "Break pattern offset"
#@         }
#@ 	{-optname     break_min_length
#@             -type     float
#@             -default  0.0
#@             -help     "Break pattern min length of wires to apply breaks to"
#@         }
#@         {-optname     transition_pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Transition pattern has the format spacing:width\n\t\t\t\tspacing is spacing from offset or from previous transition\n\t\t\t\twidth is the width of the transition boundary"
#@         }
#@ 	{-optname     transition_offset
#@             -type     float
#@             -default  0.0
#@             -help     "Transition pattern offset"
#@         }
#@ 	{-optname     transition_period
#@             -type     float
#@             -default  0.0
#@             -help     "Transition pattern period"
#@         }
#@         {-optname     grid_patterns
#@          -type        string
#@          -default     ""
#@          -help        "Grid definitions to be used with region grids\n\t\t\t\t{ {grid_name1 grid_pattern1}\n\t\t\t\t{grid_name2 grid_pattern2} ... }"
#@         }
#@         {-optname     break_patterns
#@          -type        string
#@          -default     ""
#@          -help        "Break pattern definitions to be used with region grids\n\t\t\t\t{ {break_pattern_name1 break_pattern1}\n\t\t\t\t{break_pattern_name2 break_pattern2} ... }"
#@         }
#@         {-optname     transition_patterns
#@          -type        string
#@          -default     ""
#@          -help        "transition pattern definitions to be used with region grids\n\t\t\t\t{ {transition_pattern_name1 transition_pattern1}\n\t\t\t\t{transition_pattern_name2 transition_pattern2} ... }"
#@         }
#@         {-optname     region_grids
#@          -type        string
#@          -default     ""
#@          -help        "region grids\n\t\t\t\tfollowing is the old format\n\t\t\t\t{ {polygons_set1 grid_name1 offset1 relative_offset <break_pattern1 break_offset1>}\n\t\t\t\t  {polygons_set2 grid_name2 offset2 relative_offset <break_pattern2 break_offset2>}  ... }\n\t\t\t\tpolygons_set can be CELLBOUNDARY or V3PITCHID or { ply1 ply2 ply3....}\n\t\t\t\teach ply has the format {x1,y1 x2,y2 x3,y3 x4,y4 ....}\n\t\t\t\ta two point polygon is assumed to be a rectangle {xl,yl xh,yh}\n\t\t\t\trelative_offset take boolean values true/false values\n\t\t\t\t\n\t\t\t\tfollowing is the new format\n\t\t\t\t{ option_value_pairs { {option1 value1} {option2 value2} ... }\n\t\t\t\t\t\t{ {option1 value1} {option2 value2} ... } }\n\t\t\t\tallowed options include $::dtDfm::region_grids_legal_option_names\n\t\t\t\t"
#@         }
#@ 	{-optname     fill_length
#@             -type     float
#@             -default  10000.0
#@             -help     "Max fill length: fill wires will be broken every fill_length distance"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@        {-optname     exclCells
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\twires in these cells are not to be extended"
#@        }
#@ 
#@        {-optname  prune_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tlayout from the interior of these cells will be pruned for performance gains"
#@        }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@ 
#@         {-optname  half_dr_end_to_end 
#@          -type     float
#@          -default  -1.0
#@          -help     "EOL spacing from the cell boundary"
#@         }
#@ 
#@         {-optname  output_resolution
#@          -type     float
#@          -default  0.0
#@          -help     "output resolution"
#@         }
#@ 
#@         {-optname     ply
#@          -type     string
#@          -default  ""
#@          -help     "Polygon region based fill, i.e {0.0,0.04 0.0,182.36 207.32,182.36 ...}"
#@         }
#@ 
#@         {-optname     plys
#@          -type     string
#@          -default  ""
#@          -help     "Multiple polygon region based fill, i.e { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  write_sid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write S wires as B wires with overlapping SID layer on it"
#@         }
#@         {-optname  write_cid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write C wires as B wires with overlapping CID layer on it"
#@         }
#@         {-optname  write_bid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write overlapping BID layer on B wires"
#@         }
#@         {-optname  onestep
#@          -type     bool
#@          -default  false
#@          -help     "Run mfill in one step (also calls _init and _end procedures)"
#@         }
#@         {-optname  near_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Near fill density target"
#@         }
#@         {-optname  far_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill density target"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  15.0
#@          -help     "Density window size"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@         {-optname  metal_density_before_via
#@          -type     bool
#@          -default  false
#@          -help     "Do target metal density before via"
#@         }
#@ 
#@         {-optname  use_fill_markers
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use fill markers, applicable only for M0/M1 fill"
#@         }
#@         {-optname  strict_bc_identification
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "turns on the use of the B/C color of existing wires for matching of the grid pattern\n\t\t\t\tthe normal behavior of fill is to ignore the color of wires in the layout."
#@         }
#@         {-optname  consider_off_grid
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Fill an area even if the layout in that area is off-grid"
#@         }
#@         {-optname  dfmg_extensions
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Add dfmg extensions to improve via landing/coverage"
#@         }
#@         {-optname  verbatim
#@          -type     string
#@          -default  ""
#@          -help     "Adds PXL code to UIN file verbatim"
#@         }
#@         {-optname  post_fill_operation
#@          -type     string
#@          -default  ""
#@          -help     "Post fill operation (eg. fill4cmp)"
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of ICV options specific to this layer when run in -explicit_parallel mode (default: -dp1 -turbo-lite)"
#@         }
#@        {-optname     power_nets
#@         -type     string
#@         -default  ""
#@         -help     "Power net names; wires of the specified power nets will be merged in DR clean manner whenever possible"
#@        }
#@         {-optname  fill_container_name
#@          -type     string
#@          -default  ""
#@          -help     "Fill container name; fill from this container is removed in the ECO mode"
#@         }
#@         {-optname  eco_region
#@          -type     string
#@          -default  ""
#@          -help     "ECO is performed in these polygon regions { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  tiling_options
#@          -type     string
#@          -default  ""
#@          -help     "X=microns Y=microns OVERBITE=mirons UNDERBITE=mirons LAYOUT_X=microns LAYOUT_Y=microns\n\t\t\t\texample: X=16 Y=10.5 OVERBITE=1 UNDERBITE=1 LAYOUT_X=16 LAYOUT_Y=42\n\t\t\t\tX and Y are the tile dimensions, LAYOUT_X and LAYOUT_Y are layout dimensions\n\t\t\t\tOVERBITE is the distance beyound the tile boundary the layout is looked up during fill for DR checks while filling individual tile\n\t\t\t\tUNDERBITE is the distance inside the tile boundary from which layout is removed and refilled during tile stitching."
#@         }
#@         {-optname  far_fill_ete_distance
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill region end-to-end distance from existing metal"
#@         }
#@         {-optname  far_fill_sts_distance
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill region side-to-side distance from existing metal"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set cellname $opts(cellname)
#@     set outputcellname $opts(outputcellname)
#@     set property $opts(property)
#@     set stub_property $opts(stub_property)
#@     set temp_techname $opts(techname)
#@ 
#@     set pattern $opts(pattern)
#@     set offset $opts(offset)
#@ 
#@     set break_pattern $opts(break_pattern)
#@     set break_offset $opts(break_offset)
#@ 
#@     set transition_pattern $opts(transition_pattern)
#@     set transition_offset  $opts(transition_offset)
#@     set transition_period  $opts(transition_period)
#@ 
#@     set grid_patterns $opts(grid_patterns)
#@     set break_patterns $opts(break_patterns)
#@     set transition_patterns $opts(transition_patterns)
#@     set region_grids  $opts(region_grids)
#@ 
#@     set far_fill_ete_distance $opts(far_fill_ete_distance)
#@     set far_fill_sts_distance $opts(far_fill_sts_distance)
#@ 
#@     set fill_length $opts(fill_length)
#@     set onestep $opts(onestep)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set do_ungridded_fill $opts(do_ungridded_fill)
#@     set hybrid $opts(hybrid)
#@     set write_sid_layer $opts(write_sid_layer)
#@     set write_cid_layer $opts(write_cid_layer)
#@     set write_bid_layer $opts(write_bid_layer)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@     set half_dr_end_to_end $opts(half_dr_end_to_end)
#@     set output_resolution $opts(output_resolution)
#@     set plys $opts(plys)
#@     set ply $opts(ply)
#@     set exclCells $opts(exclCells)
#@     set prune_cells_list $opts(prune_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set viewname $opts(viewname)
#@     set fillLayer $opts(layer)
#@     set stubnet $opts(stubnet)
#@     set near_fill_density_target $opts(near_fill_density_target)
#@     set far_fill_density_target  $opts(far_fill_density_target)
#@     set density_window_size $opts(density_window_size)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@     set metal_density_before_via $opts(metal_density_before_via)
#@     set icv_options $opts(icv_options)
#@     set power_nets $opts(power_nets)
#@     set eco_region $opts(eco_region)
#@     set fill_container_name $opts(fill_container_name)
#@     set tiling_options $opts(tiling_options)
#@ 
#@ # density_window_y_size, density_window_x_offset , density_window_y_offset, density_window_x_stepping, density_window_y_stepping, density_boundary_assumption, density_kor_assumption metal_density_before_via
#@ 
#@     set use_fill_markers $opts(use_fill_markers)
#@     set strict_bc_identification $opts(strict_bc_identification)
#@     set consider_off_grid $opts(consider_off_grid)
#@     set dfmg_extensions $opts(dfmg_extensions)
#@     set verbatim $opts(verbatim)
#@     set post_fill_operation $opts(post_fill_operation)
#@ 
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     if {$cellname == ""} {
#@       set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     }
#@     if {$outputcellname == ""} {
#@       set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     }
#@     if {$viewname == ""} {
#@       set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     }
#@     if {$temp_techname == ""} {
#@       set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     }
#@     if {$stubnet == ""} {
#@       set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     }
#@     if {$property == ""} {
#@       set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     }
#@     if {$stub_property == ""} {
#@       set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     }
#@     if {$icv_options == ""} {
#@       set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     }
#@ 
#@     set techname [::dtDfm::fill_metal_icv_get_tech $temp_techname]
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@ 
#@     if { $onestep } {
#@       ::dtDfm::fill_metal_icv_init -cellname $cellname
#@     }
#@ 
#@     if { $ply != "" } {
#@       lappend plys $ply
#@     }
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No metal layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set is_metal [regexp {metal(\d+)} $fillLayer fullstring level]
#@     set is_thick_metal [regexp {(tm\d+)} $fillLayer fullstring level]
#@     set is_rdl [regexp {rdl} $fillLayer fullstring level]
#@ 
#@     if { ($is_metal == 0) && ($is_thick_metal ==  0) && ($is_rdl == 0) } {
#@          ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@          return 0
#@     }
#@ 
#@     if { $is_metal } {
#@       set flowName "m${level}fill"
#@       set container_extension "_fill${level}"
#@     }
#@ 
#@     if { $is_thick_metal } {
#@       set flowName "tm1fill"
#@       set container_extension "_filltm1"
#@     }
#@ 
#@     if { $is_rdl } {
#@       set flowName "rdlfill"
#@       set container_extension "_fillrdl"
#@     }
#@ 
#@ 
#@   # write uin file
#@   # <cellname>_fill_layers.uin is written in proc fill_metal_icv_run_streamlined
#@ 
#@   set uinfilename "${cellname}${container_extension}.uin"
#@ #puts "Writing uin file $uinfilename"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   set error_code [::dtDfm::fill_metal_icv_writeuin $cellname                                    $viewname                                    $techname                                    $fillLayer                                    $write_sid_layer                                    $write_cid_layer                                    $write_bid_layer                                    $do_ungridded_fill                                    $hybrid                                    $pattern                                    $offset                                    $break_pattern                                    $break_offset                                    $transition_pattern                                    $transition_offset                                    $transition_period                                    $grid_patterns                                    $break_patterns                                    $transition_patterns                                    $region_grids                                    $fill_length                                    $excludeKOR 				   $top_level_only_kor                                    $korspX                                    $korspY                                    $half_dr_end_to_end                                    $output_resolution                                    $plys                                    $exclCells                                    $keepout_cells_list                                    $keepout_cells_x_space                                    $keepout_cells_y_space                                    $uinfilepath                                    $write_milkyway_output                                    $fill_in_cel_view                                    $mwoutpath                                    $mwlibrary 				   $near_fill_density_target 				   $far_fill_density_target                                    $density_window_size 				   $density_window_y_size 				   $density_window_x_offset                                    $density_window_y_offset                                    $density_window_x_stepping                                    $density_window_y_stepping                                    $density_boundary_assumption                                    $density_kor_assumption                                    $metal_density_before_via                                    $use_fill_markers                                    $strict_bc_identification 				   $consider_off_grid 				   $dfmg_extensions                                   $write_stm_output                                    $verbatim                                    $post_fill_operation                                    $power_nets                                    $eco_region                                    $fill_container_name                                    $far_fill_ete_distance                                    $far_fill_sts_distance ]
#@ 
#@   if { $error_code == 0 } {
#@    return 0
#@   }
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   lappend fillLayers_opts $icv_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@   set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@   lappend prune_cells_lists $prune_cells_list
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS $prune_cells_lists
#@ 
#@   set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   lappend tiling_opts $tiling_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVOPTIONS $icv_options
#@ 
#@   if { $only_write_uin || $streamlined } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                             $flowName                                             $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   if { $onestep } {
#@       ::dtDfm::fill_metal_icv_end
#@   }
#@   return $jobInfo
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- fill_metal_icv_writeuin
#@ #
#@ # Note.  For region_grids old format is depricated.  One is to use
#@ #        the following {option_value_pairs {{opt1_1 val1_1} {opt2_1 val2_1}...} {{opt1_2 val1_2} {opt2_2 val2_2}...} ...}
#@ #
#@ # For instance,
#@ #   [list option_value_pairs
#@ #      [list 
#@ #        [list region polygons({ {{-0.056,-0.040}, {58.856,-0.040}, {58.856,34.354}, {-0.056,34.354}}, })]
#@ #        [list grid_pattern grid_pattern_1]
#@ #        [list offset 0.656]
#@ #        [list period 117.600]
#@ #        [list relative_offset false]
#@ #        [list transition_pattern transition_pattern_1]
#@ #        [list transition_offset -0.040]
#@ #        [list transition_period 58.800]
#@ #        [list is_grating_hole_violation_risk_pattern true]
#@ #      ]
#@ #
#@ #      [list 
#@ #        [list region CELLBOUNDARY]
#@ #        [list grid_pattern grid_pattern_2]
#@ #        [list offset -0.016]
#@ #        [list period 0.672]
#@ #        [list relative_offset false]
#@ #        [list transition_pattern transition_pattern_2]
#@ #        [list transition_offset 0.102]
#@ #        [list transition_period 1.344]
#@ #        [list is_grating_hole_violation_risk_pattern true]
#@ #      ]
#@ #   ] 
#@ # -------------------------------------------------------------------
#@ proc ::dtDfm::fill_metal_icv_writeuin { cellname                                         viewname                                         techname                                         fillLayer                                         write_sid_layer                                         write_cid_layer                                         write_bid_layer                                         do_ungridded_fill                                         hybrid                                         pattern                                         offset                                         break_pattern                                         break_offset                                         transition_pattern                                         transition_offset                                         transition_period                                         grid_patterns                                         break_patterns                                         transition_patterns                                         region_grids                                         fill_length                                         excludeKOR                                         top_level_only_kor                                         korspX 					korspY 					half_dr_end_to_end 					output_resolution 					plys 					exclCells                                         keepout_cells_list                                         keepout_cells_x_space                                         keepout_cells_y_space 					uinfilepath 					write_milkyway_output 					fill_in_cel_view 					mwoutpath 					mwlibrary 					near_fill_density_target 					far_fill_density_target 					density_window_size 					density_window_y_size 					density_window_x_offset 					density_window_y_offset 					density_window_x_stepping 					density_window_y_stepping 					density_boundary_assumption 					density_kor_assumption 					metal_density_before_via 					use_fill_markers                                         strict_bc_identification 					consider_off_grid 					dfmg_extensions                                         write_stm_output                                         verbatim                                         post_fill_operation                                         power_nets                                         eco_region 				        fill_container_name                                         far_fill_ete_distance                                         far_fill_sts_distance } {
#@    set f [open "$uinfilepath" w]
#@ 
#@   if { $pattern != "" } {
#@     if { $plys == "" } {
#@       set grid_pattern_name "grid_pattern"
#@       set grid_pattern_name_with_type "${grid_pattern_name}"
#@     }  else {
#@       set grid_pattern_name "grid_pattern_ply"
#@       set grid_pattern_name_with_type "${grid_pattern_name}:track_pattern"
#@     }
#@     set grid_period($grid_pattern_name) [::dtDfm::fill_metal_icv_write_pattern_to_uin $f $grid_pattern_name_with_type $pattern]
#@     puts $f "offset = $offset;"
#@     puts $f "period = $grid_period($grid_pattern_name);"
#@   }
#@ 
#@   if { $break_pattern != "" } {
#@     set break_pattern_name "break_pattern"
#@     set grid_period($break_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $break_pattern_name $break_pattern]
#@     puts $f "break_offset     = $break_offset;"
#@     puts $f "break_period     = $grid_period($break_pattern_name);"
#@     puts $f "break_min_length = $grid_period($break_pattern_name);" 
#@   }
#@ 
#@   if { $transition_pattern != "" } {
#@     set transition_pattern_name "transition_pattern"
#@     set grid_period($transition_pattern_name) [::dtDfm::fill_metal_icv_write_transition_pattern_to_uin $f $transition_pattern_name $transition_pattern]
#@     puts $f "transition_offset = $transition_offset;"
#@     puts $f "transition_period = $transition_period;"
#@   }
#@ 
#@   if { $grid_patterns != "" } {
#@     foreach grid_def $grid_patterns {
#@       set grid_pattern_name [lindex $grid_def 0]
#@       set grid_pattern_name_with_type "${grid_pattern_name}:track_pattern"
#@       set pattern [lindex $grid_def 1]
#@       set grid_period($grid_pattern_name) [::dtDfm::fill_metal_icv_write_pattern_to_uin $f $grid_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@   if { $break_patterns != "" } {
#@     foreach break_def $break_patterns {
#@       set break_pattern_name [lindex $break_def 0]
#@       set break_pattern_name_with_type "${break_pattern_name}:track_pattern"
#@       set pattern [lindex $break_def 1]
#@       set grid_period($break_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $break_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@   if { $transition_patterns != "" } {
#@     foreach transition_def $transition_patterns {
#@       set transition_pattern_name [lindex $transition_def 0]
#@       set transition_pattern_name_with_type "${transition_pattern_name}:track_pattern"
#@       set pattern [lindex $transition_def 1]
#@       set grid_period($transition_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $transition_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@ 
#@ 
#@   if { $region_grids != "" || $plys != "" } {
#@     set gridded_fill 0
#@     puts $f "region_grids = {"
#@     if { [lindex $region_grids 0]== "option_value_pairs" } {
#@       set gridded_fill 1
#@       set region_grids [lrange $region_grids 1 end]
#@       foreach region_grid $region_grids {
#@         if { [::dtDfm::fill_metal_icv_write_region_grids_option_value_pair_to_uin $f $region_grid ] == 0 } {
#@           close $f
#@           return 0
#@         }
#@       }
#@     } else {
#@       foreach region_grid $region_grids {
#@         set gridded_fill 1
#@ 	set rg_plys [lindex $region_grid 0]
#@ 	set grid_pattern_name [lindex $region_grid 1]
#@ 	set offset [lindex $region_grid 2]
#@ 	set period $grid_period($grid_pattern_name)
#@ 	set relative_offset [lindex $region_grid 3]
#@ 	if { $relative_offset == "" } {
#@ 	  set relative_offset false
#@ 	}
#@ 	set break_pattern_name [lindex $region_grid 4]
#@ 	if { $break_pattern_name != "" } {
#@ 	  set break_pattern_offset [lindex $region_grid 5] 
#@ 	  if { $break_pattern_offset == "" } {
#@ 	    set break_pattern_offset 0.0
#@ 	  }
#@ 
#@      set break_pattern_period     $grid_period($break_pattern_name)
#@ 
#@      set break_pattern_min_length [lindex $region_grid 6]
#@      if {$break_pattern_min_length == "" } {    
#@        set break_pattern_min_length $grid_period($break_pattern_name)
#@      }
#@ 	} else {
#@ 	  set break_pattern_offset     0.0
#@ 	  set break_pattern_period     0.0
#@      set break_pattern_min_length 0.0
#@ 	}
#@ 	::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $rg_plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance       }
#@     }
#@ 
#@       if { $plys != "" } {
#@ 	 set grid_pattern_name "grid_pattern_ply"
#@          if { [info exists grid_period($grid_pattern_name) ] } {
#@            set gridded_fill 1
#@ 	   set period $grid_period($grid_pattern_name)
#@ 	   set relative_offset false
#@ 	   set break_pattern_name ""
#@ 	   set break_pattern_offset 0.0
#@ 	   set break_pattern_period 0.0
#@ 	  ::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance         }
#@       }
#@       puts $f "};"
#@ 
#@       if { $gridded_fill == 0 }  { 
#@         ::dtDfm::fill_metal_icv_write_kors_to_uin_whitebox_mode $f                                                                 $plys                                                                 $fillLayer
#@       }
#@   }
#@ 
#@   if { $techname != "" } {
#@     if { $techname == "1274" } {
#@       # puts $f "#include \"details/drconfig74.rs\" "
#@     }
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   if { $write_sid_layer } {
#@     puts $f "write_out_s_tracks = true;"
#@     puts $f "write_out_s_wires  = false;"
#@   }
#@ 
#@   if { $write_cid_layer } {
#@     puts $f "write_out_c_tracks = true;"
#@     puts $f "write_out_c_wires  = false;"
#@   }
#@ 
#@   if { $write_bid_layer } {
#@     puts $f "write_out_b_tracks = true;"
#@   }
#@ 
#@   puts $f "fill_length = $fill_length;"
#@ 
#@   if { $hybrid } {
#@       puts $f "hybrid = true;"
#@   } else {
#@       puts $f "hybrid = false;"
#@   }
#@ 
#@   if { $do_ungridded_fill } {
#@     puts $f "do_ungridded_fill = true;"
#@   }
#@ 
#@ 
#@   if { $half_dr_end_to_end >= 0.0 } {
#@     puts $f "half_dr_end_to_end = $half_dr_end_to_end;"
#@   }
#@ 
#@   if { $output_resolution >= 0.0 } {
#@     puts $f "output_resolution = $output_resolution;"
#@   }
#@  
#@ 
#@   if { $use_fill_markers == "true"  } {
#@     puts $f "use_fill_markers = true;"
#@   } else {
#@     puts $f "use_fill_markers = false;"
#@   }
#@ 
#@   if { $strict_bc_identification == "true"  } {
#@     puts $f "strict_bc_identification = true;"
#@   }
#@ 
#@   if { $consider_off_grid == "true" } {
#@     puts $f "consider_off_grid = true;"
#@   } else {
#@     puts $f "consider_off_grid = false;"
#@   }
#@ 
#@   if { $dfmg_extensions == "true" } {
#@     puts $f "dfmg_extensions = true;"
#@   } else {
#@     puts $f "dfmg_extensions = false;"
#@   }
#@ 
#@ 
#@   if { $verbatim != "" } {
#@     puts $f $verbatim
#@   }
#@ 
#@   if { $post_fill_operation != "" } {
#@     puts $f "post_fill_operation = \"$post_fill_operation\";"
#@   }
#@ 
#@ 
#@   if { $fill_container_name != "" } {
#@     puts $f "fill_container_name = \"$fill_container_name\";"
#@   }
#@ 
#@   if { $eco_region != "" } {
#@     set leading_string "eco_region = "
#@     set trailing_string ";"
#@     ::dtDfm::write_plys_to_uin $f                                $eco_region                                $leading_string                                $trailing_string
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_no_extend_cells_list_to_uin $f $exclCells;
#@   set cell_list_option_name "no_extend_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $exclCells;
#@ 
#@   set cell_list_option_name "power_nets"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $power_nets;
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f $keepout_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX $korspY;
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $near_fill_density_target                                                 $far_fill_density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@   close $f
#@ 
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_break_pattern_to_uin { f break_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   set period 0
#@   if { $pattern != "" } {
#@     set pattern_records ""
#@     set split_pattern [split $pattern ":"]
#@     set wire_cnt [expr [llength $split_pattern]/2 ]
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@       set wire_width [lindex $split_pattern [expr [expr $wire_num*2] + 0]]
#@       set next_space [lindex $split_pattern [expr [expr $wire_num*2] + 1]]
#@       lappend pattern_records [list $wire_width $next_space ]
#@     }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@     puts $f "$break_pattern_name = $OPEN_BRACE"
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@         set pattern_record [lindex $pattern_records $wire_num]
#@         puts $f "  {[lindex $pattern_record 0], [lindex $pattern_record 1]},"
#@       set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@     }
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@   return $period
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_transition_pattern_to_uin { f transition_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   set period 0
#@   if { $pattern != "" } {
#@     set pattern_records ""
#@     set split_pattern [split $pattern ":"]
#@     set wire_cnt [expr [llength $split_pattern]/2 ]
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@       set wire_width [lindex $split_pattern [expr [expr $wire_num*2] + 0]]
#@       set next_space [lindex $split_pattern [expr [expr $wire_num*2] + 1]]
#@       lappend pattern_records [list $wire_width $next_space ]
#@     }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@     puts $f "$transition_pattern_name = $OPEN_BRACE"
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@         set pattern_record [lindex $pattern_records $wire_num]
#@         puts $f "  {[lindex $pattern_record 0], [lindex $pattern_record 1]},"
#@       set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@     }
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@   return $period
#@ }
#@ 
#@ proc ::dtDfm::getPeriodFromPattern { pattern } {
#@   set period [::dtDfm::fill_metal_icv_write_pattern_to_uin "" "" $pattern]
#@   return $period
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_pattern_to_uin { f grid_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   if { $pattern != "" } {
#@   set pattern_records ""
#@   set split_pattern [split $pattern ":"]
#@   set wire_cnt [expr [llength $split_pattern]/3 ]
#@   for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@     set net_name [lindex $split_pattern [expr [expr $wire_num*3] + 0]]
#@     set wire_width_type [lindex $split_pattern [expr [expr $wire_num*3] + 1]]
#@     if { [regexp -nocase "(.*)C" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "C"
#@     } elseif { [regexp -nocase "(.*)B" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "B"
#@     } elseif { [regexp -nocase "(.*)S" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "S"
#@     } else {
#@       set wire_width $wire_width_type
#@       set wire_type ""
#@     }
#@     set next_space [lindex $split_pattern [expr [expr $wire_num*3] + 2]]
#@     lappend pattern_records [list $wire_width $next_space $wire_type $net_name ]
#@   }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@   if { $f != "" } {
#@     puts $f "$grid_pattern_name = $OPEN_BRACE"
#@   }
#@   set period 0
#@   for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@     if { $wire_num == 0 }  {
#@       set pattern_record [lindex $pattern_records $wire_num]
#@       if { $f != "" } {
#@         puts $f "  {0.000, [lindex $pattern_record 0], \"[lindex $pattern_record 2]\", \"[lindex $pattern_record 3]\"},"
#@       }
#@     } else {
#@       set pattern_record [lindex $pattern_records $wire_num]
#@       set prev_pattern_record [lindex $pattern_records [expr $wire_num - 1]]
#@       if { $f != "" } {
#@         puts $f "  {[lindex $prev_pattern_record 1], [lindex $pattern_record 0], \"[lindex $pattern_record 2]\", \"[lindex $pattern_record 3]\"},"
#@       } 
#@     }
#@     set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@   }
#@   if { $f != "" } {
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@  }
#@  return $period
#@ }
#@ 
#@ proc ::dtDfm::get_pxl_ply { ply  } {
#@   set plxpolygon "{"
#@   set pointcount 0
#@   foreach point $ply {
#@     if { $pointcount != 0 } {
#@      append plxpolygon ", "
#@     }
#@     incr pointcount
#@     append plxpolygon "{$point}"
#@   } 
#@   append plxpolygon "},"
#@   return $plxpolygon
#@ }
#@ 
#@ proc ::dtDfm::write_plys_to_uin { f plys {leading_string "region ="} {trailing_string ","} } {
#@     set specialRegions {"^TOPCELLBOUNDARY" "^CELLBOUNDARY" "V3PITCHID" "ULPPITCHID" }
#@     foreach spr $specialRegions {
#@       if { [regexp $spr $plys] } {
#@         puts $f " $leading_string $plys $trailing_string"
#@         return
#@       }
#@     }
#@ 
#@ #    if { [lsearch $specialRegions $plys] != -1 } {
#@ #      puts $f " $leading_string $plys ,"
#@ #      return
#@ #    }
#@ 
#@     puts $f " $leading_string polygons ({"
#@     set plycount 0
#@     foreach ply $plys {
#@       if { $plycount != 0 } {
#@         # puts -nonewline $f ", "
#@       }
#@       incr plycount
#@       set pxlpolygon [::dtDfm::get_pxl_ply $ply]
#@       puts $f "         $pxlpolygon"
#@     }
#@     puts $f " })$trailing_string"
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_kors_to_uin_whitebox_mode { f                                                           plys                                                           fillLayer } {
#@   set KORNAME [string toupper $fillLayer]KOR_ROUTE
#@   puts $f "$KORNAME = $KORNAME or (CELLBOUNDARY not "
#@   set leading_string ""
#@   set trailing_string ""
#@   ::dtDfm::write_plys_to_uin $f $plys $leading_string $trailing_string
#@   puts $f ");"
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_region_grids_to_uin { f                                                          plys                                                          grid_pattern_name                                                          offset                                                          period                                                          relative_offset                                                          break_pattern_name                                                          break_pattern_offset                                                          break_pattern_period                                                          break_pattern_min_length                                                          far_fill_ete_distance                                                          far_fill_sts_distance } {
#@ 
#@ # region_grids = {
#@ #         {
#@ #         rectangle(10, 10, 20, 20), //put arbitrary ICV code in UIN file for complex region definitions
#@ #         grid_pattern,
#@ #         offset,
#@ #         period,
#@ #         },
#@ # };
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "     $OPEN_BRACE"
#@     ::dtDfm::write_plys_to_uin $f $plys
#@     puts $f "         grid_pattern     = ${grid_pattern_name},"
#@     puts $f "         offset           = $offset,"
#@     puts $f "         period           = $period,"
#@     puts $f "         relative_offset  = $relative_offset,"
#@ if { $break_pattern_name != "" } {
#@     puts $f "         break_pattern    = ${break_pattern_name},"
#@     puts $f "         break_offset     = $break_pattern_offset,"
#@     puts $f "         break_period     = $break_pattern_period,"
#@     puts $f "         break_min_length = $break_pattern_min_length,"
#@ }
#@     puts $f "     $CLOSE_BRACE,"
#@ 
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- fill_metal_icv_writeuin
#@ #
#@ # Note.  Don't forget update ::dtDfm::region_grids_legal_option_names
#@ #        list w/ newly introduced options to support.
#@ # -------------------------------------------------------------------
#@ proc ::dtDfm::fill_metal_icv_write_region_grids_option_value_pair_to_uin { f region_grids } {
#@ 
#@ #  region : polygon_layer;
#@ #  grid_pattern:track_pattern = {};
#@ #  offset:double = 0.0;
#@ #  period:double = 0.0;
#@ #  relative_offset:boolean = false;
#@ #  break_pattern:track_pattern = {};
#@ #  break_offset:double = 0.0;
#@ #  break_period:double = 0.0;
#@ #  break_min_length:double = 0.0;
#@ #  fill_non_preferred:boolean = false;
#@ #  transition_pattern:track_pattern = {};
#@ #  transition_offset:double = 0.0;
#@ #  transition_period:double = 0.0;
#@ 
#@ 
#@     set period_found false
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "     $OPEN_BRACE"
#@     foreach opt_val_pair $region_grids {
#@       set option [lindex $opt_val_pair 0]
#@       set value [lindex $opt_val_pair 1]
#@       if { [lsearch $::dtDfm::region_grids_legal_option_names $option] == -1 } {
#@         puts "$option: Illegal option name in option-value pairs of region_grids"
#@         return 0
#@       }
#@       if { $option == "region" } {
#@         ::dtDfm::write_plys_to_uin $f $value
#@       } else { 
#@         puts $f "         $option = $value,"
#@       }
#@       if { $option == "period" } {
#@         set period_found true
#@       }
#@     }
#@     puts $f "     $CLOSE_BRACE,"
#@ }
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_base_layer ###########################################################
#@ CmdSpec ::dtDfm::fill_base_layer {
#@     -help "::dtDfm::fill_base_layer -layer poly "
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Metal layer to fill - i.e. poly"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@ 
#@         {-optname     ply
#@          -type     string
#@          -default  ""
#@          -help     "Polygon region based fill, i.e {0.0,0.04 0.0,182.36 207.32,182.36 ...}"
#@         }
#@ 
#@         {-optname     plys
#@          -type     string
#@          -default  ""
#@          -help     "Multiple polygon region based fill, i.e { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  near_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Near fill density target"
#@         }
#@         {-optname  far_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill density target"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window size"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@ 
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_base_layer {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@     set plys $opts(plys)
#@     set ply $opts(ply)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set fillLayer $opts(layer)
#@     set near_fill_density_target $opts(near_fill_density_target)
#@     set far_fill_density_target  $opts(far_fill_density_target)
#@     set density_window_size $opts(density_window_size)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@ 
#@ # density_window_y_size, density_window_x_offset , density_window_y_offset, density_window_x_stepping, density_window_y_stepping, density_boundary_assumption, density_kor_assumption 
#@ 
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@ 
#@     set techname [::dtDfm::fill_metal_icv_get_tech $temp_techname]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     if { $ply != "" } {
#@       lappend plys $ply
#@     }
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No metal layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set is_poly      [regexp "poly"       $fillLayer fullstring]
#@     set is_polycon   [regexp "polycon"    $fillLayer fullstring]
#@     set is_diffcon   [regexp "diffcon"    $fillLayer fullstring]
#@     set is_diffusion [regexp "diffusion"  $fillLayer fullstring]
#@     set is_libdfmg   [regexp "libdfmg"    $fillLayer fullstring]
#@ 
#@     if { ($is_poly == 0) && ($is_polycon == 0 ) && ($is_diffcon == 0 ) && ($is_diffusion == 0 ) && ($is_libdfmg == 0) } {
#@          ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@          return 0
#@     }
#@ 
#@     set flowName ${fillLayer}fill
#@     set container_extension _${flowName}
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   set uinfilepath "$uindir/$uinfilename"
#@   set error_code [::dtDfm::fill_base_layer_writeuin $cellname                                    $viewname                                    $techname                                    $fillLayer                                    $excludeKOR                                    $top_level_only_kor                                    $korspX                                    $korspY                                    $plys                                    $keepout_cells_list                                    $uinfilepath                                    $write_milkyway_output                                    $fill_in_cel_view                                    $mwoutpath                                    $mwlibrary 				   				   $near_fill_density_target 				   				   $far_fill_density_target                                    $density_window_size 				   				   $density_window_y_size 				   				   $density_window_x_offset                                    $density_window_y_offset                                    $density_window_x_stepping                                    $density_window_y_stepping                                    $density_boundary_assumption                                    $density_kor_assumption                                    $write_stm_output ]
#@ 
#@   if { $error_code == 0 } {
#@    return 0
#@   }
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   # set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   # lappend fillLayers_opts $icv_options
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@   set tiling_options ""
#@   # set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   # lappend tiling_opts $tiling_options
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@ 
#@   if { $only_write_uin || $streamlined} {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   # fake level
#@   set level 0
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                             $flowName                                             $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fill_base_layer_writeuin { cellname                                         viewname                                         techname                                         fillLayer                                         excludeKOR                                         top_level_only_kor                                         korspX 					korspY 					plys                                         keepout_cells_list 					uinfilepath 					write_milkyway_output 					fill_in_cel_view 					mwoutpath 					mwlibrary 					near_fill_density_target 					far_fill_density_target 					density_window_size 					density_window_y_size 					density_window_x_offset 					density_window_y_offset 					density_window_x_stepping 					density_window_y_stepping 					density_boundary_assumption 					density_kor_assumption                     			write_stm_output } {
#@     set f [open "$uinfilepath" w]
#@     set period 0
#@     if { $plys != "" } {
#@         set grid_pattern_name "grid_pattern_ply"
#@         if { [info exists grid_period($grid_pattern_name) ] } {
#@             catch {set period $grid_period($grid_pattern_name)}
#@         }
#@         set relative_offset false
#@         set break_pattern_name ""
#@         set break_pattern_offset 0.0
#@         set break_pattern_period 0.0
#@         set far_fill_ete_distance 0.0 
#@         set far_fill_sts_distance 0.0
#@ 	::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance 
#@       }
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"p$techname\";"
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f $keepout_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary
#@ 
#@ 
#@   set metal_density_before_via false
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $near_fill_density_target                                                $far_fill_density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@   close $f
#@ 
#@   return 1
#@ }
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_via_icv ##############################################################
#@ set ::dtDfm::hookup_regions_legal_option_names {region nets_above nets_below break_above break_below density_target}
#@ 
#@ CmdSpec ::dtDfm::fill_via_icv {
#@ 
#@     -help "::dtDfm::fill_via_icv -cellname abc -viewname -lnf techname 1272.0 -layer via2"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell on which fill is to be performed\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  ""
#@             -help     "Viewname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  ""
#@             -help     "Techname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "Fill metal property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "Stub property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via2"
#@         }
#@         {-optname     hookup_regions
#@          -type        string
#@          -default     ""
#@          -help        "Hookup regions\n\t\t\t\tfollowing is the old format\n\t\t\t\t{ {polygons_set1 nets_above1 nets_below1 break_above1 break_below1 density_target1}\n\t\t\t\t  {polygons_set2 nets_above2 nets_below2 break_above2 break_below2 density_target2} }\n\t\t\t\tpolygons_set can be CELLBOUNDARY or { ply1 ply2 ply3....}\n\t\t\t\teach ply has the format {x1,y1 x2,y2 x3,y3 x4,y4 ....}\n\t\t\t\ta two point polygon is assumed to be a rectangle {xl,yl xh,yh}\n\t\t\t\tbreak_above/break_below take boolean values true/false values\n\t\t\t\tdensity_target take a float value between 0 and 1\n\t\t\t\t\n\t\t\t\tfollowing is the new format\n\t\t\t\t{ option_value_pairs { {option1 value1} {option2 value2} ... }\n\t\t\t\t\t\t{ {option1 value1} {option2 value2} ... } }\n\t\t\t\tallowed options include $::dtDfm::hookup_regions_legal_option_names\n\t\t\t\t"
#@ 
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@        {-optname     exclCells
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\twires in these cells are not to be extended"
#@        }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname  fill_container_name
#@          -type     string
#@          -default  ""
#@          -help     "Name of the fill container"
#@         }
#@         {-optname  fill_net_names
#@          -type     string
#@          -default  ""
#@          -help     "Names of the fill nets"
#@         }
#@         {-optname  hv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the HV nets"
#@         }
#@         {-optname  ehv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the EHV nets"
#@         }
#@         {-optname  uhv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the UHV nets"
#@         }
#@ 
#@         {-optname  density_target
#@          -type     float
#@          -default  0.10
#@          -help     "Via density target (a number between 0 and 1 e.g. 0.02 is 2%)"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  30.0
#@          -help     "Density window size"
#@         }
#@         {-optname  fast_density
#@          -type     bool
#@          -default  false
#@          -help     "Use a simpler density algorithm to reduce memory / run time"
#@         }
#@         {-optname  density_fill_downto
#@          -type     bool
#@          -default  false
#@          -help     "Fill down to density as opposed up to to density"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@ 
#@         {-optname  iteration_count
#@          -type     integer
#@          -default  1
#@          -help     "Number of Via SG passes to maximize density (with deminising returns)"
#@         }
#@         {-optname  fillincelview
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW CEL view"
#@         }
#@         {-optname  hierarchical_nets  
#@          -type     bool
#@          -default  false
#@          -help     "Supports connections with nets in lower level of hierarchy; identified by names"
#@         }
#@         {-optname  consider_hv_violations
#@          -type     bool
#@          -default  false
#@          -help     "Check for HV rules in via fill."
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of ICV options specific to this layer when run in -explicit_parallel mode (default: -dp1 -turbo-lite)"
#@         }
#@         {-optname  eco_region
#@          -type     string
#@          -default  ""
#@          -help     "ECO is performed in these polygon regions { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  verbatim
#@          -type     string
#@          -default  ""
#@          -help     "Adds PXL code to UIN file verbatim"
#@         }
#@    }
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set cellname            $opts(cellname)
#@     set viewname            $opts(viewname)
#@     set temp_techname       $opts(techname)
#@     set fillLayer           $opts(layer)
#@     set hookup_regions      $opts(hookup_regions)
#@     set property            $opts(property)
#@     set stub_property       $opts(stub_property)
#@     set excludeKOR          $opts(excludeKOR)
#@     set top_level_only_kor  $opts(top_level_only_kor)
#@     set korspX              $opts(korspX)
#@     set korspY              $opts(korspY)
#@     set exclCells           $opts(exclCells)
#@     set fill_container_name $opts(fill_container_name)
#@     set fill_net_names      $opts(fill_net_names)
#@     set hv_nets      $opts(hv_nets)
#@     set ehv_nets      $opts(ehv_nets)
#@     set uhv_nets      $opts(uhv_nets)
#@     set density_target      $opts(density_target)
#@     set density_window_size $opts(density_window_size)
#@     set fast_density $opts(fast_density)
#@     set density_fill_upto $opts(density_fill_downto)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@     set iteration_count     $opts(iteration_count)
#@     set fill_in_cel_view   $opts(fillincelview)
#@     set hierarchical_nets  $opts(hierarchical_nets)
#@     set consider_hv_violations $opts(consider_hv_violations)
#@     set icv_options $opts(icv_options)
#@     set eco_region $opts(eco_region)
#@     set verbatim $opts(verbatim)
#@ 
#@     if {$fast_density} {
#@         ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY $fast_density
#@     }
#@ 
#@     if {$density_fill_upto} {
#@         set density_fill_upto false
#@     } else {
#@         set density_fill_upto true
#@     }
#@ 
#@     if {$cellname == ""} {
#@       set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     }
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     if {$viewname == ""} {
#@       set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     }
#@     if {$temp_techname == ""} {
#@       set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     }
#@ 
#@     set verbatim $opts(verbatim)
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     if {$property == ""} {
#@       set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     }
#@     if {$stub_property == ""} {
#@       set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     }
#@ 
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     if {$icv_options == ""} {
#@       set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     }
#@ 
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No via layer specified"
#@ 	return 0
#@     }
#@ 
#@     if { $fillLayer == "tv0" } {
#@ 	set flowName "tv0fill"
#@ 	set container_extension "_tv0fill"
#@ 	set level "0"
#@     } elseif { $fillLayer == "viat" } {
#@ 	set flowName "vcgfill"
#@ 	set container_extension "_vcgfill"
#@ 	set level "0"
#@     } elseif { $fillLayer == "viag" } {
#@ 	set flowName "vctfill"
#@ 	set container_extension "_vctfill"
#@ 	set level "0"
#@     } else {
#@ 	set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@ 	set flowName "v${level}fill"
#@ 	set container_extension "_vfill${level}"
#@ 	if { $result == 0 } {
#@ 	  ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@ 	  return 0
#@ 	}
#@     }
#@ 
#@ #    set flowName "v${level}fill"
#@ #    set container_extension "_vfill${level}"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fill_via_icv_writeuin $cellname 				 $viewname 				 $techname 				 $fillLayer 				 $hookup_regions 				 $fill_container_name 				 $fill_net_names 				 $hv_nets 				 $ehv_nets 				 $uhv_nets 				 $density_target 				 $density_window_size 				 $fast_density 				 $density_fill_upto 				 $density_window_y_size 				 $density_window_x_offset 				 $density_window_y_offset 				 $density_window_x_stepping 				 $density_window_y_stepping 				 $density_boundary_assumption 				 $density_kor_assumption 				 $excludeKOR 				 $top_level_only_kor 				 $korspX 				 $korspY 				 $exclCells 				 $uinfilepath 				 $write_milkyway_output 				 $fill_in_cel_view 				 $mwoutpath 				 $mwlibrary 				 $write_stm_output 				 $iteration_count 				 $hierarchical_nets 				 $consider_hv_violations 				 $verbatim 				 $eco_region
#@ 
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   lappend fillLayers_opts $icv_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@ 
#@   set prune_cells_list {};
#@   set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@   lappend prune_cells_lists $prune_cells_list
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS $prune_cells_lists
#@ 
#@   set tiling_options "" 
#@   set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   lappend tiling_opts $tiling_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@   if { $only_write_uin || $streamlined } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@   set ::env(PDSSTM) $stminputdir
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname 					   $flowName 					   $container_extension 					   $level 					   $stminputdir 					   $uinfilepath 					   $icvworkarea 					   $icv_options 					   $use_lnf_input 					   $use_pds 					   $nbpool 					   $nbclass 					   $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@   set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_get_net_name_list { fill_net_names } {
#@   if { $fill_net_names != "" } {
#@     set fill_net_name_list ""
#@     regsub -all "," $fill_net_names " " fill_net_names
#@     foreach fill_net_name $fill_net_names {
#@       set fill_net_name_list [concat $fill_net_name_list \"$fill_net_name\",]
#@     }
#@     return "{$fill_net_name_list}"
#@   }
#@   return ""
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_write_hookup_regions_to_uin { f hookup_regions } {
#@ 
#@ # hookup_regions = {
#@ #     {
#@ #         region = CELLBOUNDARY,
#@ #         nets_above = {"*"},
#@ #         nets_below = {"*"},
#@ #         break_above = true,
#@ #         density_target = 0.005,
#@ #     },
#@ #     {
#@ #         region = CELLBOUNDARY,
#@ #         nets_above = {"*"},
#@ #         nets_below = {"*"},
#@ #         break_below = true,
#@ #         density_target = 0.005,
#@ #     }
#@ # };
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "hookup_regions = $OPEN_BRACE"
#@ 
#@     if { [lindex $hookup_regions 0]== "option_value_pairs" } {
#@       set hookup_regions [lrange $hookup_regions 1 end]
#@       foreach hookup_region $hookup_regions {
#@ 	puts $f "     $OPEN_BRACE"
#@         foreach opt_val_pair $hookup_region {
#@           set option [lindex $opt_val_pair 0]
#@           set value [lindex $opt_val_pair 1]
#@           if { [lsearch $::dtDfm::hookup_regions_legal_option_names $option] == -1 } {
#@             puts "$option: Illegal option name in option-value pairs of region_grids"
#@             return 0
#@           }
#@           if { $option == "nets_above" || $option == "nets_below" } {
#@ 	    set value [::dtDfm::fill_via_icv_get_net_name_list $value]
#@           }
#@ 
#@           if { $option == "region" } {
#@             ::dtDfm::write_plys_to_uin $f $value
#@           } else { 
#@             puts $f "         $option = $value,"
#@           }
#@         }
#@ 	puts $f "     $CLOSE_BRACE,"
#@       }
#@     } else {
#@       foreach hookup_region $hookup_regions {
#@ 	set plys [lindex $hookup_region 0]
#@ 	set nets_above [lindex $hookup_region 1]
#@ 	set nets_below [lindex $hookup_region 2]
#@ 	set break_above [lindex $hookup_region 3]
#@ 	set break_below [lindex $hookup_region 4]
#@ 	set density_target [lindex $hookup_region 5]
#@ 
#@ 	puts $f "     $OPEN_BRACE"
#@ 	::dtDfm::write_plys_to_uin $f $plys
#@ 
#@ 	set nets_above_list [::dtDfm::fill_via_icv_get_net_name_list $nets_above]
#@         if { $nets_above_list != "" } {
#@ 	  puts $f "nets_above = $nets_above_list,"
#@         }
#@ 
#@ 	set nets_below_list [::dtDfm::fill_via_icv_get_net_name_list $nets_below]
#@         if { $nets_below_list != "" } {
#@ 	  puts $f "nets_below = $nets_below_list,"
#@         }
#@ 
#@ 	if { $break_above } {
#@ 	  set break_above true
#@ 	} else {
#@ 	  set break_above false
#@ 	}
#@ 	puts $f "break_above = $break_above,"
#@ 
#@ 	if { $break_below } {
#@ 	  set break_below true
#@ 	} else {
#@ 	  set break_below false
#@ 	}
#@ 
#@ 	puts $f "break_below = $break_below,"
#@ 
#@ 	puts $f "density_target = $density_target,"
#@ 	puts $f "     $CLOSE_BRACE,"
#@      }
#@    } 
#@    puts $f "$CLOSE_BRACE;"
#@  
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_writeuin { cellname 				      viewname 				      techname 				      fillLayer                                       hookup_regions                                       fill_container_name                                       fill_net_names                                       hv_nets                                       ehv_nets                                       uhv_nets                                       density_target                                       density_window_size                                       fast_density                                       density_fill_upto 				      density_window_y_size 				      density_window_x_offset                                       density_window_y_offset                                       density_window_x_stepping                                       density_window_y_stepping                                       density_boundary_assumption                                       density_kor_assumption                                       excludeKOR                                       top_level_only_kor                                       korspX                                       korspY                                       exclCells                                       uinfilepath                                       write_milkyway_output                                       fill_in_cel_view                                       mwoutpath                                       mwlibrary                                       write_stm_output                                       iteration_count 				      hierarchical_nets                                        consider_hv_violations                                       verbatim 				      eco_region
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@ 
#@   if { $fill_container_name != "" } {
#@     puts $f "fill_container_name = \"$fill_container_name\";"
#@   }
#@ 
#@   if { $verbatim != "" } {
#@     puts $f $verbatim
#@   }
#@ 
#@   if { $eco_region != "" } {
#@     set leading_string "eco_region = "
#@     set trailing_string ";"
#@     ::dtDfm::write_plys_to_uin $f                                $eco_region                                $leading_string                                $trailing_string
#@   }
#@ 
#@ 
#@   set fill_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $fill_net_names]
#@   if { $fill_net_name_list != "" } {
#@     puts $f "fill_net_names = $fill_net_name_list;"
#@   }
#@   set hv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $hv_nets]
#@   if { $hv_net_name_list != "" } {
#@     puts $f "hv_nets = $hv_net_name_list;"
#@   }
#@   set ehv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $ehv_nets]
#@   if { $ehv_net_name_list != "" } {
#@     puts $f "ehv_nets = $ehv_net_name_list;"
#@   }
#@   set uhv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $uhv_nets]
#@   if { $uhv_net_name_list != "" } {
#@     puts $f "uhv_nets = $uhv_net_name_list;"
#@   }
#@ 
#@   if { $hookup_regions != "" } {
#@     ::dtDfm::fill_via_icv_write_hookup_regions_to_uin $f $hookup_regions
#@   }
#@ 
#@   if { $iteration_count > 0 } {
#@     puts $f "iteration_count = $iteration_count;"
#@   }
#@ 
#@   if { $hierarchical_nets  } {
#@     puts $f "hierarchical_nets  = true;"
#@   }
#@    if { $consider_hv_violations } {
#@     puts $f "consider_hv_violations = true;"
#@   }
#@   puts $f "density_fill_upto = $density_fill_upto;"
#@   puts $f "density_fill_upto = $density_fill_upto;"
#@ 
#@   if { $density_kor_assumption } {
#@     set density_kor_assumption "true"
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f  $exclCells;
#@ 
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $exclCells
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   puts $f "density_target = $density_target;"
#@ 
#@   set metal_density_before_via false
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $density_target                                                $density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::upsz_via ##################################################################
#@ CmdSpec ::dtDfm::upsz_via {
#@ 
#@     -help "::dtDfm::upsz_via -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::upsz_via {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No via layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     if { $result == 0 || $level != 1 } {
#@       ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       return 0
#@     }
#@ 
#@     set flowName "v${level}upsz"
#@     set container_extension "_vupsz${level}"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::upsz_via_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin || $streamlined} {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::upsz_via_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fix_vcx250 ##################################################################
#@ CmdSpec ::dtDfm::fix_vcx250 {
#@ 
#@     -help "::dtDfm::fix_vcx250 -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fix_vcx250 {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     # if { $fillLayer == "" } {
#@ 	# ::dtDfm::printErr "No via layer specified"
#@ 	# return 0
#@     #}
#@ 
#@ 
#@     set fillLayer "viat"
#@     set level 0
#@     # set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     # if { $result == 0 || $level != 1 } {
#@       # ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       # return 0
#@     # }
#@ 
#@     set flowName "vcx250"
#@     set container_extension "_vcx250"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fix_vcx250_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary 
#@                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds 											$launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fix_vcx250_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::rename_mw_nets ##################################################################
#@ CmdSpec ::dtDfm::rename_nets {
#@ 
#@     -help "::dtDfm::rename_mw_nets "
#@     -opts {
#@         {-optname     mw_cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the mw output cell"
#@         }
#@         {-optname     nets_to_rename
#@             -type     string
#@             -default  ""
#@             -help     "regular expression identifying nets to be renamed"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::rename_nets { args } {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set mw_cellname $opts(mw_cellname)
#@     set nets_to_rename $opts(nets_to_rename)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     # set print_cmd_str [info level [info level]]
#@     # ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     set flowName "renamenets"
#@     set container_extension "_renamenets"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::rename_nets_writeuin  $mw_cellname                                  $nets_to_rename                                  $viewname                                  $techname                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output
#@ 
#@  # if { $only_write_uin || $streamlined }
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set level 1 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@  set fillLayer metal1
#@ 
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@ #  ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::rename_nets_writeuin { cellname                                      nets_to_rename 				                     viewname 				                     techname                                      uinfilepath                                      write_milkyway_output                                      fill_in_cel_view                                      mwoutpath                                      mwlibrary                                      write_stm_output 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   if { $nets_to_rename != "" } {
#@     puts $f "nets_to_rename = \"$nets_to_rename\";"
#@   }
#@ 
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_end ########################################################
#@ 
#@ proc ::dtDfm::fill_metal_icv_end { } {
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@   if { $streamlined } {
#@     set fillLayers        [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@     set fillLayers_opts   [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@     set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@     set tiling_opts       [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@     return [::dtDfm::fill_metal_icv_run_streamlined -layers $fillLayers -layer_opts $fillLayers_opts -tiling_opts $tiling_opts -prune_cells_lists $prune_cells_lists ]
#@   }
#@ 
#@   set jobids ""
#@   # puts "fill_metal_icv_jobs : $::dtDfm::fill_metal_icv_jobs" 
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@ 
#@   foreach job $jobs {
#@     lappend jobids [::dtDfm::keylget job PID]
#@     set metalLayer [::dtDfm::keylget job LAYER]
#@     set resubmitCount($metalLayer) 0
#@   }
#@ 
#@   # puts $jobids
#@   set remainingProcesses $jobids
#@   set jobsidover ""
#@ 
#@   set interrupted 0
#@   while { [llength $jobids] != [llength $jobsidover] } {
#@ 
#@     # set exitstatus [wait]
#@     # set pidover [lindex $exitstatus 0]
#@     set pidsover [getTerminatedProcess $remainingProcesses]
#@ 	if { $pidsover == "" } {
#@ 	   set interrupted 1
#@ 	   break 
#@ 	}
#@     foreach pidover $pidsover {
#@       set remainingProcesses [::dtDfm::lremove $remainingProcesses $pidover]
#@       set jobindex [lsearch $jobids $pidover]
#@       if { $jobindex != -1 } {
#@         set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@         set jobinfo [lindex $jobs $jobindex]
#@         # puts $jobinfo
#@         set fillLayer [::dtDfm::keylget jobinfo LAYER]
#@         if { [::dtDfm::fill_metal_icv_readresults $jobinfo $save_workdir ] == 0 } {
#@           puts "mfill failed for $fillLayer"
#@           if { [info exists resubmitCount($fillLayer) ] == 0  || $resubmitCount($fillLayer) == 0 } {
#@             incr resubmitCount($fillLayer)
#@             set print_cmd_str [::dtDfm::keylget jobinfo CMD_STR]
#@             # puts "resubmitting $jobinfo $print_cmd_str"
#@             set newJobInfo [eval $print_cmd_str]
#@             set newJobPid [::dtDfm::keylget newJobInfo PID]
#@             lappend jobids $newJobPid
#@             lappend remainingProcesses $newJobPid
#@             puts "resubmitting $fillLayer: $newJobPid"
#@           }
#@         } else {
#@           puts "mfill succeded for $fillLayer"
#@         }
#@ 
#@         lappend jobsidover $pidover
#@       }
#@     }
#@   }
#@ 
#@   if { $interrupted == 1 } {
#@     puts "job interrupted"
#@     set cmd "kill SIGKILL {$remainingProcesses}"
#@     puts "$cmd"
#@     ::dtDfm::delete_all_fill
#@     catch { eval $cmd }
#@   }
#@ 
#@   # set ::dtDfm::fill_metal_icv_jobs ""
#@ 
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   if { !$save_workdir } {
#@     if { ([file exists $icvtopworkarea/input] != 0) } {
#@       file delete -force $icvtopworkarea/input
#@     }
#@   } else {
#@     puts "saving $icvtopworkarea"
#@   }
#@ 
#@ }
#@ 
#@ proc getTerminatedProcess { pids } {
#@   while { 1 } {
#@     if { [::dtDfm::interrupted] } {
#@       return ""
#@     }
#@ 
#@     set livepids ""
#@     catch { set livepids [eval exec "ps -o pid -p $pids"] }
#@     set terminatedPids ""
#@     foreach pid $pids {
#@        if { [lsearch $livepids $pid] == -1 } {
#@           lappend terminatedPids $pid
#@        }
#@     }
#@     if { [llength $terminatedPids] > 0 } {
#@       return $terminatedPids
#@     }
#@      exec sleep 1
#@   }
#@ 
#@ }
#@ 
#@ ##################################### Common functions used by several uin writers ############################################################
#@ proc ::dtDfm::fill_metal_icv_write_kor_options_to_uin { f                                             excludeKOR                                             top_level_only_kor                                             korspX                                             korspY } {
#@   set use_drawn_kor "true"
#@   if { $excludeKOR } { 
#@     set use_drawn_kor "false"
#@   }
#@ 
#@   puts $f "use_drawn_kor = $use_drawn_kor;"
#@   if { $use_drawn_kor == "true" } {
#@ 
#@     puts $f "top_level_only_kor = $top_level_only_kor;"
#@ 
#@     puts $f "drawn_kor_x_space = $korspX;"
#@     puts $f "drawn_kor_y_space = $korspY;"
#@   }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_density_to_uin {  f                                                  near_fill_density_target                                                  far_fill_density_target                                                  density_window_size                                                  density_window_y_size                                                  density_window_x_offset                                                  density_window_y_offset                                                  density_window_x_stepping                                                  density_window_y_stepping                                                  density_boundary_assumption                                                  density_kor_assumption                                                  metal_density_before_via } {
#@   set target_density_mode 0
#@   if { $near_fill_density_target > 0.0 } {
#@     puts $f "near_fill_density_target = $near_fill_density_target;"
#@     set target_density_mode 1
#@   }
#@ 
#@   if { $far_fill_density_target > 0.0 } {
#@     puts $f "far_fill_density_target = $far_fill_density_target;"
#@     set target_density_mode 1
#@   }
#@ 
#@   if { $target_density_mode } {
#@     if { $density_window_size > 0.0 } {
#@       puts $f "density_window_size = $density_window_size;"
#@     }
#@ 
#@     if { $density_window_y_size > 0.0 } {
#@       puts $f "density_window_y_size = $density_window_y_size;"
#@     }
#@ 
#@     if { $density_window_x_offset > 0.0 } {
#@       puts $f "density_window_x_offset= $density_window_x_offset;"
#@     }
#@ 
#@     if { $density_window_y_offset > 0.0 } {
#@       puts $f "density_window_y_offset = $density_window_y_offset;"
#@     }
#@ 
#@     if { $density_window_x_stepping > 0.0 } {
#@       puts $f "density_window_x_stepping = $density_window_x_stepping;"
#@     }
#@ 
#@     if { $density_window_y_stepping > 0.0 } {
#@       puts $f "density_window_y_stepping = $density_window_y_stepping;"
#@     }
#@ 
#@     if { $density_boundary_assumption != -1 } {
#@       puts $f "density_boundary_assumption = $density_boundary_assumption;"
#@     }
#@ 
#@     if { $density_kor_assumption } {
#@       puts $f "density_kor_assumption = $density_kor_assumption;"
#@     }
#@ 
#@     if { $metal_density_before_via } {
#@       puts $f "#define METAL_DENSITY_BEFORE_VIA"
#@     }
#@   }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_output_options_to_uin {  f                                                 write_stm_output                                                 write_milkyway_output                                                 fill_in_cel_view                                                 mwoutpath                                                 cellname                                                 mwlibrary } {
#@ 
#@     if { [info exists ::env(PVPD_PIF_TOOL_NAME)] } {
#@         set toolname $::env(PVPD_PIF_TOOL_NAME)
#@         if {$toolname == "genesys" || $toolname == "genoa" || $toolname == "gena" || $toolname == "gend"} {
#@             puts $f "//set to true for cadworks"
#@             puts $f "write_stm_output = true;"
#@         } elseif { !$write_stm_output} {
#@             puts $f "write_stm_output = false;"
#@         }
#@     } elseif { !$write_stm_output} {
#@         puts $f "write_stm_output = false;"
#@     }
#@     
#@   if { $write_milkyway_output } {
#@     puts $f "write_milkyway_output = true;"
#@ 
#@     if { $fill_in_cel_view } {
#@       puts $f "mw_view = \"CEL\";"
#@     }
#@ 
#@     if { $mwoutpath != "" } {
#@       puts $f "mw_path = \"$mwoutpath\";"
#@     }
#@ 
#@     if { $cellname != "" } {
#@       puts $f "mw_cellname = \"$cellname\";"
#@     }
#@ 
#@     if { $mwlibrary != "" } {
#@       puts $f "mw_library = \"$mwlibrary\";"
#@     }
#@   }
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_cells_list_to_uin {  f  					                cell_list_option_name                                                         keepout_cells_list } {
#@ 
#@   if { $keepout_cells_list != "" } {
#@     set keepoutCellsList ""
#@     regsub -all "," $keepout_cells_list " " keepout_cells_list
#@     foreach keepoutCell $keepout_cells_list {
#@       set keepoutCellsList [concat $keepoutCellsList \"$keepoutCell\",]
#@     }
#@     puts $f "$cell_list_option_name = {$keepoutCellsList};"
#@   }
#@ }
#@ 
#@ ##################################### Function that calls fillflow.pl #########################################################################
#@ 
#@ proc ::dtDfm::fill_metal_icv_runflow { cellname                                        flowname                                        container_extension                                        level                                        stminputdir                                        uinfilepath                                        icvworkarea                                        icv_options                                        use_lnf_input 
#@                                        use_pds 				       				   launch_script                                        nbpool                                        nbclass                                        nbslot  } {
#@   global env
#@   # set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@   if { [file exists $icvworkarea] != 0 } {
#@     # puts "deleting $icvworkarea"
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   file mkdir $icvworkarea/output
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   # file copy $uinfilepath ./flexuin_fill${level}.rs
#@   file copy -force $uinfilepath ./flexuin${container_extension}.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@     cd $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath ]
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   cd $old_dir
#@   return $pid
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_runflow { cellname                                      flowname                                      level                                      stminputdir                                      uinfilepath                                      icvworkarea                                      icv_options} {
#@   global env
#@   # set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@   if { [file exists $icvworkarea] != 0 } {
#@     # puts "deleting $icvworkarea"
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   file mkdir $icvworkarea/output
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   file copy -force $uinfilepath ./flexuin_vfill${level}.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   # set stmoutputdir ${icvworkarea}
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath]
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   cd $old_dir
#@   return $pid
#@ }
#@ 
#@ ######################################### UDM DEPENDENT CODE STARTS HERE ######################################################################
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   printError $str
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   printInfo $str
#@ }
#@ 
#@ proc ::dtDfm::writeRegionGrids { f cellname viewname plys } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     set cell [get_cell "$cellname,$viewname"]
#@     set tech [cell_get_tech $cell]
#@ 
#@     puts $f "region_grids = $OPEN_BRACE "
#@     puts $f "                 $OPEN_BRACE "
#@ 
#@     set gigplys ""
#@     foreach ply $plys {
#@       set ply_gig [create_gigfig_from_ply $ply $tech]
#@       lappend gigplys $ply_gig
#@     }
#@     set ply_gig [gig_op_or_list $gigplys]
#@     set cell_boundary [cell_get_boundary $cell]
#@     if { $ply_gig != "" } {
#@       set ply_rects [gig_op_segment_list $ply_gig 4]
#@ 
#@       set writeor 0
#@       foreach ply_rect $ply_rects {
#@         set ply_box [gig_figure_get_bbox $ply_rect]
#@         set box_coord [ split $ply_box ":"]
#@ 
#@         set xl [tech_udm_to_micron $tech [lindex $box_coord 0]]
#@         set yl [tech_udm_to_micron $tech [lindex $box_coord 1]]
#@         set xh [tech_udm_to_micron $tech [lindex $box_coord 2]]
#@         set yh [tech_udm_to_micron $tech [lindex $box_coord 3]]
#@ 
#@         if { $writeor == 1 } {
#@           puts -nonewline $f "or "
#@         } else {
#@           set writeor 1
#@         }
#@         puts -nonewline $f "rectangle( $xl, $yl, $xh, $yh) "
#@       }
#@     }
#@     puts $f ","
#@     puts $f "grid_pattern1,"
#@     puts $f "offset,"
#@     puts $f "period,"
#@     puts $f "   $CLOSE_BRACE,"
#@     puts $f "$CLOSE_BRACE;"
#@ }
#@ 
#@ proc ::dtDfm::writeKORsToUIN { f cellname viewname plys } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     set cell [get_cell "$cellname,$viewname"]
#@     set tech [cell_get_tech $cell]
#@ 
#@     puts $f "region_gids = $OPEN_BRACE "
#@     puts $f "                 $OPEN_BRACE "
#@ 
#@     set gigplys ""
#@     foreach ply $plys {
#@       set ply_gig [create_gigfig_from_ply $ply $tech]
#@       lappend gigplys $ply_gig
#@     }
#@     set ply_gig [gig_op_or_list $gigplys]
#@     set cell_boundary [cell_get_boundary $cell]
#@     # set ply_gig [create_gigfig_from_ply $ply $tech]
#@     # set kor_gig [gig_op_not_two_lists [list $cell_boundary] $ply_gig]
#@     set kor_gig $ply_gig
#@     if { $kor_gig != "" } {
#@       set kor_rects [gig_op_segment_list $kor_gig 4]
#@ 
#@       set firstkor 1
#@       foreach kor_rect $kor_rects {
#@         set ply_box [gig_figure_get_bbox $kor_rect]
#@         set box_coord [ split $ply_box ":"]
#@ 
#@         set xl [tech_udm_to_micron $tech [lindex $box_coord 0]]
#@         set yl [tech_udm_to_micron $tech [lindex $box_coord 1]]
#@         set xh [tech_udm_to_micron $tech [lindex $box_coord 2]]
#@         set yh [tech_udm_to_micron $tech [lindex $box_coord 3]]
#@ 
#@         if { !$firstkor } {
#@           puts -nonewline $f "or "
#@           set firstkor 0
#@         }
#@         puts -nonewline $f "rectangle( $xl, $yl, $xh, $yh) "
#@       }
#@     }
#@     puts $f ","
#@     puts $f "grid_pattern,"
#@     puts $f "offset,"
#@     puts $f "period,"
#@     puts $f "   $CLOSE_BRACE,"
#@     puts $f "$CLOSE_BRACE;"
#@ }
#@ 
#@ proc create_gigfig_from_ply { ply tech} {
#@  set vertex_list [split $ply " "]
#@  set num_of_vertex [llength $vertex_list]
#@ 
#@  set xlist_for_fig [list]
#@  set ylist_for_fig [list]
#@  for {set i 0} {$i < $num_of_vertex} {incr i} {
#@    set pt [lindex $vertex_list $i]
#@    lassign [split $pt ","] xpt ypt
#@    set xpt [tech_micron_to_udm $tech $xpt]
#@    set ypt [tech_micron_to_udm $tech $ypt]
#@    lappend xlist_for_fig $xpt
#@    lappend ylist_for_fig $ypt
#@  }
#@ 
#@  set orig_ply_gig_figure [gig_figure_create_polygon $xlist_for_fig $ylist_for_fig $num_of_vertex]
#@  return  $orig_ply_gig_figure
#@ }
#@ 
#@ proc ::dtDfm::is_via_layer_by_name { layername } {
#@     set result [regexp {via(\d+)} $layername fullstring level]
#@     if { $result == 0 } {
#@       set result [regexp {viaa(\d+)} $layername fullstring level]
#@     }
#@     if { $result == 0 } {
#@       set result [regexp {viab(\d+)} $layername fullstring level]
#@     }
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::is_via_layer { objLayer } {
#@     set layername [layer_get_name $objLayer]
#@     set result [::dtDfm::is_via_layer_by_name $layername]
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::is_dg_layer { objLayer } {
#@     set layername [layer_get_name $objLayer]
#@     set result [regexp {(\d+)dg} $layername fullstring level]
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::copyFromSTMToTop { srcCellName                                  srcViewName                                  destCellName                                  destViewName                                  layeNameList                                  stubnet                                  property                                  stub_property 								 netname_for_untexted_objects                                  {rename_nets ""}  }  {
#@   set from_nets {}
#@   set to_nets {}
#@   foreach from_to_net $rename_nets {
#@     lappend from_nets [lindex $from_to_net 0]
#@     lappend to_nets   [lindex $from_to_net 1]
#@   }
#@ 
#@   set prop_name_scope_value [split $property :]
#@   set propname  [lindex $prop_name_scope_value 0]
#@   set propscope [lindex $prop_name_scope_value 1]
#@   set propvalue [lindex $prop_name_scope_value 2]
#@ 
#@   set stub_prop_name_scope_value [split $stub_property :]
#@   set stub_propname  [lindex $stub_prop_name_scope_value 0]
#@   set stub_propscope [lindex $stub_prop_name_scope_value 1]
#@   set stub_propvalue [lindex $stub_prop_name_scope_value 2]
#@ 
#@   set src [cell_mgr_get_cell [cell_mgr_get_mgr] $srcCellName $srcViewName]
#@   set dest [cell_mgr_get_cell [cell_mgr_get_mgr] $destCellName $destViewName ]
#@   set tech [cell_get_tech $src]
#@   set layerList ""
#@ 
#@   foreach fillLayer $layeNameList {
#@   lappend layerList [tech_get_layer $tech $fillLayer]
#@   if { $fillLayer == "metal0" } {
#@     set metalc0Layer [tech_get_layer $tech metalc0]
#@     if { $metalc0Layer != "NULL" } {
#@       lappend layerList $metalc0Layer
#@     }
#@     set metals0Layer [tech_get_layer $tech metals0]
#@     if { $metals0Layer != "NULL" } {
#@       lappend layerList $metals0Layer
#@     }
#@   }
#@   if { $fillLayer == "metal1" } {
#@     set metal1dgLayer [tech_get_layer $tech metal1dg]
#@     if { $metal1dgLayer != "NULL" } {
#@       lappend layerList $metal1dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal2" } {
#@     set metalc2Layer [tech_get_layer $tech metalc2]
#@     if { $metalc2Layer != "NULL" } {
#@       lappend layerList $metalc2Layer
#@     }
#@     set metal2dgLayer [tech_get_layer $tech metal2dg]
#@     if { $metal2dgLayer != "NULL" } {
#@       lappend layerList $metal2dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal3" } {
#@     set metalc3Layer [tech_get_layer $tech metalc3]
#@     if { $metalc3Layer != "NULL" } {
#@       lappend layerList $metalc3Layer
#@     }
#@     set metal3dgLayer [tech_get_layer $tech metal3dg]
#@     if { $metal3dgLayer != "NULL" } {
#@       lappend layerList $metal3dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal4" } {
#@     set metalc4Layer [tech_get_layer $tech metalc4]
#@     if { $metalc4Layer != "NULL" } {
#@       lappend layerList $metalc4Layer
#@     }
#@   }
#@   if { $fillLayer == "metal5" } {
#@     set metalc5Layer [tech_get_layer $tech metalc5]
#@     if { $metalc5Layer != "NULL" } {
#@       lappend layerList $metalc5Layer
#@     }
#@   }
#@   if { $fillLayer == "via1" } {
#@     set viaa1Layer [tech_get_layer $tech viaa1]
#@     if { $viaa1Layer != "NULL" } {
#@       lappend layerList $viaa1Layer
#@     }
#@     set viab1Layer [tech_get_layer $tech viab1]
#@     if { $viab1Layer != "NULL" } {
#@       lappend layerList $viab1Layer
#@     }
#@     set viac1Layer [tech_get_layer $tech viac1]
#@     if { $viac1Layer != "NULL" } {
#@       lappend layerList $viac1Layer
#@     }
#@   }
#@   if { $fillLayer == "via2" } {
#@     set viaa2Layer [tech_get_layer $tech viaa2]
#@     if { $viaa2Layer != "NULL" } {
#@       lappend layerList $viaa2Layer
#@     }
#@     set viab2Layer [tech_get_layer $tech viab2]
#@     if { $viab2Layer != "NULL" } {
#@       lappend layerList $viab2Layer
#@     }
#@   }
#@   if { $fillLayer == "via3" } {
#@     set viaa3Layer [tech_get_layer $tech viaa3]
#@     if { $viaa3Layer != "NULL" } {
#@       lappend layerList $viaa3Layer
#@     }
#@     set viab3Layer [tech_get_layer $tech viab3]
#@     if { $viab3Layer != "NULL" } {
#@       lappend layerList $viab3Layer
#@     }
#@   }
#@   }
#@ 
#@   set bcPersona [udm_app_get_opt_layer_persona]
#@   if {[expr $bcPersona & 1]} {
#@     udm_app_change_opt_layer_persona 6
#@   }
#@   set objsIter  [cell_get_geo_objs_iter $src]
#@   set objCount 0
#@   set objIdList ""
#@   set stubList ""
#@ 
#@   while {[geo_obj_iter_advance $objsIter]} {
#@     set obj [geo_obj_iter_get_current $objsIter]
#@     set objLayer [geo_obj_get_layer $obj]
#@     incr objCount
#@     if { [lsearch $layerList $objLayer] != -1 } {
#@       if { [ isa_geo_poly $obj ] == 1 } {
#@         set syn 0
#@         set srcnet [geo_polygon_get_net $obj]
#@         if { $srcnet != "" } {
#@           set destnetname [net_get_name $srcnet]
#@         } else {
#@           if { $netname_for_untexted_objects == "unique_syn" } {
#@             set destnet [udm_utils_create_synth_net $dest]
#@             set destnetname  [net_get_name $destnet] 
#@           }  else {
#@             set destnetname $netname_for_untexted_objects
#@           }
#@         }
#@ 
#@         set destnet ""
#@         set this_is_stub false
#@         if { [regexp {syn_generated_([0-9\.]+)} $destnetname match num] } {
#@           if { $stubnet == "" } {
#@             set destnet [udm_utils_create_synth_net $dest]
#@           } else {
#@             set destnetname syn_stub
#@           }
#@           set this_is_stub true
#@         }
#@ 
#@ if { 0 } {
#@         if { [regexp {.*_floatiss_} $destnetname match num] } {
#@           set destnetname floatiss_
#@         }
#@ }
#@ 
#@         set net_index [lsearch $from_nets $destnetname]
#@         if { $net_index != -1 } {
#@           set destnetname [lindex $to_nets $net_index]
#@         }
#@ 
#@         if { $destnet == "" } {
#@           set destnet [cell_get_net $dest $destnetname ]
#@           if { $destnet == "" } {
#@             set destnet [cell_create_net $dest $destnetname ]
#@           }
#@         }
#@ 
#@         set bbox [::boo::new_BooBBox]
#@         geo_obj_get_bounding_box $obj $bbox
#@         set rect [new_rect_from_bbox $bbox $objLayer]
#@ 
#@         set this_is_a_wire true
#@ 
#@         if { [::dtDfm::is_via_layer $objLayer] } {
#@           set viapoly [new_polygon_from_bbox $bbox $objLayer]
#@           # set p [geo_polygon_create $dest $viapoly $destnet]
#@ 
#@          set enclist {}
#@          set p [via_create_general_via $destnet $enclist $viapoly]
#@          lappend objIdList [obj_get_obj_id $p]
#@          set this_is_a_wire false
#@         } elseif { [::dtDfm::is_dg_layer $objLayer] } {
#@           set dgpoly [new_polygon_from_bbox $bbox $objLayer]
#@           set p [geo_polygon_create $dest $dgpoly $destnet]
#@         } else {
#@           set w [wire_create $destnet $rect 0]
#@           lappend objIdList [obj_get_obj_id $w]
#@         }
#@         if {$syn == 1} {net_set_synth_net $destnet 1}
#@ 
#@         if { $this_is_stub && $this_is_a_wire } {
#@           lappend stubList  [obj_get_obj_id $w]
#@         }
#@       }
#@     }
#@   }
#@   if { [info commands Dfm] != {} && $objIdList != "" && $prop_name_scope_value != "" } {
#@     Dfm setCell -cell $destCellName
#@     Dfm setProp -name $propname -value $propvalue -scope $propscope -objIds $objIdList
#@     # puts "Dfm setProp -name $propname -value $propvalue -scope $propscope -objIds $objIdList"
#@   }
#@ 
#@   if { [info commands Dfm] != {} && $stubList != "" && $stub_prop_name_scope_value != "" } {
#@     Dfm setCell -cell $destCellName
#@     Dfm setProp -name $stub_propname -value $stub_propvalue -scope $stub_propscope -objIds $stubList
#@     # puts "Dfm setProp -name $stub_propname -value $stub_propvalue -scope $stub_propscope -objIds $stubList"
#@   }
#@ 
#@   udm_app_change_opt_layer_persona $bcPersona
#@   return $objIdList
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   # read and process results
#@   # set pid                 [::dtDfm::keylget jobInfo PID]
#@   set cellname            [::dtDfm::keylget jobInfo CELLNAME]
#@   set outputcellname      [::dtDfm::keylget jobInfo OUTPUT_CELL_NAME]
#@   set viewname            [::dtDfm::keylget jobInfo VIEWNAME]
#@   # set techname            [::dtDfm::keylget jobInfo TECHNAME]
#@   set container_extension [::dtDfm::keylget jobInfo EXTENSION]
#@   set fillLayers          [::dtDfm::keylget jobInfo LAYER]
#@   set stubnet             [::dtDfm::keylget jobInfo STUBNET]
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@   set property            [::dtDfm::keylget jobInfo PROPERTY]
#@   set stub_property       [::dtDfm::keylget jobInfo STUB_PROPERTY]
#@   set rename_nets         [::dtDfm::keylget jobInfo RENAME_NETS]
#@   set netname_for_untexted_objects [::dtDfm::keylget jobInfo NETNAME_FOR_UNTEXTED_OBJECTS]
#@   # set print_cmd_str       [::dtDfm::keylget jobInfo CMD_STR]
#@   
#@   # wait $pid
#@   # stm inputTechnology $tech
#@   set container_name ${cellname}${container_extension}
#@   set path ${icvworkarea}/${container_name}.stm
#@ 
#@   set readLayers ""
#@   foreach fillLayer $fillLayers {
#@     if { $fillLayer == "poly" } {
#@       lappend readLayers wirepoly
#@     } elseif { $fillLayer == "diffusion" || $fillLayer == "libdfmg" } {
#@       lappend readLayers nwirediff pwirediff wirepoly diffcon polycon
#@     } elseif { $fillLayer == "polycon" } {
#@       lappend readLayers polycon
#@     } elseif { $fillLayer == "diffcon" } {
#@       lappend readLayers diffcon
#@     } elseif { $fillLayer == "viat" } {
#@       lappend readLayers metal0 viat viag
#@     } else {
#@       lappend readLayers $fillLayer
#@     }
#@   }
#@   ::dtDfm::read_stm -from_cell $container_name                     -from_view stm                     -to_cell $outputcellname                     -to_view $viewname                     -path $path                     -layers $readLayers                     -stubnet $stubnet                     -property $property                     -stub_property $stub_property                     -rename_nets  $rename_nets  					-netname_for_untexted_objects $netname_for_untexted_objects
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   stm terminalProperty 126
#@   stm inputObjectProperties 1
#@   stm propertyAttributes 1
#@ 
#@   set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_checkcell { cellname viewname } {
#@     if {[info commands ::get_cell] != ""} {
#@         set cell [get_cell "$cellname,$viewname"]
#@         if {$cell == ""} {
#@             ::dtDfm::printErr "cell $cellname not found"
#@             return 0
#@         }
#@         set tech [cell_get_tech $cell]
#@         if {$tech == ""} {
#@             ::dtDfm::printErr "Failed to get udm tech"
#@             return 0
#@         }
#@     }
#@     return 1
#@ }
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   # puts "checking interrupt"
#@   set interrupted 0
#@   set interruptManager_ [::boo::BooInterruptMgr_getMgr]
#@   if {[::boo::BooInterruptMgr_interruptOccurred $interruptManager_]} {
#@     ::boo::BooInterruptMgr_clearInterrupt $interruptManager_
#@     set interrupted 1
#@   }
#@   return $interrupted
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   puts "Discarding partial fill objects"
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@ 
#@   set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@   if {$outputcellname != ""} {
#@     set cellname $outputcellname
#@   }
#@ 
#@   set properties {}
#@   foreach jobinfo $jobs {
#@     set property [::dtDfm::keylget jobinfo PROPERTY]
#@     if { [lsearch $properties $property] == -1 } {
#@       lappend properties $property
#@     }
#@     set stub_property [::dtDfm::keylget jobinfo STUB_PROPERTY]
#@     if { [lsearch $properties $stub_property] == -1 } {
#@       lappend properties $stub_property
#@     }
#@   }
#@ 
#@   Dfm setCell -cell $cellname
#@   set tbd_cell TO_BE_DELETED 
#@   Dfm createDfmCell -dfmCellName $tbd_cell
#@   foreach property $properties {
#@     set prop_name_scope_value [split $property :]
#@     set propname  [lindex $prop_name_scope_value 0]
#@     set propscope [lindex $prop_name_scope_value 1]
#@     set propvalue [lindex $prop_name_scope_value 2]
#@ 
#@     set cmd "Dfm objsByProp -command move -cell $tbd_cell -propName $propname -propScope $propscope -propValue $propvalue"
#@     set objs [eval $cmd]
#@     # puts "$cmd"
#@   }
#@   Discard -cellname $tbd_cell -noask
#@ }
#@ 
#@ ######################################### Parade DEPENDENT CODE STARTS HERE ####################################################################
#@ 
#@ 
#@ if { [info exists ICV_MFILL_FOR_PARADE] } {
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   set interrupted 0
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   # read and process results
#@   set pid                 [::dtDfm::keylget jobInfo PID]
#@   set cellname            [::dtDfm::keylget jobInfo CELLNAME]
#@   set outputcellname      [::dtDfm::keylget jobInfo OUTPUT_CELL_NAME]
#@   set viewname            [::dtDfm::keylget jobInfo VIEWNAME]
#@   set techname            [::dtDfm::keylget jobInfo TECHNAME]
#@   set container_extension [::dtDfm::keylget jobInfo EXTENSION]
#@   set fillLayer           [::dtDfm::keylget jobInfo LAYER]
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@   set property            [::dtDfm::keylget jobInfo PROPERTY]
#@   set stub_property       [::dtDfm::keylget jobInfo STUB_PROPERTY]
#@   set print_cmd_str       [::dtDfm::keylget jobInfo CMD_STR]
#@ 
#@   # wait $pid
#@   set container_name ${cellname}${container_extension}
#@ 
#@   # qb_node_create [pa_top_macro] vss 1
#@ 
#@   set old_dir [pwd]
#@   cd ${icvworkarea}
#@   set cmd "qb_gdsii_read_shapes ${icvworkarea}/${container_name}.stm vss"
#@ 
#@   # Open -cellname $container_name -viewname stm -nowindow 1
#@   set openret [eval $cmd]
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@ 
#@   if { $openret == 0 } {
#@     puts "Fail to load in ISS result stream file."
#@     return "0"
#@   }
#@  cd $old_dir
#@ 
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   # set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   set cmd "qb_write_gdsii \"\" \"\"  $path"
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_checkcell { cellname viewname } {
#@         return [expr {$cellname == [qb_macro_get_name [pa_top_macro]]}]
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   pa_log $str i
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   pa_log $str i
#@ }
#@ 
#@ 
#@ }
#@ 
#@ ######################################### ICC DEPENDENT CODE STARTS HERE #######################################################################
#@ 
#@ if { [info exists ICV_MFILL_FOR_ICC] } {
#@ 
#@ namespace eval ::boo {}; proc ::boo::EOUT {args} { puts $args }
#@ namespace eval ::boo {}; proc ::boo::IOUT {args} { puts $args }
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   set interrupted 0
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   # set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   # set cmd "qb_write_gdsii \"\" \"\"  $path"
#@ 
#@ 
#@    set_write_stream_options          -output_first_same_name_cell          -skip_global_route_contact          -contact X          -child_depth 1000          -output_filling fill          -output_outdated_fill          -output_pin {geometry}          -keep_data_type          -flatten_via          -map_layer $layer_map_for_mw          -output_instance_name_as_property 112          -max_name_length 64          -output_net_name_as_property 126          -set_hier_net_name_long          -set_hier_instance_name_long
#@ 
#@   if { [info exists env(PROJ_RDT)] } {
#@     set cmd "P_write_layout_file -format gds -cell $cellname -output_file $path"
#@   } else {
#@     set cmd "write_stream -cells $cellname $path"
#@   }
#@ 
#@   puts $cmd
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   puts $str
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   puts $str
#@ }
#@ 
#@ }
#@ 
#@ ################################################### General Functions ##########################################################################
#@ 
#@ proc ::dtDfm::get_cist_cmd_info {cmdname {filepath ""}} {
#@   set f ""
#@   if { $filepath != "" } {
#@     set f [open $filepath w]
#@   }
#@ 
#@   set cmd [[cist::cist_cmd_mgr::get_mgr] get_cmd $cmdname]
#@ 
#@   if {$cmd == ""} {
#@     return [list]
#@   }
#@ 
#@   set retval [list]
#@ 
#@   #
#@   # See also:  public variables in class cist::cist_input in /vobs/cadpax/cist/tcl/cist.tcl
#@   #
#@   foreach opt [$cmd get_inputs] {
#@     set name [$opt cget -optname]
#@     set def  [$opt cget -default]
#@     set desc [$opt cget -help]
#@     regsub -all "\n\t\t\t\t" $desc ";;;" desc
#@     if { $f != "" } { 
#@       puts $f "$name\t$def\t$desc"
#@     }
#@     lappend retval [list $name $def $desc]
#@   }
#@ 
#@   close $f
#@   return $retval
#@ }
#@ 
#@ proc ::dtDfm::keylset { instruct key value } {
#@   upvar 1 $instruct mystruct
#@   set found 0
#@   set index 0
#@   foreach info $mystruct {
#@     set info_key [lindex $info 0]
#@     if { $info_key == $key } {
#@       set found 1
#@       break;
#@     }
#@     incr index
#@   }
#@   if { $found == 1 } {
#@     set mystruct [lreplace $mystruct $index $index "$key $value"]
#@   } else {
#@     set mystruct [lappend mystruct "$key $value"]
#@   }
#@ }
#@ 
#@ proc ::dtDfm::keylget { instruct key } {
#@   upvar 1 $instruct mystruct
#@   set found 0
#@   set index 0
#@   foreach info $mystruct {
#@     set info_key [lindex $info 0]
#@     if { $info_key == $key } {
#@       return [lrange $info 1 end]
#@     }
#@     incr index
#@   }
#@   error "key $key not found in keyed list"
#@ }
#@ 
#@ proc ::dtDfm::lremove {args} {
#@      if {[llength $args] < 2} {
#@         puts stderr {Wrong # args: should be "lremove ?-all? list pattern"}
#@      }
#@      set list [lindex $args end-1]
#@      set elements [lindex $args end]
#@      if [string match -all [lindex $args 0]] {
#@         foreach element $elements {
#@             set list [lsearch -all -inline -not -exact $list $element]
#@         }
#@      } else {
#@         # Using lreplace to truncate the list saves having to calculate
#@         # ranges or offsets from the indexed element. The trimming is
#@         # necessary in cases where the first or last element is the
#@         # indexed element.
#@         foreach element $elements {
#@             set idx [lsearch $list $element]
#@             set list [string trim                 "[lreplace $list $idx end] [lreplace $list 0 $idx]"]
#@         }
#@      }
#@      return $list
#@ }
#@ proc ::dtDfm::fill_metal_icv_get_tech { temp_techname } {
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@     return $techname
#@ }
#@ 
#@ proc ::dtDfm::wait_on_pds_job { cellname flowname } {
#@   global env
#@ 
#@   set user $env(USER) 
#@   set supportfile "$env(PDSSUPPORT)/psicv_${user}.${cellname}.${flowname}.none.none"
#@   set currentfile "$env(PDSLOGS)/${cellname}.${flowname}.iss.current"
#@   set abortfile   "$env(PDSLOGS)/${cellname}.${flowname}.iss.abort"
#@   set logfile     "$env(PDSLOGS)/${cellname}.${flowname}.iss.log"
#@  
#@   exec sleep 2
#@   while { ([file exists $supportfile] != 0) } {
#@     exec sleep 2
#@   }
#@ 
#@   if { ([file exists $abortfile] != 0) } {
#@     return 1
#@   }
#@   return 0
#@ }
#@ 
#@ 
#@ ######################################### TEST PROCEDURE BELOW         #########################################################################
#@ proc my1272fill { cellname layers } {
#@ 
#@ set serial FALSE
#@ 
#@ ::dtDfm::fill_metal_icv_init -cellname $cellname
#@ 
#@ if { [lsearch $layers metal0] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal0 -offset 0.038 -pattern VSS_DUMMY:0.080B:0.028:VSS_DUMMY:0.032C:0.028 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal1] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal1 -offset 0.049 -pattern VSS_DUMMY:0.042:0.028 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal2] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal2 -offset 0.038 -pattern VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.038C:0.024:VSS:0.074:0.024:VSS_DUMMY:0.038C:0.024:VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.028C:0.024 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal3] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspY 0.028 -layer metal3 -offset 0.066 -pattern VSS_DUMMY:0.048C:0.024:VSS_DUMMY:0.032B:0.024:VSS_DUMMY:0.032C:0.024:VSS_DUMMY:0.032B:0.024:VSS_DUMMY:0.048C:0.024:VCC:0.084:0.024
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal4] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -layer metal4 -pattern VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.208 -offset 0.104 -property Dmi:test:Dmi -korspX 0.04 -korspY 0 -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal5] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -layer metal5 -pattern VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.266 -offset 0.133 -property Dmi:test:Dmi -korspX 0 -korspY 0.045 -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal6] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal6 -pattern VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.388 -offset 0.194 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal7] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal7 -pattern VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.500 -offset 0.250 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal8] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal8 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.532 -offset 0.266 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal9] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal9 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.700 -offset 0.350 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal10] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal10 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:1.204 -offset 0.602 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ 
#@ if { !$serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fix_v0pax_dfmg ##################################################################
#@ CmdSpec ::dtDfm::fix_v0pax_dfmg {
#@ 
#@     -help "::dtDfm::fix_v0pax_dfmg -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fix_v0pax_dfmg {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     # if { $fillLayer == "" } {
#@ 	# ::dtDfm::printErr "No via layer specified"
#@ 	# return 0
#@     #}
#@ 
#@ 
#@     set fillLayer "viat"
#@     set level 0
#@     # set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     # if { $result == 0 || $level != 1 } {
#@       # ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       # return 0
#@     # }
#@ 
#@     set flowName "v0pax_dfmg"
#@     set container_extension "_v0pax_dfmg"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fix_v0pax_dfmg_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds 											$launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fix_v0pax_dfmg_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ # Functions related to ::dtDfm::powerhookup 
#@ # BMB 2012-10-14
#@ 
#@ CmdSpec ::dtDfm::powerhookup {
#@     -help "::dtDfm::powerhookup"
#@     -opts {
#@         {-optname     process_name
#@             -type     string
#@             -default  "p1274.0"
#@             -help     "process name"
#@         }
#@         {-optname  top_level_only_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     use_drawn_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use drawn KOR layers"
#@         }
#@         {-optname     use_route_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use route KOR layers"
#@         }
#@         {-optname     use_fill_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Use fill KOR layers"
#@         }
#@         {-optname     use_global_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use global KOR layers"
#@         }
#@         {-optname     drawn_kor_x_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     drawn_kor_y_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     dh_bonus_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "list of double-height bonus cells"
#@         }
#@         {-optname     force_hookup_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "force hookup of power on listed cells"
#@         }
#@         {-optname     hookup_cell_names_list
#@             -type     string
#@             -default  ""
#@             -help     "list of cells (with wildcards) to hookup"
#@         }
#@         {-optname     hookup_cell_names_list_xn
#@             -type     string
#@             -default  ""
#@             -help     "list of xn cells (with wildcards) to hookup"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@         {-optname     keepout_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@         }
#@         {-optname     keepout_cells_x_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname     keepout_cells_y_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     powerhookup_grid_count
#@             -type     integer
#@             -default  0.0
#@             -help     "Grid count spacing for power hookup connections"
#@         }
#@         {-optname     powerhookup_empty_area
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Place power hookups in areas with no cell placements"
#@         }
#@         {-optname     powerhookup_cells_area
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Place power hookups in areas with cell placements"
#@         }
#@         {-optname     powerhookup_avoid_drv
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Avoid DRV and shorts when placing powerhookup vias"
#@         }
#@         {-optname     powerhookup_all_segments
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Ensure power hookups are on all segments of M2 power grid"
#@         }
#@         {-optname     powerhookup_drv_vias_cells_list 
#@             -type     string
#@             -default  "{\"*\"}"
#@             -help     "List of cells vias to consider for DRV"
#@         }
#@         {-optname     powerhookup_offset_locations
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Alternate the initial offset to place vias each M2 track"
#@         }
#@         {-optname     write_coord_file
#@             -type     string
#@             -default  ""
#@             -help     "Write center x,y cooridinates of power hookup to file"
#@         }
#@         {-optname     write_def_file_prefix
#@             -type     string
#@             -default  ""
#@             -help     "Write vias placements to DEF file"
#@         }
#@         {-optname     power_name
#@             -type     string
#@             -default  "vcc"
#@             -help     "Name of power rail (default = vcc)"
#@         }
#@         {-optname     ground_name
#@             -type     string
#@             -default  "vss"
#@             -help     "Name of ground rail (default = vss)"
#@         }
#@         {-optname     ground_rail_y_start
#@             -type     float
#@             -default  0.0
#@             -help     "y-value of center of first horizontal ground rail (default = 0.0)"
#@         }
#@         {-optname     power_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for power nets"
#@         }
#@         {-optname     ground_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for ground nets"
#@         }
#@         {-optname     dsn_core_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing core_area key=int_width and value=points_of_area for core_area"
#@         }
#@         {-optname     m2_rail_width
#@             -type     float
#@             -default  -1.0
#@             -help     "Width of m2 pwr/gnd rails" 
#@         }
#@         {-optname     cell_height
#@             -type     float
#@             -default  -1.0
#@             -help     "Height of single height stdcell" 
#@         }
#@         {-optname     v0_master
#@             -type     string
#@             -default  ""
#@             -help     "v0 via master" 
#@         }
#@         {-optname     v1_master
#@             -type     string
#@             -default  ""
#@             -help     "v1 via master" 
#@         }
#@         {-optname     hookup_via_settings
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing override settings for p1271-p1273 via masters and dimensions" 
#@         }
#@         {-optname     use_xll_grid
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Use XLL grid"
#@         }
#@         {-optname     bndry_y_min
#@             -type     float
#@             -default  0.0
#@             -help     "block boundary lower-y (default = 0.0)"
#@         }
#@     }
#@ }
#@ 
#@ # BMB 2012-10-14
#@ proc ::dtDfm::powerhookup {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set dh_bonus_cells_list       $opts(dh_bonus_cells_list)
#@     set force_hookup_cells_list   $opts(force_hookup_cells_list)
#@     set hookup_cell_names_list    $opts(hookup_cell_names_list)
#@     set hookup_cell_names_list_xn $opts(hookup_cell_names_list_xn)
#@     set keepin_cells_list        $opts(keepin_cells_list)
#@     set keepout_cells_list       $opts(keepout_cells_list)
#@     set keepout_cells_x_space    $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space    $opts(keepout_cells_y_space)
#@     set powerhookup_grid_count   $opts(powerhookup_grid_count)
#@     set powerhookup_empty_area   $opts(powerhookup_empty_area)
#@     set powerhookup_cells_area   $opts(powerhookup_cells_area)
#@     set powerhookup_avoid_drv    $opts(powerhookup_avoid_drv)
#@     set powerhookup_all_segments $opts(powerhookup_all_segments)
#@     set powerhookup_drv_vias_cells_list $opts(powerhookup_drv_vias_cells_list)
#@     set powerhookup_offset_locations $opts(powerhookup_offset_locations)
#@     set use_drawn_kor            $opts(use_drawn_kor)
#@     set top_level_only_kor       $opts(top_level_only_kor)
#@     set use_route_kor            $opts(use_route_kor)
#@     set use_fill_kor             $opts(use_fill_kor)
#@     set use_global_kor           $opts(use_global_kor)
#@     set drawn_kor_x_space        $opts(drawn_kor_x_space)
#@     set drawn_kor_y_space        $opts(drawn_kor_y_space)
#@     set write_coord_file         $opts(write_coord_file)
#@     set write_def_file_prefix    $opts(write_def_file_prefix)
#@     set power_name               $opts(power_name)
#@     set ground_name              $opts(ground_name)
#@     set ground_rail_y_start      $opts(ground_rail_y_start)
#@     if { $opts(power_voltage_areas) ne "" } {
#@        upvar $opts(power_voltage_areas) power_voltage_areas
#@        set pwr_va_areas [array get power_voltage_areas]
#@     } else {
#@        set pwr_va_areas ""
#@     }
#@     if { $opts(ground_voltage_areas) ne "" } {
#@        upvar $opts(ground_voltage_areas) ground_voltage_areas
#@        set gnd_va_areas [array get ground_voltage_areas]
#@     } else {
#@        set gnd_va_areas ""
#@     }
#@     if { $opts(dsn_core_areas) ne "" } {
#@        upvar $opts(dsn_core_areas) core_areas
#@        set dsn_core_areas [array get core_areas]
#@     } else {
#@        set dsn_core_areas ""
#@     }
#@     if { $opts(hookup_via_settings) ne "" } {
#@        upvar $opts(hookup_via_settings) hookup_masters
#@        set hookup_via_settings [array get hookup_masters]
#@     } else {
#@        set hookup_via_settings ""
#@     }
#@     set m2_rail_width            $opts(m2_rail_width)
#@     set cell_height              $opts(cell_height)
#@     set v0_master                $opts(v0_master)
#@     set v1_master                $opts(v1_master)
#@     set use_xll_grid             $opts(use_xll_grid)
#@     set dsn_y_min                $opts(bndry_y_min)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     ### If UDM, get tech from UDM cell
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@         return 0
#@     }
#@ 
#@     set fillLayer           "via1" 
#@     if { [regexp {127[123]} $techname] } {
#@        set flowName            "powerhookup72"
#@     } else {
#@        set flowName            "powerhookup"
#@     }
#@     set container_extension "_powerhookup"
#@     
#@     # write uin file
#@     set uinfilename "${cellname}${container_extension}.uin"
#@     # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     set uinfilepath "$uindir/$uinfilename"
#@     
#@     ::dtDfm::powerhookup_writeuin $cellname         $viewname         $techname         $uinfilepath         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $mwlibrary         $write_stm_output         $write_coord_file         $write_def_file_prefix         $dh_bonus_cells_list         $force_hookup_cells_list         $hookup_cell_names_list         $hookup_cell_names_list_xn         $keepin_cells_list         $keepout_cells_list         $keepout_cells_x_space         $keepout_cells_y_space         $use_drawn_kor         $top_level_only_kor         $use_route_kor         $use_fill_kor         $use_global_kor         $drawn_kor_x_space         $drawn_kor_y_space         $powerhookup_grid_count         $powerhookup_empty_area         $powerhookup_cells_area         $powerhookup_avoid_drv         $powerhookup_all_segments         $powerhookup_drv_vias_cells_list         $powerhookup_offset_locations         $power_name         $ground_name         $ground_rail_y_start         $pwr_va_areas         $gnd_va_areas         $dsn_core_areas         $m2_rail_width         $cell_height         $v0_master         $v1_master         $hookup_via_settings         $use_xll_grid         $dsn_y_min
#@ 
#@     if { $only_write_uin || $streamlined } {
#@         return ""
#@     }
#@ 
#@     # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@     set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@     set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@     set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@     set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@     set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@     set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@     set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@     set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@     
#@     set pid [::dtDfm::fill_metal_icv_runflow $cellname                  $flowName                  $container_extension                  0                  $stminputdir                  $uinfilepath                  $icvworkarea                  $icv_options                  $use_lnf_input                  $use_pds                  $launch_script                  $nbpool                  $nbclass                  $nbslot ]
#@     
#@     # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@     # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@     
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set jobInfo ""
#@     ::dtDfm::keylset jobInfo PID           $pid
#@     ::dtDfm::keylset jobInfo CELLNAME      $cellname
#@     ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME      $outputcellname
#@     ::dtDfm::keylset jobInfo VIEWNAME      $viewname
#@     ::dtDfm::keylset jobInfo TECHNAME      $techname
#@     ::dtDfm::keylset jobInfo EXTENSION     $container_extension
#@     ::dtDfm::keylset jobInfo ICVWORKAREA   $icvworkarea
#@     ::dtDfm::keylset jobInfo PROPERTY      $property
#@     ::dtDfm::keylset jobInfo STUBNET       $stubnet
#@     ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@     ::dtDfm::keylset jobInfo RENAME_NETS   $rename_nets
#@     ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@     ::dtDfm::keylset jobInfo CMD_STR       $print_cmd_str
#@     ::dtDfm::keylset jobInfo LAYER         $fillLayer
#@ 
#@     set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@     lappend jobs $jobInfo
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@     
#@     return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::powerhookup_writeuin { cellname                                          viewname                                          techname                                          uinfilepath                                          write_milkyway_output                                          fill_in_cel_view                                          mwoutpath                                          mwlibrary                                          write_stm_output                                          write_coord_file                                          write_def_file_prefix                                          dh_bonus_cells_list                                          force_hookup_cells_list                                          hookup_cell_names_list                                          hookup_cell_names_list_xn                                          keepin_cells_list                                          keepout_cells_list                                          keepout_cells_x_space                                          keepout_cells_y_space                                          use_drawn_kor                                          top_level_only_kor                                          use_route_kor                                          use_fill_kor                                          use_global_kor                                          drawn_kor_x_space                                          drawn_kor_y_space                                          powerhookup_grid_count                                          powerhookup_empty_area                                          powerhookup_cells_area                                          powerhookup_avoid_drv                                          powerhookup_all_segments                                          powerhookup_drv_vias_cells_list                                          powerhookup_offset_locations                                          power_name                                          ground_name                                          ground_rail_y_start                                          {pwr_va_areas ""}                                          {gnd_va_areas ""}                                          {dsn_core_areas ""}                                          m2_rail_width                                          cell_height                                          v0_master                                          v1_master                                          hookup_via_settings                                          use_xll_grid                                          dsn_y_min                                  } {
#@ 
#@     set f [open "$uinfilepath" w]
#@     
#@     if { $techname != "" } {
#@         puts $f "process_name = \"$techname\";"
#@     }
#@     
#@     ::dtDfm::fill_metal_icv_write_output_options_to_uin $f         $write_stm_output         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $cellname         $mwlibrary;
#@ 
#@     set use_p1272_opts 0
#@     if { [regexp {127[123]} $techname] } {
#@        set use_p1272_opts 1
#@        if { $dh_bonus_cells_list ne "" } {
#@           set dh_bonus_option_name "dh_bonus_cells_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $dh_bonus_option_name               $dh_bonus_cells_list;
#@        }
#@ 
#@        if { $force_hookup_cells_list ne "" } {
#@           set force_hookup_option_name "force_hookup_cells_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $force_hookup_option_name               $force_hookup_cells_list;
#@        }
#@ 
#@        if { $hookup_cell_names_list ne "" } {
#@           set hookup_cells_option_name "hookup_cell_names_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $hookup_cells_option_name               $hookup_cell_names_list;
#@        }
#@ 
#@        if { $hookup_cell_names_list_xn ne "" } {
#@           set hookup_cells_xn_option_name "hookup_cell_names_list_xn"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $hookup_cells_xn_option_name               $hookup_cell_names_list_xn;
#@        }
#@     }
#@ 
#@     set cell_list_option_name "keepin_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepin_cells_list;
#@     
#@     set cell_list_option_name "keepout_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepout_cells_list;    
#@ 
#@     puts $f "keepout_cells_x_space    = $keepout_cells_x_space;"
#@     puts $f "keepout_cells_y_space    = $keepout_cells_y_space;"
#@     puts $f "use_drawn_kor            = $use_drawn_kor;"
#@     puts $f "top_level_only_kor       = $top_level_only_kor;"
#@     puts $f "use_route_kor            = $use_route_kor;"
#@     puts $f "use_fill_kor             = $use_fill_kor;"
#@     puts $f "use_global_kor           = $use_global_kor;"
#@     puts $f "drawn_kor_x_space        = $drawn_kor_x_space;"
#@     puts $f "drawn_kor_y_space        = $drawn_kor_y_space;"
#@     puts $f "powerhookup_grid_count   = $powerhookup_grid_count;"
#@     puts $f "powerhookup_empty_area   = $powerhookup_empty_area;"
#@     puts $f "powerhookup_cells_area   = $powerhookup_cells_area;"
#@     puts $f "powerhookup_avoid_drv    = $powerhookup_avoid_drv;"
#@     puts $f "powerhookup_all_segments = $powerhookup_all_segments;"
#@     if { ! $use_p1272_opts } {
#@        puts $f "powerhookup_drv_vias_cells_list = $powerhookup_drv_vias_cells_list;"
#@        puts $f "powerhookup_offset_locations = $powerhookup_offset_locations;"
#@     }
#@     puts $f "write_coord_file         = \"$write_coord_file\";"
#@     if { $use_p1272_opts } {
#@        puts $f "write_def_file           = \"$write_def_file_prefix.def\";"
#@     } else {
#@        puts $f "write_def_file_prefix    = \"$write_def_file_prefix\";"
#@     }
#@ 
#@     puts $f "ground_rail_y_start      = $ground_rail_y_start;"
#@ 
#@     if { $pwr_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $pwr_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "pwr_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "power_name               = \"$power_name\";"
#@     }
#@     if { $gnd_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $gnd_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "gnd_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "ground_name              = \"$ground_name\";"
#@     }
#@ 
#@     if { $dsn_core_areas != "" } {
#@        foreach {int_width core_area} [regsub -all "," $dsn_core_areas " "] {
#@           # reformat core_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $core_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $core_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $core_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "core_area\[$int_width\] = {[join $fmt_area {,}]};"
#@        }
#@     }
#@ 
#@     if { $m2_rail_width > 0 } {
#@        puts $f "m2_rail_width            = $m2_rail_width;"
#@     }
#@     if { $cell_height > 0 } {
#@        puts $f "cell_height              = $cell_height;"
#@     }
#@     if { $v0_master != "" } {
#@        puts $f "v0_master                = \"$v0_master\";"
#@     }
#@     if { $v1_master != "" } {
#@        puts $f "v1_master                = \"$v1_master\";"
#@     }
#@ 
#@     if { $use_p1272_opts && ($hookup_via_settings != "") } {
#@        # hookup_via_settings are an array of array settings 
#@        # initial names: bndry_gnd_via_master bndry_gnd_via_w bndry_gnd_via_h
#@        #                bndry_pwr_via_master bndry_pwr_via_w bndry_pwr_via_h
#@        #                polyg_pwr_via_master polyg_pwr_via_w polyg_pwr_via_h
#@        # each set is then a string identifier for the arrays
#@        # via_master values are string, w & h values are double
#@        array set legacy_via_setup $hookup_via_settings
#@        foreach hookup_type {bndry_gnd_via bndry_pwr_via polyg_pwr} {
#@           foreach param {master w h} is_real_param {0 1 1} {
#@              set hookup_setting "${hookup_type}_${param}"
#@              if { ! [info exists legacy_via_setup($hookup_setting)] } {
#@                 continue
#@              }
#@              unset -nocomplain hookup_vias
#@              array set hookup_vias $legacy_via_setup($hookup_setting)
#@              foreach key [array names hookup_vias] {
#@                 set value $hookup_vias($key)
#@                 if { $value eq "" } {
#@                    continue
#@                 }
#@                 if { $is_real_param } {
#@                    puts $f "${hookup_setting}\[\"${key}\"\] = $value ;"
#@                 } else {
#@                    puts $f "${hookup_setting}\[\"${key}\"\] = \"$value\";"
#@                 }
#@              }
#@           }
#@        }
#@     }
#@ 
#@     puts $f "use_xll_grid             = $use_xll_grid;"
#@     puts $f "dsn_y_min                = $dsn_y_min;"
#@ 
#@     close $f
#@ }
#@ 
#@ 
#@ # Functions related to ::dtDfm::V0_328_vss_fixing
#@ # JEH 2014-01-31
#@ CmdSpec ::dtDfm::V0_328_vss_fixing {
#@     -help "::dtDfm::V0_328_vss_fixing"
#@     -opts {
#@         {-optname     process_name
#@             -type     string
#@             -default  "p1273.1"
#@             -help     "process name"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "only allow fixing in these cells"
#@         }
#@         {-optname     write_def_file
#@             -type     string
#@             -default  ""
#@             -help     "Write vias placements to DEF file"
#@         }
#@         {-optname     power_name
#@             -type     string
#@             -default  "vcc"
#@             -help     "Name of power rail (default = vcc)"
#@         }
#@         {-optname     ground_name
#@             -type     string
#@             -default  "vss"
#@             -help     "Name of ground rail (default = vss)"
#@         }
#@         {-optname     power_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for power nets"
#@         }
#@         {-optname     ground_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for ground nets"
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # JEH 2014-01-31
#@ proc ::dtDfm::V0_328_vss_fixing {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set keepin_cells_list        $opts(keepin_cells_list)
#@     set write_def_file           $opts(write_def_file)
#@     set power_name               $opts(power_name)
#@     set ground_name              $opts(ground_name)
#@     if { $opts(power_voltage_areas) ne "" } {
#@        upvar $opts(power_voltage_areas) power_voltage_areas
#@        set pwr_va_areas [array get power_voltage_areas]
#@     } else {
#@        set pwr_va_areas ""
#@     }
#@     if { $opts(ground_voltage_areas) ne "" } {
#@        upvar $opts(ground_voltage_areas) ground_voltage_areas
#@        set gnd_va_areas [array get ground_voltage_areas]
#@     } else {
#@        set gnd_va_areas ""
#@     }
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_coord_file ""
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     # set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     ### If UDM, get tech from UDM cell
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@         return 0
#@     }
#@ 
#@     set fillLayer           "via0"
#@     set flowName            "v0_328vssFix"
#@     set container_extension "_v0_328vssFix"
#@ 
#@     # write uin file
#@     set uinfilename "${cellname}${container_extension}.uin"
#@     # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     set uinfilepath "$uindir/$uinfilename"
#@ 
#@     ::dtDfm::V0_328_vss_fixing_writeuin $cellname         $viewname         $techname         $uinfilepath         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $mwlibrary         $write_stm_output         $write_coord_file         $write_def_file         $keepin_cells_list         $power_name         $ground_name         $pwr_va_areas         $gnd_va_areas
#@ 
#@     if { $only_write_uin || $streamlined } {
#@         return ""
#@     }
#@ 
#@     # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@     set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@     set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@     set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@     set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@     set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@     set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@     set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@     set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     set pid [::dtDfm::fill_metal_icv_runflow $cellname                  $flowName                  $container_extension                  0                  $stminputdir                  $uinfilepath                  $icvworkarea                  $icv_options                  $use_lnf_input                  $use_pds                  $launch_script                  $nbpool                  $nbclass                  $nbslot ]
#@ 
#@     # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@     # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set jobInfo ""
#@     ::dtDfm::keylset jobInfo PID           $pid
#@     ::dtDfm::keylset jobInfo CELLNAME      $cellname
#@     ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME      $outputcellname
#@     ::dtDfm::keylset jobInfo VIEWNAME      $viewname
#@     ::dtDfm::keylset jobInfo TECHNAME      $techname
#@     ::dtDfm::keylset jobInfo EXTENSION     $container_extension
#@     ::dtDfm::keylset jobInfo ICVWORKAREA   $icvworkarea
#@     ::dtDfm::keylset jobInfo PROPERTY      $property
#@     ::dtDfm::keylset jobInfo STUBNET       $stubnet
#@     ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@     ::dtDfm::keylset jobInfo RENAME_NETS   $rename_nets
#@     # ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@     ::dtDfm::keylset jobInfo CMD_STR       $print_cmd_str
#@     ::dtDfm::keylset jobInfo LAYER         $fillLayer
#@ 
#@     set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@     lappend jobs $jobInfo
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@     return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::V0_328_vss_fixing_writeuin { cellname                                          viewname                                          techname                                          uinfilepath                                          write_milkyway_output                                          fill_in_cel_view                                          mwoutpath                                          mwlibrary                                          write_stm_output                                          write_coord_file                                          write_def_file                                          keepin_cells_list                                          power_name                                          ground_name                                          {pwr_va_areas ""}                                          {gnd_va_areas ""}                                  } {
#@ 
#@     set f [open "$uinfilepath" w]
#@ 
#@     if { $techname != "" } {
#@         puts $f "process_name = \"$techname\";"
#@     }
#@ 
#@     ::dtDfm::fill_metal_icv_write_output_options_to_uin $f         $write_stm_output         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $cellname         $mwlibrary;
#@ 
#@     set cell_list_option_name "keepin_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepin_cells_list;
#@ 
#@     puts $f "write_def_file           = \"$write_def_file\";"
#@ 
#@     if { $pwr_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $pwr_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "pwr_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "power_name               = \"$power_name\";"
#@     }
#@     if { $gnd_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $gnd_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "gnd_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "ground_name              = \"$ground_name\";"
#@     }
#@ 
#@     close $f
#@ }
#@ 
#@ if {[info exists env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/flexfill/templates/via_color_wrapper.tcl]} {
#@     source $env(CDS_ISS_OVRRD)/flexfill/templates/via_color_wrapper.tcl
#@ }
#@ # -- End source /p/fdk/fdk73/builds/pdk733_r1.7/fill/icv/flexfill/templates/dtDfmFillMetalICV.tcl

#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_pg_hookup.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ ##############################################################################
#@ # Script: route_options_drc.tcl
#@ # Description: Sets Z-Route options to achieve DRV convergence
#@ ##############################################################################
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Common Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_common_options -default true
#@ 
#@ # specifies the routing clock topology - normal routing of clock nets(default : normal)
#@ set_route_zrt_common_options -clock_topology normal
#@ 
#@ #switch forces the router to only allow a single connection to be made to any cell pin
#@ set_route_zrt_common_options -single_connection_to_pins all_pins
#@ 
#@ # control strength of min layer constraint
#@ set_route_zrt_common_options -global_min_layer_mode allow_pin_connection
#@ set_route_zrt_common_options -net_min_layer_mode soft
#@ 
#@ # control strength of max layer constraint
#@ set_route_zrt_common_options -global_max_layer_mode hard
#@ set_route_zrt_common_options -net_max_layer_mode hard
#@ 
#@ 
#@ # amount of information in logfile - range 0 1 2 (default : 0)
#@ set_route_zrt_common_options -verbose_level 1
#@ 
#@ # no documentation on this switch
#@ set_route_zrt_common_options -connect_tie_off true
#@ 
#@ # Ensures route connections are made within the pins
#@ # If connections need to be made to ends of pins this should not be set
#@ #set_route_zrt_common_options -connect_within_pins_by_layer_name {{m1 via_standard_cell_pins}}
#@ 
#@ # control whether or not to rotate the default vias
#@ set_route_zrt_common_options -rotate_default_vias false
#@ 
#@ # control reading in shapes on metal blockage layer
#@ set_route_zrt_common_options -read_user_metal_blockage_layer true
#@ 
#@ # set route_m1ExtraCost 20
#@ #set_route_zrt_common_options -extra_preferred_direction_wire_cost_multiplier_by_layer_name {{m1 20}}
#@ 
#@ # mark clock tree nets as minor-change only (default : true)
#@ set_route_zrt_common_options -mark_clock_nets_minor_change true
#@ 
#@ # reroute clock net shapes  (default : false)
#@ set_route_zrt_common_options -reroute_clock_shapes false
#@ 
#@ # reroute user created shapes (default : false)
#@ set_route_zrt_common_options -reroute_user_shapes false
#@ 
#@ # Redundant via insertion
#@ if {[info exists INTEL_ZROUTE_VIA_DBL] && $INTEL_ZROUTE_VIA_DBL ==1} {
#@   ## Setting this option prior to routing, starts the via doubling,
#@   ## without the need for the standalone command
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion medium
#@ } else {
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion off
#@ }
#@ 
#@ # Enable RC driven layer assignment
#@ if {[info exists INTEL_LAYER_PROMOTION] && $INTEL_LAYER_PROMOTION == 1} {
#@   set_route_zrt_common_options -rc_driven_setup_effort_level high
#@ }
#@ 
#@ # Enable reshielding of modified nets
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   set_route_zrt_common_options -reshield_modified_nets reshield
#@ }
#@ 
#@ ###################################################
#@ #ZRT: Global Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_global_options -default true
#@ 
#@ # enables (true) or disables (false) timing-driven global routing (default : false)
#@ set_route_zrt_global_options -timing_driven true
#@ 
#@ # option -macro_corner_track_utilization limits the utilization of tracks
#@ # available in the gcells near a macro corner to a specified  percentage.
#@ # This  variable is used to control the accessibility of pins and conges-
#@ # tion at the macro corners. By default, the router uses 100  percent  of
#@ # available tracks in the macro boundary width.
#@ set_route_zrt_global_options -macro_corner_track_utilization 95
#@ 
#@ ### performs global routing using effort level (low,medium,high) - tool defualt medium
#@ set_route_zrt_global_options -effort medium
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Track Assignment Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_track_options -default true
#@ 
#@ # Enables  (true)  or disables (false) timing-driven track assign (default : false)
#@ set_route_zrt_track_options -timing_driven true
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Detail Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_detail_options -default true
#@ 
#@ # Initially turn off antenna (if INTEL_ZROUTE_FIX_ANTENNA is set, fix antenna later)
#@ set_route_zrt_detail_options -antenna false
#@ 
#@ # DRC convergence effort level (default : medium)
#@ set_route_zrt_detail_options -drc_convergence_effort_level medium
#@ 
#@ # controls whether the router ignores specific design rule
#@ # The setting says "DO NOT" ignore same_net_metal_space DRV's
#@ set_route_zrt_detail_options -ignore_drc {{same_net_metal_space false}}
#@ 
#@ # specifies whether variable routing rule spacing is ignored against blockages
#@ set_route_zrt_common_options -ignore_var_spacing_to_blockage false
#@ 
#@ # specifies whether variable routing rule spacing is ignored against p/g nets
#@ set_route_zrt_common_options -ignore_var_spacing_to_pg true
#@ 
#@ # specifies whether timing-driven routing is enabled (default : false)
#@ set_route_zrt_detail_options -timing_driven true
#@ 
#@ # Ensure that there is no illegal tapering from NDR width to default width
#@ #set_route_zrt_detail_options -use_wide_wire_to_input_pin true -use_wide_wire_to_output_pin true
#@ 
#@ ## Set this to reduce the initial amount of vias.  The default tool setting is low.
#@ set_route_zrt_detail_options -optimize_wire_via_effort_level medium
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/redundant_via_insertion.tcl

#@ ##############################################################################
#@ 
#@ define_zrt_redundant_vias     -from_via {VIA1A VIA1A VIA1A                    VIA2A VIA2A VIA2A                    VIA2C VIA2C VIA2C                    VIA3C VIA3C VIA3C                    VIA3C_32 VIA3C_32 VIA3C_32                    VIA4A_32 VIA4A_32 VIA4A_32                    VIA4C VIA4C VIA4C                    VIA5B VIA5B VIA5B                    VIA5B_44 VIA5B_44 VIA5B_44                    VIA6A44 VIA6A44 VIA6A44                    VIA7F VIA7F VIA7F}     -from_via_x_size {1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1}     -from_via_y_size {1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1                           1 1 1}     -to_via {VIA1A_DA VIA1A_DB VIA1A_DC                  VIA2A_DA VIA2A_DB VIA2A_DC                  VIA2C_DA VIA2C_DB VIA2C_DC                  VIA3C_DA VIA3C_DB VIA3C_DC                  VIA3C_32_DA VIA3C_32_DB VIA3C_32_DC                  VIA4A_32_DA VIA4A_32_DB VIA4A_32_DC                  VIA4C_DA VIA4C_DB VIA4C_DC                  VIA5B_DA VIA5B_DB VIA5B_DC                  VIA5B_44_DA VIA5B_44_DB VIA5B_44_DC                  VIA6A44_DA VIA6A44_DB VIA6A44_DC                  VIA7F_DA VIA7F_DB VIA7F_DC}     -to_via_x_size {1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1}     -to_via_y_size {1 1 1
#@       1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1                         1 1 1}     -to_via_weights { 10 10 30                           10 10 30                           10 10 30                           10 10 30                           10 10 30                           10 10 30                           10 10 30                           10 10 30                           10 10 30                           10 10 30                           10 10 30 }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/redundant_via_insertion.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/clock_route.tcl

#@ ##############################################################################
#@ ##############################################################################
#@ # List of procs used by this scripts
#@ # 1. P_msg_info
#@ ##############################################################################
#@ 
#@ #Route clock nets
#@ P_msg_info "Routing clock nets"
#@ route_zrt_group -all_clock_nets -reuse_existing_global_route true
#@ 
#@ #Optimize routed clock tree
#@ P_msg_info "Running optimization on routed clock tree"
#@ optimize_clock_tree -routed_clock_stage detail -buffer_sizing -gate_sizing
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/clock_route.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/create_clock_shield.tcl

#@ ##############################################################################
#@ 
#@ ###################################################
#@ # Create clock shield
#@ ###################################################
#@ 
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   create_zrt_shield -preferred_direction_only true -align_to_shape_end true
#@   set_extraction_options -virtual_shield_extraction false
#@   report_zrt_shield
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/create_clock_shield.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/remove_pg_hookup.tcl

#@ ##############################################################################
#@ # script : remove_pg_hookup.tcl
#@ # description : Removes PG hookup from design.
#@ ##############################################################################
#@ 
#@ 
#@ # New Runset based PG Hookup
#@ set items_removed_with_attributes 0
#@ if { [namespace which ::pwr::remove_stdcell_powerhookup] ne "" } {
#@   # use stdcell power hookup attributes for removal
#@   set items_removed_with_attributes [::pwr::remove_stdcell_powerhookup]
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/remove_pg_hookup.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/freeze_clock_nets.tcl

#@ ##############################################################################
#@ ##############################################################################
#@ # List of procs used by this scripts
#@ # 1. P_msg_info
#@ ##############################################################################
#@ 
#@ ###################################################
#@ #Freeze clock nets
#@ ###################################################
#@ #Grab all clock nets
#@ set all_clk_nets [get_nets -hierarchical * -filter @net_type=="Clock"]
#@ 
#@ P_msg_info "Marking clock buf/inv and flops to fixed and clock routes to minor change"
#@ mark_clock_tree -fix_sinks -clock_synthesized
#@ set_net_routing_rule -reroute minorchange $all_clk_nets
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/freeze_clock_nets.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/update_clocks.tcl

#@ ##############################################################################
#@ ##############################################################################
#@ # List of procs used by this scripts
#@ # 1. P_source_if_exists
#@ #    (i) P_rdtConvertSeconds
#@ # 2. P_msg_info
#@ ##############################################################################
#@ 
#@ ###################################################
#@ # Adjust I/O timing and set to propagated clock timing
#@ ###################################################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   set_active_scenarios [all_scenarios]
#@   foreach SCENARIO $INTEL_MCMM_SCENARIOS {
#@     current_scenario $SCENARIO
#@     P_msg_info "Running update_clock_latency for scenario $SCENARIO - Adjusting I/O timing and set to propagated clock timing"
#@     update_clock_latency
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ } else {
#@   P_msg_info "Running update_clock_latency - Adjusting I/O timing and set to propagated clock timing"
#@   update_clock_latency
#@ }
#@ 
#@ ###################################################
#@ # Update clock uncertainty
#@ ###################################################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   set_active_scenarios [all_scenarios]
#@   foreach SCENARIO $INTEL_MCMM_SCENARIOS {
#@     current_scenario $SCENARIO
#@     if {[file exists scripts/update_clock_uncertainty.tcl]} {
#@       P_msg_info "Applying uncertainty values from scripts/update_clock_uncertainty.tcl for scenario $SCENARIO";
#@       P_source_if_exists update_clock_uncertainty.tcl
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ } else {
#@   if {[file exists scripts/update_clock_uncertainty.tcl]} {
#@     P_msg_info "Applying uncertainty values from scripts/update_clock_uncertainty.tcl";
#@     P_source_if_exists update_clock_uncertainty.tcl
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/update_clocks.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_cts.tcl

#@ ##############################################################################
#@ ##############################################################################
#@ # List of procs used by this scripts
#@ # 1. P_check_place_overlap
#@ #    (i) P_msg_info
#@ #    (ii) P_msg_error
#@ # 2. P_msg_info
#@ # 3. P_check_cells
#@ #    (i) P_msg_info
#@ #    (ii) P_msg_warn
#@ #    (iii) P_msg_error
#@ ##############################################################################
#@ 
#@ ##############################################################################
#@ ## Flag overlap cells in the design                                         ##
#@ ##############################################################################
#@ P_check_place_overlap
#@ 
#@ set clk_logic "d04cgc* d04scb* d04cgm* d04scb* d04gbf* d04gin*"
#@ 
#@ #################################################################################
#@ ## Dont_use cells except clock cells                                           ##
#@ #################################################################################
#@ P_msg_info "CHECK_CTS.tcl: dont_use cells except clock cells"
#@ set ref_list $dont_use_list
#@ set icc_local_dont_use_list [list ]
#@ 
#@ set clock_cell_min_delay [list ]
#@ foreach {cell_types cell_description} $ref_list {
#@   set icc_local_dont_use_list [concat $icc_local_dont_use_list "${cell_types} "]
#@ }
#@ 
#@ foreach cell $clk_logic {
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $cell]
#@ }
#@ 
#@ set clock_cell_min_delay "$INTEL_CTS_CELLS_DEFAULT $INTEL_CTS_CELLS_SIZE $INTEL_CTS_CELLS_DELAY_INSERT $INTEL_CTS_CELL_BOUNDARY $INTEL_DELAY_CELL_LIST d04bfn1* d04inn12*"
#@ set icc_local_dont_use_list [lminus $icc_local_dont_use_list $clock_cell_min_delay]
#@ 
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_cells "d04slc* d04swa00* d04swo00* d04pws* d04pws10* d04sc* d04dly0* d04swi00* d04swb00* d04slg* d04sv*"
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $pm_cells]
#@ }
#@ 
#@ set ref_list $icc_local_dont_use_list
#@ set inst_list [get_cells -hierarchical]
#@ set msg "dont_use cell found in design:"
#@ set flag "err"
#@ if { [sizeof_collection $inst_list] > 0 } {
#@   P_check_cells $ref_list $inst_list $msg $flag
#@ } else  {
#@   P_msg_info "Done: Checking cells in the design.."
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_cts.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ ##############################################################################
#@ 
#@ #####################################
#@ # List of procs used in script
#@ # None
#@ ################################
#@ 
#@ 
#@ ## making the net names case insensitive to avoid false violation from LVS
#@ define_name_rules standard_netnames -case_insensitive -type net
#@ 
#@ if {$synopsys_program_name == "icc_shell" && $INTEL_ECO_TYPE != 0 } {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ } else {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ }
#@ 
#@ 
#@ puts "==>INFORMATION: Running default verilog rule , check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules verilog >> $change_name_log_file
#@ 
#@ puts "==>INFORMATION: Running name rule 'standard_netnames_verilog', check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules standard_netnames >> $change_name_log_file
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ ##############################################################################
#@ #Script: tool_constraints.tcl
#@ # List of procs used by this tcl
#@ # 1. P_lminus
#@ # 2. P_msg_info
#@ # 3. get_completed_steps
#@ 
#@ # Density screening
#@ #
#@ # set_congestion_options
#@ #       [-max_util value]: Specifies the layer name whose availability is reduced.
#@ #       [-layer name]: Specifies the availability of the routing resource for the layer
#@ #       [-availability value]: Specifies the availability of the routing resource for the layer
#@ #       [-coordinate {X1 Y1 X2 Y2}]: Specifies the lower left and upper right coordinates
#@ #                                    for which the congestion options will apply.
#@ #                                    The numbers are in microns.
#@ # Example: set_congestion_options -max_util 0.5 -coordinate {0 0 2560 155}
#@ 
#@ 
#@ # Soft blockage (0% utilization during initial place, but allows for buffering later)
#@ #
#@ # create_placement_blockage
#@ #       -bbox rectangle: Specifies the coordinates of the bounding box of the blockage.
#@ #                        rectangle  x1 y1 x2 y2
#@ #       -type soft: Specifies the type of blockage to be created as soft.
#@ #                   With a soft blockage, the placer tries not to place standard cells
#@ #                   or hard macros in the specified region but will do so if the congestion
#@ #                   is too high.
#@ #       [-name blockage_name]: Specifies the optional name of the blockage.
#@ #                              If you  specify  a name  for  the blockage,
#@ #                              you can use it later in the flow to get the blockage by name.
#@ # Example: create_placement_blockage -name hot_corner_plcmnt_blkg_1 -bbox {{4066 259.2} {4096 459.2}} -type soft
#@ # Example: create_placement_blockage -name KO_idv4 -bbox { 540.4 1094.56 579.6  1225.28} -type soft
#@ 
#@ 
#@ # Cells inserted during each flow will have a prefix of the flow name. For ex. placement will have "place" prefix
#@ # If Intel flow variables are not defined, then the default prefix will be used
#@ if {[lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0] != ""} {
#@   set_app_var compile_instance_name_prefix [lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0]
#@ }
#@ 
#@ # Enables congestion removal with the global router
#@ set_app_var placer_enable_enhanced_router true
#@ 
#@ #To prevent side load on output ports
#@ set_isolate_ports -type buffer [filter_collection [all_outputs] "direction=~out"]
#@ 
#@ # Congestion removal effort during coarse placement
#@ set_app_var placer_enable_high_effort_congestion true
#@ 
#@ # Congestion effort during place_opt (default is auto)
#@ # Setting to medium/high, ICC always uses the Zroute global route for congestion-driven placement
#@ set_app_var placer_congestion_effort medium
#@ 
#@ # Prints out Zroute global routing information during congestion-driven placement
#@ set_app_var placer_show_zroutegr_output true
#@ 
#@ # Ensure cells are placed close together for low-utilization blocks
#@ # Recommended setings are somewhere between 0.5 and 0.65
#@ set_app_var placer_max_cell_density_threshold 0.6
#@ 
#@ # Set critical range
#@ set_critical_range $INTEL_CRITICAL_RANGE [get_designs]
#@ 
#@ # Pre-route area and power critical range values
#@ if {[info exists INTEL_AREA_CRITICAL_RANGE] && $INTEL_AREA_CRITICAL_RANGE!="not_set"} {
#@   set_app_var physopt_area_critical_range $INTEL_AREA_CRITICAL_RANGE
#@ }
#@ if {[info exists INTEL_POWER_CRITICAL_RANGE] && $INTEL_POWER_CRITICAL_RANGE != "not_set" } {
#@   set_app_var physopt_power_critical_range $INTEL_POWER_CRITICAL_RANGE
#@ }
#@ 
#@ # Avoid excessive buffering
#@ set_buffer_opt_strategy -effort medium
#@ 
#@ # Set auto high fanout synthesis options
#@ set_ahfs_options     -constant_nets true     -port_map_file outputs/${INTEL_DESIGN_NAME}_ahfs_port_map.txt
#@ 
#@ # Set routing layers
#@ remove_ignored_layers -all
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS
#@ }
#@ P_msg_info "Setting min_routing_layer: $min_routing_layer"
#@ P_msg_info "Setting max_routing_layer: $max_routing_layer"
#@ P_msg_info "Setting rc_ignore_layer:   $rc_ignore_layer"
#@ set_ignored_layers      -min_routing_layer $min_routing_layer     -max_routing_layer $max_routing_layer     -rc_congestion_ignored_layers $rc_ignore_layer
#@ 
#@ 
#@ # Setting default Toggle Rate and Static Probability for power optmization in the absence of SAIF
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@     P_msg_info "Input saif file will be used for dynamic power optmization"
#@   } else {
#@     P_msg_info "Setting default toggle rate $INTEL_POWER_TR and default static probability $INTEL_POWER_SP for dynamic power optimization"
#@     set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@     set_app_var power_default_static_probability $INTEL_POWER_SP
#@   }
#@ }
#@ 
#@ # Power optimization options (turn on dynamic power opt if INTEL_DYNAMIC_POWER is set to 1)
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement true
#@ } else {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement false
#@ }
#@ 
#@ #Enable DRC on constant nets
#@ set_auto_disable_drc_nets -constant false
#@ 
#@ #Ensure the tool observes max_cap constraints during tie-off optimization
#@ set_app_var physopt_new_fix_constants true
#@ 
#@ # Enable via resistance estimation
#@ set_app_var physopt_enable_via_res_support true
#@ 
#@ # Uses alternate name styles to solve name mismatching issues in read_def
#@ set_app_var def_enable_no_legalize_name true
#@ 
#@ # Set multiple port nets options
#@ #        [-feedthroughs]        (fix feedthroughs)
#@ #        [-outputs]             (fix multiple output port nets)
#@ #        [-buffer_constants]    (buffer constants driving multiple ports)
#@ # Without this option, feedthrough ports can be connected directly to each other
#@ # and create text short error in LVS.
#@ set_fix_multiple_port_nets -feedthroughs -outputs -buffer_constants
#@ 
#@ ################################
#@ # Placement
#@ ################################
#@ # Use Zrouter to drive peroute optimization.
#@ if { $::sh_product_version > {I-2013.12-ICC-SP2} } {
#@   set_place_opt_strategy -consider_routing true
#@ }
#@ 
#@ ####################################
#@ # Setting Delay Calculation Options
#@ ####################################
#@ P_msg_info "Setting Delay Calculation as follows :\n Pre-route : Elmore\n Routed Clock : Arnoldi\n Post-route : Arnoldi"
#@ set_delay_calculation_options -preroute elmore -routed_clock arnoldi -postroute arnoldi
#@ 
#@ ####################################
#@ # CTS
#@ ####################################
#@ # The following are used to force CTS to fix more max_cap drcs.
#@ set         ctdn_enable_ccs_low_cap true
#@ set_app_var cto_enable_drc_fixing   true
#@ set         cts_low_power           false
#@ 
#@ ####################################
#@ # Extraction Options
#@ ####################################
#@ 
#@ if { [lsearch -exact [get_completed_steps] fill] > 0} {
#@   set_extraction_options       -real_metalfill_extraction FLOATING       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ } else {
#@   set_extraction_options       -real_metalfill_extraction none       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ ##############################################################################
#@ # Description: This script enables the application of frequency based max-capacitance values
#@ #              The highest frequency in the design is used for max-capacitance lookup
#@ #Required Vars: INTEL_CMAX_DEFAULT_PERIOD - Clock Period used if minimum clock period could not be derived.
#@ #               INTEL_CMAX_LUT - Full Path to Cmax Lookup Table CSV file
#@ #Procs Used:
#@ #1. P_msg_warn
#@ #2. P_msg_error
#@ #3. P_msg_info
#@ 
#@ # Determine maximum frequency
#@ set minperiod [lindex [lsort -increasing -real [get_attribute [get_clocks] period -quiet]] 0]
#@ 
#@ # As a fail-safe, set a default frequency
#@ if {$minperiod eq ""} {
#@   if {[info exists INTEL_CMAX_DEFAULT_PERIOD] && $INTEL_CMAX_DEFAULT_PERIOD != ""} {
#@     P_msg_warn "Minimum period could not be determined. Defaulting to ${INTEL_CMAX_DEFAULT_PERIOD}ps"
#@     set minperiod $INTEL_CMAX_DEFAULT_PERIOD
#@   } else {
#@     P_msg_error "Minimum period could not be determined. Please provide minimum period to use by setting INTEL_CMAX_DEFAULT_PERIOD variable."
#@     return
#@   }
#@ }
#@ 
#@ # Multiplying by 1000 as lookup table values are in GHz
#@ set fmax [expr [expr 1.0/$minperiod] * 1000]
#@ 
#@ # Read reference file
#@ if {[info exists INTEL_CMAX_LUT] && [file exists $INTEL_CMAX_LUT]} {
#@   P_msg_info "Reading Max-Cap LUT file - $INTEL_CMAX_LUT"
#@   set lut_file $INTEL_CMAX_LUT
#@   set fh [open $lut_file "r"]
#@ } else {
#@   P_msg_warn "Either INTEL_CMAX_LUT variable does not exist (or) $INTEL_CMAX_LUT file cannot be found"
#@   return
#@ }
#@ 
#@ if {[info exists INTEL_SCALE_RV_CMAX] && $INTEL_SCALE_RV_CMAX != ""} {
#@   P_msg_info "RV Cmax scaling enabled. Scaling factor value - $INTEL_SCALE_RV_CMAX - has been used..."
#@   set scaling_factor $INTEL_SCALE_RV_CMAX
#@ } else {
#@   set scaling_factor 1
#@ }
#@ 
#@ P_msg_info "Applying frequency based max-capacitance values..."
#@ set err_cnt 0
#@ while {[gets $fh line] > -1} {
#@   set line_vals [split $line ","]
#@   if {[regexp {^cell} $line]} {
#@     set indices [lrange $line_vals 1 end]
#@   } else {
#@     if {[sizeof_collection [set lib_pin [get_lib_pins */[lindex $line_vals 0] -quiet]]]} {
#@       set i 0
#@       set prev_val ""
#@       set curr_val ""
#@       set prev_index ""
#@       set curr_index ""
#@       set new_cmax_value ""
#@       foreach cmax [lrange $line_vals 1 end] {
#@         set prev_val $curr_val
#@         set curr_val $cmax
#@         set prev_index $curr_index
#@         set curr_index [lindex $indices $i]
#@         if {[expr $fmax >= $curr_index]} {
#@           # continue to next value
#@           if {$i == [expr [llength [lrange $line_vals 1 end]] - 1]} {
#@             set new_cmax_value $cmax
#@             break
#@           }
#@         } elseif {$prev_val eq ""} {
#@           # if "" then this is the first index and the fmax is less than the minimum table value
#@           # set to minimum value
#@           set new_cmax_value $cmax
#@           break
#@         } else {
#@           # at this point we should be between two table values. interpolate.
#@           set index_prop [expr ($fmax - $prev_index)/($curr_index - $prev_index)]
#@           set new_cmax_value [expr $index_prop * ($curr_val - $prev_val) + $prev_val]
#@           set new_cmax_value [expr $new_cmax_value * $scaling_factor]
#@           break
#@         }
#@         incr i
#@       }
#@ 
#@       # Check for new_cmax_value
#@       if {$new_cmax_value eq ""} {
#@         P_msg_error "Cmax value not gathered correctly"
#@         incr err_cnt
#@       } elseif {[lindex [get_attribute $lib_pin pin_direction] 0] eq "in"} {
#@         P_msg_error "Library pin is input. Not setting Cmax. Something is likely wrong with the LUT."
#@         P_msg_error "Lib pin - [lindex [get_object_name $lib_pin] 0]"
#@         incr err_cnt
#@       } else {
#@         suppress_message {MWUI-031}
#@         set_attribute $lib_pin max_capacitance $new_cmax_value
#@         unsuppress_message {MWUI-031}
#@       }
#@     } else {
#@       P_msg_warn "Lib pin [lindex $line_vals 0] could not be found"
#@     }
#@   }
#@ }
#@ close $fh
#@ 
#@ if {$err_cnt == 0} {
#@   P_msg_info "Frequency based max-capacitance values applied successfully!"
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options.tcl

#@ ##############################################################################
#@ # Script: route_options.tcl
#@ # Description:
#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ ###################################################
#@ # Set up for hold-fix on all dominate scenarios
#@ ###################################################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   foreach scenario [all_active_scenarios] {
#@     current_scenario $scenario
#@     set_fix_hold [all_clocks]
#@     P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@     set min_delay_cells ""
#@     foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@       set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@     }
#@     if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@       set_prefer -min $min_delay_cells
#@       set_fix_hold_options -default
#@       set_fix_hold_options -preferred_buffer
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ } else {
#@   set_fix_hold [all_clocks]
#@   P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@   set min_delay_cells ""
#@   foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@     set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@   }
#@   if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@     set_prefer -min $min_delay_cells
#@     set_fix_hold_options -default
#@     set_fix_hold_options -preferred_buffer
#@   }
#@ }
#@ 
#@ # Route-opt strategy - this setting is non-persistent
#@ P_msg_info "Setting route_opt strategy"
#@ set_route_opt_strategy     -fix_hold_mode route_base     -search_repair_loops 10     -eco_route_search_repair_loops 10
#@ 
#@ # SI Strategy
#@ # Set SI options to enable the zroute crosstalk reduction and fix violations
#@ P_msg_info "Setting SI parameters"
#@ set_si_options     -route_xtalk_prevention true     -route_xtalk_prevention_threshold 0.25     -timing_window true     -delta_delay true     -min_delta_delay true     -max_transition_mode normal_slew     -analysis_effort medium     -reselect true
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ ##############################################################################
#@ # Script: route_options_drc.tcl
#@ # Description: Sets Z-Route options to achieve DRV convergence
#@ ##############################################################################
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Common Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_common_options -default true
#@ 
#@ # specifies the routing clock topology - normal routing of clock nets(default : normal)
#@ set_route_zrt_common_options -clock_topology normal
#@ 
#@ #switch forces the router to only allow a single connection to be made to any cell pin
#@ set_route_zrt_common_options -single_connection_to_pins all_pins
#@ 
#@ # control strength of min layer constraint
#@ set_route_zrt_common_options -global_min_layer_mode allow_pin_connection
#@ set_route_zrt_common_options -net_min_layer_mode soft
#@ 
#@ # control strength of max layer constraint
#@ set_route_zrt_common_options -global_max_layer_mode hard
#@ set_route_zrt_common_options -net_max_layer_mode hard
#@ 
#@ 
#@ # amount of information in logfile - range 0 1 2 (default : 0)
#@ set_route_zrt_common_options -verbose_level 1
#@ 
#@ # no documentation on this switch
#@ set_route_zrt_common_options -connect_tie_off true
#@ 
#@ # Ensures route connections are made within the pins
#@ # If connections need to be made to ends of pins this should not be set
#@ #set_route_zrt_common_options -connect_within_pins_by_layer_name {{m1 via_standard_cell_pins}}
#@ 
#@ # control whether or not to rotate the default vias
#@ set_route_zrt_common_options -rotate_default_vias false
#@ 
#@ # control reading in shapes on metal blockage layer
#@ set_route_zrt_common_options -read_user_metal_blockage_layer true
#@ 
#@ # set route_m1ExtraCost 20
#@ #set_route_zrt_common_options -extra_preferred_direction_wire_cost_multiplier_by_layer_name {{m1 20}}
#@ 
#@ # mark clock tree nets as minor-change only (default : true)
#@ set_route_zrt_common_options -mark_clock_nets_minor_change true
#@ 
#@ # reroute clock net shapes  (default : false)
#@ set_route_zrt_common_options -reroute_clock_shapes false
#@ 
#@ # reroute user created shapes (default : false)
#@ set_route_zrt_common_options -reroute_user_shapes false
#@ 
#@ # Redundant via insertion
#@ if {[info exists INTEL_ZROUTE_VIA_DBL] && $INTEL_ZROUTE_VIA_DBL ==1} {
#@   ## Setting this option prior to routing, starts the via doubling,
#@   ## without the need for the standalone command
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion medium
#@ } else {
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion off
#@ }
#@ 
#@ # Enable RC driven layer assignment
#@ if {[info exists INTEL_LAYER_PROMOTION] && $INTEL_LAYER_PROMOTION == 1} {
#@   set_route_zrt_common_options -rc_driven_setup_effort_level high
#@ }
#@ 
#@ # Enable reshielding of modified nets
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   set_route_zrt_common_options -reshield_modified_nets reshield
#@ }
#@ 
#@ ###################################################
#@ #ZRT: Global Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_global_options -default true
#@ 
#@ # enables (true) or disables (false) timing-driven global routing (default : false)
#@ set_route_zrt_global_options -timing_driven true
#@ 
#@ # option -macro_corner_track_utilization limits the utilization of tracks
#@ # available in the gcells near a macro corner to a specified  percentage.
#@ # This  variable is used to control the accessibility of pins and conges-
#@ # tion at the macro corners. By default, the router uses 100  percent  of
#@ # available tracks in the macro boundary width.
#@ set_route_zrt_global_options -macro_corner_track_utilization 95
#@ 
#@ ### performs global routing using effort level (low,medium,high) - tool defualt medium
#@ set_route_zrt_global_options -effort medium
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Track Assignment Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_track_options -default true
#@ 
#@ # Enables  (true)  or disables (false) timing-driven track assign (default : false)
#@ set_route_zrt_track_options -timing_driven true
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Detail Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_detail_options -default true
#@ 
#@ # Initially turn off antenna (if INTEL_ZROUTE_FIX_ANTENNA is set, fix antenna later)
#@ set_route_zrt_detail_options -antenna false
#@ 
#@ # DRC convergence effort level (default : medium)
#@ set_route_zrt_detail_options -drc_convergence_effort_level medium
#@ 
#@ # controls whether the router ignores specific design rule
#@ # The setting says "DO NOT" ignore same_net_metal_space DRV's
#@ set_route_zrt_detail_options -ignore_drc {{same_net_metal_space false}}
#@ 
#@ # specifies whether variable routing rule spacing is ignored against blockages
#@ set_route_zrt_common_options -ignore_var_spacing_to_blockage false
#@ 
#@ # specifies whether variable routing rule spacing is ignored against p/g nets
#@ set_route_zrt_common_options -ignore_var_spacing_to_pg true
#@ 
#@ # specifies whether timing-driven routing is enabled (default : false)
#@ set_route_zrt_detail_options -timing_driven true
#@ 
#@ # Ensure that there is no illegal tapering from NDR width to default width
#@ #set_route_zrt_detail_options -use_wide_wire_to_input_pin true -use_wide_wire_to_output_pin true
#@ 
#@ ## Set this to reduce the initial amount of vias.  The default tool setting is low.
#@ set_route_zrt_detail_options -optimize_wire_via_effort_level medium
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/report_pre_route.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ 
#@ # Report preferred routing direction
#@ report_preferred_routing_direction
#@ 
#@ # Report TLU+
#@ report_tlu_plus_files
#@ 
#@ # Check routeablilty
#@ check_zrt_routability
#@ 
#@ # Check for Ideal Nets
#@ set num_ideal [sizeof_collection [all_ideal_nets]]
#@ if {$num_ideal >= 1} {
#@   P_msg_info "$num_ideal Nets are ideal prior to route_opt. Please investigate"
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/report_pre_route.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_trackassign.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ ###################################################
#@ # Run route_opt with track assignment
#@ ###################################################
#@ 
#@ P_msg_info "Running intial route_opt upto track Assignment"
#@ 
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set INTEL_ROUTE_TRACK_ASSIGN_CMD "$INTEL_ROUTE_TRACK_ASSIGN_CMD -power"
#@ }
#@ 
#@ eval $INTEL_ROUTE_TRACK_ASSIGN_CMD
#@ 
#@ #save mw cell
#@ save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_initialTrackAssign
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_trackassign.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_pg_hookup.tcl

#@ ##############################################################################
#@ # script : add_pg_hookup.tcl
#@ # description : Add PG hookup for cells in the design
#@ ##############################################################################
#@ 
#@ 
#@ # Runset based PG Hookup
#@ ::pwr::create_stdcell_powerhookup -powerhookup_cells_area
#@ # -- Starting source /p/fdk/fdk73/builds/pdk733_r1.7/fill/icv/flexfill/templates/dtDfmFillMetalICV.tcl

#@ # -------------------------------------------------------------------
#@ # --- dtDfmFillMetalICV.tcl
#@ # -------------------------------------------------------------------
#@ #               Proprietary Information of Intel Corp.               
#@ # -------------------------------------------------------------------
#@ #   This listing is supplied under the terms of a license agreement  
#@ #   with Intel Corp. and may not be copied nor disclosed except in   
#@ #   accordance with the terms of the agreement.                      
#@ # -------------------------------------------------------------------
#@ #                     (c) 2012-2014 Intel Corp.                          
#@ # -------------------------------------------------------------------
#@ 
#@ # -------------------------------------------------------------------
#@ # --- Header
#@ # -------------------------------------------------------------------
#@ #
#@ # Note.  This section makes sure dependency packages are loaded into 
#@ # Tcl interpreter.  In case the packages could not be loaded 
#@ # (e.g. cist) the corresponding helper functions are instantiated 
#@ # instead.  
#@ #
#@ # The helper functions are taken from dtDfmFillMetalICV_header.tcl 
#@ # which actually takes them from /p/kits/intel/flows/rdt/parseOpt
#@ # package.  
#@ # -------------------------------------------------------------------
#@ 
#@ if { [info command open_mw_lib ] != "" } {
#@   set ICV_MFILL_FOR_ICC 1
#@ } elseif { [info command pa_top_macro ] != "" } {
#@   set ICV_MFILL_FOR_PARADE 1
#@ }
#@ 
#@ 
#@ if { [info exists ICV_MFILL_FOR_PARADE] } {
#@   if {![info exists env(CADPAX_DIR)]} {
#@         #set env(CADPAX_DIR) $env(CAD_ROOT)/cadpax/9.1_shPseOpt64
#@         set env(CADPAX_DIR) $env(CAD_ROOT)/cadpax/9.2.p2_shPseOpt64
#@   }
#@   lappend auto_path $env(CADPAX_DIR)
#@   package require cist
#@   package require param_mgr
#@ }
#@ 
#@ 
#@ #
#@ # Check if parseOpt package can be loaded and CmdSpec + parseOptions procs get defined 
#@ #
#@ if { [info exists ICV_MFILL_FOR_ICC] } {
#@    if { [catch {package require parseOpt}] } {
#@       # error - package was not found in auto_path - try to locate it in the kit
#@       # try to find the package in a valid kit common path
#@       unset -nocomplain __flexfill_orig_auto_path __flexfill_rdt_common
#@       set __flexfill_orig_auto_path $::auto_path
#@       set __flexfill_rdt_common(dirs) ""
#@       if { [file readable /p/kits/intel/flows/rdt] } {
#@          # use the 'ls' builtin from icc_shell
#@          set __flexfill_rdt_common(dirs) [concat $__flexfill_rdt_common(dirs) [ls -1 -dt /p/kits/intel/flows/rdt/*.*.*]]
#@       }
#@       if { [file readable /p/hdk/cad/kits_common] } {
#@          # use the 'ls' builtin from icc_shell
#@          set __flexfill_rdt_common(dirs) [concat $__flexfill_rdt_common(dirs) [ls -1 -dt /p/hdk/cad/kits_common/*.*.*]]
#@       }
#@ 
#@       # order possible common kits by version (major.sub.minor release)
#@       set __flexfill_rdt_common(sort_dirs) {}
#@       foreach __flexfill_rdt_common(elem) $__flexfill_rdt_common(dirs) {
#@          set __flexfill_rdt_common(version) [split [lindex [file split $__flexfill_rdt_common(elem)] end] {.}]
#@          if { [llength $__flexfill_rdt_common(version)] != 3 } {
#@             # not of form major.sub.minor release
#@             continue
#@          }
#@          if { [catch { lsort -real $__flexfill_rdt_common(version) } __flexfill_rdt_common(catch_result)] != 0 } {
#@             # list or {major sub minor} not all integers - ignore
#@             continue
#@          }
#@          lappend __flexfill_rdt_common(sort_dirs) [concat $__flexfill_rdt_common(version) $__flexfill_rdt_common(elem)]
#@       }
#@       set __flexfill_rdt_common(sort_dirs) [lsort -integer -decreasing -index 0 [lsort -integer -decreasing -index 1 [lsort -integer -decreasing -index 2 $__flexfill_rdt_common(sort_dirs)]]]
#@ 
#@ 
#@       # prepend if RDT_COMMON_PATH is set
#@       if { [info exists ::env(RDT_COMMON_PATH)] } {
#@          set __flexfill_rdt_common(sort_dirs) [linsert $__flexfill_rdt_common(sort_dirs) 0 $::env(RDT_COMMON_PATH)]
#@       }
#@ 
#@       # cycle through until parseOpt package is found
#@       foreach __flexfill_rdt_common(elem) $__flexfill_rdt_common(sort_dirs) {
#@          set __flexfill_rdt_common(elem) [lindex ${__flexfill_rdt_common(elem)} end]
#@          if { [file isdirectory ${__flexfill_rdt_common(elem)}/common/pkgs/parseOpt] &&  [file readable ${__flexfill_rdt_common(elem)}/common/pkgs/parseOpt] } {
#@             lappend ::auto_path  ${__flexfill_rdt_common(elem)}/common/pkgs
#@             break
#@          }
#@       }
#@       unset -nocomplain __flexfill_rdt_common
#@       if { $__flexfill_orig_auto_path ne $::auto_path } {
#@          package require parseOpt
#@       }
#@       set ::auto_path $__flexfill_orig_auto_path
#@       unset -nocomplain __flexfill_orig_auto_path
#@ 
#@       if { [lsearch -exact [package names] parseOpt] == -1 } {
#@          puts "Error: unable to find parseOpt package.  Please append ::auto_path to include it or set ::env(RDT_COMMON_PATH) to a valid path"
#@       }
#@    }
#@ }
#@ 
#@ 
#@ #
#@ # If running icc and CmdSpec + parseOptions don't exist, then create the helper functions
#@ #
#@ if { [info exists ICV_MFILL_FOR_ICC] && ([info commands ::CmdSpec] eq "") && ([info commands ::parseOptions] eq "") } {
#@ 
#@ # -------------------------------------------------------------------
#@ # --- CmdSpec
#@ # -------------------------------------------------------------------
#@ proc CmdSpec { args } {
#@       # pre-parse options to make friendly for ::parseOpt::cmdSpec
#@       # Getting procedure full name
#@       set procName [::parseOpt::varPop args]
#@ 
#@       # will check that all opts arguments only use valid options
#@       set validOpt {"optname" "type" "default" "default_from_pg" "help" "required" "values" "filter" "singel_selection" "radio_grp" "hidden"}
#@ 
#@       array set procInfo [::parseOpt::varPop args]
#@       # goal is to remove / reformat invalid opt names
#@       foreach obj [array names procInfo] {
#@          if { ! [regexp -nocase {\-opt} $obj] } {
#@             # skip other arguments, only want to update opts
#@             continue
#@          }
#@          set updated_procInfo_obj {}
#@          set updated_opts {}
#@ 
#@          # Going over the list of options
#@          foreach option $procInfo($obj) {
#@             set updated_option {}
#@             unset -nocomplain type qualifiers
#@             while { [llength $option] > 0 } {
#@                set option_name_full [::parseOpt::varPop option]
#@                regsub {^\-} $option_name_full {} option_name
#@ 
#@                # Ignore epmty variables
#@                if { [regexp {^[[:space:]]*$} $option_name] } { continue }
#@ 
#@                # Check that this is a valid option
#@                if { [lsearch -exact $validOpt $option_name] < 0 } {
#@                   # this is an unknown option so ignore
#@                   # i.e. this could be:  -proc -qualifiers or other.
#@                   if { $option_name eq "qualifiers" } {
#@                      # record qualifier - swap to one_of_string later
#@                      set qualifiers [lindex [::parseOpt::varPop option] 1]
#@                   }
#@                   continue
#@                }
#@ 
#@                set value [::parseOpt::varPop option]
#@ 
#@                if { $option_name eq "type" } {
#@                   set type $value
#@                } else {
#@                   lappend updated_option $option_name_full $value
#@                }
#@             }
#@             if { [info exists type] && $type eq "string" && [info exists qualifiers] } {
#@                lappend updated_option "-type" "one_of_string" "-values" $qualifiers
#@             } elseif { [info exists type] } {
#@                lappend updated_option "-type" $type
#@             }
#@             lappend updated_procInfo_obj $updated_option
#@          }
#@          set procInfo($obj) $updated_procInfo_obj
#@ 
#@       }
#@ 
#@       # uplevel & run the equivalent ::parseOpt::cmdSpec command
#@       # (parseOpt shouldn't actually need the uplevel)
#@       set ::__flexfill_procName $procName
#@       set ::__flexfill_procInfo [array get procInfo]
#@       uplevel 1 { ::parseOpt::cmdSpec $::__flexfill_procName $::__flexfill_procInfo}
#@ 
#@       unset -nocomplain ::__flexfill_procName ::__flexfill_procInfo
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- parseOptions
#@ # -------------------------------------------------------------------
#@ proc parseOptions { args } {
#@       # allow for embedded call to ::parseOpt::parseOptions
#@       # parseOptions takes: args ?caller?
#@       #    args is a single argument that give the list of arguments
#@       #    ?caller? is optional giving the name of the calling proc
#@       unset -nocomplain ::__flexfill_parseOpts_opts __flexfill_parseOpts_args
#@       unset -nocomplain ::__flexfill_procName
#@       set ::__flexfill_procName "parseOptions"
#@       set proc_level [info level]
#@ 
#@       if { [lsearch -exact [lindex $args 0] "-help"] != -1 } {
#@          set print_help 1
#@       } elseif { [lsearch -exact $args "-help"] != -1 } {
#@          set args [lsearch -exact -all -inline -not $args "-help"]
#@          set print_help 1
#@       }
#@ 
#@       # check for ?caller?
#@       if { [llength $args] > 2 } {
#@          unset -nocomplain ::__flexfill_procName
#@          uplevel 1 {error {wrong # args: should be "parseOptions args ?caller?"}}
#@       } elseif { [llength $args] == 2 } {
#@          set ::__flexfill_procName [namespace which [lindex $args 1]]
#@          if { $::__flexfill_procName eq "" } {
#@             set ::__flexfill_procName [lindex $args 1]
#@          }
#@          set args [lindex $args 0]
#@       } elseif { $proc_level < 2 } {
#@          # not in a proc the caller is considered parseOptions
#@       } else {
#@          set ::__flexfill_procName [namespace which [lindex [info level [expr $proc_level - 1]] 0]]
#@          # make sure that the package was defined.
#@          # May need to strip leading :: from the command/namespace
#@          if { ![info exist parseOpt::procInfo(${::__flexfill_procName}:Init)] } {
#@             set ::__flexfill_procName [regsub {^::} $::__flexfill_procName {}]
#@          }
#@           
#@       }
#@ 
#@       if { [info exists print_help] } {
#@          uplevel 1 {
#@             unset -nocomplain opts
#@             ::parseOpt::parseOpts $::__flexfill_procName ::__flexfill_parseOpts_opts "-help"
#@             unset -nocomplain ::__flexfill_procName :: __flexfill_parseOpts_opts
#@             return -code return 1
#@          }
#@       }
#@ 
#@       set ::__flexfill_parseOpts_args $args
#@       set parseOpt_return [uplevel 1 {unset -nocomplain opts ; ::parseOpt::parseOpts $::__flexfill_procName ::__flexfill_parseOpts_opts $::__flexfill_parseOpts_args }]
#@ 
#@       upvar opts return_opts
#@ 
#@       # remove leading '-' in returned opts
#@       foreach opt_name [array names ::__flexfill_parseOpts_opts] {
#@          set return_opts([regsub -- {^-} $opt_name {}]) $::__flexfill_parseOpts_opts($opt_name)
#@       }
#@       unset -nocomplain ::__flexfill_parseOpts_opts ::__flexfill_parseOpts_args
#@ 
#@       if { ! $parseOpt_return } {
#@          uplevel 1 { error "parseOptions - incorrect procedure arguments for $::__flexfill_procName"}
#@       }
#@       unset -nocomplain ::__flexfill_procName
#@ 
#@       return $parseOpt_return
#@ 
#@ }
#@ # end of 'proc parseOptions { args } '
#@ 
#@ }
#@ # end of 'if { [info exists ICV_MFILL_FOR_ICC] && ([info commands ::CmdSpec] eq "")'
#@ 
#@ # -------------------------------------------------------------------
#@ # --- End Header
#@ # -------------------------------------------------------------------
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- ::dtDfm namespace
#@ # -------------------------------------------------------------------
#@ namespace eval ::dtDfm {
#@ }
#@ 
#@ 
#@ CmdSpec ::dtDfm::read_stm {
#@     -help "::dtDfm::read_stm -from_cell test_fill -to_cell test -layers {metal1 metal2 metal3} ... "
#@     -opts {
#@         {-optname     from_cell
#@             -type     string
#@             -default  ""
#@             -help     "name of STM cell from which contents need to be read"
#@         }
#@         {-optname     from_view
#@             -type     string
#@             -default  "stm"
#@             -help     "view name of from_cell"
#@         }
#@         {-optname     to_cell
#@             -type     string
#@             -default  ""
#@             -help     "name of cell into which contents need to be read"
#@         }
#@         {-optname     to_view
#@             -type     string
#@             -default  "lnf"
#@             -help     "view name of the to_cell"
#@         }
#@         {-optname     layers
#@             -type     string
#@             -default  ""
#@             -help     "list of fill layers"
#@         }
#@         {-optname     path
#@             -type     string
#@             -default  ""
#@             -help     "path to the input STM file"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  "1272"
#@             -help     "Techname of the cell"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "net to be assigned to stubs; by default the stubs are assigned syn* nets"
#@         }
#@         {-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "propery to be assigned to fill metal"
#@         }
#@         {-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "propery to be assigned to stubs"
#@         }
#@         {-optname     rename_nets
#@             -type     string
#@             -default  ""
#@             -help     "nets are renamed as per these specs\n\t\t\t\texample { {drv_floatiss_ floatiss_} {near_floatiss_ floatiss_} {far_floatiss_ flaotiss_} }"
#@         }
#@         {-optname     netname_for_untexted_objects
#@             -type     string
#@             -default  "floatiss_"
#@             -help     "netname for untexted objects"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::read_stm { args } {
#@   global env
#@   parseOptions $args
#@   set layers $opts(layers)
#@   set from_cell $opts(from_cell)
#@   set from_view $opts(from_view)
#@   set to_cell $opts(to_cell)
#@   set to_view $opts(to_view)
#@   set from_path $opts(path)
#@   set to_tech p$opts(techname)
#@   set stubnet $opts(stubnet)
#@   set property $opts(property)
#@   set stub_property $opts(stub_property)
#@   set rename_nets $opts(rename_nets)
#@   set netname_for_untexted_objects $opts(netname_for_untexted_objects)
#@  
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view] != "" } {
#@     cell_mgr_rem_cell [cell_mgr_get_mgr] "{$from_cell,$from_view}"
#@   }
#@ 
#@   set cmd "Read -cellname $from_cell -viewname $from_view -nowindow 1"
#@   if { $from_path != "" } {
#@     if {[file exists $from_path] != 0} {
#@       append cmd " -path $from_path"
#@     } else {
#@       ::dtDfm::fill_metal_icv_print_error "Cound not find file $from_path"
#@       return "0"
#@     }
#@   }
#@ 
#@   set openret [eval $cmd]
#@   if { $openret == 0 } {
#@     puts "Fail to open $from_cell, $from_view."
#@     return "0"
#@   }
#@ 
#@   set src [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view]
#@   if { "" == $src } {
#@     puts "Fail to load in ISS result stream file."
#@     return "0"
#@   }
#@ 
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $to_cell $to_view] == "" } {
#@     puts "did not find $to_cell,$to_view"
#@     set cell_boundary [cell_get_boundary "{$from_cell,$from_view}"]
#@     if { [cell_create $to_cell $to_tech $cell_boundary $to_view] == "" } {
#@       puts "failed to create $to_cell,$to_view"
#@       return "0"
#@     }
#@     puts "created $to_cell,$to_view"
#@     Display -cellname $to_cell -viewname $to_view
#@   }
#@ 
#@ 
#@   set objIdList [::dtDfm::copyFromSTMToTop $from_cell                                            $from_view                                            $to_cell                                            $to_view                                            $layers                                            $stubnet                                            $property                                            $stub_property                                            $netname_for_untexted_objects                                            $rename_nets]
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view ] != "" } {
#@     cell_mgr_rem_cell [cell_mgr_get_mgr] "{$from_cell,$from_view}"
#@   }
#@ 
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_run_streamlined ###########################################
#@ proc ::dtDfm::runFillFlow { cellname                             flowname                             stminputdir                             stmoutputdir                             uininputdir                             icv_options                             use_lnf_input                             use_pds 			    launch_script                             nbpool                             nbclass                             nbslot                             perlFlowLogPath                             {background 1}                             {explicit_parallel 0} } {
#@   global env
#@   set fillFlowPlPath ""
#@   set flowfile "fillflow.pl"
#@   if { $explicit_parallel >= 1 } {
#@     set flowfile "fillflow_snap.pl"
#@   }
#@ 
#@ 
#@   if {[info exists  env(MY_DFM_DIR)] && [file exists "$env(MY_DFM_DIR)/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(MY_DFM_DIR)/$flowfile"
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists "$env(PDS_ISS_OVRRD)/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(PDS_ISS_OVRRD)/flexfill/templates/$flowfile"
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists "$env(PDS_ISS_OVRRD)/DTS/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(PDS_ISS_OVRRD)/DTS/flexfill/templates/$flowfile"
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists "$env(CDS_ISS_OVRRD)/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(CDS_ISS_OVRRD)/flexfill/templates/$flowfile"
#@   } 
#@ 
#@   #
#@   # Runset Directory
#@   #
#@ 
#@   set runsetDir {}
#@ 
#@   if {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/flexfill] != 0} {
#@     set runsetDir $env(PDS_ISS_OVRRD)
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/DTS/flexfill] != 0} {
#@     set runsetDir $env(PDS_ISS_OVRRD)/DTS
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/flexfill] != 0} {
#@     set runsetDir $env(CDS_ISS_OVRRD)
#@   }
#@ 
#@ 
#@   #
#@   # Return pid = 0 to indicate error
#@   #
#@   if {$runsetDir == {}} {
#@     ::dtDfm::fill_metal_icv_print_error "ISS runset directory could not be set. Please check your environment settings."
#@     return 0
#@   }
#@ 
#@ 
#@   #
#@   # PXL Directory
#@   #
#@ 
#@   set pxlDir {}
#@   if {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/PXL] != 0} {
#@     set pxlDir $env(PDS_ISS_OVRRD)/PXL
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/DTS/PXL] != 0} {
#@     set pxlDir $env(PDS_ISS_OVRRD)/DTS/PXL
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/PXL] != 0} {
#@     set pxlDir $env(CDS_ISS_OVRRD)/PXL
#@   }
#@ 
#@   #
#@   # Return pid = 0 to indicate error
#@   #
#@   if {$pxlDir == {}} {
#@     ::dtDfm::fill_metal_icv_print_error "PXL directory could not be set. Please check your environment settings."
#@     return 0
#@   }
#@ 
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@   set noclean ""
#@   if { $save_workdir } {
#@     set noclean "--noclean"
#@   }
#@ 
#@   set cmd ""
#@   set runmode "local"
#@   if { $nbpool != "" } {
#@     set runmode "netbatch"
#@   }
#@ 
#@   if { $fillFlowPlPath != "" } {
#@        if { $explicit_parallel >= 1 } {
#@           set opt_nbpool  ""
#@           set opt_nbclass ""
#@           set opt_nbslot  ""
#@           if { $nbpool != "" } {
#@             regsub -all "\'" $nbclass "\"" nbclass
#@             set opt_nbpool  "--nb_pool $nbpool"
#@             set opt_nbclass "--nb_class $nbclass"
#@             set opt_nbslot  "--nb_slot $nbslot"
#@           }
#@           set cmd "$fillFlowPlPath  --layout $cellname --layout_path ${stminputdir} --work_uin $uininputdir --max_jobs $explicit_parallel --output_path ${stmoutputdir} $opt_nbpool $opt_nbclass $opt_nbslot $noclean >& $perlFlowLogPath "
#@        } else {
#@           set cmd "$fillFlowPlPath $cellname                                 $flowname                                 ${stminputdir}                                 ${stmoutputdir}                                 $uininputdir                                 $runsetDir                                 $pxlDir                                 \"$icv_options\"                                 $use_lnf_input                                 $use_pds                                 $runmode                                 \"$launch_script\"                                 $nbpool                                 $nbclass                                 $nbslot >& $perlFlowLogPath " 
#@         }
#@ 
#@         
#@       if { $background == 1 } {
#@           set cmd "$cmd &"
#@       }
#@       
#@       ::dtDfm::fill_metal_icv_print_info "$cmd"
#@       
#@       set pid [eval exec "$cmd"]
#@       return $pid
#@      
#@  } else {
#@     ::dtDfm::fill_metal_icv_print_error "flexfill runset not found -- Please get help from DFM owner"
#@     return 0
#@  }
#@ }
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv_run_streamlined {
#@     -help "::dtDfm::fill_metal_icv -layer {metal1 metal2 metal3 ...} "
#@     -opts {
#@         {-optname     layers
#@             -type     string
#@             -default  ""
#@             -help     "list of fill layers"
#@         }
#@         {-optname     layer_opts
#@             -type     string
#@             -default  ""
#@             -help     "list of opts for each layer"
#@         }
#@         {-optname     prune_cells_lists
#@             -type     string
#@             -default  ""
#@             -help     "list of cells to be pruned each layer"
#@         }
#@         {-optname     tiling_opts
#@             -type     string
#@             -default  ""
#@             -help     "list of tiling opts for each layer"
#@         }
#@    }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_run_streamlined {args} {
#@   global env
#@   parseOptions $args
#@   set layers $opts(layers)
#@   set layer_opts $opts(layer_opts)
#@   set prune_cells_lists $opts(prune_cells_lists)
#@   set tiling_opts $opts(tiling_opts)
#@ 
#@   if { $layers == "" } {
#@     puts "::dtDfm::fill_metal_icv_run_streamlined: empty layers list"
#@     return 0
#@   }
#@ 
#@   set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@   set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@   set fillinmw [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@   set fillincelview [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@   set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@   set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@ 
#@   set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@   set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@   set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@   set techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@   set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@   set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@   set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@   set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@   set explicit_parallel [::dtDfm::keylget ::dtDfm::fill_metal_icv_data EXPLICIT_PARALLEL]
#@   set text_extensions [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TEXT_EXTENSIONS]
#@   set do_final_texting [::dtDfm::keylget ::dtDfm::fill_metal_icv_data DO_FINAL_TEXTING]
#@   set skip_dummy_250 [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SKIP_DUMMY_250]
#@   set no_tracks_file [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NO_TRACKS_FILE]
#@   set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@   set launch_script [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@   if { $explicit_parallel >= 1 } {
#@     set use_pds false
#@   }
#@ 
#@   set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@   set flowname fill_layers
#@   set uinfilename "${cellname}_${flowname}.uin"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   set writeuin_success [::dtDfm::fill_metal_icv_streamlined_writeuin $cellname                                                 $layers                                                 $techname                                                 $uinfilepath                                                 $fillinmw                                                 $fillincelview                                                 $mwoutpath                                                 $mwlibrary                                                 $icvtopworkarea                                                 $write_stm_output                                                 $layer_opts                                                 $tiling_opts                                                 $prune_cells_lists                                                 $text_extensions                                                 $do_final_texting                                                 $skip_dummy_250                                                 $no_tracks_file ]
#@ 
#@   if { $writeuin_success == 0 } {
#@     puts "writeuin failed"
#@     return 1
#@   }
#@   
#@     if { $only_write_uin } {
#@ 	#puts "Writing uin file ${cellname}_fill_layers.uin."
#@ 	return ""
#@     }
#@ 
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@ 
#@   if { [file exists $icvworkarea] != 0 } {
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   foreach  fillLayer $layers {
#@     if { $fillLayer == "poly" } {
#@       set layer_uin_extension "_polyfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_polyfill.rs
#@     } elseif { $fillLayer == "polycon" } {
#@       set layer_uin_extension "_polyconfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_polyconfill.rs
#@     } elseif { $fillLayer == "diffusion" } {
#@       set layer_uin_extension "_diffusionfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_diffusionfill.rs
#@     } elseif { $fillLayer == "libdfmg" } {
#@       set layer_uin_extension "_libdfmgfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_libdfmgfill.rs
#@     } elseif { $fillLayer == "diffcon" } {
#@       set layer_uin_extension "_diffconfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_diffconfill.rs
#@     } elseif { $fillLayer == "tv0" } {
#@       set layer_uin_extension "_tv0fill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_tv0fill.rs
#@     } elseif { $fillLayer == "viat" } {
#@       set layer_uin_extension "_vcgfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_vfillvcg.rs
#@     } elseif { $fillLayer == "viag" } {
#@       set layer_uin_extension "_vctfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_vfillvct.rs
#@     } else {
#@       set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@       if { $result != 0 } {
#@         set layer_uin_extension "_fill${level}"
#@         set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@         set layer_uinfilepath "$uindir/$layer_uinfilename"
#@         file copy -force $layer_uinfilepath ./flexuin_fill${level}.rs
#@       } else {
#@         set result [regexp {via(\d+)} $fillLayer fullstring level]
#@         if { $result != 0 } {
#@           set layer_uin_extension "_vfill${level}"
#@           set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@           set layer_uinfilepath "$uindir/$layer_uinfilename"
#@           file copy -force $layer_uinfilepath ./flexuin_vfill${level}.rs
#@         } else {
#@           set result [regexp {tm(\d+)} $fillLayer fullstring level]
#@           if { $result != 0 } {
#@             set layer_uin_extension "_filltm1"
#@             set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@             set layer_uinfilepath "$uindir/$layer_uinfilename"
#@             file copy -force $layer_uinfilepath ./flexuin_filltm1.rs
#@           } else {
#@             set result [regexp {rdl} $fillLayer fullstring level]
#@             if { $result != 0 } {
#@               set layer_uin_extension "_fillrdl"
#@               set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@               set layer_uinfilepath "$uindir/$layer_uinfilename"
#@               file copy -force $layer_uinfilepath ./flexuin_fillrdl.rs
#@             }
#@           }
#@         }
#@       }
#@     }
#@   }
#@   file copy -force $uinfilepath ./flexuin_fill_layers.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@     cd $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set background 1
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath                              $background                              $explicit_parallel ]
#@ 
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   set interrupted 0
#@   if { $use_pds } {
#@     ::dtDfm::wait_on_pds_job $cellname                              "flexfill"
#@   } else {
#@     set remainingProcesses  [list $pid]   
#@     set pidsover [getTerminatedProcess $remainingProcesses]
#@     if { $pidsover == "" } {
#@ 	   set interrupted 1
#@     }
#@     if { $interrupted == 1 } {
#@       puts "job interrupted"
#@       set cmd "kill SIGKILL {$remainingProcesses}"
#@       puts "$cmd"
#@       catch { eval $cmd }
#@     }
#@   }
#@ 
#@   cd $old_dir
#@ 
#@   if { $interrupted == 1 } {
#@     puts "skipping ::dtDfm::fill_metal_icv_readresults"
#@     return 0
#@   }
#@ 
#@ 
#@   set jobInfo ""
#@   set container_extension "_fill"
#@ 
#@   # ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $layers
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@ 
#@   # ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   if { [::dtDfm::fill_metal_icv_readresults $jobInfo $save_workdir ] == 0 } {
#@           puts "mfill failed for $layers"
#@   }
#@ 
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_streamlined_writeuin { cellname                                                     layers                                                     techname                                                     uinfilepath                                                     fillinmw                                                     fillincelview                                                     mwoutpath                                                     mwlibrary                                                     icvtopworkarea                                                     write_stm_output                                                     layer_opts                                                     tiling_opts                                                     prune_cells_lists                                                     text_extensions 													do_final_texting                                                     skip_dummy_250                                                     no_tracks_file } {
#@   set f [open "$uinfilepath" w]
#@ 
#@   set write_milkyway_output $fillinmw
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fillincelview                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set dfm_via_fast_density [::dtDfm::keylget ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY]
#@   if {$dfm_via_fast_density} {
#@       puts $f "#define DFM_VIA_FAST_DENSITY"
#@   } else {
#@       puts $f "//#define DFM_VIA_FAST_DENSITY"
#@   }
#@ 
#@   set i 0
#@   foreach  fillLayer $layers {
#@     set my_opts [lindex $layer_opts $i]
#@     set my_tiling_opts [lindex $tiling_opts $i]
#@     if { $fillLayer == "poly" } {
#@       puts $f "#define DFM_POLYFILL"
#@     } elseif { $fillLayer == "polycon" } {
#@       puts $f "#define DFM_POLYCONFILL"
#@     } elseif { $fillLayer == "diffusion" } {
#@       puts $f "#define DFM_DIFFUSIONFILL"
#@     } elseif { $fillLayer == "diffcon" } {
#@       puts $f "#define DFM_DIFFCONFILL"
#@     } elseif { $fillLayer == "tv0" } {
#@       puts $f "#define DFM_TV0FILL"
#@     } elseif { $fillLayer == "viat" } {
#@       puts $f "#define DFM_VCTFILL"
#@     } elseif { $fillLayer == "viag" } {
#@       puts $f "#define DFM_VCGFILL"
#@     } else {
#@       set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@       if { $result != 0 } {
#@         puts $f "#define DFM_M${level}FILL $my_opts"
#@         if { $my_tiling_opts != "" } {
#@           puts $f "#define DFM_M${level}FILL_TILE $my_tiling_opts"
#@         }
#@       } else {
#@         set result [regexp {via(\d+)} $fillLayer fullstring level]
#@         if { $result != 0 } {
#@           puts $f "#define DFM_V${level}FILL $my_opts"
#@         } else {
#@           set result [regexp {tm(\d+)} $fillLayer fullstring level]
#@           if { $result != 0 } {
#@            puts $f "#define DFM_TM1FILL $my_opts"
#@           } else {
#@             ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@             return 0
#@           }
#@         }
#@       }
#@     }
#@     incr i
#@   }
#@ 
#@   set i 0
#@   foreach  fillLayer $layers {
#@     set prune_cells_list [lindex $prune_cells_lists $i]
#@     set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@     if { $result != 0 } {
#@       set cell_list_option_name "m${level}_prune_cells_list";
#@       ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $prune_cells_list;
#@     }
#@     incr i
#@   }
#@ 
#@   puts $f "text_extensions = $text_extensions;";
#@   puts $f "do_final_texting = $do_final_texting;";
#@   if { $skip_dummy_250 } {
#@     puts $f "#define SKIP_DUMMY_250";
#@   }
#@   if { $no_tracks_file } {
#@     puts $f "#define NO_TRACKS_FILE";
#@   }
#@   puts $f "process_name = \"$techname\";"
#@ 
#@   close $f
#@   return 1
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_init ######################################################
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv_init {
#@     -help "::dtDfm::fill_metal_icv -cellname abc"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell on which fill is to be performed"
#@         }
#@         {-optname     outputcellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell where fill results should be placed"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  "lnf"
#@             -help     "Viewname of the cell"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  "1272"
#@             -help     "Techname of the cell"
#@         }
#@         {-optname  skip_output
#@          -type     bool
#@          -default  false
#@          -help     "Skip STM output"
#@         }
#@         {-optname  use_lnf_input
#@          -type     bool
#@          -default  false
#@          -help     "Uses LNF from disk as input format for the flow"
#@         }
#@         {-optname  save_workdir
#@          -type     bool
#@          -default  false
#@          -help     "Saves ICV work directory for debugging purpose"
#@         }
#@         {-optname  only_write_uin
#@          -type     bool
#@          -default  false
#@          -help     "When this option is used fill_metal_icv only writes out UIN file"
#@         }
#@         {-optname  streamlined
#@          -type     bool
#@          -default  false
#@          -help     "Do necessary setup to run streamlined metal/via fill\n\t\t\t\tAutomatically turns ON only_write_uin"
#@         }
#@         {-optname  text_extensions
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use real net names for the extensions on the wires of top level nets; only used gy streamlined mode at present"
#@         }
#@         {-optname  do_final_texting
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "do_final_texting for streamlined flow"
#@         }
#@         {-optname  skip_dummy_250
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "skips writing dummy-fill on data-type 250"
#@         }
#@         {-optname  no_tracks_file
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "skips writing tracks files"
#@         }
#@         {-optname  explicit_parallel
#@          -type     int
#@          -default  0
#@          -help     "Run streamlined explicitly parallel (multiple ICV jobs) with specified max number of LOCAL jobs"
#@         }
#@         {-optname  launch_script
#@          -type     string
#@          -default  "null"
#@          -help     "Specify a launch script for particular ICV version"
#@         }
#@         {-optname  nbpool
#@          -type     string
#@          -default  ""
#@          -help     "Enable Netbatch on -explict_parallel max number of Netbatch jobs using pool specified (ie: pdx_dts)"
#@         }
#@         {-optname  nbslot
#@          -type     string
#@          -default  "null"
#@          -help     "Submit netbatch jobs to this specified queue slot (ie: cds)"
#@         }
#@         {-optname  nbclass
#@          -type     string
#@          -default  "SLES10_EM64T_16G"
#@          -help     "Request this type of netbatch machine (default: SLES10_EM64T_16G)"
#@         }
#@         {-optname  uindir
#@          -type     string
#@          -default  "default"
#@          -help     "Location to save UIN files, default location $env(WORK_AREA_ROOT_DIR)/pds/uins"
#@         }
#@         {-optname  stream
#@          -type     string
#@          -default  ""
#@          -help     "Path to an existing stream file, skips generating a new stream file"
#@         }
#@         {-optname  fillinmw
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW"
#@         }
#@         {-optname  fillincelview
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW CEL view"
#@         }
#@         {-optname  mwoutpath
#@          -type     string
#@          -default  ""
#@          -help     "ICC specific option: directory in which MW library resides"
#@         }
#@         {-optname  mwlibrary
#@          -type     string
#@          -default  ""
#@          -help     "ICC specific option: MW library name"
#@         }
#@         {-optname     layer_map_for_mw
#@             -type     string
#@             -default  ""
#@             -help     "ICC specific option: layer map for MW"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "Genesys specific option: net name to be used for stubs\n\t\t\t\tOtherwise stubs are created on syn* nets"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  "Dmi:none:Dmi"
#@             -help     "Genesys specific option: fill metal property info"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  "Stub:Stub:test"
#@             -help     "Genesys specific option: stub property info"
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of options to be used with ICV"
#@         }
#@         {-optname     rename_nets
#@             -type     string
#@             -default  ""
#@             -help     "List of nets to be renamed { {from1 to1} {from2 to2} ... }"
#@         }
#@         {-optname     netname_for_untexted_objects
#@             -type     string
#@             -default  "floatiss_"
#@             -help     "netname for untexted objects"
#@         }
#@         {-optname  skip_result_stm_output
#@          -type     bool
#@          -default  false
#@          -help     "Skip writing final/result layout in GDSII/STM (default output format; only useful when in MW mode)"
#@         }
#@         {-optname  use_pds
#@          -type     bool
#@          -default  false
#@          -help     "Use PDS to launch ICV job; required to support netbatch in non -explict_parallel mode"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_init {args} {
#@   global env
#@   parseOptions $args
#@   set cellname $opts(cellname)
#@ 
#@   set outputcellname $opts(outputcellname)
#@   if {$outputcellname == ""} {
#@     set outputcellname $cellname
#@   }
#@ 
#@   set layer_map_for_mw $opts(layer_map_for_mw)
#@   set fillinmw $opts(fillinmw)
#@   set fillincelview $opts(fillincelview)
#@   set mwoutpath $opts(mwoutpath)
#@   set mwlibrary $opts(mwlibrary)
#@   set skip_output $opts(skip_output)
#@   set use_lnf_input $opts(use_lnf_input)
#@   if { $use_lnf_input } {
#@     set skip_output true
#@   } 
#@   set use_pds $opts(use_pds)
#@   set nbpool  $opts(nbpool)
#@   set nbclass $opts(nbclass)
#@   set nbslot  $opts(nbslot)
#@   set launch_script $opts(launch_script)
#@   set save_workdir $opts(save_workdir)
#@   set uindir $opts(uindir)
#@   set only_write_uin $opts(only_write_uin)
#@   set streamlined $opts(streamlined)
#@   set text_extensions $opts(text_extensions)
#@   set do_final_texting $opts(do_final_texting)
#@   set skip_dummy_250 $opts(skip_dummy_250)
#@   set no_tracks_file $opts(no_tracks_file)
#@   set explicit_parallel $opts(explicit_parallel)
#@   set viewname $opts(viewname)
#@   set techname $opts(techname)
#@   set stubnet $opts(stubnet)
#@   set property $opts(property)
#@   set stub_property $opts(stub_property)
#@   set icv_options $opts(icv_options)
#@   set rename_nets $opts(rename_nets)
#@   set netname_for_untexted_objects $opts(netname_for_untexted_objects)
#@   set stream $opts(stream)
#@   set write_stm_output true
#@   if { $opts(skip_result_stm_output) } {
#@     set write_stm_output false
#@   }
#@ 
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   if { $uindir == "default" } {
#@     set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     if { ![file exists $uindir] } {
#@       puts "$uindir does not exist"
#@       return 0
#@     }
#@     if { [file type $uindir] != "directory" } {
#@       puts "$uindir is not a directory"
#@       return 0
#@     }
#@   }
#@ 
#@   set pid [pid]
#@ 
#@   set icvtopworkarea $env(PDSWORKROOT)/$env(USER).${cellname}.${pid}.iss
#@ 
#@   set ::dtDfm::fill_metal_icv_data ""
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA $icvtopworkarea
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data SAVEWORKDIR    $save_workdir
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data INITIALIZED 1
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLINMW $fillinmw
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLINCELVIEW $fillincelview
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data MWOUTPATH $mwoutpath
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data MWLIBRARY $mwlibrary
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data UINDIR $uindir
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data CELLNAME $cellname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data VIEWNAME $viewname
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TECHNAME $techname
#@   set techname [::dtDfm::fill_metal_icv_get_tech $techname] 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TECHNAME $techname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STUBNET $stubnet
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PROPERTY $property
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME $outputcellname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY false
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data RENAME_NETS $rename_nets
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT $write_stm_output
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data USE_LNF_INPUT $use_lnf_input
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data USE_PDS $use_pds
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBPOOL  $nbpool
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBCLASS $nbclass
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBSLOT  $nbslot
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT  $launch_script
#@ 
#@   
#@ 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STREAMLINED $streamlined
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TEXT_EXTENSIONS $text_extensions
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DO_FINAL_TEXTING $do_final_texting
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data SKIP_DUMMY_250 $skip_dummy_250
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NO_TRACKS_FILE $no_tracks_file
#@   # ED
#@   #if { $streamlined } {
#@   #  set only_write_uin true
#@   #}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ONLYWRITEUIN $only_write_uin
#@ 
#@   if { $streamlined } {
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data EXPLICIT_PARALLEL $explicit_parallel
#@   } elseif { $explicit_parallel >= 1 } {
#@     ::dtDfm::fill_metal_icv_print_error "Explicit_Parallel mode only valid in Streamlined mode"
#@   }
#@ 
#@   if { $streamlined && $explicit_parallel == 0 && $icv_options == "" } {
#@     set icv_options "-ndg -turbo"
#@   } 
#@ 
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@ 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVOPTIONS $icv_options
#@   
#@   # set ::dtDfm::fill_metal_icv_icvtopworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${pid}.iss"
#@   # set ::dtDfm::fill_metal_icv_jobs {}
#@   # set ::dtDfm::fill_metal_icv_correctly 1
#@ 
#@   if { [file exists $icvtopworkarea ] != 0 } {
#@     file delete -force $icvtopworkarea
#@   }
#@   # puts "creating $icvtopworkarea"
#@   file mkdir $icvtopworkarea
#@   file mkdir $icvtopworkarea/input
#@   # file mkdir $icvtopworkarea/output
#@ 
#@   if { $use_pds } {
#@     set stminputdir $env(PDSSTM)
#@   } else {
#@     set stminputdir $icvtopworkarea/input
#@   }
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STMINPUTDIR $stminputdir
#@ 
#@   if { $stream != "" } {
#@     set skip_output 1
#@     if { ([file exists $stream ] != 0) } {
#@       file copy -force $stream $stminputdir
#@       puts "copying file from $stream to $stminputdir"
#@     }
#@   }
#@ 
#@   if { !$skip_output } {
#@     set old_dir [pwd]
#@     cd $icvtopworkarea/input
#@     # set saveret [::dtDfm::fill_metal_icv_saveas $cellname stm $icvtopworkarea/input/${cellname}.stm $layer_map_for_mw]
#@     set saveret [::dtDfm::fill_metal_icv_saveas $cellname stm $stminputdir/${cellname}.stm $layer_map_for_mw]
#@     if { $saveret == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Save Failed"
#@       ::dtDfm::keylset ::dtDfm::fill_metal_icv_data INITIALIZED 0
#@       # set ::dtDfm::fill_metal_icv_correctly 0
#@     }
#@     cd $old_dir
#@   }
#@ 
#@ }
#@ 
#@ set ::dtDfm::region_grids_legal_option_names {region grid_pattern                                               offset                                               period                                               relative_offset                                               break_pattern                                               break_offset                                               break_period                                               break_min_length \    
#@                                               break_pattern_offset_increment                                               far_fill_ete_distance                                               far_fill_sts_distance                                               fill_non_preferred                                               transition_pattern                                               transition_offset                                               transition_period                                               far_fill_ete_distance                                               far_fill_sts_distance                                               is_grating_hole_violation_risk_pattern }
#@ 
#@ 
#@ #
#@ # NOTE: when changing metal or via fill options, keep the 
#@ # the documentation for customers in sync on this Wiki:
#@ #
#@ # https://intelpedia.intel.com/PD-DFM/internal/antares_sg
#@ #
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv {
#@     -help "::dtDfm::fill_metal_icv -cellname abc -viewname -lnf -techname 1272.0 -layer metal2 -offset 0.012 -pattern VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.038C"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "\tName of the cell on which fill is to be performed\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     outputcellname
#@             -type     string
#@             -default  ""
#@             -help     "\tName of the cell where fill is to be placed"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  ""
#@             -help     "Viewname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  ""
#@             -help     "Techname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "Fill metal property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "Stub property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "Genesys specific feature: net name to be used for stubs\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Metal layer to fill - i.e. metal2"
#@         }
#@         {-optname  do_ungridded_fill
#@          -type     bool
#@          -default  false
#@          -help     "Do ungridded fill"
#@         }
#@         {-optname  hybrid
#@          -type     bool
#@          -default  false
#@          -help     "Do hybrid fill"
#@         }
#@         {-optname     pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Pattern has the format triplet1:triplet2:.....\n\t\t\t\twhere triplet has the format netname:width:spacing\n\t\t\t\twidth and spacing are specified in microns\n\t\t\t\twidth may also have a B or C suffix\n\t\t\t\tPattern must be complete including power lines\n\t\t\t\tIn absence of pattern and region_grids ungridded (KLM style) fill is performed"
#@         }
#@ 	{-optname     offset
#@             -type     float
#@             -default  0.0
#@             -help     "Fill pattern offset wrt left/bottom boundary of the cell"
#@         }
#@         {-optname     break_pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Break pattern for the fill wires\n\t\t\t\tWorks with both gridded as well as ungridded fill modes\n\t\t\t\tFormat: pair1:pair2:.....\n\t\t\t\twhere pair has the format wire_length:ete_spacing\n\t\t\t\twire_length and ete_spacing are specified in microns\n\t\t\t\tIn absence of break_pattern wires are broken every fill_length"
#@         }
#@ 	{-optname     break_offset
#@             -type     float
#@             -default  0.0
#@             -help     "Break pattern offset"
#@         }
#@ 	{-optname     break_min_length
#@             -type     float
#@             -default  0.0
#@             -help     "Break pattern min length of wires to apply breaks to"
#@         }
#@         {-optname     transition_pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Transition pattern has the format spacing:width\n\t\t\t\tspacing is spacing from offset or from previous transition\n\t\t\t\twidth is the width of the transition boundary"
#@         }
#@ 	{-optname     transition_offset
#@             -type     float
#@             -default  0.0
#@             -help     "Transition pattern offset"
#@         }
#@ 	{-optname     transition_period
#@             -type     float
#@             -default  0.0
#@             -help     "Transition pattern period"
#@         }
#@         {-optname     grid_patterns
#@          -type        string
#@          -default     ""
#@          -help        "Grid definitions to be used with region grids\n\t\t\t\t{ {grid_name1 grid_pattern1}\n\t\t\t\t{grid_name2 grid_pattern2} ... }"
#@         }
#@         {-optname     break_patterns
#@          -type        string
#@          -default     ""
#@          -help        "Break pattern definitions to be used with region grids\n\t\t\t\t{ {break_pattern_name1 break_pattern1}\n\t\t\t\t{break_pattern_name2 break_pattern2} ... }"
#@         }
#@         {-optname     transition_patterns
#@          -type        string
#@          -default     ""
#@          -help        "transition pattern definitions to be used with region grids\n\t\t\t\t{ {transition_pattern_name1 transition_pattern1}\n\t\t\t\t{transition_pattern_name2 transition_pattern2} ... }"
#@         }
#@         {-optname     region_grids
#@          -type        string
#@          -default     ""
#@          -help        "region grids\n\t\t\t\tfollowing is the old format\n\t\t\t\t{ {polygons_set1 grid_name1 offset1 relative_offset <break_pattern1 break_offset1>}\n\t\t\t\t  {polygons_set2 grid_name2 offset2 relative_offset <break_pattern2 break_offset2>}  ... }\n\t\t\t\tpolygons_set can be CELLBOUNDARY or V3PITCHID or { ply1 ply2 ply3....}\n\t\t\t\teach ply has the format {x1,y1 x2,y2 x3,y3 x4,y4 ....}\n\t\t\t\ta two point polygon is assumed to be a rectangle {xl,yl xh,yh}\n\t\t\t\trelative_offset take boolean values true/false values\n\t\t\t\t\n\t\t\t\tfollowing is the new format\n\t\t\t\t{ option_value_pairs { {option1 value1} {option2 value2} ... }\n\t\t\t\t\t\t{ {option1 value1} {option2 value2} ... } }\n\t\t\t\tallowed options include $::dtDfm::region_grids_legal_option_names\n\t\t\t\t"
#@         }
#@ 	{-optname     fill_length
#@             -type     float
#@             -default  10000.0
#@             -help     "Max fill length: fill wires will be broken every fill_length distance"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@        {-optname     exclCells
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\twires in these cells are not to be extended"
#@        }
#@ 
#@        {-optname  prune_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tlayout from the interior of these cells will be pruned for performance gains"
#@        }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@ 
#@         {-optname  half_dr_end_to_end 
#@          -type     float
#@          -default  -1.0
#@          -help     "EOL spacing from the cell boundary"
#@         }
#@ 
#@         {-optname  output_resolution
#@          -type     float
#@          -default  0.0
#@          -help     "output resolution"
#@         }
#@ 
#@         {-optname     ply
#@          -type     string
#@          -default  ""
#@          -help     "Polygon region based fill, i.e {0.0,0.04 0.0,182.36 207.32,182.36 ...}"
#@         }
#@ 
#@         {-optname     plys
#@          -type     string
#@          -default  ""
#@          -help     "Multiple polygon region based fill, i.e { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  write_sid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write S wires as B wires with overlapping SID layer on it"
#@         }
#@         {-optname  write_cid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write C wires as B wires with overlapping CID layer on it"
#@         }
#@         {-optname  write_bid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write overlapping BID layer on B wires"
#@         }
#@         {-optname  onestep
#@          -type     bool
#@          -default  false
#@          -help     "Run mfill in one step (also calls _init and _end procedures)"
#@         }
#@         {-optname  near_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Near fill density target"
#@         }
#@         {-optname  far_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill density target"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  15.0
#@          -help     "Density window size"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@         {-optname  metal_density_before_via
#@          -type     bool
#@          -default  false
#@          -help     "Do target metal density before via"
#@         }
#@ 
#@         {-optname  use_fill_markers
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use fill markers, applicable only for M0/M1 fill"
#@         }
#@         {-optname  strict_bc_identification
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "turns on the use of the B/C color of existing wires for matching of the grid pattern\n\t\t\t\tthe normal behavior of fill is to ignore the color of wires in the layout."
#@         }
#@         {-optname  consider_off_grid
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Fill an area even if the layout in that area is off-grid"
#@         }
#@         {-optname  dfmg_extensions
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Add dfmg extensions to improve via landing/coverage"
#@         }
#@         {-optname  verbatim
#@          -type     string
#@          -default  ""
#@          -help     "Adds PXL code to UIN file verbatim"
#@         }
#@         {-optname  post_fill_operation
#@          -type     string
#@          -default  ""
#@          -help     "Post fill operation (eg. fill4cmp)"
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of ICV options specific to this layer when run in -explicit_parallel mode (default: -dp1 -turbo-lite)"
#@         }
#@        {-optname     power_nets
#@         -type     string
#@         -default  ""
#@         -help     "Power net names; wires of the specified power nets will be merged in DR clean manner whenever possible"
#@        }
#@         {-optname  fill_container_name
#@          -type     string
#@          -default  ""
#@          -help     "Fill container name; fill from this container is removed in the ECO mode"
#@         }
#@         {-optname  eco_region
#@          -type     string
#@          -default  ""
#@          -help     "ECO is performed in these polygon regions { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  tiling_options
#@          -type     string
#@          -default  ""
#@          -help     "X=microns Y=microns OVERBITE=mirons UNDERBITE=mirons LAYOUT_X=microns LAYOUT_Y=microns\n\t\t\t\texample: X=16 Y=10.5 OVERBITE=1 UNDERBITE=1 LAYOUT_X=16 LAYOUT_Y=42\n\t\t\t\tX and Y are the tile dimensions, LAYOUT_X and LAYOUT_Y are layout dimensions\n\t\t\t\tOVERBITE is the distance beyound the tile boundary the layout is looked up during fill for DR checks while filling individual tile\n\t\t\t\tUNDERBITE is the distance inside the tile boundary from which layout is removed and refilled during tile stitching."
#@         }
#@         {-optname  far_fill_ete_distance
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill region end-to-end distance from existing metal"
#@         }
#@         {-optname  far_fill_sts_distance
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill region side-to-side distance from existing metal"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set cellname $opts(cellname)
#@     set outputcellname $opts(outputcellname)
#@     set property $opts(property)
#@     set stub_property $opts(stub_property)
#@     set temp_techname $opts(techname)
#@ 
#@     set pattern $opts(pattern)
#@     set offset $opts(offset)
#@ 
#@     set break_pattern $opts(break_pattern)
#@     set break_offset $opts(break_offset)
#@ 
#@     set transition_pattern $opts(transition_pattern)
#@     set transition_offset  $opts(transition_offset)
#@     set transition_period  $opts(transition_period)
#@ 
#@     set grid_patterns $opts(grid_patterns)
#@     set break_patterns $opts(break_patterns)
#@     set transition_patterns $opts(transition_patterns)
#@     set region_grids  $opts(region_grids)
#@ 
#@     set far_fill_ete_distance $opts(far_fill_ete_distance)
#@     set far_fill_sts_distance $opts(far_fill_sts_distance)
#@ 
#@     set fill_length $opts(fill_length)
#@     set onestep $opts(onestep)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set do_ungridded_fill $opts(do_ungridded_fill)
#@     set hybrid $opts(hybrid)
#@     set write_sid_layer $opts(write_sid_layer)
#@     set write_cid_layer $opts(write_cid_layer)
#@     set write_bid_layer $opts(write_bid_layer)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@     set half_dr_end_to_end $opts(half_dr_end_to_end)
#@     set output_resolution $opts(output_resolution)
#@     set plys $opts(plys)
#@     set ply $opts(ply)
#@     set exclCells $opts(exclCells)
#@     set prune_cells_list $opts(prune_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set viewname $opts(viewname)
#@     set fillLayer $opts(layer)
#@     set stubnet $opts(stubnet)
#@     set near_fill_density_target $opts(near_fill_density_target)
#@     set far_fill_density_target  $opts(far_fill_density_target)
#@     set density_window_size $opts(density_window_size)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@     set metal_density_before_via $opts(metal_density_before_via)
#@     set icv_options $opts(icv_options)
#@     set power_nets $opts(power_nets)
#@     set eco_region $opts(eco_region)
#@     set fill_container_name $opts(fill_container_name)
#@     set tiling_options $opts(tiling_options)
#@ 
#@ # density_window_y_size, density_window_x_offset , density_window_y_offset, density_window_x_stepping, density_window_y_stepping, density_boundary_assumption, density_kor_assumption metal_density_before_via
#@ 
#@     set use_fill_markers $opts(use_fill_markers)
#@     set strict_bc_identification $opts(strict_bc_identification)
#@     set consider_off_grid $opts(consider_off_grid)
#@     set dfmg_extensions $opts(dfmg_extensions)
#@     set verbatim $opts(verbatim)
#@     set post_fill_operation $opts(post_fill_operation)
#@ 
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     if {$cellname == ""} {
#@       set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     }
#@     if {$outputcellname == ""} {
#@       set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     }
#@     if {$viewname == ""} {
#@       set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     }
#@     if {$temp_techname == ""} {
#@       set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     }
#@     if {$stubnet == ""} {
#@       set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     }
#@     if {$property == ""} {
#@       set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     }
#@     if {$stub_property == ""} {
#@       set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     }
#@     if {$icv_options == ""} {
#@       set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     }
#@ 
#@     set techname [::dtDfm::fill_metal_icv_get_tech $temp_techname]
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@ 
#@     if { $onestep } {
#@       ::dtDfm::fill_metal_icv_init -cellname $cellname
#@     }
#@ 
#@     if { $ply != "" } {
#@       lappend plys $ply
#@     }
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No metal layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set is_metal [regexp {metal(\d+)} $fillLayer fullstring level]
#@     set is_thick_metal [regexp {(tm\d+)} $fillLayer fullstring level]
#@     set is_rdl [regexp {rdl} $fillLayer fullstring level]
#@ 
#@     if { ($is_metal == 0) && ($is_thick_metal ==  0) && ($is_rdl == 0) } {
#@          ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@          return 0
#@     }
#@ 
#@     if { $is_metal } {
#@       set flowName "m${level}fill"
#@       set container_extension "_fill${level}"
#@     }
#@ 
#@     if { $is_thick_metal } {
#@       set flowName "tm1fill"
#@       set container_extension "_filltm1"
#@     }
#@ 
#@     if { $is_rdl } {
#@       set flowName "rdlfill"
#@       set container_extension "_fillrdl"
#@     }
#@ 
#@ 
#@   # write uin file
#@   # <cellname>_fill_layers.uin is written in proc fill_metal_icv_run_streamlined
#@ 
#@   set uinfilename "${cellname}${container_extension}.uin"
#@ #puts "Writing uin file $uinfilename"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   set error_code [::dtDfm::fill_metal_icv_writeuin $cellname                                    $viewname                                    $techname                                    $fillLayer                                    $write_sid_layer                                    $write_cid_layer                                    $write_bid_layer                                    $do_ungridded_fill                                    $hybrid                                    $pattern                                    $offset                                    $break_pattern                                    $break_offset                                    $transition_pattern                                    $transition_offset                                    $transition_period                                    $grid_patterns                                    $break_patterns                                    $transition_patterns                                    $region_grids                                    $fill_length                                    $excludeKOR 				   $top_level_only_kor                                    $korspX                                    $korspY                                    $half_dr_end_to_end                                    $output_resolution                                    $plys                                    $exclCells                                    $keepout_cells_list                                    $keepout_cells_x_space                                    $keepout_cells_y_space                                    $uinfilepath                                    $write_milkyway_output                                    $fill_in_cel_view                                    $mwoutpath                                    $mwlibrary 				   $near_fill_density_target 				   $far_fill_density_target                                    $density_window_size 				   $density_window_y_size 				   $density_window_x_offset                                    $density_window_y_offset                                    $density_window_x_stepping                                    $density_window_y_stepping                                    $density_boundary_assumption                                    $density_kor_assumption                                    $metal_density_before_via                                    $use_fill_markers                                    $strict_bc_identification 				   $consider_off_grid 				   $dfmg_extensions                                   $write_stm_output                                    $verbatim                                    $post_fill_operation                                    $power_nets                                    $eco_region                                    $fill_container_name                                    $far_fill_ete_distance                                    $far_fill_sts_distance ]
#@ 
#@   if { $error_code == 0 } {
#@    return 0
#@   }
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   lappend fillLayers_opts $icv_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@   set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@   lappend prune_cells_lists $prune_cells_list
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS $prune_cells_lists
#@ 
#@   set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   lappend tiling_opts $tiling_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVOPTIONS $icv_options
#@ 
#@   if { $only_write_uin || $streamlined } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                             $flowName                                             $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   if { $onestep } {
#@       ::dtDfm::fill_metal_icv_end
#@   }
#@   return $jobInfo
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- fill_metal_icv_writeuin
#@ #
#@ # Note.  For region_grids old format is depricated.  One is to use
#@ #        the following {option_value_pairs {{opt1_1 val1_1} {opt2_1 val2_1}...} {{opt1_2 val1_2} {opt2_2 val2_2}...} ...}
#@ #
#@ # For instance,
#@ #   [list option_value_pairs
#@ #      [list 
#@ #        [list region polygons({ {{-0.056,-0.040}, {58.856,-0.040}, {58.856,34.354}, {-0.056,34.354}}, })]
#@ #        [list grid_pattern grid_pattern_1]
#@ #        [list offset 0.656]
#@ #        [list period 117.600]
#@ #        [list relative_offset false]
#@ #        [list transition_pattern transition_pattern_1]
#@ #        [list transition_offset -0.040]
#@ #        [list transition_period 58.800]
#@ #        [list is_grating_hole_violation_risk_pattern true]
#@ #      ]
#@ #
#@ #      [list 
#@ #        [list region CELLBOUNDARY]
#@ #        [list grid_pattern grid_pattern_2]
#@ #        [list offset -0.016]
#@ #        [list period 0.672]
#@ #        [list relative_offset false]
#@ #        [list transition_pattern transition_pattern_2]
#@ #        [list transition_offset 0.102]
#@ #        [list transition_period 1.344]
#@ #        [list is_grating_hole_violation_risk_pattern true]
#@ #      ]
#@ #   ] 
#@ # -------------------------------------------------------------------
#@ proc ::dtDfm::fill_metal_icv_writeuin { cellname                                         viewname                                         techname                                         fillLayer                                         write_sid_layer                                         write_cid_layer                                         write_bid_layer                                         do_ungridded_fill                                         hybrid                                         pattern                                         offset                                         break_pattern                                         break_offset                                         transition_pattern                                         transition_offset                                         transition_period                                         grid_patterns                                         break_patterns                                         transition_patterns                                         region_grids                                         fill_length                                         excludeKOR                                         top_level_only_kor                                         korspX 					korspY 					half_dr_end_to_end 					output_resolution 					plys 					exclCells                                         keepout_cells_list                                         keepout_cells_x_space                                         keepout_cells_y_space 					uinfilepath 					write_milkyway_output 					fill_in_cel_view 					mwoutpath 					mwlibrary 					near_fill_density_target 					far_fill_density_target 					density_window_size 					density_window_y_size 					density_window_x_offset 					density_window_y_offset 					density_window_x_stepping 					density_window_y_stepping 					density_boundary_assumption 					density_kor_assumption 					metal_density_before_via 					use_fill_markers                                         strict_bc_identification 					consider_off_grid 					dfmg_extensions                                         write_stm_output                                         verbatim                                         post_fill_operation                                         power_nets                                         eco_region 				        fill_container_name                                         far_fill_ete_distance                                         far_fill_sts_distance } {
#@    set f [open "$uinfilepath" w]
#@ 
#@   if { $pattern != "" } {
#@     if { $plys == "" } {
#@       set grid_pattern_name "grid_pattern"
#@       set grid_pattern_name_with_type "${grid_pattern_name}"
#@     }  else {
#@       set grid_pattern_name "grid_pattern_ply"
#@       set grid_pattern_name_with_type "${grid_pattern_name}:track_pattern"
#@     }
#@     set grid_period($grid_pattern_name) [::dtDfm::fill_metal_icv_write_pattern_to_uin $f $grid_pattern_name_with_type $pattern]
#@     puts $f "offset = $offset;"
#@     puts $f "period = $grid_period($grid_pattern_name);"
#@   }
#@ 
#@   if { $break_pattern != "" } {
#@     set break_pattern_name "break_pattern"
#@     set grid_period($break_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $break_pattern_name $break_pattern]
#@     puts $f "break_offset     = $break_offset;"
#@     puts $f "break_period     = $grid_period($break_pattern_name);"
#@     puts $f "break_min_length = $grid_period($break_pattern_name);" 
#@   }
#@ 
#@   if { $transition_pattern != "" } {
#@     set transition_pattern_name "transition_pattern"
#@     set grid_period($transition_pattern_name) [::dtDfm::fill_metal_icv_write_transition_pattern_to_uin $f $transition_pattern_name $transition_pattern]
#@     puts $f "transition_offset = $transition_offset;"
#@     puts $f "transition_period = $transition_period;"
#@   }
#@ 
#@   if { $grid_patterns != "" } {
#@     foreach grid_def $grid_patterns {
#@       set grid_pattern_name [lindex $grid_def 0]
#@       set grid_pattern_name_with_type "${grid_pattern_name}:track_pattern"
#@       set pattern [lindex $grid_def 1]
#@       set grid_period($grid_pattern_name) [::dtDfm::fill_metal_icv_write_pattern_to_uin $f $grid_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@   if { $break_patterns != "" } {
#@     foreach break_def $break_patterns {
#@       set break_pattern_name [lindex $break_def 0]
#@       set break_pattern_name_with_type "${break_pattern_name}:track_pattern"
#@       set pattern [lindex $break_def 1]
#@       set grid_period($break_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $break_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@   if { $transition_patterns != "" } {
#@     foreach transition_def $transition_patterns {
#@       set transition_pattern_name [lindex $transition_def 0]
#@       set transition_pattern_name_with_type "${transition_pattern_name}:track_pattern"
#@       set pattern [lindex $transition_def 1]
#@       set grid_period($transition_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $transition_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@ 
#@ 
#@   if { $region_grids != "" || $plys != "" } {
#@     set gridded_fill 0
#@     puts $f "region_grids = {"
#@     if { [lindex $region_grids 0]== "option_value_pairs" } {
#@       set gridded_fill 1
#@       set region_grids [lrange $region_grids 1 end]
#@       foreach region_grid $region_grids {
#@         if { [::dtDfm::fill_metal_icv_write_region_grids_option_value_pair_to_uin $f $region_grid ] == 0 } {
#@           close $f
#@           return 0
#@         }
#@       }
#@     } else {
#@       foreach region_grid $region_grids {
#@         set gridded_fill 1
#@ 	set rg_plys [lindex $region_grid 0]
#@ 	set grid_pattern_name [lindex $region_grid 1]
#@ 	set offset [lindex $region_grid 2]
#@ 	set period $grid_period($grid_pattern_name)
#@ 	set relative_offset [lindex $region_grid 3]
#@ 	if { $relative_offset == "" } {
#@ 	  set relative_offset false
#@ 	}
#@ 	set break_pattern_name [lindex $region_grid 4]
#@ 	if { $break_pattern_name != "" } {
#@ 	  set break_pattern_offset [lindex $region_grid 5] 
#@ 	  if { $break_pattern_offset == "" } {
#@ 	    set break_pattern_offset 0.0
#@ 	  }
#@ 
#@      set break_pattern_period     $grid_period($break_pattern_name)
#@ 
#@      set break_pattern_min_length [lindex $region_grid 6]
#@      if {$break_pattern_min_length == "" } {    
#@        set break_pattern_min_length $grid_period($break_pattern_name)
#@      }
#@ 	} else {
#@ 	  set break_pattern_offset     0.0
#@ 	  set break_pattern_period     0.0
#@      set break_pattern_min_length 0.0
#@ 	}
#@ 	::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $rg_plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance       }
#@     }
#@ 
#@       if { $plys != "" } {
#@ 	 set grid_pattern_name "grid_pattern_ply"
#@          if { [info exists grid_period($grid_pattern_name) ] } {
#@            set gridded_fill 1
#@ 	   set period $grid_period($grid_pattern_name)
#@ 	   set relative_offset false
#@ 	   set break_pattern_name ""
#@ 	   set break_pattern_offset 0.0
#@ 	   set break_pattern_period 0.0
#@ 	  ::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance         }
#@       }
#@       puts $f "};"
#@ 
#@       if { $gridded_fill == 0 }  { 
#@         ::dtDfm::fill_metal_icv_write_kors_to_uin_whitebox_mode $f                                                                 $plys                                                                 $fillLayer
#@       }
#@   }
#@ 
#@   if { $techname != "" } {
#@     if { $techname == "1274" } {
#@       # puts $f "#include \"details/drconfig74.rs\" "
#@     }
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   if { $write_sid_layer } {
#@     puts $f "write_out_s_tracks = true;"
#@     puts $f "write_out_s_wires  = false;"
#@   }
#@ 
#@   if { $write_cid_layer } {
#@     puts $f "write_out_c_tracks = true;"
#@     puts $f "write_out_c_wires  = false;"
#@   }
#@ 
#@   if { $write_bid_layer } {
#@     puts $f "write_out_b_tracks = true;"
#@   }
#@ 
#@   puts $f "fill_length = $fill_length;"
#@ 
#@   if { $hybrid } {
#@       puts $f "hybrid = true;"
#@   } else {
#@       puts $f "hybrid = false;"
#@   }
#@ 
#@   if { $do_ungridded_fill } {
#@     puts $f "do_ungridded_fill = true;"
#@   }
#@ 
#@ 
#@   if { $half_dr_end_to_end >= 0.0 } {
#@     puts $f "half_dr_end_to_end = $half_dr_end_to_end;"
#@   }
#@ 
#@   if { $output_resolution >= 0.0 } {
#@     puts $f "output_resolution = $output_resolution;"
#@   }
#@  
#@ 
#@   if { $use_fill_markers == "true"  } {
#@     puts $f "use_fill_markers = true;"
#@   } else {
#@     puts $f "use_fill_markers = false;"
#@   }
#@ 
#@   if { $strict_bc_identification == "true"  } {
#@     puts $f "strict_bc_identification = true;"
#@   }
#@ 
#@   if { $consider_off_grid == "true" } {
#@     puts $f "consider_off_grid = true;"
#@   } else {
#@     puts $f "consider_off_grid = false;"
#@   }
#@ 
#@   if { $dfmg_extensions == "true" } {
#@     puts $f "dfmg_extensions = true;"
#@   } else {
#@     puts $f "dfmg_extensions = false;"
#@   }
#@ 
#@ 
#@   if { $verbatim != "" } {
#@     puts $f $verbatim
#@   }
#@ 
#@   if { $post_fill_operation != "" } {
#@     puts $f "post_fill_operation = \"$post_fill_operation\";"
#@   }
#@ 
#@ 
#@   if { $fill_container_name != "" } {
#@     puts $f "fill_container_name = \"$fill_container_name\";"
#@   }
#@ 
#@   if { $eco_region != "" } {
#@     set leading_string "eco_region = "
#@     set trailing_string ";"
#@     ::dtDfm::write_plys_to_uin $f                                $eco_region                                $leading_string                                $trailing_string
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_no_extend_cells_list_to_uin $f $exclCells;
#@   set cell_list_option_name "no_extend_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $exclCells;
#@ 
#@   set cell_list_option_name "power_nets"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $power_nets;
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f $keepout_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX $korspY;
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $near_fill_density_target                                                 $far_fill_density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@   close $f
#@ 
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_break_pattern_to_uin { f break_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   set period 0
#@   if { $pattern != "" } {
#@     set pattern_records ""
#@     set split_pattern [split $pattern ":"]
#@     set wire_cnt [expr [llength $split_pattern]/2 ]
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@       set wire_width [lindex $split_pattern [expr [expr $wire_num*2] + 0]]
#@       set next_space [lindex $split_pattern [expr [expr $wire_num*2] + 1]]
#@       lappend pattern_records [list $wire_width $next_space ]
#@     }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@     puts $f "$break_pattern_name = $OPEN_BRACE"
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@         set pattern_record [lindex $pattern_records $wire_num]
#@         puts $f "  {[lindex $pattern_record 0], [lindex $pattern_record 1]},"
#@       set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@     }
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@   return $period
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_transition_pattern_to_uin { f transition_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   set period 0
#@   if { $pattern != "" } {
#@     set pattern_records ""
#@     set split_pattern [split $pattern ":"]
#@     set wire_cnt [expr [llength $split_pattern]/2 ]
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@       set wire_width [lindex $split_pattern [expr [expr $wire_num*2] + 0]]
#@       set next_space [lindex $split_pattern [expr [expr $wire_num*2] + 1]]
#@       lappend pattern_records [list $wire_width $next_space ]
#@     }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@     puts $f "$transition_pattern_name = $OPEN_BRACE"
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@         set pattern_record [lindex $pattern_records $wire_num]
#@         puts $f "  {[lindex $pattern_record 0], [lindex $pattern_record 1]},"
#@       set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@     }
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@   return $period
#@ }
#@ 
#@ proc ::dtDfm::getPeriodFromPattern { pattern } {
#@   set period [::dtDfm::fill_metal_icv_write_pattern_to_uin "" "" $pattern]
#@   return $period
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_pattern_to_uin { f grid_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   if { $pattern != "" } {
#@   set pattern_records ""
#@   set split_pattern [split $pattern ":"]
#@   set wire_cnt [expr [llength $split_pattern]/3 ]
#@   for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@     set net_name [lindex $split_pattern [expr [expr $wire_num*3] + 0]]
#@     set wire_width_type [lindex $split_pattern [expr [expr $wire_num*3] + 1]]
#@     if { [regexp -nocase "(.*)C" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "C"
#@     } elseif { [regexp -nocase "(.*)B" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "B"
#@     } elseif { [regexp -nocase "(.*)S" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "S"
#@     } else {
#@       set wire_width $wire_width_type
#@       set wire_type ""
#@     }
#@     set next_space [lindex $split_pattern [expr [expr $wire_num*3] + 2]]
#@     lappend pattern_records [list $wire_width $next_space $wire_type $net_name ]
#@   }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@   if { $f != "" } {
#@     puts $f "$grid_pattern_name = $OPEN_BRACE"
#@   }
#@   set period 0
#@   for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@     if { $wire_num == 0 }  {
#@       set pattern_record [lindex $pattern_records $wire_num]
#@       if { $f != "" } {
#@         puts $f "  {0.000, [lindex $pattern_record 0], \"[lindex $pattern_record 2]\", \"[lindex $pattern_record 3]\"},"
#@       }
#@     } else {
#@       set pattern_record [lindex $pattern_records $wire_num]
#@       set prev_pattern_record [lindex $pattern_records [expr $wire_num - 1]]
#@       if { $f != "" } {
#@         puts $f "  {[lindex $prev_pattern_record 1], [lindex $pattern_record 0], \"[lindex $pattern_record 2]\", \"[lindex $pattern_record 3]\"},"
#@       } 
#@     }
#@     set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@   }
#@   if { $f != "" } {
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@  }
#@  return $period
#@ }
#@ 
#@ proc ::dtDfm::get_pxl_ply { ply  } {
#@   set plxpolygon "{"
#@   set pointcount 0
#@   foreach point $ply {
#@     if { $pointcount != 0 } {
#@      append plxpolygon ", "
#@     }
#@     incr pointcount
#@     append plxpolygon "{$point}"
#@   } 
#@   append plxpolygon "},"
#@   return $plxpolygon
#@ }
#@ 
#@ proc ::dtDfm::write_plys_to_uin { f plys {leading_string "region ="} {trailing_string ","} } {
#@     set specialRegions {"^TOPCELLBOUNDARY" "^CELLBOUNDARY" "V3PITCHID" "ULPPITCHID" }
#@     foreach spr $specialRegions {
#@       if { [regexp $spr $plys] } {
#@         puts $f " $leading_string $plys $trailing_string"
#@         return
#@       }
#@     }
#@ 
#@ #    if { [lsearch $specialRegions $plys] != -1 } {
#@ #      puts $f " $leading_string $plys ,"
#@ #      return
#@ #    }
#@ 
#@     puts $f " $leading_string polygons ({"
#@     set plycount 0
#@     foreach ply $plys {
#@       if { $plycount != 0 } {
#@         # puts -nonewline $f ", "
#@       }
#@       incr plycount
#@       set pxlpolygon [::dtDfm::get_pxl_ply $ply]
#@       puts $f "         $pxlpolygon"
#@     }
#@     puts $f " })$trailing_string"
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_kors_to_uin_whitebox_mode { f                                                           plys                                                           fillLayer } {
#@   set KORNAME [string toupper $fillLayer]KOR_ROUTE
#@   puts $f "$KORNAME = $KORNAME or (CELLBOUNDARY not "
#@   set leading_string ""
#@   set trailing_string ""
#@   ::dtDfm::write_plys_to_uin $f $plys $leading_string $trailing_string
#@   puts $f ");"
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_region_grids_to_uin { f                                                          plys                                                          grid_pattern_name                                                          offset                                                          period                                                          relative_offset                                                          break_pattern_name                                                          break_pattern_offset                                                          break_pattern_period                                                          break_pattern_min_length                                                          far_fill_ete_distance                                                          far_fill_sts_distance } {
#@ 
#@ # region_grids = {
#@ #         {
#@ #         rectangle(10, 10, 20, 20), //put arbitrary ICV code in UIN file for complex region definitions
#@ #         grid_pattern,
#@ #         offset,
#@ #         period,
#@ #         },
#@ # };
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "     $OPEN_BRACE"
#@     ::dtDfm::write_plys_to_uin $f $plys
#@     puts $f "         grid_pattern     = ${grid_pattern_name},"
#@     puts $f "         offset           = $offset,"
#@     puts $f "         period           = $period,"
#@     puts $f "         relative_offset  = $relative_offset,"
#@ if { $break_pattern_name != "" } {
#@     puts $f "         break_pattern    = ${break_pattern_name},"
#@     puts $f "         break_offset     = $break_pattern_offset,"
#@     puts $f "         break_period     = $break_pattern_period,"
#@     puts $f "         break_min_length = $break_pattern_min_length,"
#@ }
#@     puts $f "     $CLOSE_BRACE,"
#@ 
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- fill_metal_icv_writeuin
#@ #
#@ # Note.  Don't forget update ::dtDfm::region_grids_legal_option_names
#@ #        list w/ newly introduced options to support.
#@ # -------------------------------------------------------------------
#@ proc ::dtDfm::fill_metal_icv_write_region_grids_option_value_pair_to_uin { f region_grids } {
#@ 
#@ #  region : polygon_layer;
#@ #  grid_pattern:track_pattern = {};
#@ #  offset:double = 0.0;
#@ #  period:double = 0.0;
#@ #  relative_offset:boolean = false;
#@ #  break_pattern:track_pattern = {};
#@ #  break_offset:double = 0.0;
#@ #  break_period:double = 0.0;
#@ #  break_min_length:double = 0.0;
#@ #  fill_non_preferred:boolean = false;
#@ #  transition_pattern:track_pattern = {};
#@ #  transition_offset:double = 0.0;
#@ #  transition_period:double = 0.0;
#@ 
#@ 
#@     set period_found false
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "     $OPEN_BRACE"
#@     foreach opt_val_pair $region_grids {
#@       set option [lindex $opt_val_pair 0]
#@       set value [lindex $opt_val_pair 1]
#@       if { [lsearch $::dtDfm::region_grids_legal_option_names $option] == -1 } {
#@         puts "$option: Illegal option name in option-value pairs of region_grids"
#@         return 0
#@       }
#@       if { $option == "region" } {
#@         ::dtDfm::write_plys_to_uin $f $value
#@       } else { 
#@         puts $f "         $option = $value,"
#@       }
#@       if { $option == "period" } {
#@         set period_found true
#@       }
#@     }
#@     puts $f "     $CLOSE_BRACE,"
#@ }
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_base_layer ###########################################################
#@ CmdSpec ::dtDfm::fill_base_layer {
#@     -help "::dtDfm::fill_base_layer -layer poly "
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Metal layer to fill - i.e. poly"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@ 
#@         {-optname     ply
#@          -type     string
#@          -default  ""
#@          -help     "Polygon region based fill, i.e {0.0,0.04 0.0,182.36 207.32,182.36 ...}"
#@         }
#@ 
#@         {-optname     plys
#@          -type     string
#@          -default  ""
#@          -help     "Multiple polygon region based fill, i.e { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  near_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Near fill density target"
#@         }
#@         {-optname  far_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill density target"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window size"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@ 
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_base_layer {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@     set plys $opts(plys)
#@     set ply $opts(ply)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set fillLayer $opts(layer)
#@     set near_fill_density_target $opts(near_fill_density_target)
#@     set far_fill_density_target  $opts(far_fill_density_target)
#@     set density_window_size $opts(density_window_size)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@ 
#@ # density_window_y_size, density_window_x_offset , density_window_y_offset, density_window_x_stepping, density_window_y_stepping, density_boundary_assumption, density_kor_assumption 
#@ 
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@ 
#@     set techname [::dtDfm::fill_metal_icv_get_tech $temp_techname]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     if { $ply != "" } {
#@       lappend plys $ply
#@     }
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No metal layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set is_poly      [regexp "poly"       $fillLayer fullstring]
#@     set is_polycon   [regexp "polycon"    $fillLayer fullstring]
#@     set is_diffcon   [regexp "diffcon"    $fillLayer fullstring]
#@     set is_diffusion [regexp "diffusion"  $fillLayer fullstring]
#@     set is_libdfmg   [regexp "libdfmg"    $fillLayer fullstring]
#@ 
#@     if { ($is_poly == 0) && ($is_polycon == 0 ) && ($is_diffcon == 0 ) && ($is_diffusion == 0 ) && ($is_libdfmg == 0) } {
#@          ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@          return 0
#@     }
#@ 
#@     set flowName ${fillLayer}fill
#@     set container_extension _${flowName}
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   set uinfilepath "$uindir/$uinfilename"
#@   set error_code [::dtDfm::fill_base_layer_writeuin $cellname                                    $viewname                                    $techname                                    $fillLayer                                    $excludeKOR                                    $top_level_only_kor                                    $korspX                                    $korspY                                    $plys                                    $keepout_cells_list                                    $uinfilepath                                    $write_milkyway_output                                    $fill_in_cel_view                                    $mwoutpath                                    $mwlibrary 				   				   $near_fill_density_target 				   				   $far_fill_density_target                                    $density_window_size 				   				   $density_window_y_size 				   				   $density_window_x_offset                                    $density_window_y_offset                                    $density_window_x_stepping                                    $density_window_y_stepping                                    $density_boundary_assumption                                    $density_kor_assumption                                    $write_stm_output ]
#@ 
#@   if { $error_code == 0 } {
#@    return 0
#@   }
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   # set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   # lappend fillLayers_opts $icv_options
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@   set tiling_options ""
#@   # set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   # lappend tiling_opts $tiling_options
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@ 
#@   if { $only_write_uin || $streamlined} {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   # fake level
#@   set level 0
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                             $flowName                                             $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fill_base_layer_writeuin { cellname                                         viewname                                         techname                                         fillLayer                                         excludeKOR                                         top_level_only_kor                                         korspX 					korspY 					plys                                         keepout_cells_list 					uinfilepath 					write_milkyway_output 					fill_in_cel_view 					mwoutpath 					mwlibrary 					near_fill_density_target 					far_fill_density_target 					density_window_size 					density_window_y_size 					density_window_x_offset 					density_window_y_offset 					density_window_x_stepping 					density_window_y_stepping 					density_boundary_assumption 					density_kor_assumption                     			write_stm_output } {
#@     set f [open "$uinfilepath" w]
#@     set period 0
#@     if { $plys != "" } {
#@         set grid_pattern_name "grid_pattern_ply"
#@         if { [info exists grid_period($grid_pattern_name) ] } {
#@             catch {set period $grid_period($grid_pattern_name)}
#@         }
#@         set relative_offset false
#@         set break_pattern_name ""
#@         set break_pattern_offset 0.0
#@         set break_pattern_period 0.0
#@         set far_fill_ete_distance 0.0 
#@         set far_fill_sts_distance 0.0
#@ 	::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance 
#@       }
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"p$techname\";"
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f $keepout_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary
#@ 
#@ 
#@   set metal_density_before_via false
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $near_fill_density_target                                                $far_fill_density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@   close $f
#@ 
#@   return 1
#@ }
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_via_icv ##############################################################
#@ set ::dtDfm::hookup_regions_legal_option_names {region nets_above nets_below break_above break_below density_target}
#@ 
#@ CmdSpec ::dtDfm::fill_via_icv {
#@ 
#@     -help "::dtDfm::fill_via_icv -cellname abc -viewname -lnf techname 1272.0 -layer via2"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell on which fill is to be performed\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  ""
#@             -help     "Viewname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  ""
#@             -help     "Techname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "Fill metal property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "Stub property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via2"
#@         }
#@         {-optname     hookup_regions
#@          -type        string
#@          -default     ""
#@          -help        "Hookup regions\n\t\t\t\tfollowing is the old format\n\t\t\t\t{ {polygons_set1 nets_above1 nets_below1 break_above1 break_below1 density_target1}\n\t\t\t\t  {polygons_set2 nets_above2 nets_below2 break_above2 break_below2 density_target2} }\n\t\t\t\tpolygons_set can be CELLBOUNDARY or { ply1 ply2 ply3....}\n\t\t\t\teach ply has the format {x1,y1 x2,y2 x3,y3 x4,y4 ....}\n\t\t\t\ta two point polygon is assumed to be a rectangle {xl,yl xh,yh}\n\t\t\t\tbreak_above/break_below take boolean values true/false values\n\t\t\t\tdensity_target take a float value between 0 and 1\n\t\t\t\t\n\t\t\t\tfollowing is the new format\n\t\t\t\t{ option_value_pairs { {option1 value1} {option2 value2} ... }\n\t\t\t\t\t\t{ {option1 value1} {option2 value2} ... } }\n\t\t\t\tallowed options include $::dtDfm::hookup_regions_legal_option_names\n\t\t\t\t"
#@ 
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@        {-optname     exclCells
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\twires in these cells are not to be extended"
#@        }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname  fill_container_name
#@          -type     string
#@          -default  ""
#@          -help     "Name of the fill container"
#@         }
#@         {-optname  fill_net_names
#@          -type     string
#@          -default  ""
#@          -help     "Names of the fill nets"
#@         }
#@         {-optname  hv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the HV nets"
#@         }
#@         {-optname  ehv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the EHV nets"
#@         }
#@         {-optname  uhv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the UHV nets"
#@         }
#@ 
#@         {-optname  density_target
#@          -type     float
#@          -default  0.10
#@          -help     "Via density target (a number between 0 and 1 e.g. 0.02 is 2%)"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  30.0
#@          -help     "Density window size"
#@         }
#@         {-optname  fast_density
#@          -type     bool
#@          -default  false
#@          -help     "Use a simpler density algorithm to reduce memory / run time"
#@         }
#@         {-optname  density_fill_downto
#@          -type     bool
#@          -default  false
#@          -help     "Fill down to density as opposed up to to density"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@ 
#@         {-optname  iteration_count
#@          -type     integer
#@          -default  1
#@          -help     "Number of Via SG passes to maximize density (with deminising returns)"
#@         }
#@         {-optname  fillincelview
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW CEL view"
#@         }
#@         {-optname  hierarchical_nets  
#@          -type     bool
#@          -default  false
#@          -help     "Supports connections with nets in lower level of hierarchy; identified by names"
#@         }
#@         {-optname  consider_hv_violations
#@          -type     bool
#@          -default  false
#@          -help     "Check for HV rules in via fill."
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of ICV options specific to this layer when run in -explicit_parallel mode (default: -dp1 -turbo-lite)"
#@         }
#@         {-optname  eco_region
#@          -type     string
#@          -default  ""
#@          -help     "ECO is performed in these polygon regions { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  verbatim
#@          -type     string
#@          -default  ""
#@          -help     "Adds PXL code to UIN file verbatim"
#@         }
#@    }
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set cellname            $opts(cellname)
#@     set viewname            $opts(viewname)
#@     set temp_techname       $opts(techname)
#@     set fillLayer           $opts(layer)
#@     set hookup_regions      $opts(hookup_regions)
#@     set property            $opts(property)
#@     set stub_property       $opts(stub_property)
#@     set excludeKOR          $opts(excludeKOR)
#@     set top_level_only_kor  $opts(top_level_only_kor)
#@     set korspX              $opts(korspX)
#@     set korspY              $opts(korspY)
#@     set exclCells           $opts(exclCells)
#@     set fill_container_name $opts(fill_container_name)
#@     set fill_net_names      $opts(fill_net_names)
#@     set hv_nets      $opts(hv_nets)
#@     set ehv_nets      $opts(ehv_nets)
#@     set uhv_nets      $opts(uhv_nets)
#@     set density_target      $opts(density_target)
#@     set density_window_size $opts(density_window_size)
#@     set fast_density $opts(fast_density)
#@     set density_fill_upto $opts(density_fill_downto)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@     set iteration_count     $opts(iteration_count)
#@     set fill_in_cel_view   $opts(fillincelview)
#@     set hierarchical_nets  $opts(hierarchical_nets)
#@     set consider_hv_violations $opts(consider_hv_violations)
#@     set icv_options $opts(icv_options)
#@     set eco_region $opts(eco_region)
#@     set verbatim $opts(verbatim)
#@ 
#@     if {$fast_density} {
#@         ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY $fast_density
#@     }
#@ 
#@     if {$density_fill_upto} {
#@         set density_fill_upto false
#@     } else {
#@         set density_fill_upto true
#@     }
#@ 
#@     if {$cellname == ""} {
#@       set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     }
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     if {$viewname == ""} {
#@       set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     }
#@     if {$temp_techname == ""} {
#@       set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     }
#@ 
#@     set verbatim $opts(verbatim)
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     if {$property == ""} {
#@       set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     }
#@     if {$stub_property == ""} {
#@       set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     }
#@ 
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     if {$icv_options == ""} {
#@       set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     }
#@ 
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No via layer specified"
#@ 	return 0
#@     }
#@ 
#@     if { $fillLayer == "tv0" } {
#@ 	set flowName "tv0fill"
#@ 	set container_extension "_tv0fill"
#@ 	set level "0"
#@     } elseif { $fillLayer == "viat" } {
#@ 	set flowName "vcgfill"
#@ 	set container_extension "_vcgfill"
#@ 	set level "0"
#@     } elseif { $fillLayer == "viag" } {
#@ 	set flowName "vctfill"
#@ 	set container_extension "_vctfill"
#@ 	set level "0"
#@     } else {
#@ 	set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@ 	set flowName "v${level}fill"
#@ 	set container_extension "_vfill${level}"
#@ 	if { $result == 0 } {
#@ 	  ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@ 	  return 0
#@ 	}
#@     }
#@ 
#@ #    set flowName "v${level}fill"
#@ #    set container_extension "_vfill${level}"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fill_via_icv_writeuin $cellname 				 $viewname 				 $techname 				 $fillLayer 				 $hookup_regions 				 $fill_container_name 				 $fill_net_names 				 $hv_nets 				 $ehv_nets 				 $uhv_nets 				 $density_target 				 $density_window_size 				 $fast_density 				 $density_fill_upto 				 $density_window_y_size 				 $density_window_x_offset 				 $density_window_y_offset 				 $density_window_x_stepping 				 $density_window_y_stepping 				 $density_boundary_assumption 				 $density_kor_assumption 				 $excludeKOR 				 $top_level_only_kor 				 $korspX 				 $korspY 				 $exclCells 				 $uinfilepath 				 $write_milkyway_output 				 $fill_in_cel_view 				 $mwoutpath 				 $mwlibrary 				 $write_stm_output 				 $iteration_count 				 $hierarchical_nets 				 $consider_hv_violations 				 $verbatim 				 $eco_region
#@ 
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   lappend fillLayers_opts $icv_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@ 
#@   set prune_cells_list {};
#@   set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@   lappend prune_cells_lists $prune_cells_list
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS $prune_cells_lists
#@ 
#@   set tiling_options "" 
#@   set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   lappend tiling_opts $tiling_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@   if { $only_write_uin || $streamlined } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@   set ::env(PDSSTM) $stminputdir
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname 					   $flowName 					   $container_extension 					   $level 					   $stminputdir 					   $uinfilepath 					   $icvworkarea 					   $icv_options 					   $use_lnf_input 					   $use_pds 					   $nbpool 					   $nbclass 					   $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@   set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_get_net_name_list { fill_net_names } {
#@   if { $fill_net_names != "" } {
#@     set fill_net_name_list ""
#@     regsub -all "," $fill_net_names " " fill_net_names
#@     foreach fill_net_name $fill_net_names {
#@       set fill_net_name_list [concat $fill_net_name_list \"$fill_net_name\",]
#@     }
#@     return "{$fill_net_name_list}"
#@   }
#@   return ""
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_write_hookup_regions_to_uin { f hookup_regions } {
#@ 
#@ # hookup_regions = {
#@ #     {
#@ #         region = CELLBOUNDARY,
#@ #         nets_above = {"*"},
#@ #         nets_below = {"*"},
#@ #         break_above = true,
#@ #         density_target = 0.005,
#@ #     },
#@ #     {
#@ #         region = CELLBOUNDARY,
#@ #         nets_above = {"*"},
#@ #         nets_below = {"*"},
#@ #         break_below = true,
#@ #         density_target = 0.005,
#@ #     }
#@ # };
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "hookup_regions = $OPEN_BRACE"
#@ 
#@     if { [lindex $hookup_regions 0]== "option_value_pairs" } {
#@       set hookup_regions [lrange $hookup_regions 1 end]
#@       foreach hookup_region $hookup_regions {
#@ 	puts $f "     $OPEN_BRACE"
#@         foreach opt_val_pair $hookup_region {
#@           set option [lindex $opt_val_pair 0]
#@           set value [lindex $opt_val_pair 1]
#@           if { [lsearch $::dtDfm::hookup_regions_legal_option_names $option] == -1 } {
#@             puts "$option: Illegal option name in option-value pairs of region_grids"
#@             return 0
#@           }
#@           if { $option == "nets_above" || $option == "nets_below" } {
#@ 	    set value [::dtDfm::fill_via_icv_get_net_name_list $value]
#@           }
#@ 
#@           if { $option == "region" } {
#@             ::dtDfm::write_plys_to_uin $f $value
#@           } else { 
#@             puts $f "         $option = $value,"
#@           }
#@         }
#@ 	puts $f "     $CLOSE_BRACE,"
#@       }
#@     } else {
#@       foreach hookup_region $hookup_regions {
#@ 	set plys [lindex $hookup_region 0]
#@ 	set nets_above [lindex $hookup_region 1]
#@ 	set nets_below [lindex $hookup_region 2]
#@ 	set break_above [lindex $hookup_region 3]
#@ 	set break_below [lindex $hookup_region 4]
#@ 	set density_target [lindex $hookup_region 5]
#@ 
#@ 	puts $f "     $OPEN_BRACE"
#@ 	::dtDfm::write_plys_to_uin $f $plys
#@ 
#@ 	set nets_above_list [::dtDfm::fill_via_icv_get_net_name_list $nets_above]
#@         if { $nets_above_list != "" } {
#@ 	  puts $f "nets_above = $nets_above_list,"
#@         }
#@ 
#@ 	set nets_below_list [::dtDfm::fill_via_icv_get_net_name_list $nets_below]
#@         if { $nets_below_list != "" } {
#@ 	  puts $f "nets_below = $nets_below_list,"
#@         }
#@ 
#@ 	if { $break_above } {
#@ 	  set break_above true
#@ 	} else {
#@ 	  set break_above false
#@ 	}
#@ 	puts $f "break_above = $break_above,"
#@ 
#@ 	if { $break_below } {
#@ 	  set break_below true
#@ 	} else {
#@ 	  set break_below false
#@ 	}
#@ 
#@ 	puts $f "break_below = $break_below,"
#@ 
#@ 	puts $f "density_target = $density_target,"
#@ 	puts $f "     $CLOSE_BRACE,"
#@      }
#@    } 
#@    puts $f "$CLOSE_BRACE;"
#@  
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_writeuin { cellname 				      viewname 				      techname 				      fillLayer                                       hookup_regions                                       fill_container_name                                       fill_net_names                                       hv_nets                                       ehv_nets                                       uhv_nets                                       density_target                                       density_window_size                                       fast_density                                       density_fill_upto 				      density_window_y_size 				      density_window_x_offset                                       density_window_y_offset                                       density_window_x_stepping                                       density_window_y_stepping                                       density_boundary_assumption                                       density_kor_assumption                                       excludeKOR                                       top_level_only_kor                                       korspX                                       korspY                                       exclCells                                       uinfilepath                                       write_milkyway_output                                       fill_in_cel_view                                       mwoutpath                                       mwlibrary                                       write_stm_output                                       iteration_count 				      hierarchical_nets                                        consider_hv_violations                                       verbatim 				      eco_region
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@ 
#@   if { $fill_container_name != "" } {
#@     puts $f "fill_container_name = \"$fill_container_name\";"
#@   }
#@ 
#@   if { $verbatim != "" } {
#@     puts $f $verbatim
#@   }
#@ 
#@   if { $eco_region != "" } {
#@     set leading_string "eco_region = "
#@     set trailing_string ";"
#@     ::dtDfm::write_plys_to_uin $f                                $eco_region                                $leading_string                                $trailing_string
#@   }
#@ 
#@ 
#@   set fill_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $fill_net_names]
#@   if { $fill_net_name_list != "" } {
#@     puts $f "fill_net_names = $fill_net_name_list;"
#@   }
#@   set hv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $hv_nets]
#@   if { $hv_net_name_list != "" } {
#@     puts $f "hv_nets = $hv_net_name_list;"
#@   }
#@   set ehv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $ehv_nets]
#@   if { $ehv_net_name_list != "" } {
#@     puts $f "ehv_nets = $ehv_net_name_list;"
#@   }
#@   set uhv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $uhv_nets]
#@   if { $uhv_net_name_list != "" } {
#@     puts $f "uhv_nets = $uhv_net_name_list;"
#@   }
#@ 
#@   if { $hookup_regions != "" } {
#@     ::dtDfm::fill_via_icv_write_hookup_regions_to_uin $f $hookup_regions
#@   }
#@ 
#@   if { $iteration_count > 0 } {
#@     puts $f "iteration_count = $iteration_count;"
#@   }
#@ 
#@   if { $hierarchical_nets  } {
#@     puts $f "hierarchical_nets  = true;"
#@   }
#@    if { $consider_hv_violations } {
#@     puts $f "consider_hv_violations = true;"
#@   }
#@   puts $f "density_fill_upto = $density_fill_upto;"
#@   puts $f "density_fill_upto = $density_fill_upto;"
#@ 
#@   if { $density_kor_assumption } {
#@     set density_kor_assumption "true"
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f  $exclCells;
#@ 
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $exclCells
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   puts $f "density_target = $density_target;"
#@ 
#@   set metal_density_before_via false
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $density_target                                                $density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::upsz_via ##################################################################
#@ CmdSpec ::dtDfm::upsz_via {
#@ 
#@     -help "::dtDfm::upsz_via -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::upsz_via {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No via layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     if { $result == 0 || $level != 1 } {
#@       ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       return 0
#@     }
#@ 
#@     set flowName "v${level}upsz"
#@     set container_extension "_vupsz${level}"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::upsz_via_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin || $streamlined} {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::upsz_via_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fix_vcx250 ##################################################################
#@ CmdSpec ::dtDfm::fix_vcx250 {
#@ 
#@     -help "::dtDfm::fix_vcx250 -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fix_vcx250 {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     # if { $fillLayer == "" } {
#@ 	# ::dtDfm::printErr "No via layer specified"
#@ 	# return 0
#@     #}
#@ 
#@ 
#@     set fillLayer "viat"
#@     set level 0
#@     # set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     # if { $result == 0 || $level != 1 } {
#@       # ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       # return 0
#@     # }
#@ 
#@     set flowName "vcx250"
#@     set container_extension "_vcx250"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fix_vcx250_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary 
#@                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds 											$launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fix_vcx250_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::rename_mw_nets ##################################################################
#@ CmdSpec ::dtDfm::rename_nets {
#@ 
#@     -help "::dtDfm::rename_mw_nets "
#@     -opts {
#@         {-optname     mw_cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the mw output cell"
#@         }
#@         {-optname     nets_to_rename
#@             -type     string
#@             -default  ""
#@             -help     "regular expression identifying nets to be renamed"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::rename_nets { args } {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set mw_cellname $opts(mw_cellname)
#@     set nets_to_rename $opts(nets_to_rename)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     # set print_cmd_str [info level [info level]]
#@     # ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     set flowName "renamenets"
#@     set container_extension "_renamenets"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::rename_nets_writeuin  $mw_cellname                                  $nets_to_rename                                  $viewname                                  $techname                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output
#@ 
#@  # if { $only_write_uin || $streamlined }
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set level 1 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@  set fillLayer metal1
#@ 
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@ #  ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::rename_nets_writeuin { cellname                                      nets_to_rename 				                     viewname 				                     techname                                      uinfilepath                                      write_milkyway_output                                      fill_in_cel_view                                      mwoutpath                                      mwlibrary                                      write_stm_output 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   if { $nets_to_rename != "" } {
#@     puts $f "nets_to_rename = \"$nets_to_rename\";"
#@   }
#@ 
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_end ########################################################
#@ 
#@ proc ::dtDfm::fill_metal_icv_end { } {
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@   if { $streamlined } {
#@     set fillLayers        [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@     set fillLayers_opts   [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@     set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@     set tiling_opts       [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@     return [::dtDfm::fill_metal_icv_run_streamlined -layers $fillLayers -layer_opts $fillLayers_opts -tiling_opts $tiling_opts -prune_cells_lists $prune_cells_lists ]
#@   }
#@ 
#@   set jobids ""
#@   # puts "fill_metal_icv_jobs : $::dtDfm::fill_metal_icv_jobs" 
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@ 
#@   foreach job $jobs {
#@     lappend jobids [::dtDfm::keylget job PID]
#@     set metalLayer [::dtDfm::keylget job LAYER]
#@     set resubmitCount($metalLayer) 0
#@   }
#@ 
#@   # puts $jobids
#@   set remainingProcesses $jobids
#@   set jobsidover ""
#@ 
#@   set interrupted 0
#@   while { [llength $jobids] != [llength $jobsidover] } {
#@ 
#@     # set exitstatus [wait]
#@     # set pidover [lindex $exitstatus 0]
#@     set pidsover [getTerminatedProcess $remainingProcesses]
#@ 	if { $pidsover == "" } {
#@ 	   set interrupted 1
#@ 	   break 
#@ 	}
#@     foreach pidover $pidsover {
#@       set remainingProcesses [::dtDfm::lremove $remainingProcesses $pidover]
#@       set jobindex [lsearch $jobids $pidover]
#@       if { $jobindex != -1 } {
#@         set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@         set jobinfo [lindex $jobs $jobindex]
#@         # puts $jobinfo
#@         set fillLayer [::dtDfm::keylget jobinfo LAYER]
#@         if { [::dtDfm::fill_metal_icv_readresults $jobinfo $save_workdir ] == 0 } {
#@           puts "mfill failed for $fillLayer"
#@           if { [info exists resubmitCount($fillLayer) ] == 0  || $resubmitCount($fillLayer) == 0 } {
#@             incr resubmitCount($fillLayer)
#@             set print_cmd_str [::dtDfm::keylget jobinfo CMD_STR]
#@             # puts "resubmitting $jobinfo $print_cmd_str"
#@             set newJobInfo [eval $print_cmd_str]
#@             set newJobPid [::dtDfm::keylget newJobInfo PID]
#@             lappend jobids $newJobPid
#@             lappend remainingProcesses $newJobPid
#@             puts "resubmitting $fillLayer: $newJobPid"
#@           }
#@         } else {
#@           puts "mfill succeded for $fillLayer"
#@         }
#@ 
#@         lappend jobsidover $pidover
#@       }
#@     }
#@   }
#@ 
#@   if { $interrupted == 1 } {
#@     puts "job interrupted"
#@     set cmd "kill SIGKILL {$remainingProcesses}"
#@     puts "$cmd"
#@     ::dtDfm::delete_all_fill
#@     catch { eval $cmd }
#@   }
#@ 
#@   # set ::dtDfm::fill_metal_icv_jobs ""
#@ 
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   if { !$save_workdir } {
#@     if { ([file exists $icvtopworkarea/input] != 0) } {
#@       file delete -force $icvtopworkarea/input
#@     }
#@   } else {
#@     puts "saving $icvtopworkarea"
#@   }
#@ 
#@ }
#@ 
#@ proc getTerminatedProcess { pids } {
#@   while { 1 } {
#@     if { [::dtDfm::interrupted] } {
#@       return ""
#@     }
#@ 
#@     set livepids ""
#@     catch { set livepids [eval exec "ps -o pid -p $pids"] }
#@     set terminatedPids ""
#@     foreach pid $pids {
#@        if { [lsearch $livepids $pid] == -1 } {
#@           lappend terminatedPids $pid
#@        }
#@     }
#@     if { [llength $terminatedPids] > 0 } {
#@       return $terminatedPids
#@     }
#@      exec sleep 1
#@   }
#@ 
#@ }
#@ 
#@ ##################################### Common functions used by several uin writers ############################################################
#@ proc ::dtDfm::fill_metal_icv_write_kor_options_to_uin { f                                             excludeKOR                                             top_level_only_kor                                             korspX                                             korspY } {
#@   set use_drawn_kor "true"
#@   if { $excludeKOR } { 
#@     set use_drawn_kor "false"
#@   }
#@ 
#@   puts $f "use_drawn_kor = $use_drawn_kor;"
#@   if { $use_drawn_kor == "true" } {
#@ 
#@     puts $f "top_level_only_kor = $top_level_only_kor;"
#@ 
#@     puts $f "drawn_kor_x_space = $korspX;"
#@     puts $f "drawn_kor_y_space = $korspY;"
#@   }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_density_to_uin {  f                                                  near_fill_density_target                                                  far_fill_density_target                                                  density_window_size                                                  density_window_y_size                                                  density_window_x_offset                                                  density_window_y_offset                                                  density_window_x_stepping                                                  density_window_y_stepping                                                  density_boundary_assumption                                                  density_kor_assumption                                                  metal_density_before_via } {
#@   set target_density_mode 0
#@   if { $near_fill_density_target > 0.0 } {
#@     puts $f "near_fill_density_target = $near_fill_density_target;"
#@     set target_density_mode 1
#@   }
#@ 
#@   if { $far_fill_density_target > 0.0 } {
#@     puts $f "far_fill_density_target = $far_fill_density_target;"
#@     set target_density_mode 1
#@   }
#@ 
#@   if { $target_density_mode } {
#@     if { $density_window_size > 0.0 } {
#@       puts $f "density_window_size = $density_window_size;"
#@     }
#@ 
#@     if { $density_window_y_size > 0.0 } {
#@       puts $f "density_window_y_size = $density_window_y_size;"
#@     }
#@ 
#@     if { $density_window_x_offset > 0.0 } {
#@       puts $f "density_window_x_offset= $density_window_x_offset;"
#@     }
#@ 
#@     if { $density_window_y_offset > 0.0 } {
#@       puts $f "density_window_y_offset = $density_window_y_offset;"
#@     }
#@ 
#@     if { $density_window_x_stepping > 0.0 } {
#@       puts $f "density_window_x_stepping = $density_window_x_stepping;"
#@     }
#@ 
#@     if { $density_window_y_stepping > 0.0 } {
#@       puts $f "density_window_y_stepping = $density_window_y_stepping;"
#@     }
#@ 
#@     if { $density_boundary_assumption != -1 } {
#@       puts $f "density_boundary_assumption = $density_boundary_assumption;"
#@     }
#@ 
#@     if { $density_kor_assumption } {
#@       puts $f "density_kor_assumption = $density_kor_assumption;"
#@     }
#@ 
#@     if { $metal_density_before_via } {
#@       puts $f "#define METAL_DENSITY_BEFORE_VIA"
#@     }
#@   }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_output_options_to_uin {  f                                                 write_stm_output                                                 write_milkyway_output                                                 fill_in_cel_view                                                 mwoutpath                                                 cellname                                                 mwlibrary } {
#@ 
#@     if { [info exists ::env(PVPD_PIF_TOOL_NAME)] } {
#@         set toolname $::env(PVPD_PIF_TOOL_NAME)
#@         if {$toolname == "genesys" || $toolname == "genoa" || $toolname == "gena" || $toolname == "gend"} {
#@             puts $f "//set to true for cadworks"
#@             puts $f "write_stm_output = true;"
#@         } elseif { !$write_stm_output} {
#@             puts $f "write_stm_output = false;"
#@         }
#@     } elseif { !$write_stm_output} {
#@         puts $f "write_stm_output = false;"
#@     }
#@     
#@   if { $write_milkyway_output } {
#@     puts $f "write_milkyway_output = true;"
#@ 
#@     if { $fill_in_cel_view } {
#@       puts $f "mw_view = \"CEL\";"
#@     }
#@ 
#@     if { $mwoutpath != "" } {
#@       puts $f "mw_path = \"$mwoutpath\";"
#@     }
#@ 
#@     if { $cellname != "" } {
#@       puts $f "mw_cellname = \"$cellname\";"
#@     }
#@ 
#@     if { $mwlibrary != "" } {
#@       puts $f "mw_library = \"$mwlibrary\";"
#@     }
#@   }
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_cells_list_to_uin {  f  					                cell_list_option_name                                                         keepout_cells_list } {
#@ 
#@   if { $keepout_cells_list != "" } {
#@     set keepoutCellsList ""
#@     regsub -all "," $keepout_cells_list " " keepout_cells_list
#@     foreach keepoutCell $keepout_cells_list {
#@       set keepoutCellsList [concat $keepoutCellsList \"$keepoutCell\",]
#@     }
#@     puts $f "$cell_list_option_name = {$keepoutCellsList};"
#@   }
#@ }
#@ 
#@ ##################################### Function that calls fillflow.pl #########################################################################
#@ 
#@ proc ::dtDfm::fill_metal_icv_runflow { cellname                                        flowname                                        container_extension                                        level                                        stminputdir                                        uinfilepath                                        icvworkarea                                        icv_options                                        use_lnf_input 
#@                                        use_pds 				       				   launch_script                                        nbpool                                        nbclass                                        nbslot  } {
#@   global env
#@   # set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@   if { [file exists $icvworkarea] != 0 } {
#@     # puts "deleting $icvworkarea"
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   file mkdir $icvworkarea/output
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   # file copy $uinfilepath ./flexuin_fill${level}.rs
#@   file copy -force $uinfilepath ./flexuin${container_extension}.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@     cd $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath ]
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   cd $old_dir
#@   return $pid
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_runflow { cellname                                      flowname                                      level                                      stminputdir                                      uinfilepath                                      icvworkarea                                      icv_options} {
#@   global env
#@   # set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@   if { [file exists $icvworkarea] != 0 } {
#@     # puts "deleting $icvworkarea"
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   file mkdir $icvworkarea/output
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   file copy -force $uinfilepath ./flexuin_vfill${level}.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   # set stmoutputdir ${icvworkarea}
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath]
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   cd $old_dir
#@   return $pid
#@ }
#@ 
#@ ######################################### UDM DEPENDENT CODE STARTS HERE ######################################################################
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   printError $str
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   printInfo $str
#@ }
#@ 
#@ proc ::dtDfm::writeRegionGrids { f cellname viewname plys } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     set cell [get_cell "$cellname,$viewname"]
#@     set tech [cell_get_tech $cell]
#@ 
#@     puts $f "region_grids = $OPEN_BRACE "
#@     puts $f "                 $OPEN_BRACE "
#@ 
#@     set gigplys ""
#@     foreach ply $plys {
#@       set ply_gig [create_gigfig_from_ply $ply $tech]
#@       lappend gigplys $ply_gig
#@     }
#@     set ply_gig [gig_op_or_list $gigplys]
#@     set cell_boundary [cell_get_boundary $cell]
#@     if { $ply_gig != "" } {
#@       set ply_rects [gig_op_segment_list $ply_gig 4]
#@ 
#@       set writeor 0
#@       foreach ply_rect $ply_rects {
#@         set ply_box [gig_figure_get_bbox $ply_rect]
#@         set box_coord [ split $ply_box ":"]
#@ 
#@         set xl [tech_udm_to_micron $tech [lindex $box_coord 0]]
#@         set yl [tech_udm_to_micron $tech [lindex $box_coord 1]]
#@         set xh [tech_udm_to_micron $tech [lindex $box_coord 2]]
#@         set yh [tech_udm_to_micron $tech [lindex $box_coord 3]]
#@ 
#@         if { $writeor == 1 } {
#@           puts -nonewline $f "or "
#@         } else {
#@           set writeor 1
#@         }
#@         puts -nonewline $f "rectangle( $xl, $yl, $xh, $yh) "
#@       }
#@     }
#@     puts $f ","
#@     puts $f "grid_pattern1,"
#@     puts $f "offset,"
#@     puts $f "period,"
#@     puts $f "   $CLOSE_BRACE,"
#@     puts $f "$CLOSE_BRACE;"
#@ }
#@ 
#@ proc ::dtDfm::writeKORsToUIN { f cellname viewname plys } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     set cell [get_cell "$cellname,$viewname"]
#@     set tech [cell_get_tech $cell]
#@ 
#@     puts $f "region_gids = $OPEN_BRACE "
#@     puts $f "                 $OPEN_BRACE "
#@ 
#@     set gigplys ""
#@     foreach ply $plys {
#@       set ply_gig [create_gigfig_from_ply $ply $tech]
#@       lappend gigplys $ply_gig
#@     }
#@     set ply_gig [gig_op_or_list $gigplys]
#@     set cell_boundary [cell_get_boundary $cell]
#@     # set ply_gig [create_gigfig_from_ply $ply $tech]
#@     # set kor_gig [gig_op_not_two_lists [list $cell_boundary] $ply_gig]
#@     set kor_gig $ply_gig
#@     if { $kor_gig != "" } {
#@       set kor_rects [gig_op_segment_list $kor_gig 4]
#@ 
#@       set firstkor 1
#@       foreach kor_rect $kor_rects {
#@         set ply_box [gig_figure_get_bbox $kor_rect]
#@         set box_coord [ split $ply_box ":"]
#@ 
#@         set xl [tech_udm_to_micron $tech [lindex $box_coord 0]]
#@         set yl [tech_udm_to_micron $tech [lindex $box_coord 1]]
#@         set xh [tech_udm_to_micron $tech [lindex $box_coord 2]]
#@         set yh [tech_udm_to_micron $tech [lindex $box_coord 3]]
#@ 
#@         if { !$firstkor } {
#@           puts -nonewline $f "or "
#@           set firstkor 0
#@         }
#@         puts -nonewline $f "rectangle( $xl, $yl, $xh, $yh) "
#@       }
#@     }
#@     puts $f ","
#@     puts $f "grid_pattern,"
#@     puts $f "offset,"
#@     puts $f "period,"
#@     puts $f "   $CLOSE_BRACE,"
#@     puts $f "$CLOSE_BRACE;"
#@ }
#@ 
#@ proc create_gigfig_from_ply { ply tech} {
#@  set vertex_list [split $ply " "]
#@  set num_of_vertex [llength $vertex_list]
#@ 
#@  set xlist_for_fig [list]
#@  set ylist_for_fig [list]
#@  for {set i 0} {$i < $num_of_vertex} {incr i} {
#@    set pt [lindex $vertex_list $i]
#@    lassign [split $pt ","] xpt ypt
#@    set xpt [tech_micron_to_udm $tech $xpt]
#@    set ypt [tech_micron_to_udm $tech $ypt]
#@    lappend xlist_for_fig $xpt
#@    lappend ylist_for_fig $ypt
#@  }
#@ 
#@  set orig_ply_gig_figure [gig_figure_create_polygon $xlist_for_fig $ylist_for_fig $num_of_vertex]
#@  return  $orig_ply_gig_figure
#@ }
#@ 
#@ proc ::dtDfm::is_via_layer_by_name { layername } {
#@     set result [regexp {via(\d+)} $layername fullstring level]
#@     if { $result == 0 } {
#@       set result [regexp {viaa(\d+)} $layername fullstring level]
#@     }
#@     if { $result == 0 } {
#@       set result [regexp {viab(\d+)} $layername fullstring level]
#@     }
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::is_via_layer { objLayer } {
#@     set layername [layer_get_name $objLayer]
#@     set result [::dtDfm::is_via_layer_by_name $layername]
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::is_dg_layer { objLayer } {
#@     set layername [layer_get_name $objLayer]
#@     set result [regexp {(\d+)dg} $layername fullstring level]
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::copyFromSTMToTop { srcCellName                                  srcViewName                                  destCellName                                  destViewName                                  layeNameList                                  stubnet                                  property                                  stub_property 								 netname_for_untexted_objects                                  {rename_nets ""}  }  {
#@   set from_nets {}
#@   set to_nets {}
#@   foreach from_to_net $rename_nets {
#@     lappend from_nets [lindex $from_to_net 0]
#@     lappend to_nets   [lindex $from_to_net 1]
#@   }
#@ 
#@   set prop_name_scope_value [split $property :]
#@   set propname  [lindex $prop_name_scope_value 0]
#@   set propscope [lindex $prop_name_scope_value 1]
#@   set propvalue [lindex $prop_name_scope_value 2]
#@ 
#@   set stub_prop_name_scope_value [split $stub_property :]
#@   set stub_propname  [lindex $stub_prop_name_scope_value 0]
#@   set stub_propscope [lindex $stub_prop_name_scope_value 1]
#@   set stub_propvalue [lindex $stub_prop_name_scope_value 2]
#@ 
#@   set src [cell_mgr_get_cell [cell_mgr_get_mgr] $srcCellName $srcViewName]
#@   set dest [cell_mgr_get_cell [cell_mgr_get_mgr] $destCellName $destViewName ]
#@   set tech [cell_get_tech $src]
#@   set layerList ""
#@ 
#@   foreach fillLayer $layeNameList {
#@   lappend layerList [tech_get_layer $tech $fillLayer]
#@   if { $fillLayer == "metal0" } {
#@     set metalc0Layer [tech_get_layer $tech metalc0]
#@     if { $metalc0Layer != "NULL" } {
#@       lappend layerList $metalc0Layer
#@     }
#@     set metals0Layer [tech_get_layer $tech metals0]
#@     if { $metals0Layer != "NULL" } {
#@       lappend layerList $metals0Layer
#@     }
#@   }
#@   if { $fillLayer == "metal1" } {
#@     set metal1dgLayer [tech_get_layer $tech metal1dg]
#@     if { $metal1dgLayer != "NULL" } {
#@       lappend layerList $metal1dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal2" } {
#@     set metalc2Layer [tech_get_layer $tech metalc2]
#@     if { $metalc2Layer != "NULL" } {
#@       lappend layerList $metalc2Layer
#@     }
#@     set metal2dgLayer [tech_get_layer $tech metal2dg]
#@     if { $metal2dgLayer != "NULL" } {
#@       lappend layerList $metal2dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal3" } {
#@     set metalc3Layer [tech_get_layer $tech metalc3]
#@     if { $metalc3Layer != "NULL" } {
#@       lappend layerList $metalc3Layer
#@     }
#@     set metal3dgLayer [tech_get_layer $tech metal3dg]
#@     if { $metal3dgLayer != "NULL" } {
#@       lappend layerList $metal3dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal4" } {
#@     set metalc4Layer [tech_get_layer $tech metalc4]
#@     if { $metalc4Layer != "NULL" } {
#@       lappend layerList $metalc4Layer
#@     }
#@   }
#@   if { $fillLayer == "metal5" } {
#@     set metalc5Layer [tech_get_layer $tech metalc5]
#@     if { $metalc5Layer != "NULL" } {
#@       lappend layerList $metalc5Layer
#@     }
#@   }
#@   if { $fillLayer == "via1" } {
#@     set viaa1Layer [tech_get_layer $tech viaa1]
#@     if { $viaa1Layer != "NULL" } {
#@       lappend layerList $viaa1Layer
#@     }
#@     set viab1Layer [tech_get_layer $tech viab1]
#@     if { $viab1Layer != "NULL" } {
#@       lappend layerList $viab1Layer
#@     }
#@     set viac1Layer [tech_get_layer $tech viac1]
#@     if { $viac1Layer != "NULL" } {
#@       lappend layerList $viac1Layer
#@     }
#@   }
#@   if { $fillLayer == "via2" } {
#@     set viaa2Layer [tech_get_layer $tech viaa2]
#@     if { $viaa2Layer != "NULL" } {
#@       lappend layerList $viaa2Layer
#@     }
#@     set viab2Layer [tech_get_layer $tech viab2]
#@     if { $viab2Layer != "NULL" } {
#@       lappend layerList $viab2Layer
#@     }
#@   }
#@   if { $fillLayer == "via3" } {
#@     set viaa3Layer [tech_get_layer $tech viaa3]
#@     if { $viaa3Layer != "NULL" } {
#@       lappend layerList $viaa3Layer
#@     }
#@     set viab3Layer [tech_get_layer $tech viab3]
#@     if { $viab3Layer != "NULL" } {
#@       lappend layerList $viab3Layer
#@     }
#@   }
#@   }
#@ 
#@   set bcPersona [udm_app_get_opt_layer_persona]
#@   if {[expr $bcPersona & 1]} {
#@     udm_app_change_opt_layer_persona 6
#@   }
#@   set objsIter  [cell_get_geo_objs_iter $src]
#@   set objCount 0
#@   set objIdList ""
#@   set stubList ""
#@ 
#@   while {[geo_obj_iter_advance $objsIter]} {
#@     set obj [geo_obj_iter_get_current $objsIter]
#@     set objLayer [geo_obj_get_layer $obj]
#@     incr objCount
#@     if { [lsearch $layerList $objLayer] != -1 } {
#@       if { [ isa_geo_poly $obj ] == 1 } {
#@         set syn 0
#@         set srcnet [geo_polygon_get_net $obj]
#@         if { $srcnet != "" } {
#@           set destnetname [net_get_name $srcnet]
#@         } else {
#@           if { $netname_for_untexted_objects == "unique_syn" } {
#@             set destnet [udm_utils_create_synth_net $dest]
#@             set destnetname  [net_get_name $destnet] 
#@           }  else {
#@             set destnetname $netname_for_untexted_objects
#@           }
#@         }
#@ 
#@         set destnet ""
#@         set this_is_stub false
#@         if { [regexp {syn_generated_([0-9\.]+)} $destnetname match num] } {
#@           if { $stubnet == "" } {
#@             set destnet [udm_utils_create_synth_net $dest]
#@           } else {
#@             set destnetname syn_stub
#@           }
#@           set this_is_stub true
#@         }
#@ 
#@ if { 0 } {
#@         if { [regexp {.*_floatiss_} $destnetname match num] } {
#@           set destnetname floatiss_
#@         }
#@ }
#@ 
#@         set net_index [lsearch $from_nets $destnetname]
#@         if { $net_index != -1 } {
#@           set destnetname [lindex $to_nets $net_index]
#@         }
#@ 
#@         if { $destnet == "" } {
#@           set destnet [cell_get_net $dest $destnetname ]
#@           if { $destnet == "" } {
#@             set destnet [cell_create_net $dest $destnetname ]
#@           }
#@         }
#@ 
#@         set bbox [::boo::new_BooBBox]
#@         geo_obj_get_bounding_box $obj $bbox
#@         set rect [new_rect_from_bbox $bbox $objLayer]
#@ 
#@         set this_is_a_wire true
#@ 
#@         if { [::dtDfm::is_via_layer $objLayer] } {
#@           set viapoly [new_polygon_from_bbox $bbox $objLayer]
#@           # set p [geo_polygon_create $dest $viapoly $destnet]
#@ 
#@          set enclist {}
#@          set p [via_create_general_via $destnet $enclist $viapoly]
#@          lappend objIdList [obj_get_obj_id $p]
#@          set this_is_a_wire false
#@         } elseif { [::dtDfm::is_dg_layer $objLayer] } {
#@           set dgpoly [new_polygon_from_bbox $bbox $objLayer]
#@           set p [geo_polygon_create $dest $dgpoly $destnet]
#@         } else {
#@           set w [wire_create $destnet $rect 0]
#@           lappend objIdList [obj_get_obj_id $w]
#@         }
#@         if {$syn == 1} {net_set_synth_net $destnet 1}
#@ 
#@         if { $this_is_stub && $this_is_a_wire } {
#@           lappend stubList  [obj_get_obj_id $w]
#@         }
#@       }
#@     }
#@   }
#@   if { [info commands Dfm] != {} && $objIdList != "" && $prop_name_scope_value != "" } {
#@     Dfm setCell -cell $destCellName
#@     Dfm setProp -name $propname -value $propvalue -scope $propscope -objIds $objIdList
#@     # puts "Dfm setProp -name $propname -value $propvalue -scope $propscope -objIds $objIdList"
#@   }
#@ 
#@   if { [info commands Dfm] != {} && $stubList != "" && $stub_prop_name_scope_value != "" } {
#@     Dfm setCell -cell $destCellName
#@     Dfm setProp -name $stub_propname -value $stub_propvalue -scope $stub_propscope -objIds $stubList
#@     # puts "Dfm setProp -name $stub_propname -value $stub_propvalue -scope $stub_propscope -objIds $stubList"
#@   }
#@ 
#@   udm_app_change_opt_layer_persona $bcPersona
#@   return $objIdList
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   # read and process results
#@   # set pid                 [::dtDfm::keylget jobInfo PID]
#@   set cellname            [::dtDfm::keylget jobInfo CELLNAME]
#@   set outputcellname      [::dtDfm::keylget jobInfo OUTPUT_CELL_NAME]
#@   set viewname            [::dtDfm::keylget jobInfo VIEWNAME]
#@   # set techname            [::dtDfm::keylget jobInfo TECHNAME]
#@   set container_extension [::dtDfm::keylget jobInfo EXTENSION]
#@   set fillLayers          [::dtDfm::keylget jobInfo LAYER]
#@   set stubnet             [::dtDfm::keylget jobInfo STUBNET]
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@   set property            [::dtDfm::keylget jobInfo PROPERTY]
#@   set stub_property       [::dtDfm::keylget jobInfo STUB_PROPERTY]
#@   set rename_nets         [::dtDfm::keylget jobInfo RENAME_NETS]
#@   set netname_for_untexted_objects [::dtDfm::keylget jobInfo NETNAME_FOR_UNTEXTED_OBJECTS]
#@   # set print_cmd_str       [::dtDfm::keylget jobInfo CMD_STR]
#@   
#@   # wait $pid
#@   # stm inputTechnology $tech
#@   set container_name ${cellname}${container_extension}
#@   set path ${icvworkarea}/${container_name}.stm
#@ 
#@   set readLayers ""
#@   foreach fillLayer $fillLayers {
#@     if { $fillLayer == "poly" } {
#@       lappend readLayers wirepoly
#@     } elseif { $fillLayer == "diffusion" || $fillLayer == "libdfmg" } {
#@       lappend readLayers nwirediff pwirediff wirepoly diffcon polycon
#@     } elseif { $fillLayer == "polycon" } {
#@       lappend readLayers polycon
#@     } elseif { $fillLayer == "diffcon" } {
#@       lappend readLayers diffcon
#@     } elseif { $fillLayer == "viat" } {
#@       lappend readLayers metal0 viat viag
#@     } else {
#@       lappend readLayers $fillLayer
#@     }
#@   }
#@   ::dtDfm::read_stm -from_cell $container_name                     -from_view stm                     -to_cell $outputcellname                     -to_view $viewname                     -path $path                     -layers $readLayers                     -stubnet $stubnet                     -property $property                     -stub_property $stub_property                     -rename_nets  $rename_nets  					-netname_for_untexted_objects $netname_for_untexted_objects
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   stm terminalProperty 126
#@   stm inputObjectProperties 1
#@   stm propertyAttributes 1
#@ 
#@   set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_checkcell { cellname viewname } {
#@     if {[info commands ::get_cell] != ""} {
#@         set cell [get_cell "$cellname,$viewname"]
#@         if {$cell == ""} {
#@             ::dtDfm::printErr "cell $cellname not found"
#@             return 0
#@         }
#@         set tech [cell_get_tech $cell]
#@         if {$tech == ""} {
#@             ::dtDfm::printErr "Failed to get udm tech"
#@             return 0
#@         }
#@     }
#@     return 1
#@ }
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   # puts "checking interrupt"
#@   set interrupted 0
#@   set interruptManager_ [::boo::BooInterruptMgr_getMgr]
#@   if {[::boo::BooInterruptMgr_interruptOccurred $interruptManager_]} {
#@     ::boo::BooInterruptMgr_clearInterrupt $interruptManager_
#@     set interrupted 1
#@   }
#@   return $interrupted
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   puts "Discarding partial fill objects"
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@ 
#@   set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@   if {$outputcellname != ""} {
#@     set cellname $outputcellname
#@   }
#@ 
#@   set properties {}
#@   foreach jobinfo $jobs {
#@     set property [::dtDfm::keylget jobinfo PROPERTY]
#@     if { [lsearch $properties $property] == -1 } {
#@       lappend properties $property
#@     }
#@     set stub_property [::dtDfm::keylget jobinfo STUB_PROPERTY]
#@     if { [lsearch $properties $stub_property] == -1 } {
#@       lappend properties $stub_property
#@     }
#@   }
#@ 
#@   Dfm setCell -cell $cellname
#@   set tbd_cell TO_BE_DELETED 
#@   Dfm createDfmCell -dfmCellName $tbd_cell
#@   foreach property $properties {
#@     set prop_name_scope_value [split $property :]
#@     set propname  [lindex $prop_name_scope_value 0]
#@     set propscope [lindex $prop_name_scope_value 1]
#@     set propvalue [lindex $prop_name_scope_value 2]
#@ 
#@     set cmd "Dfm objsByProp -command move -cell $tbd_cell -propName $propname -propScope $propscope -propValue $propvalue"
#@     set objs [eval $cmd]
#@     # puts "$cmd"
#@   }
#@   Discard -cellname $tbd_cell -noask
#@ }
#@ 
#@ ######################################### Parade DEPENDENT CODE STARTS HERE ####################################################################
#@ 
#@ 
#@ if { [info exists ICV_MFILL_FOR_PARADE] } {
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   set interrupted 0
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   # read and process results
#@   set pid                 [::dtDfm::keylget jobInfo PID]
#@   set cellname            [::dtDfm::keylget jobInfo CELLNAME]
#@   set outputcellname      [::dtDfm::keylget jobInfo OUTPUT_CELL_NAME]
#@   set viewname            [::dtDfm::keylget jobInfo VIEWNAME]
#@   set techname            [::dtDfm::keylget jobInfo TECHNAME]
#@   set container_extension [::dtDfm::keylget jobInfo EXTENSION]
#@   set fillLayer           [::dtDfm::keylget jobInfo LAYER]
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@   set property            [::dtDfm::keylget jobInfo PROPERTY]
#@   set stub_property       [::dtDfm::keylget jobInfo STUB_PROPERTY]
#@   set print_cmd_str       [::dtDfm::keylget jobInfo CMD_STR]
#@ 
#@   # wait $pid
#@   set container_name ${cellname}${container_extension}
#@ 
#@   # qb_node_create [pa_top_macro] vss 1
#@ 
#@   set old_dir [pwd]
#@   cd ${icvworkarea}
#@   set cmd "qb_gdsii_read_shapes ${icvworkarea}/${container_name}.stm vss"
#@ 
#@   # Open -cellname $container_name -viewname stm -nowindow 1
#@   set openret [eval $cmd]
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@ 
#@   if { $openret == 0 } {
#@     puts "Fail to load in ISS result stream file."
#@     return "0"
#@   }
#@  cd $old_dir
#@ 
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   # set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   set cmd "qb_write_gdsii \"\" \"\"  $path"
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_checkcell { cellname viewname } {
#@         return [expr {$cellname == [qb_macro_get_name [pa_top_macro]]}]
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   pa_log $str i
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   pa_log $str i
#@ }
#@ 
#@ 
#@ }
#@ 
#@ ######################################### ICC DEPENDENT CODE STARTS HERE #######################################################################
#@ 
#@ if { [info exists ICV_MFILL_FOR_ICC] } {
#@ 
#@ namespace eval ::boo {}; proc ::boo::EOUT {args} { puts $args }
#@ namespace eval ::boo {}; proc ::boo::IOUT {args} { puts $args }
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   set interrupted 0
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   # set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   # set cmd "qb_write_gdsii \"\" \"\"  $path"
#@ 
#@ 
#@    set_write_stream_options          -output_first_same_name_cell          -skip_global_route_contact          -contact X          -child_depth 1000          -output_filling fill          -output_outdated_fill          -output_pin {geometry}          -keep_data_type          -flatten_via          -map_layer $layer_map_for_mw          -output_instance_name_as_property 112          -max_name_length 64          -output_net_name_as_property 126          -set_hier_net_name_long          -set_hier_instance_name_long
#@ 
#@   if { [info exists env(PROJ_RDT)] } {
#@     set cmd "P_write_layout_file -format gds -cell $cellname -output_file $path"
#@   } else {
#@     set cmd "write_stream -cells $cellname $path"
#@   }
#@ 
#@   puts $cmd
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   puts $str
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   puts $str
#@ }
#@ 
#@ }
#@ 
#@ ################################################### General Functions ##########################################################################
#@ 
#@ proc ::dtDfm::get_cist_cmd_info {cmdname {filepath ""}} {
#@   set f ""
#@   if { $filepath != "" } {
#@     set f [open $filepath w]
#@   }
#@ 
#@   set cmd [[cist::cist_cmd_mgr::get_mgr] get_cmd $cmdname]
#@ 
#@   if {$cmd == ""} {
#@     return [list]
#@   }
#@ 
#@   set retval [list]
#@ 
#@   #
#@   # See also:  public variables in class cist::cist_input in /vobs/cadpax/cist/tcl/cist.tcl
#@   #
#@   foreach opt [$cmd get_inputs] {
#@     set name [$opt cget -optname]
#@     set def  [$opt cget -default]
#@     set desc [$opt cget -help]
#@     regsub -all "\n\t\t\t\t" $desc ";;;" desc
#@     if { $f != "" } { 
#@       puts $f "$name\t$def\t$desc"
#@     }
#@     lappend retval [list $name $def $desc]
#@   }
#@ 
#@   close $f
#@   return $retval
#@ }
#@ 
#@ proc ::dtDfm::keylset { instruct key value } {
#@   upvar 1 $instruct mystruct
#@   set found 0
#@   set index 0
#@   foreach info $mystruct {
#@     set info_key [lindex $info 0]
#@     if { $info_key == $key } {
#@       set found 1
#@       break;
#@     }
#@     incr index
#@   }
#@   if { $found == 1 } {
#@     set mystruct [lreplace $mystruct $index $index "$key $value"]
#@   } else {
#@     set mystruct [lappend mystruct "$key $value"]
#@   }
#@ }
#@ 
#@ proc ::dtDfm::keylget { instruct key } {
#@   upvar 1 $instruct mystruct
#@   set found 0
#@   set index 0
#@   foreach info $mystruct {
#@     set info_key [lindex $info 0]
#@     if { $info_key == $key } {
#@       return [lrange $info 1 end]
#@     }
#@     incr index
#@   }
#@   error "key $key not found in keyed list"
#@ }
#@ 
#@ proc ::dtDfm::lremove {args} {
#@      if {[llength $args] < 2} {
#@         puts stderr {Wrong # args: should be "lremove ?-all? list pattern"}
#@      }
#@      set list [lindex $args end-1]
#@      set elements [lindex $args end]
#@      if [string match -all [lindex $args 0]] {
#@         foreach element $elements {
#@             set list [lsearch -all -inline -not -exact $list $element]
#@         }
#@      } else {
#@         # Using lreplace to truncate the list saves having to calculate
#@         # ranges or offsets from the indexed element. The trimming is
#@         # necessary in cases where the first or last element is the
#@         # indexed element.
#@         foreach element $elements {
#@             set idx [lsearch $list $element]
#@             set list [string trim                 "[lreplace $list $idx end] [lreplace $list 0 $idx]"]
#@         }
#@      }
#@      return $list
#@ }
#@ proc ::dtDfm::fill_metal_icv_get_tech { temp_techname } {
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@     return $techname
#@ }
#@ 
#@ proc ::dtDfm::wait_on_pds_job { cellname flowname } {
#@   global env
#@ 
#@   set user $env(USER) 
#@   set supportfile "$env(PDSSUPPORT)/psicv_${user}.${cellname}.${flowname}.none.none"
#@   set currentfile "$env(PDSLOGS)/${cellname}.${flowname}.iss.current"
#@   set abortfile   "$env(PDSLOGS)/${cellname}.${flowname}.iss.abort"
#@   set logfile     "$env(PDSLOGS)/${cellname}.${flowname}.iss.log"
#@  
#@   exec sleep 2
#@   while { ([file exists $supportfile] != 0) } {
#@     exec sleep 2
#@   }
#@ 
#@   if { ([file exists $abortfile] != 0) } {
#@     return 1
#@   }
#@   return 0
#@ }
#@ 
#@ 
#@ ######################################### TEST PROCEDURE BELOW         #########################################################################
#@ proc my1272fill { cellname layers } {
#@ 
#@ set serial FALSE
#@ 
#@ ::dtDfm::fill_metal_icv_init -cellname $cellname
#@ 
#@ if { [lsearch $layers metal0] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal0 -offset 0.038 -pattern VSS_DUMMY:0.080B:0.028:VSS_DUMMY:0.032C:0.028 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal1] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal1 -offset 0.049 -pattern VSS_DUMMY:0.042:0.028 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal2] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal2 -offset 0.038 -pattern VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.038C:0.024:VSS:0.074:0.024:VSS_DUMMY:0.038C:0.024:VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.028C:0.024 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal3] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspY 0.028 -layer metal3 -offset 0.066 -pattern VSS_DUMMY:0.048C:0.024:VSS_DUMMY:0.032B:0.024:VSS_DUMMY:0.032C:0.024:VSS_DUMMY:0.032B:0.024:VSS_DUMMY:0.048C:0.024:VCC:0.084:0.024
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal4] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -layer metal4 -pattern VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.208 -offset 0.104 -property Dmi:test:Dmi -korspX 0.04 -korspY 0 -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal5] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -layer metal5 -pattern VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.266 -offset 0.133 -property Dmi:test:Dmi -korspX 0 -korspY 0.045 -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal6] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal6 -pattern VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.388 -offset 0.194 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal7] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal7 -pattern VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.500 -offset 0.250 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal8] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal8 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.532 -offset 0.266 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal9] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal9 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.700 -offset 0.350 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal10] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal10 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:1.204 -offset 0.602 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ 
#@ if { !$serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fix_v0pax_dfmg ##################################################################
#@ CmdSpec ::dtDfm::fix_v0pax_dfmg {
#@ 
#@     -help "::dtDfm::fix_v0pax_dfmg -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fix_v0pax_dfmg {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     # if { $fillLayer == "" } {
#@ 	# ::dtDfm::printErr "No via layer specified"
#@ 	# return 0
#@     #}
#@ 
#@ 
#@     set fillLayer "viat"
#@     set level 0
#@     # set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     # if { $result == 0 || $level != 1 } {
#@       # ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       # return 0
#@     # }
#@ 
#@     set flowName "v0pax_dfmg"
#@     set container_extension "_v0pax_dfmg"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fix_v0pax_dfmg_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds 											$launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fix_v0pax_dfmg_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ # Functions related to ::dtDfm::powerhookup 
#@ # BMB 2012-10-14
#@ 
#@ CmdSpec ::dtDfm::powerhookup {
#@     -help "::dtDfm::powerhookup"
#@     -opts {
#@         {-optname     process_name
#@             -type     string
#@             -default  "p1274.0"
#@             -help     "process name"
#@         }
#@         {-optname  top_level_only_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     use_drawn_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use drawn KOR layers"
#@         }
#@         {-optname     use_route_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use route KOR layers"
#@         }
#@         {-optname     use_fill_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Use fill KOR layers"
#@         }
#@         {-optname     use_global_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use global KOR layers"
#@         }
#@         {-optname     drawn_kor_x_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     drawn_kor_y_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     dh_bonus_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "list of double-height bonus cells"
#@         }
#@         {-optname     force_hookup_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "force hookup of power on listed cells"
#@         }
#@         {-optname     hookup_cell_names_list
#@             -type     string
#@             -default  ""
#@             -help     "list of cells (with wildcards) to hookup"
#@         }
#@         {-optname     hookup_cell_names_list_xn
#@             -type     string
#@             -default  ""
#@             -help     "list of xn cells (with wildcards) to hookup"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@         {-optname     keepout_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@         }
#@         {-optname     keepout_cells_x_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname     keepout_cells_y_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     powerhookup_grid_count
#@             -type     integer
#@             -default  0.0
#@             -help     "Grid count spacing for power hookup connections"
#@         }
#@         {-optname     powerhookup_empty_area
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Place power hookups in areas with no cell placements"
#@         }
#@         {-optname     powerhookup_cells_area
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Place power hookups in areas with cell placements"
#@         }
#@         {-optname     powerhookup_avoid_drv
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Avoid DRV and shorts when placing powerhookup vias"
#@         }
#@         {-optname     powerhookup_all_segments
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Ensure power hookups are on all segments of M2 power grid"
#@         }
#@         {-optname     powerhookup_drv_vias_cells_list 
#@             -type     string
#@             -default  "{\"*\"}"
#@             -help     "List of cells vias to consider for DRV"
#@         }
#@         {-optname     powerhookup_offset_locations
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Alternate the initial offset to place vias each M2 track"
#@         }
#@         {-optname     write_coord_file
#@             -type     string
#@             -default  ""
#@             -help     "Write center x,y cooridinates of power hookup to file"
#@         }
#@         {-optname     write_def_file_prefix
#@             -type     string
#@             -default  ""
#@             -help     "Write vias placements to DEF file"
#@         }
#@         {-optname     power_name
#@             -type     string
#@             -default  "vcc"
#@             -help     "Name of power rail (default = vcc)"
#@         }
#@         {-optname     ground_name
#@             -type     string
#@             -default  "vss"
#@             -help     "Name of ground rail (default = vss)"
#@         }
#@         {-optname     ground_rail_y_start
#@             -type     float
#@             -default  0.0
#@             -help     "y-value of center of first horizontal ground rail (default = 0.0)"
#@         }
#@         {-optname     power_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for power nets"
#@         }
#@         {-optname     ground_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for ground nets"
#@         }
#@         {-optname     dsn_core_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing core_area key=int_width and value=points_of_area for core_area"
#@         }
#@         {-optname     m2_rail_width
#@             -type     float
#@             -default  -1.0
#@             -help     "Width of m2 pwr/gnd rails" 
#@         }
#@         {-optname     cell_height
#@             -type     float
#@             -default  -1.0
#@             -help     "Height of single height stdcell" 
#@         }
#@         {-optname     v0_master
#@             -type     string
#@             -default  ""
#@             -help     "v0 via master" 
#@         }
#@         {-optname     v1_master
#@             -type     string
#@             -default  ""
#@             -help     "v1 via master" 
#@         }
#@         {-optname     hookup_via_settings
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing override settings for p1271-p1273 via masters and dimensions" 
#@         }
#@         {-optname     use_xll_grid
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Use XLL grid"
#@         }
#@         {-optname     bndry_y_min
#@             -type     float
#@             -default  0.0
#@             -help     "block boundary lower-y (default = 0.0)"
#@         }
#@     }
#@ }
#@ 
#@ # BMB 2012-10-14
#@ proc ::dtDfm::powerhookup {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set dh_bonus_cells_list       $opts(dh_bonus_cells_list)
#@     set force_hookup_cells_list   $opts(force_hookup_cells_list)
#@     set hookup_cell_names_list    $opts(hookup_cell_names_list)
#@     set hookup_cell_names_list_xn $opts(hookup_cell_names_list_xn)
#@     set keepin_cells_list        $opts(keepin_cells_list)
#@     set keepout_cells_list       $opts(keepout_cells_list)
#@     set keepout_cells_x_space    $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space    $opts(keepout_cells_y_space)
#@     set powerhookup_grid_count   $opts(powerhookup_grid_count)
#@     set powerhookup_empty_area   $opts(powerhookup_empty_area)
#@     set powerhookup_cells_area   $opts(powerhookup_cells_area)
#@     set powerhookup_avoid_drv    $opts(powerhookup_avoid_drv)
#@     set powerhookup_all_segments $opts(powerhookup_all_segments)
#@     set powerhookup_drv_vias_cells_list $opts(powerhookup_drv_vias_cells_list)
#@     set powerhookup_offset_locations $opts(powerhookup_offset_locations)
#@     set use_drawn_kor            $opts(use_drawn_kor)
#@     set top_level_only_kor       $opts(top_level_only_kor)
#@     set use_route_kor            $opts(use_route_kor)
#@     set use_fill_kor             $opts(use_fill_kor)
#@     set use_global_kor           $opts(use_global_kor)
#@     set drawn_kor_x_space        $opts(drawn_kor_x_space)
#@     set drawn_kor_y_space        $opts(drawn_kor_y_space)
#@     set write_coord_file         $opts(write_coord_file)
#@     set write_def_file_prefix    $opts(write_def_file_prefix)
#@     set power_name               $opts(power_name)
#@     set ground_name              $opts(ground_name)
#@     set ground_rail_y_start      $opts(ground_rail_y_start)
#@     if { $opts(power_voltage_areas) ne "" } {
#@        upvar $opts(power_voltage_areas) power_voltage_areas
#@        set pwr_va_areas [array get power_voltage_areas]
#@     } else {
#@        set pwr_va_areas ""
#@     }
#@     if { $opts(ground_voltage_areas) ne "" } {
#@        upvar $opts(ground_voltage_areas) ground_voltage_areas
#@        set gnd_va_areas [array get ground_voltage_areas]
#@     } else {
#@        set gnd_va_areas ""
#@     }
#@     if { $opts(dsn_core_areas) ne "" } {
#@        upvar $opts(dsn_core_areas) core_areas
#@        set dsn_core_areas [array get core_areas]
#@     } else {
#@        set dsn_core_areas ""
#@     }
#@     if { $opts(hookup_via_settings) ne "" } {
#@        upvar $opts(hookup_via_settings) hookup_masters
#@        set hookup_via_settings [array get hookup_masters]
#@     } else {
#@        set hookup_via_settings ""
#@     }
#@     set m2_rail_width            $opts(m2_rail_width)
#@     set cell_height              $opts(cell_height)
#@     set v0_master                $opts(v0_master)
#@     set v1_master                $opts(v1_master)
#@     set use_xll_grid             $opts(use_xll_grid)
#@     set dsn_y_min                $opts(bndry_y_min)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     ### If UDM, get tech from UDM cell
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@         return 0
#@     }
#@ 
#@     set fillLayer           "via1" 
#@     if { [regexp {127[123]} $techname] } {
#@        set flowName            "powerhookup72"
#@     } else {
#@        set flowName            "powerhookup"
#@     }
#@     set container_extension "_powerhookup"
#@     
#@     # write uin file
#@     set uinfilename "${cellname}${container_extension}.uin"
#@     # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     set uinfilepath "$uindir/$uinfilename"
#@     
#@     ::dtDfm::powerhookup_writeuin $cellname         $viewname         $techname         $uinfilepath         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $mwlibrary         $write_stm_output         $write_coord_file         $write_def_file_prefix         $dh_bonus_cells_list         $force_hookup_cells_list         $hookup_cell_names_list         $hookup_cell_names_list_xn         $keepin_cells_list         $keepout_cells_list         $keepout_cells_x_space         $keepout_cells_y_space         $use_drawn_kor         $top_level_only_kor         $use_route_kor         $use_fill_kor         $use_global_kor         $drawn_kor_x_space         $drawn_kor_y_space         $powerhookup_grid_count         $powerhookup_empty_area         $powerhookup_cells_area         $powerhookup_avoid_drv         $powerhookup_all_segments         $powerhookup_drv_vias_cells_list         $powerhookup_offset_locations         $power_name         $ground_name         $ground_rail_y_start         $pwr_va_areas         $gnd_va_areas         $dsn_core_areas         $m2_rail_width         $cell_height         $v0_master         $v1_master         $hookup_via_settings         $use_xll_grid         $dsn_y_min
#@ 
#@     if { $only_write_uin || $streamlined } {
#@         return ""
#@     }
#@ 
#@     # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@     set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@     set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@     set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@     set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@     set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@     set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@     set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@     set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@     
#@     set pid [::dtDfm::fill_metal_icv_runflow $cellname                  $flowName                  $container_extension                  0                  $stminputdir                  $uinfilepath                  $icvworkarea                  $icv_options                  $use_lnf_input                  $use_pds                  $launch_script                  $nbpool                  $nbclass                  $nbslot ]
#@     
#@     # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@     # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@     
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set jobInfo ""
#@     ::dtDfm::keylset jobInfo PID           $pid
#@     ::dtDfm::keylset jobInfo CELLNAME      $cellname
#@     ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME      $outputcellname
#@     ::dtDfm::keylset jobInfo VIEWNAME      $viewname
#@     ::dtDfm::keylset jobInfo TECHNAME      $techname
#@     ::dtDfm::keylset jobInfo EXTENSION     $container_extension
#@     ::dtDfm::keylset jobInfo ICVWORKAREA   $icvworkarea
#@     ::dtDfm::keylset jobInfo PROPERTY      $property
#@     ::dtDfm::keylset jobInfo STUBNET       $stubnet
#@     ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@     ::dtDfm::keylset jobInfo RENAME_NETS   $rename_nets
#@     ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@     ::dtDfm::keylset jobInfo CMD_STR       $print_cmd_str
#@     ::dtDfm::keylset jobInfo LAYER         $fillLayer
#@ 
#@     set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@     lappend jobs $jobInfo
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@     
#@     return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::powerhookup_writeuin { cellname                                          viewname                                          techname                                          uinfilepath                                          write_milkyway_output                                          fill_in_cel_view                                          mwoutpath                                          mwlibrary                                          write_stm_output                                          write_coord_file                                          write_def_file_prefix                                          dh_bonus_cells_list                                          force_hookup_cells_list                                          hookup_cell_names_list                                          hookup_cell_names_list_xn                                          keepin_cells_list                                          keepout_cells_list                                          keepout_cells_x_space                                          keepout_cells_y_space                                          use_drawn_kor                                          top_level_only_kor                                          use_route_kor                                          use_fill_kor                                          use_global_kor                                          drawn_kor_x_space                                          drawn_kor_y_space                                          powerhookup_grid_count                                          powerhookup_empty_area                                          powerhookup_cells_area                                          powerhookup_avoid_drv                                          powerhookup_all_segments                                          powerhookup_drv_vias_cells_list                                          powerhookup_offset_locations                                          power_name                                          ground_name                                          ground_rail_y_start                                          {pwr_va_areas ""}                                          {gnd_va_areas ""}                                          {dsn_core_areas ""}                                          m2_rail_width                                          cell_height                                          v0_master                                          v1_master                                          hookup_via_settings                                          use_xll_grid                                          dsn_y_min                                  } {
#@ 
#@     set f [open "$uinfilepath" w]
#@     
#@     if { $techname != "" } {
#@         puts $f "process_name = \"$techname\";"
#@     }
#@     
#@     ::dtDfm::fill_metal_icv_write_output_options_to_uin $f         $write_stm_output         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $cellname         $mwlibrary;
#@ 
#@     set use_p1272_opts 0
#@     if { [regexp {127[123]} $techname] } {
#@        set use_p1272_opts 1
#@        if { $dh_bonus_cells_list ne "" } {
#@           set dh_bonus_option_name "dh_bonus_cells_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $dh_bonus_option_name               $dh_bonus_cells_list;
#@        }
#@ 
#@        if { $force_hookup_cells_list ne "" } {
#@           set force_hookup_option_name "force_hookup_cells_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $force_hookup_option_name               $force_hookup_cells_list;
#@        }
#@ 
#@        if { $hookup_cell_names_list ne "" } {
#@           set hookup_cells_option_name "hookup_cell_names_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $hookup_cells_option_name               $hookup_cell_names_list;
#@        }
#@ 
#@        if { $hookup_cell_names_list_xn ne "" } {
#@           set hookup_cells_xn_option_name "hookup_cell_names_list_xn"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $hookup_cells_xn_option_name               $hookup_cell_names_list_xn;
#@        }
#@     }
#@ 
#@     set cell_list_option_name "keepin_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepin_cells_list;
#@     
#@     set cell_list_option_name "keepout_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepout_cells_list;    
#@ 
#@     puts $f "keepout_cells_x_space    = $keepout_cells_x_space;"
#@     puts $f "keepout_cells_y_space    = $keepout_cells_y_space;"
#@     puts $f "use_drawn_kor            = $use_drawn_kor;"
#@     puts $f "top_level_only_kor       = $top_level_only_kor;"
#@     puts $f "use_route_kor            = $use_route_kor;"
#@     puts $f "use_fill_kor             = $use_fill_kor;"
#@     puts $f "use_global_kor           = $use_global_kor;"
#@     puts $f "drawn_kor_x_space        = $drawn_kor_x_space;"
#@     puts $f "drawn_kor_y_space        = $drawn_kor_y_space;"
#@     puts $f "powerhookup_grid_count   = $powerhookup_grid_count;"
#@     puts $f "powerhookup_empty_area   = $powerhookup_empty_area;"
#@     puts $f "powerhookup_cells_area   = $powerhookup_cells_area;"
#@     puts $f "powerhookup_avoid_drv    = $powerhookup_avoid_drv;"
#@     puts $f "powerhookup_all_segments = $powerhookup_all_segments;"
#@     if { ! $use_p1272_opts } {
#@        puts $f "powerhookup_drv_vias_cells_list = $powerhookup_drv_vias_cells_list;"
#@        puts $f "powerhookup_offset_locations = $powerhookup_offset_locations;"
#@     }
#@     puts $f "write_coord_file         = \"$write_coord_file\";"
#@     if { $use_p1272_opts } {
#@        puts $f "write_def_file           = \"$write_def_file_prefix.def\";"
#@     } else {
#@        puts $f "write_def_file_prefix    = \"$write_def_file_prefix\";"
#@     }
#@ 
#@     puts $f "ground_rail_y_start      = $ground_rail_y_start;"
#@ 
#@     if { $pwr_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $pwr_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "pwr_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "power_name               = \"$power_name\";"
#@     }
#@     if { $gnd_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $gnd_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "gnd_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "ground_name              = \"$ground_name\";"
#@     }
#@ 
#@     if { $dsn_core_areas != "" } {
#@        foreach {int_width core_area} [regsub -all "," $dsn_core_areas " "] {
#@           # reformat core_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $core_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $core_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $core_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "core_area\[$int_width\] = {[join $fmt_area {,}]};"
#@        }
#@     }
#@ 
#@     if { $m2_rail_width > 0 } {
#@        puts $f "m2_rail_width            = $m2_rail_width;"
#@     }
#@     if { $cell_height > 0 } {
#@        puts $f "cell_height              = $cell_height;"
#@     }
#@     if { $v0_master != "" } {
#@        puts $f "v0_master                = \"$v0_master\";"
#@     }
#@     if { $v1_master != "" } {
#@        puts $f "v1_master                = \"$v1_master\";"
#@     }
#@ 
#@     if { $use_p1272_opts && ($hookup_via_settings != "") } {
#@        # hookup_via_settings are an array of array settings 
#@        # initial names: bndry_gnd_via_master bndry_gnd_via_w bndry_gnd_via_h
#@        #                bndry_pwr_via_master bndry_pwr_via_w bndry_pwr_via_h
#@        #                polyg_pwr_via_master polyg_pwr_via_w polyg_pwr_via_h
#@        # each set is then a string identifier for the arrays
#@        # via_master values are string, w & h values are double
#@        array set legacy_via_setup $hookup_via_settings
#@        foreach hookup_type {bndry_gnd_via bndry_pwr_via polyg_pwr} {
#@           foreach param {master w h} is_real_param {0 1 1} {
#@              set hookup_setting "${hookup_type}_${param}"
#@              if { ! [info exists legacy_via_setup($hookup_setting)] } {
#@                 continue
#@              }
#@              unset -nocomplain hookup_vias
#@              array set hookup_vias $legacy_via_setup($hookup_setting)
#@              foreach key [array names hookup_vias] {
#@                 set value $hookup_vias($key)
#@                 if { $value eq "" } {
#@                    continue
#@                 }
#@                 if { $is_real_param } {
#@                    puts $f "${hookup_setting}\[\"${key}\"\] = $value ;"
#@                 } else {
#@                    puts $f "${hookup_setting}\[\"${key}\"\] = \"$value\";"
#@                 }
#@              }
#@           }
#@        }
#@     }
#@ 
#@     puts $f "use_xll_grid             = $use_xll_grid;"
#@     puts $f "dsn_y_min                = $dsn_y_min;"
#@ 
#@     close $f
#@ }
#@ 
#@ 
#@ # Functions related to ::dtDfm::V0_328_vss_fixing
#@ # JEH 2014-01-31
#@ CmdSpec ::dtDfm::V0_328_vss_fixing {
#@     -help "::dtDfm::V0_328_vss_fixing"
#@     -opts {
#@         {-optname     process_name
#@             -type     string
#@             -default  "p1273.1"
#@             -help     "process name"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "only allow fixing in these cells"
#@         }
#@         {-optname     write_def_file
#@             -type     string
#@             -default  ""
#@             -help     "Write vias placements to DEF file"
#@         }
#@         {-optname     power_name
#@             -type     string
#@             -default  "vcc"
#@             -help     "Name of power rail (default = vcc)"
#@         }
#@         {-optname     ground_name
#@             -type     string
#@             -default  "vss"
#@             -help     "Name of ground rail (default = vss)"
#@         }
#@         {-optname     power_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for power nets"
#@         }
#@         {-optname     ground_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for ground nets"
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # JEH 2014-01-31
#@ proc ::dtDfm::V0_328_vss_fixing {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set keepin_cells_list        $opts(keepin_cells_list)
#@     set write_def_file           $opts(write_def_file)
#@     set power_name               $opts(power_name)
#@     set ground_name              $opts(ground_name)
#@     if { $opts(power_voltage_areas) ne "" } {
#@        upvar $opts(power_voltage_areas) power_voltage_areas
#@        set pwr_va_areas [array get power_voltage_areas]
#@     } else {
#@        set pwr_va_areas ""
#@     }
#@     if { $opts(ground_voltage_areas) ne "" } {
#@        upvar $opts(ground_voltage_areas) ground_voltage_areas
#@        set gnd_va_areas [array get ground_voltage_areas]
#@     } else {
#@        set gnd_va_areas ""
#@     }
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_coord_file ""
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     # set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     ### If UDM, get tech from UDM cell
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@         return 0
#@     }
#@ 
#@     set fillLayer           "via0"
#@     set flowName            "v0_328vssFix"
#@     set container_extension "_v0_328vssFix"
#@ 
#@     # write uin file
#@     set uinfilename "${cellname}${container_extension}.uin"
#@     # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     set uinfilepath "$uindir/$uinfilename"
#@ 
#@     ::dtDfm::V0_328_vss_fixing_writeuin $cellname         $viewname         $techname         $uinfilepath         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $mwlibrary         $write_stm_output         $write_coord_file         $write_def_file         $keepin_cells_list         $power_name         $ground_name         $pwr_va_areas         $gnd_va_areas
#@ 
#@     if { $only_write_uin || $streamlined } {
#@         return ""
#@     }
#@ 
#@     # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@     set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@     set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@     set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@     set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@     set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@     set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@     set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@     set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     set pid [::dtDfm::fill_metal_icv_runflow $cellname                  $flowName                  $container_extension                  0                  $stminputdir                  $uinfilepath                  $icvworkarea                  $icv_options                  $use_lnf_input                  $use_pds                  $launch_script                  $nbpool                  $nbclass                  $nbslot ]
#@ 
#@     # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@     # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set jobInfo ""
#@     ::dtDfm::keylset jobInfo PID           $pid
#@     ::dtDfm::keylset jobInfo CELLNAME      $cellname
#@     ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME      $outputcellname
#@     ::dtDfm::keylset jobInfo VIEWNAME      $viewname
#@     ::dtDfm::keylset jobInfo TECHNAME      $techname
#@     ::dtDfm::keylset jobInfo EXTENSION     $container_extension
#@     ::dtDfm::keylset jobInfo ICVWORKAREA   $icvworkarea
#@     ::dtDfm::keylset jobInfo PROPERTY      $property
#@     ::dtDfm::keylset jobInfo STUBNET       $stubnet
#@     ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@     ::dtDfm::keylset jobInfo RENAME_NETS   $rename_nets
#@     # ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@     ::dtDfm::keylset jobInfo CMD_STR       $print_cmd_str
#@     ::dtDfm::keylset jobInfo LAYER         $fillLayer
#@ 
#@     set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@     lappend jobs $jobInfo
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@     return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::V0_328_vss_fixing_writeuin { cellname                                          viewname                                          techname                                          uinfilepath                                          write_milkyway_output                                          fill_in_cel_view                                          mwoutpath                                          mwlibrary                                          write_stm_output                                          write_coord_file                                          write_def_file                                          keepin_cells_list                                          power_name                                          ground_name                                          {pwr_va_areas ""}                                          {gnd_va_areas ""}                                  } {
#@ 
#@     set f [open "$uinfilepath" w]
#@ 
#@     if { $techname != "" } {
#@         puts $f "process_name = \"$techname\";"
#@     }
#@ 
#@     ::dtDfm::fill_metal_icv_write_output_options_to_uin $f         $write_stm_output         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $cellname         $mwlibrary;
#@ 
#@     set cell_list_option_name "keepin_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepin_cells_list;
#@ 
#@     puts $f "write_def_file           = \"$write_def_file\";"
#@ 
#@     if { $pwr_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $pwr_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "pwr_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "power_name               = \"$power_name\";"
#@     }
#@     if { $gnd_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $gnd_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "gnd_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "ground_name              = \"$ground_name\";"
#@     }
#@ 
#@     close $f
#@ }
#@ 
#@ if {[info exists env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/flexfill/templates/via_color_wrapper.tcl]} {
#@     source $env(CDS_ISS_OVRRD)/flexfill/templates/via_color_wrapper.tcl
#@ }
#@ # -- End source /p/fdk/fdk73/builds/pdk733_r1.7/fill/icv/flexfill/templates/dtDfmFillMetalICV.tcl

#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_pg_hookup.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/initial_detailroute.tcl

#@ ##############################################################################
#@ 
#@ ###################################################
#@ # Initial detail route & incremental route optimization
#@ ###################################################
#@ 
#@ P_msg_info "Running initial detail route"
#@ eval $INTEL_INITIAL_DETAIL_ROUTE_CMD 
#@ save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_initialDetailRoute
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/initial_detailroute.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_create_clock_shield.tcl

#@ ##############################################################################
#@ 
#@ ###################################################
#@ # Create clock shield
#@ ###################################################
#@ 
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   create_zrt_shield -mode reshield -preferred_direction_only true -align_to_shape_end true
#@   set_extraction_options -virtual_shield_extraction false
#@   report_zrt_shield
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_create_clock_shield.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/verify_zrt_route.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ if {[info exists INTEL_ZROUTE_FIX_ANTENNA] && $INTEL_ZROUTE_FIX_ANTENNA ==1} {
#@   P_msg_info "Running verify_zrt_route - Antenna check enabled"
#@   verify_zrt_route -antenna true -check_from_frozen_shapes true
#@ } else {
#@   P_msg_info "Running verify_zrt_route - Antenna check disabled"
#@   verify_zrt_route -antenna false -check_from_frozen_shapes true
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/verify_zrt_route.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ ##############################################################################
#@ 
#@ #####################################
#@ # List of procs used in script
#@ # None
#@ ################################
#@ 
#@ 
#@ ## making the net names case insensitive to avoid false violation from LVS
#@ define_name_rules standard_netnames -case_insensitive -type net
#@ 
#@ if {$synopsys_program_name == "icc_shell" && $INTEL_ECO_TYPE != 0 } {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ } else {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ }
#@ 
#@ 
#@ puts "==>INFORMATION: Running default verilog rule , check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules verilog >> $change_name_log_file
#@ 
#@ puts "==>INFORMATION: Running name rule 'standard_netnames_verilog', check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules standard_netnames >> $change_name_log_file
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ ##############################################################################
#@ #Script: tool_constraints.tcl
#@ # List of procs used by this tcl
#@ # 1. P_lminus
#@ # 2. P_msg_info
#@ # 3. get_completed_steps
#@ 
#@ # Density screening
#@ #
#@ # set_congestion_options
#@ #       [-max_util value]: Specifies the layer name whose availability is reduced.
#@ #       [-layer name]: Specifies the availability of the routing resource for the layer
#@ #       [-availability value]: Specifies the availability of the routing resource for the layer
#@ #       [-coordinate {X1 Y1 X2 Y2}]: Specifies the lower left and upper right coordinates
#@ #                                    for which the congestion options will apply.
#@ #                                    The numbers are in microns.
#@ # Example: set_congestion_options -max_util 0.5 -coordinate {0 0 2560 155}
#@ 
#@ 
#@ # Soft blockage (0% utilization during initial place, but allows for buffering later)
#@ #
#@ # create_placement_blockage
#@ #       -bbox rectangle: Specifies the coordinates of the bounding box of the blockage.
#@ #                        rectangle  x1 y1 x2 y2
#@ #       -type soft: Specifies the type of blockage to be created as soft.
#@ #                   With a soft blockage, the placer tries not to place standard cells
#@ #                   or hard macros in the specified region but will do so if the congestion
#@ #                   is too high.
#@ #       [-name blockage_name]: Specifies the optional name of the blockage.
#@ #                              If you  specify  a name  for  the blockage,
#@ #                              you can use it later in the flow to get the blockage by name.
#@ # Example: create_placement_blockage -name hot_corner_plcmnt_blkg_1 -bbox {{4066 259.2} {4096 459.2}} -type soft
#@ # Example: create_placement_blockage -name KO_idv4 -bbox { 540.4 1094.56 579.6  1225.28} -type soft
#@ 
#@ 
#@ # Cells inserted during each flow will have a prefix of the flow name. For ex. placement will have "place" prefix
#@ # If Intel flow variables are not defined, then the default prefix will be used
#@ if {[lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0] != ""} {
#@   set_app_var compile_instance_name_prefix [lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0]
#@ }
#@ 
#@ # Enables congestion removal with the global router
#@ set_app_var placer_enable_enhanced_router true
#@ 
#@ #To prevent side load on output ports
#@ set_isolate_ports -type buffer [filter_collection [all_outputs] "direction=~out"]
#@ 
#@ # Congestion removal effort during coarse placement
#@ set_app_var placer_enable_high_effort_congestion true
#@ 
#@ # Congestion effort during place_opt (default is auto)
#@ # Setting to medium/high, ICC always uses the Zroute global route for congestion-driven placement
#@ set_app_var placer_congestion_effort medium
#@ 
#@ # Prints out Zroute global routing information during congestion-driven placement
#@ set_app_var placer_show_zroutegr_output true
#@ 
#@ # Ensure cells are placed close together for low-utilization blocks
#@ # Recommended setings are somewhere between 0.5 and 0.65
#@ set_app_var placer_max_cell_density_threshold 0.6
#@ 
#@ # Set critical range
#@ set_critical_range $INTEL_CRITICAL_RANGE [get_designs]
#@ 
#@ # Pre-route area and power critical range values
#@ if {[info exists INTEL_AREA_CRITICAL_RANGE] && $INTEL_AREA_CRITICAL_RANGE!="not_set"} {
#@   set_app_var physopt_area_critical_range $INTEL_AREA_CRITICAL_RANGE
#@ }
#@ if {[info exists INTEL_POWER_CRITICAL_RANGE] && $INTEL_POWER_CRITICAL_RANGE != "not_set" } {
#@   set_app_var physopt_power_critical_range $INTEL_POWER_CRITICAL_RANGE
#@ }
#@ 
#@ # Avoid excessive buffering
#@ set_buffer_opt_strategy -effort medium
#@ 
#@ # Set auto high fanout synthesis options
#@ set_ahfs_options     -constant_nets true     -port_map_file outputs/${INTEL_DESIGN_NAME}_ahfs_port_map.txt
#@ 
#@ # Set routing layers
#@ remove_ignored_layers -all
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS
#@ }
#@ P_msg_info "Setting min_routing_layer: $min_routing_layer"
#@ P_msg_info "Setting max_routing_layer: $max_routing_layer"
#@ P_msg_info "Setting rc_ignore_layer:   $rc_ignore_layer"
#@ set_ignored_layers      -min_routing_layer $min_routing_layer     -max_routing_layer $max_routing_layer     -rc_congestion_ignored_layers $rc_ignore_layer
#@ 
#@ 
#@ # Setting default Toggle Rate and Static Probability for power optmization in the absence of SAIF
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@     P_msg_info "Input saif file will be used for dynamic power optmization"
#@   } else {
#@     P_msg_info "Setting default toggle rate $INTEL_POWER_TR and default static probability $INTEL_POWER_SP for dynamic power optimization"
#@     set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@     set_app_var power_default_static_probability $INTEL_POWER_SP
#@   }
#@ }
#@ 
#@ # Power optimization options (turn on dynamic power opt if INTEL_DYNAMIC_POWER is set to 1)
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement true
#@ } else {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement false
#@ }
#@ 
#@ #Enable DRC on constant nets
#@ set_auto_disable_drc_nets -constant false
#@ 
#@ #Ensure the tool observes max_cap constraints during tie-off optimization
#@ set_app_var physopt_new_fix_constants true
#@ 
#@ # Enable via resistance estimation
#@ set_app_var physopt_enable_via_res_support true
#@ 
#@ # Uses alternate name styles to solve name mismatching issues in read_def
#@ set_app_var def_enable_no_legalize_name true
#@ 
#@ # Set multiple port nets options
#@ #        [-feedthroughs]        (fix feedthroughs)
#@ #        [-outputs]             (fix multiple output port nets)
#@ #        [-buffer_constants]    (buffer constants driving multiple ports)
#@ # Without this option, feedthrough ports can be connected directly to each other
#@ # and create text short error in LVS.
#@ set_fix_multiple_port_nets -feedthroughs -outputs -buffer_constants
#@ 
#@ ################################
#@ # Placement
#@ ################################
#@ # Use Zrouter to drive peroute optimization.
#@ if { $::sh_product_version > {I-2013.12-ICC-SP2} } {
#@   set_place_opt_strategy -consider_routing true
#@ }
#@ 
#@ ####################################
#@ # Setting Delay Calculation Options
#@ ####################################
#@ P_msg_info "Setting Delay Calculation as follows :\n Pre-route : Elmore\n Routed Clock : Arnoldi\n Post-route : Arnoldi"
#@ set_delay_calculation_options -preroute elmore -routed_clock arnoldi -postroute arnoldi
#@ 
#@ ####################################
#@ # CTS
#@ ####################################
#@ # The following are used to force CTS to fix more max_cap drcs.
#@ set         ctdn_enable_ccs_low_cap true
#@ set_app_var cto_enable_drc_fixing   true
#@ set         cts_low_power           false
#@ 
#@ ####################################
#@ # Extraction Options
#@ ####################################
#@ 
#@ if { [lsearch -exact [get_completed_steps] fill] > 0} {
#@   set_extraction_options       -real_metalfill_extraction FLOATING       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ } else {
#@   set_extraction_options       -real_metalfill_extraction none       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ ##############################################################################
#@ # Description: This script enables the application of frequency based max-capacitance values
#@ #              The highest frequency in the design is used for max-capacitance lookup
#@ #Required Vars: INTEL_CMAX_DEFAULT_PERIOD - Clock Period used if minimum clock period could not be derived.
#@ #               INTEL_CMAX_LUT - Full Path to Cmax Lookup Table CSV file
#@ #Procs Used:
#@ #1. P_msg_warn
#@ #2. P_msg_error
#@ #3. P_msg_info
#@ 
#@ # Determine maximum frequency
#@ set minperiod [lindex [lsort -increasing -real [get_attribute [get_clocks] period -quiet]] 0]
#@ 
#@ # As a fail-safe, set a default frequency
#@ if {$minperiod eq ""} {
#@   if {[info exists INTEL_CMAX_DEFAULT_PERIOD] && $INTEL_CMAX_DEFAULT_PERIOD != ""} {
#@     P_msg_warn "Minimum period could not be determined. Defaulting to ${INTEL_CMAX_DEFAULT_PERIOD}ps"
#@     set minperiod $INTEL_CMAX_DEFAULT_PERIOD
#@   } else {
#@     P_msg_error "Minimum period could not be determined. Please provide minimum period to use by setting INTEL_CMAX_DEFAULT_PERIOD variable."
#@     return
#@   }
#@ }
#@ 
#@ # Multiplying by 1000 as lookup table values are in GHz
#@ set fmax [expr [expr 1.0/$minperiod] * 1000]
#@ 
#@ # Read reference file
#@ if {[info exists INTEL_CMAX_LUT] && [file exists $INTEL_CMAX_LUT]} {
#@   P_msg_info "Reading Max-Cap LUT file - $INTEL_CMAX_LUT"
#@   set lut_file $INTEL_CMAX_LUT
#@   set fh [open $lut_file "r"]
#@ } else {
#@   P_msg_warn "Either INTEL_CMAX_LUT variable does not exist (or) $INTEL_CMAX_LUT file cannot be found"
#@   return
#@ }
#@ 
#@ if {[info exists INTEL_SCALE_RV_CMAX] && $INTEL_SCALE_RV_CMAX != ""} {
#@   P_msg_info "RV Cmax scaling enabled. Scaling factor value - $INTEL_SCALE_RV_CMAX - has been used..."
#@   set scaling_factor $INTEL_SCALE_RV_CMAX
#@ } else {
#@   set scaling_factor 1
#@ }
#@ 
#@ P_msg_info "Applying frequency based max-capacitance values..."
#@ set err_cnt 0
#@ while {[gets $fh line] > -1} {
#@   set line_vals [split $line ","]
#@   if {[regexp {^cell} $line]} {
#@     set indices [lrange $line_vals 1 end]
#@   } else {
#@     if {[sizeof_collection [set lib_pin [get_lib_pins */[lindex $line_vals 0] -quiet]]]} {
#@       set i 0
#@       set prev_val ""
#@       set curr_val ""
#@       set prev_index ""
#@       set curr_index ""
#@       set new_cmax_value ""
#@       foreach cmax [lrange $line_vals 1 end] {
#@         set prev_val $curr_val
#@         set curr_val $cmax
#@         set prev_index $curr_index
#@         set curr_index [lindex $indices $i]
#@         if {[expr $fmax >= $curr_index]} {
#@           # continue to next value
#@           if {$i == [expr [llength [lrange $line_vals 1 end]] - 1]} {
#@             set new_cmax_value $cmax
#@             break
#@           }
#@         } elseif {$prev_val eq ""} {
#@           # if "" then this is the first index and the fmax is less than the minimum table value
#@           # set to minimum value
#@           set new_cmax_value $cmax
#@           break
#@         } else {
#@           # at this point we should be between two table values. interpolate.
#@           set index_prop [expr ($fmax - $prev_index)/($curr_index - $prev_index)]
#@           set new_cmax_value [expr $index_prop * ($curr_val - $prev_val) + $prev_val]
#@           set new_cmax_value [expr $new_cmax_value * $scaling_factor]
#@           break
#@         }
#@         incr i
#@       }
#@ 
#@       # Check for new_cmax_value
#@       if {$new_cmax_value eq ""} {
#@         P_msg_error "Cmax value not gathered correctly"
#@         incr err_cnt
#@       } elseif {[lindex [get_attribute $lib_pin pin_direction] 0] eq "in"} {
#@         P_msg_error "Library pin is input. Not setting Cmax. Something is likely wrong with the LUT."
#@         P_msg_error "Lib pin - [lindex [get_object_name $lib_pin] 0]"
#@         incr err_cnt
#@       } else {
#@         suppress_message {MWUI-031}
#@         set_attribute $lib_pin max_capacitance $new_cmax_value
#@         unsuppress_message {MWUI-031}
#@       }
#@     } else {
#@       P_msg_warn "Lib pin [lindex $line_vals 0] could not be found"
#@     }
#@   }
#@ }
#@ close $fh
#@ 
#@ if {$err_cnt == 0} {
#@   P_msg_info "Frequency based max-capacitance values applied successfully!"
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/cmax_interpolate.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options.tcl

#@ ##############################################################################
#@ # Script: route_options.tcl
#@ # Description:
#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ ###################################################
#@ # Set up for hold-fix on all dominate scenarios
#@ ###################################################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   foreach scenario [all_active_scenarios] {
#@     current_scenario $scenario
#@     set_fix_hold [all_clocks]
#@     P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@     set min_delay_cells ""
#@     foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@       set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@     }
#@     if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@       set_prefer -min $min_delay_cells
#@       set_fix_hold_options -default
#@       set_fix_hold_options -preferred_buffer
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ } else {
#@   set_fix_hold [all_clocks]
#@   P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@   set min_delay_cells ""
#@   foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@     set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@   }
#@   if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@     set_prefer -min $min_delay_cells
#@     set_fix_hold_options -default
#@     set_fix_hold_options -preferred_buffer
#@   }
#@ }
#@ 
#@ # Route-opt strategy - this setting is non-persistent
#@ P_msg_info "Setting route_opt strategy"
#@ set_route_opt_strategy     -fix_hold_mode route_base     -search_repair_loops 10     -eco_route_search_repair_loops 10
#@ 
#@ # SI Strategy
#@ # Set SI options to enable the zroute crosstalk reduction and fix violations
#@ P_msg_info "Setting SI parameters"
#@ set_si_options     -route_xtalk_prevention true     -route_xtalk_prevention_threshold 0.25     -timing_window true     -delta_delay true     -min_delta_delay true     -max_transition_mode normal_slew     -analysis_effort medium     -reselect true
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ ##############################################################################
#@ # Script: route_options_drc.tcl
#@ # Description: Sets Z-Route options to achieve DRV convergence
#@ ##############################################################################
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Common Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_common_options -default true
#@ 
#@ # specifies the routing clock topology - normal routing of clock nets(default : normal)
#@ set_route_zrt_common_options -clock_topology normal
#@ 
#@ #switch forces the router to only allow a single connection to be made to any cell pin
#@ set_route_zrt_common_options -single_connection_to_pins all_pins
#@ 
#@ # control strength of min layer constraint
#@ set_route_zrt_common_options -global_min_layer_mode allow_pin_connection
#@ set_route_zrt_common_options -net_min_layer_mode soft
#@ 
#@ # control strength of max layer constraint
#@ set_route_zrt_common_options -global_max_layer_mode hard
#@ set_route_zrt_common_options -net_max_layer_mode hard
#@ 
#@ 
#@ # amount of information in logfile - range 0 1 2 (default : 0)
#@ set_route_zrt_common_options -verbose_level 1
#@ 
#@ # no documentation on this switch
#@ set_route_zrt_common_options -connect_tie_off true
#@ 
#@ # Ensures route connections are made within the pins
#@ # If connections need to be made to ends of pins this should not be set
#@ #set_route_zrt_common_options -connect_within_pins_by_layer_name {{m1 via_standard_cell_pins}}
#@ 
#@ # control whether or not to rotate the default vias
#@ set_route_zrt_common_options -rotate_default_vias false
#@ 
#@ # control reading in shapes on metal blockage layer
#@ set_route_zrt_common_options -read_user_metal_blockage_layer true
#@ 
#@ # set route_m1ExtraCost 20
#@ #set_route_zrt_common_options -extra_preferred_direction_wire_cost_multiplier_by_layer_name {{m1 20}}
#@ 
#@ # mark clock tree nets as minor-change only (default : true)
#@ set_route_zrt_common_options -mark_clock_nets_minor_change true
#@ 
#@ # reroute clock net shapes  (default : false)
#@ set_route_zrt_common_options -reroute_clock_shapes false
#@ 
#@ # reroute user created shapes (default : false)
#@ set_route_zrt_common_options -reroute_user_shapes false
#@ 
#@ # Redundant via insertion
#@ if {[info exists INTEL_ZROUTE_VIA_DBL] && $INTEL_ZROUTE_VIA_DBL ==1} {
#@   ## Setting this option prior to routing, starts the via doubling,
#@   ## without the need for the standalone command
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion medium
#@ } else {
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion off
#@ }
#@ 
#@ # Enable RC driven layer assignment
#@ if {[info exists INTEL_LAYER_PROMOTION] && $INTEL_LAYER_PROMOTION == 1} {
#@   set_route_zrt_common_options -rc_driven_setup_effort_level high
#@ }
#@ 
#@ # Enable reshielding of modified nets
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   set_route_zrt_common_options -reshield_modified_nets reshield
#@ }
#@ 
#@ ###################################################
#@ #ZRT: Global Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_global_options -default true
#@ 
#@ # enables (true) or disables (false) timing-driven global routing (default : false)
#@ set_route_zrt_global_options -timing_driven true
#@ 
#@ # option -macro_corner_track_utilization limits the utilization of tracks
#@ # available in the gcells near a macro corner to a specified  percentage.
#@ # This  variable is used to control the accessibility of pins and conges-
#@ # tion at the macro corners. By default, the router uses 100  percent  of
#@ # available tracks in the macro boundary width.
#@ set_route_zrt_global_options -macro_corner_track_utilization 95
#@ 
#@ ### performs global routing using effort level (low,medium,high) - tool defualt medium
#@ set_route_zrt_global_options -effort medium
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Track Assignment Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_track_options -default true
#@ 
#@ # Enables  (true)  or disables (false) timing-driven track assign (default : false)
#@ set_route_zrt_track_options -timing_driven true
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Detail Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_detail_options -default true
#@ 
#@ # Initially turn off antenna (if INTEL_ZROUTE_FIX_ANTENNA is set, fix antenna later)
#@ set_route_zrt_detail_options -antenna false
#@ 
#@ # DRC convergence effort level (default : medium)
#@ set_route_zrt_detail_options -drc_convergence_effort_level medium
#@ 
#@ # controls whether the router ignores specific design rule
#@ # The setting says "DO NOT" ignore same_net_metal_space DRV's
#@ set_route_zrt_detail_options -ignore_drc {{same_net_metal_space false}}
#@ 
#@ # specifies whether variable routing rule spacing is ignored against blockages
#@ set_route_zrt_common_options -ignore_var_spacing_to_blockage false
#@ 
#@ # specifies whether variable routing rule spacing is ignored against p/g nets
#@ set_route_zrt_common_options -ignore_var_spacing_to_pg true
#@ 
#@ # specifies whether timing-driven routing is enabled (default : false)
#@ set_route_zrt_detail_options -timing_driven true
#@ 
#@ # Ensure that there is no illegal tapering from NDR width to default width
#@ #set_route_zrt_detail_options -use_wide_wire_to_input_pin true -use_wide_wire_to_output_pin true
#@ 
#@ ## Set this to reduce the initial amount of vias.  The default tool setting is low.
#@ set_route_zrt_detail_options -optimize_wire_via_effort_level medium
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/antenna_rules.tcl

#@ ##############################################################################
#@ # Script: antenna_rules.tcl
#@ # Description:
#@ ###############################################################################
#@ 
#@ if {[info exists INTEL_ZROUTE_FIX_ANTENNA] && $INTEL_ZROUTE_FIX_ANTENNA ==1} {
#@   P_msg_info "Setting NAC rules prior to routing"
#@ 
#@   set metal_ratio 1400
#@   set metal9_ratio 560
#@   set max_metal_ratio 1400
#@ 
#@   set max_via_ratio 475
#@   set via0_ratio 45
#@   set via1_ratio 180
#@   set via2_ratio 180
#@   set via3_ratio 180
#@   set via4_ratio 210
#@   set via5_ratio 275
#@   set via6_ratio 275
#@   set via7_ratio 475
#@   set via8_ratio 475
#@   set via9_ratio 35
#@ 
#@   set v_dmode 15
#@ 
#@   remove_antenna_rules
#@ 
#@   define_antenna_rule -mode 1 -diode_mode $v_dmode -metal_ratio $max_metal_ratio -cut_nratio $max_via_ratio  -cut_pratio $max_via_ratio       -metal_area_to_ngate_diffusion_length_ratio 35
#@ 
#@   define_antenna_layer_rule -mode 1 -layer {m0}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m1}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m2}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m3}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m4}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m5}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m6}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m7}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m8}  -ratio $metal_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {m9}  -ratio $metal9_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {tm1} -ratio $metal9_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {c4}  -ratio $metal9_ratio -nratio 2850 -pratio 850 -area_to_ngate_diffusion_length_ratio 35  -diode_ratio {0 1 1 0 0}
#@ 
#@   define_antenna_layer_rule -mode 1 -layer {v0}  -nratio $via0_ratio  -pratio $via0_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v1}  -nratio $via1_ratio  -pratio $via1_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v2}  -nratio $via2_ratio  -pratio $via2_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v3}  -nratio $via3_ratio  -pratio $via3_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v4}  -nratio $via4_ratio  -pratio $via4_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v5}  -nratio $via5_ratio  -pratio $via5_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v6}  -nratio $via6_ratio  -pratio $via6_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v7}  -nratio $via7_ratio  -pratio $via7_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v8}  -nratio $via8_ratio  -pratio $via8_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {v9}  -nratio $via9_ratio  -pratio $via9_ratio  -diode_ratio {0 1 1 0 0}
#@   define_antenna_layer_rule -mode 1 -layer {tv1} -nratio $via9_ratio -pratio $via9_ratio -diode_ratio {0 1 1 0 0}
#@ 
#@   report_antenna_rules -output reports/dump_antenna.rules
#@ 
#@   P_msg_info "Set NAC rules before routing"
#@ 
#@   set_route_zrt_detail_options -diode_libcell_names $INTEL_ANTENNA_DIODE
#@   set_route_zrt_detail_options -antenna true
#@   set_route_zrt_detail_options -default_gate_size 0
#@   set_route_zrt_detail_options -hop_layers_to_fix_antenna true
#@   set_route_zrt_detail_options -insert_diodes_during_routing true
#@   set_route_zrt_detail_options -default_port_external_gate_size 0.001
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/antenna_rules.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/remove_pg_hookup.tcl

#@ ##############################################################################
#@ # script : remove_pg_hookup.tcl
#@ # description : Removes PG hookup from design.
#@ ##############################################################################
#@ 
#@ 
#@ # New Runset based PG Hookup
#@ set items_removed_with_attributes 0
#@ if { [namespace which ::pwr::remove_stdcell_powerhookup] ne "" } {
#@   # use stdcell power hookup attributes for removal
#@   set items_removed_with_attributes [::pwr::remove_stdcell_powerhookup]
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/remove_pg_hookup.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_route_opt.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ # To disable splitting of the routing process
#@ # Setting allows accurate runtime and memory calculation
#@ set_separate_process_options -routing false
#@ 
#@ P_msg_info "Running post route incremental optimization"
#@ eval $INTEL_INCR_ROUTE_OPT_CMD
#@ 
#@ # Save mw cell
#@ save_mw_cel -as ${INTEL_DESIGN_NAME}_fdksave_incrDetailRoute
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_route_opt.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/insert_antenna_diodes_on_input.tcl

#@ ##############################################################################
#@ # List of procs used by this script
#@ # 1. P_msg_error
#@ # 2. P_msg_info
#@ 
#@ # Get lib cells to use for diode insertion.
#@ # The tool requires the specific diode library to be used and for MCMM mode that needs to be the current scenario.
#@ # So for MCMM mode a dummy diode cell is inserted to get the correct lib_cell, once done the dummy diode in removed.
#@ 
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   if {[sizeof_collection [get_cells -all -filter "ref_name =~ $INTEL_ANTENNA_DIODE"]] == 0} {
#@     create_cell test_diode $INTEL_ANTENNA_DIODE
#@   }
#@   foreach lib [get_object_name [get_libs -scenario [current_scenario]]] {
#@     if {[get_lib_cells -quiet $lib/$INTEL_ANTENNA_DIODE] ne ""} {
#@       set diode_cell_insert [get_object_name [get_lib_cells -quiet $lib/$INTEL_ANTENNA_DIODE]]
#@     }
#@   }
#@   if {[sizeof_collection [get_cells *test_diode*]] > 0} {
#@     remove_cell test_diode
#@   }
#@ } else {
#@   foreach lib [split $target_library] {
#@     set lib [file rootname $lib]
#@     if {[get_lib_cells -quiet ${lib}*/${INTEL_ANTENNA_DIODE}] ne ""} {
#@       set diode_cell_insert [get_object_name [get_lib_cells -quiet ${lib}*/${INTEL_ANTENNA_DIODE}]]
#@     }
#@   }
#@ }
#@ 
#@ # Check if the chosen diode cell to insert exists
#@ if {![info exists diode_cell_insert] || $diode_cell_insert eq ""} {
#@   P_msg_error "No input port diode cell found in library. Please check that $INTEL_ANTENNA_DIODE is set and the cell is available in the library!"
#@   return
#@ }
#@ 
#@ # Insert GNAC diode on all input ports Except Clock Ports and the Ports specified by The User Through Variable INTEL_NO_INPUT_DIODE_PORTS
#@ set clock_ports [get_ports [get_attribute [all_clocks] sources -quiet]]
#@ # Avoid tm1 ports as they are typically pad inputs
#@ set tm1_ports [get_ports -filter {layer == "tm1"}]
#@ set avoid_ports [add_to_collection [add_to_collection $clock_ports $INTEL_NO_INPUT_DIODE_PORTS] $tm1_ports]
#@ if {[get_attribute $diode_cell_insert dont_use] == true} {
#@   remove_attribute $diode_cell_insert dont_use
#@ }
#@ define_user_attribute -class port -type string in_diode
#@ set ports_need_diodes [remove_from_collection [all_inputs] $avoid_ports]
#@ set ports_with_diodes [get_ports -quiet * -filter "in_diode=~*DIODE*"]
#@ set ports_need_diodes [remove_from_collection $ports_need_diodes $ports_with_diodes]
#@ set cmd ""
#@ if { [sizeof_collection $ports_need_diodes] > 0} {
#@   insert_port_protection_diodes -prefix IN_PORT_DIODE -ignore_dont_touch -diode_cell [get_lib_cells $diode_cell_insert] -port $ports_need_diodes
#@   foreach prt [get_object_name $ports_need_diodes] {
#@     set pcells [get_cells -quiet -of [all_connected [get_port $prt]] -filter "full_name=~*_DIODE_*"]
#@     if {[sizeof_collection $pcells]>0} {
#@       set dpin [get_object_name [get_pins -of $pcells]]
#@       set_attribute [get_port $prt] in_diode $dpin
#@       append cmd "disconnect_net \[all_connected $dpin\] ${dpin}; connect_net vss \[get_pin ${dpin}\]; "
#@     }
#@   }
#@ }
#@ if {[sizeof_collection [get_nets -quiet -hier * -filter "net_type==Clock"]]>0} {
#@   foreach_in_collection prt [get_ports -quiet * -filter "in_diode=~*DIODE*"] {
#@     append cmd "disconnect_net \[all_connected \[get_pin [get_attribute $prt in_diode]\]\] \[get_pin [get_attribute $prt in_diode]\] ; "
#@     append cmd "connect_net [get_object_name [all_connected $prt]] \[get_pin [get_attribute $prt in_diode]\] ; "
#@   }
#@ }
#@ eval $cmd
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/insert_antenna_diodes_on_input.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tie_high.tcl

#@ ##############################################################################
#@ # Script: tie_high.tcl
#@ # Description : Insert tie high cells only. Tie low connections are direct to VSS.
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ # 2. P_placement_blockage_move_or_unmove
#@ # 3. P_query_voltage_pgnet
#@ 
#@ ## Tie high cells insertion
#@ if { [get_physical_lib_cells -quiet */$INTEL_TIE_HIGH_CELL]   != ""}  {
#@ 
#@   ### get and save the blockages in the design, to allow add later
#@   ### Remove the placement blockage to allow the tie_hight / tie_low placed closer to the tie high pins
#@   set blockage_bbox_pairs [P_placement_blockage_move_or_unmove move]
#@ 
#@   ## Remove any tie cells in the design already
#@   if {[sizeof_collection [all_tieoff_cells]]} {
#@     remove_tie_cells [all_tieoff_cells]
#@   }
#@ 
#@   if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@     derive_pg_connection -all
#@   } else {
#@     derive_pg_connection -power_net $INTEL_MW_POWER_NET       -ground_net $INTEL_MW_GROUND_NET       -tie
#@   } 
#@  
#@   set count 0
#@   if {[sizeof_collection [get_voltage_areas -quiet  -filter "within_ilm==false"]] == 0} {
#@     set tie_high_net $INTEL_MW_POWER_NET
#@     set eco_pins [get_flat_pins -filter "@preserved == false && @global_net_name == $tie_high_net" ]
#@     set ssb_pins [get_pins -of [all_registers -edge_triggered] -filter "full_name=~*/ssb"]
#@     if {[get_scan_chains]<=1} {
#@       P_msg_info "Excluding ssb pins from tie-high insertion"
#@       set eco_pins [remove_from_collection $eco_pins $ssb_pins]
#@     }
#@     if {[sizeof_collection $eco_pins]} {
#@       connect_tie_cells -objects $eco_pins         -obj_type port_inst         -tie_high_lib_cell $INTEL_TIE_HIGH_CELL         -tie_high_port_name o        -tie_low_lib_cell $INTEL_TIE_LOW_CELL         -tie_low_port_name o        -max_fanout 1 -max_wirelength 10
#@     }
#@   } else {
#@     ### To find each voltage power/ground net name,  "P_query_voltage_pgnet" which
#@     ### set G_VA_POWER & G_VA_GROUND
#@     P_query_voltage_pgnet
#@     foreach_in_collection va [get_voltage_areas -filter "within_ilm==false"] {
#@       set va_name [get_attribute $va name]
#@       set tie_high_net $INTEL_VA_PWR($va_name)
#@       set eco_pins [get_flat_pins -filter "@preserved == false && @global_net_name == $tie_high_net" ]
#@       set ssb_pins [get_pins -of [all_registers -edge_triggered] -filter "full_name=~*/ssb"]
#@       if {[get_scan_chains]<=1} {
#@         P_msg_info "Excluding ssb pins from tie-high insertion"
#@         set eco_pins [remove_from_collection $eco_pins $ssb_pins]
#@       }
#@       if {[sizeof_collection $eco_pins]} {
#@         connect_tie_cells -objects $eco_pins           -obj_type port_inst           -tie_high_lib_cell $INTEL_TIE_HIGH_CELL           -tie_high_port_name o          -tie_low_lib_cell $INTEL_TIE_LOW_CELL           -tie_low_port_name o          -max_fanout 1 -max_wirelength 10      
#@       }
#@     }
#@   }
#@ 
#@   # set dont touch on the tie cells
#@   if { [sizeof_collection [get_cells -hier -filter "ref_name == $INTEL_TIE_HIGH_CELL"]] } {
#@     set_dont_touch [get_cells -hier -filter "ref_name == $INTEL_TIE_HIGH_CELL"]
#@     set_dont_touch [get_nets -of_objects [get_pins -of_objects [get_cells -hier -filter "ref_name == $INTEL_TIE_HIGH_CELL"]]]
#@   }
#@ 
#@   ### Restore placement blockage that was moved
#@   P_placement_blockage_move_or_unmove $blockage_bbox_pairs
#@ 
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tie_high.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_eco_detail_route.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ # Do a incremental legalize for tie cells and diodes introduced.
#@ legalize_placement -incremental
#@ 
#@ P_msg_info "Running eco route for tie nets and diode pins" 
#@ eval $INTEL_INCR_ECO_DETAIL_ROUTE_CMD
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_eco_detail_route.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/opportunistic_local_fiducial_place.tcl

#@ ##############################################################################
#@ # Opportunistically 1x2 and 2x1 local fiducial cells post route
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ # 2. P_placement_blockage_move_or_unmove
#@ # 3. P_adv_polygon_logic
#@ # 4. P_adv_polygon_size
#@ # 5. P_adv_polygon_check
#@ 
#@ # Temporarily move Placement blockages before insertion
#@ set blockage_bbox_pairs ""
#@ if {[sizeof_collection [get_placement_blockages -quiet]] > 0 } {
#@   P_msg_info "Temporarily removing placement blockages before tap cell insertion."
#@   set blockage_bbox_pairs [P_placement_blockage_move_or_unmove move];  ## move placement blockage out of bounds ##
#@ }
#@ 
#@ set shift 0.0
#@ foreach fid_cell $INTEL_LOCAL_FIDUCIAL_POSTROUTE_CELLS {
#@ 
#@   if { [get_physical_lib_cells -quiet */$fid_cell] != ""}  {
#@     P_msg_info "Working on $fid_cell cells insertion ..."
#@     set start_time [clock seconds]
#@     puts "Insert Local Fiducial Start time: [date]"
#@ 
#@     unset -nocomplain _tmp_polygon wsize my_pgon box
#@     set _tmp_polygon {}
#@ 
#@     if {[info exists INTEL_LOCAL_FIDUCIAL_POSTROUTE_SPACING] && $INTEL_LOCAL_FIDUCIAL_POSTROUTE_SPACING ne ""} {
#@       set wsize $INTEL_LOCAL_FIDUCIAL_POSTROUTE_SPACING
#@     } else {
#@       set wsize 8
#@     }
#@ 
#@     # set the prefix of the post routed local fiducial cells
#@     set lfid_inst_prefix "post_route_fiducial_"
#@     set _tmp_clist_boundary [get_attribute [get_flat_cells -all -filter "ref_name=~$INTEL_LOCAL_FIDUCIAL_PREPLACE_CELL && is_fixed==true"] boundary]
#@     set _tmp_polygon [P_adv_polygon_logic or $_tmp_polygon [P_adv_polygon_size $_tmp_clist_boundary "$wsize $wsize"]]
#@ 
#@     if { ![P_adv_polygon_check empty $_tmp_polygon]} {
#@       set count 0
#@       remove_placement_blockage _temp_lfid_blk_*
#@       foreach my_pgon $_tmp_polygon {
#@         foreach box [convert_from_polygon -format rectangle $my_pgon] {
#@           create_placement_blockage -bbox $box -type hard -name "_temp_lfid_blk_${count}"
#@           incr count
#@         }
#@       }
#@     }
#@ 
#@     set_parameter  -module  place -name  legalUnitTiles -value $INTEL_STDCELL_TILE  -type string
#@ 
#@     # insert post route local fiducials
#@     insert_stdcell_filler -cell_without_metal $fid_cell -ignore_soft_placement_blockage         -cell_without_metal_prefix $lfid_inst_prefix
#@ 
#@     # remove local fiducials with violations and placement blockages
#@     remove_zrt_filler_with_violation -name *${fid_cell}*
#@     remove_placement_blockage _temp_lfid_blk_*
#@ 
#@     # Now need to remove the extra INTEL_LOCAL_FIDUCIAL_POSTROUTE_CELLS cells
#@     # Remove extra 1x fiducicals using 2D array to mark if fiducial exists in region
#@ 
#@     array unset distgrid
#@     array unset namegrid
#@     set removed 0
#@     set kept 0
#@     set count 0
#@     set max_x 0
#@     set max_y 0
#@ 
#@     scan [get_attribute [index_collection [get_physical_lib_cells */$fid_cell] 0] bbox] "{%f %f} {%f %f}" fd_llx fd_lly fd_urx fd_ury
#@     set fd_width [expr $fd_urx - $fd_llx]
#@     set fd_height [expr $fd_ury - $fd_lly]
#@ 
#@     foreach_in_collection lfid [get_flat_cells -all -filter ref_name==$fid_cell] {
#@       # get location of 1x fiducial
#@       set cell_x [get_attribute $lfid bbox_llx]
#@       set cell_y [get_attribute $lfid bbox_lly]
#@       set cell_ux [get_attribute $lfid bbox_urx]
#@       set cell_uy [get_attribute $lfid bbox_ury]
#@ 
#@       # get grid box this cell belongs to
#@       set box_x [expr {int(floor([expr {$cell_x / $wsize}]))}]
#@       set box_y [expr {int(floor([expr {$cell_y / $wsize}]))}]
#@ 
#@       # get the center of the grid box
#@       set box_center_x [expr {[expr {$box_x * $wsize}] + $wsize/2.0 + $shift}]
#@       set box_center_y [expr {[expr {$box_y * $wsize}] + $wsize/2.0 + $shift}]
#@ 
#@       # calculate the center point of the 1x fiducial cell
#@       set cell_center_x [expr {$cell_x + $fd_width/2.0}]
#@       set cell_center_y [expr {$cell_y + $fd_height/2.0}]
#@ 
#@       # calculate the distance from center point of cell to center point of box.
#@       set dist_x [expr {$cell_center_x - $box_center_x}]
#@       set dist_y [expr {$cell_center_y - $box_center_y}]
#@       set dist  [expr sqrt([expr {pow($dist_x,2) + pow($dist_y,2)}])]
#@ 
#@       # get the distance of the previous nearest fiducial in this box
#@       set prev_dist [expr $wsize*100]
#@       if {[info exists distgrid($box_x,$box_y)]} {
#@         set prev_dist $distgrid($box_x,$box_y)
#@       }
#@ 
#@       # keep the fiducial nearest the center of the box, and ignore the fiducial across up bound of box.
#@       if {($dist < $prev_dist ) && ($cell_uy < [expr ($box_y + 1) * $wsize]) } {
#@         set fname [get_attribute $lfid full_name]
#@         set distgrid($box_x,$box_y) $dist
#@         set namegrid($box_x,$box_y) $fname
#@       }
#@ 
#@       # record max x value reached
#@       if {$box_x > $max_x} {
#@         set max_x $box_x
#@       }
#@ 
#@       # record max y value reached
#@       if {$box_y > $max_y} {
#@         set max_y $box_y
#@       }
#@ 
#@       # report progress
#@       incr count
#@       if {$count % 10000 == 0} {
#@         P_msg_info "Processed $count fiducials"
#@       }
#@     }
#@     set shift [expr $shift + $wsize/2.0 ]
#@ 
#@     # build a list of 1x fiducials that are nearest the center of each box
#@     set kept_fids ""
#@     for {set x 0 } { $x <= $max_x } { incr x} {
#@       for { set y 0 } { $y <= $max_y } { incr y } {
#@         if {[info exists namegrid($x,$y)]} {
#@           set fid $namegrid($x,$y)
#@           lappend kept_fids $fid
#@         }
#@       }
#@     }
#@ 
#@     set kept_fids_count [llength $kept_fids]
#@     P_msg_info "Inserted $kept_fids_count fiducial cell: $fid_cell to keep"
#@ 
#@     redirect /dev/null {set_attribute $kept_fids is_fixed true}
#@     redirect /dev/null {remove_cell  [get_flat_cells -all -filter "ref_name=~$fid_cell && full_name=~ *${lfid_inst_prefix}* && is_fixed == false"]}
#@     redirect /dev/null {set_attribute -quiet [get_flat_cells -all -filter "ref_name=~$fid_cell && full_name=~ *${lfid_inst_prefix}*"] is_fixed false }
#@ 
#@     set elapsed_time [expr [clock seconds] - $start_time]
#@     set clock_hours "[clock format [expr $elapsed_time / 60] -format %M]"
#@     set fill_clock_elapsed "$clock_hours:[clock format $elapsed_time -format %M:%S]"
#@     puts "Insert Local Fiducial Runtime(hh:mm:ss) $fill_clock_elapsed "
#@   } else {
#@     puts "Error: Missing Local Fiducial cells $fid_cell in the MW libs"
#@   }
#@ }
#@ 
#@ ### Restore hard placement blockage that were moved
#@ P_placement_blockage_move_or_unmove $blockage_bbox_pairs;            ## restore original placement blockage   ##
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/opportunistic_local_fiducial_place.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_create_clock_shield.tcl

#@ ##############################################################################
#@ 
#@ ###################################################
#@ # Create clock shield
#@ ###################################################
#@ 
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   create_zrt_shield -mode reshield -preferred_direction_only true -align_to_shape_end true
#@   set_extraction_options -virtual_shield_extraction false
#@   report_zrt_shield
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_create_clock_shield.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_filler_cells_d04.tcl

#@ ##############################################################################
#@ # Script: add_filler_cells_d04.tcl
#@ # Description:
#@ ##############################################################################
#@ 
#@ ### Required procs:
#@ # P_placement_blockage_move_or_unmove
#@ # P_bonus_array_blockage
#@ # P_stdcell_filler_vcn_v0
#@ 
#@ 
#@ if {![info exists INTEL_STDCELL_FILLER_MODE]} { set INTEL_STDCELL_FILLER_MODE decap; }; # default|decap #
#@ ##  spacer_vcnv0  - adds spacer3 between bonus array and vcn v0 over spacer3_2  - will pass vcn v0 density  ##
#@ ##  decap         - adds decap between bonus array                              - will pass vcn v0 density  ##
#@ ######################################################################################################################
#@ 
#@ 
#@ ##############################################################################
#@ # Insert filler cells
#@ ##############################################################################
#@ 
#@ #Insert bonus array cells
#@ set physopt_check_site_array_overlap false
#@ if { [info exists INTEL_STDCELL_BONUS_GATEARRAY_TILE] } {
#@   set_parameter -module  place -name  legalUnitTiles -value $INTEL_STDCELL_BONUS_GATEARRAY_TILE -type string
#@ }
#@ 
#@ if {$INTEL_STDCELL_FILLER_MODE=="decap"} {
#@   set blockage_bbox_pairs [P_placement_blockage_move_or_unmove move];  ## move placement blockage out of bounds ##
#@   P_bonus_array_blockage odd_blockage $INTEL_STDCELL_FILLER_MODE;          ## add odd  bonus cell placement blockage ##
#@   insert_stdcell_filler -cell_without_metal $INTEL_BONUS_GATEARRAY_CELLS -ignore_soft_placement_blockage; ## add bonus cells ##
#@   P_bonus_array_blockage even_blockage $INTEL_STDCELL_FILLER_MODE;         ## add even bonus cell placement blockage ##
#@   insert_stdcell_filler -cell_without_metal $INTEL_BONUS_GATEARRAY_CELLS -ignore_soft_placement_blockage; ## add bonus cells ##
#@   P_bonus_array_blockage remove_blockage $INTEL_STDCELL_FILLER_MODE;       ## remove   bonus cell placement blockage ##
#@   P_placement_blockage_move_or_unmove $blockage_bbox_pairs;            ## restore original placement blockage   ##
#@ } else {
#@   ## original bonus fill routine ##
#@   insert_stdcell_filler -cell_without_metal $INTEL_BONUS_GATEARRAY_CELLS       -ignore_hard_placement_blockage       -ignore_soft_placement_blockage
#@ }
#@ #Insert decap and spacer cells
#@ set_parameter  -module  place -name  legalUnitTiles  -value $INTEL_STDCELL_TILE  -type string
#@ 
#@ if {$INTEL_STDCELL_FILLER_MODE=="decap"} {
#@   insert_stdcell_filler -cell_with_metal $INTEL_2X_DECAP_CELLS -ignore_hard_placement_blockage -ignore_soft_placement_blockage
#@   insert_stdcell_filler -cell_with_metal $INTEL_DECAP_CELLS -ignore_hard_placement_blockage -ignore_soft_placement_blockage
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -ground_net $INTEL_MW_GROUND_NET -power_pin vcc -ground_pin vss
#@   remove_zrt_filler_with_violation -name xofiller_d04dcp00*;  ## because insert_stdcell_filler -cell_with_metal does not work ##
#@ }
#@ 
#@ ##############################################################################
#@ # Insert spc*03 & spc*02 & spc*01 filler cells
#@ ##############################################################################
#@ # Insert spc*03 & spc*02 placement site spacer fill cells. 
#@ 
#@ insert_stdcell_filler -cell_without_metal $INTEL_STDCELL_FILLER_CELLS     -ignore_hard_placement_blockage     -ignore_soft_placement_blockage
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_filler_cells_d04.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_pg_hookup.tcl

#@ ##############################################################################
#@ # script : add_pg_hookup.tcl
#@ # description : Add PG hookup for cells in the design
#@ ##############################################################################
#@ 
#@ 
#@ # Runset based PG Hookup
#@ ::pwr::create_stdcell_powerhookup -powerhookup_cells_area
#@ # -- Starting source /p/fdk/fdk73/builds/pdk733_r1.7/fill/icv/flexfill/templates/dtDfmFillMetalICV.tcl

#@ # -------------------------------------------------------------------
#@ # --- dtDfmFillMetalICV.tcl
#@ # -------------------------------------------------------------------
#@ #               Proprietary Information of Intel Corp.               
#@ # -------------------------------------------------------------------
#@ #   This listing is supplied under the terms of a license agreement  
#@ #   with Intel Corp. and may not be copied nor disclosed except in   
#@ #   accordance with the terms of the agreement.                      
#@ # -------------------------------------------------------------------
#@ #                     (c) 2012-2014 Intel Corp.                          
#@ # -------------------------------------------------------------------
#@ 
#@ # -------------------------------------------------------------------
#@ # --- Header
#@ # -------------------------------------------------------------------
#@ #
#@ # Note.  This section makes sure dependency packages are loaded into 
#@ # Tcl interpreter.  In case the packages could not be loaded 
#@ # (e.g. cist) the corresponding helper functions are instantiated 
#@ # instead.  
#@ #
#@ # The helper functions are taken from dtDfmFillMetalICV_header.tcl 
#@ # which actually takes them from /p/kits/intel/flows/rdt/parseOpt
#@ # package.  
#@ # -------------------------------------------------------------------
#@ 
#@ if { [info command open_mw_lib ] != "" } {
#@   set ICV_MFILL_FOR_ICC 1
#@ } elseif { [info command pa_top_macro ] != "" } {
#@   set ICV_MFILL_FOR_PARADE 1
#@ }
#@ 
#@ 
#@ if { [info exists ICV_MFILL_FOR_PARADE] } {
#@   if {![info exists env(CADPAX_DIR)]} {
#@         #set env(CADPAX_DIR) $env(CAD_ROOT)/cadpax/9.1_shPseOpt64
#@         set env(CADPAX_DIR) $env(CAD_ROOT)/cadpax/9.2.p2_shPseOpt64
#@   }
#@   lappend auto_path $env(CADPAX_DIR)
#@   package require cist
#@   package require param_mgr
#@ }
#@ 
#@ 
#@ #
#@ # Check if parseOpt package can be loaded and CmdSpec + parseOptions procs get defined 
#@ #
#@ if { [info exists ICV_MFILL_FOR_ICC] } {
#@    if { [catch {package require parseOpt}] } {
#@       # error - package was not found in auto_path - try to locate it in the kit
#@       # try to find the package in a valid kit common path
#@       unset -nocomplain __flexfill_orig_auto_path __flexfill_rdt_common
#@       set __flexfill_orig_auto_path $::auto_path
#@       set __flexfill_rdt_common(dirs) ""
#@       if { [file readable /p/kits/intel/flows/rdt] } {
#@          # use the 'ls' builtin from icc_shell
#@          set __flexfill_rdt_common(dirs) [concat $__flexfill_rdt_common(dirs) [ls -1 -dt /p/kits/intel/flows/rdt/*.*.*]]
#@       }
#@       if { [file readable /p/hdk/cad/kits_common] } {
#@          # use the 'ls' builtin from icc_shell
#@          set __flexfill_rdt_common(dirs) [concat $__flexfill_rdt_common(dirs) [ls -1 -dt /p/hdk/cad/kits_common/*.*.*]]
#@       }
#@ 
#@       # order possible common kits by version (major.sub.minor release)
#@       set __flexfill_rdt_common(sort_dirs) {}
#@       foreach __flexfill_rdt_common(elem) $__flexfill_rdt_common(dirs) {
#@          set __flexfill_rdt_common(version) [split [lindex [file split $__flexfill_rdt_common(elem)] end] {.}]
#@          if { [llength $__flexfill_rdt_common(version)] != 3 } {
#@             # not of form major.sub.minor release
#@             continue
#@          }
#@          if { [catch { lsort -real $__flexfill_rdt_common(version) } __flexfill_rdt_common(catch_result)] != 0 } {
#@             # list or {major sub minor} not all integers - ignore
#@             continue
#@          }
#@          lappend __flexfill_rdt_common(sort_dirs) [concat $__flexfill_rdt_common(version) $__flexfill_rdt_common(elem)]
#@       }
#@       set __flexfill_rdt_common(sort_dirs) [lsort -integer -decreasing -index 0 [lsort -integer -decreasing -index 1 [lsort -integer -decreasing -index 2 $__flexfill_rdt_common(sort_dirs)]]]
#@ 
#@ 
#@       # prepend if RDT_COMMON_PATH is set
#@       if { [info exists ::env(RDT_COMMON_PATH)] } {
#@          set __flexfill_rdt_common(sort_dirs) [linsert $__flexfill_rdt_common(sort_dirs) 0 $::env(RDT_COMMON_PATH)]
#@       }
#@ 
#@       # cycle through until parseOpt package is found
#@       foreach __flexfill_rdt_common(elem) $__flexfill_rdt_common(sort_dirs) {
#@          set __flexfill_rdt_common(elem) [lindex ${__flexfill_rdt_common(elem)} end]
#@          if { [file isdirectory ${__flexfill_rdt_common(elem)}/common/pkgs/parseOpt] &&  [file readable ${__flexfill_rdt_common(elem)}/common/pkgs/parseOpt] } {
#@             lappend ::auto_path  ${__flexfill_rdt_common(elem)}/common/pkgs
#@             break
#@          }
#@       }
#@       unset -nocomplain __flexfill_rdt_common
#@       if { $__flexfill_orig_auto_path ne $::auto_path } {
#@          package require parseOpt
#@       }
#@       set ::auto_path $__flexfill_orig_auto_path
#@       unset -nocomplain __flexfill_orig_auto_path
#@ 
#@       if { [lsearch -exact [package names] parseOpt] == -1 } {
#@          puts "Error: unable to find parseOpt package.  Please append ::auto_path to include it or set ::env(RDT_COMMON_PATH) to a valid path"
#@       }
#@    }
#@ }
#@ 
#@ 
#@ #
#@ # If running icc and CmdSpec + parseOptions don't exist, then create the helper functions
#@ #
#@ if { [info exists ICV_MFILL_FOR_ICC] && ([info commands ::CmdSpec] eq "") && ([info commands ::parseOptions] eq "") } {
#@ 
#@ # -------------------------------------------------------------------
#@ # --- CmdSpec
#@ # -------------------------------------------------------------------
#@ proc CmdSpec { args } {
#@       # pre-parse options to make friendly for ::parseOpt::cmdSpec
#@       # Getting procedure full name
#@       set procName [::parseOpt::varPop args]
#@ 
#@       # will check that all opts arguments only use valid options
#@       set validOpt {"optname" "type" "default" "default_from_pg" "help" "required" "values" "filter" "singel_selection" "radio_grp" "hidden"}
#@ 
#@       array set procInfo [::parseOpt::varPop args]
#@       # goal is to remove / reformat invalid opt names
#@       foreach obj [array names procInfo] {
#@          if { ! [regexp -nocase {\-opt} $obj] } {
#@             # skip other arguments, only want to update opts
#@             continue
#@          }
#@          set updated_procInfo_obj {}
#@          set updated_opts {}
#@ 
#@          # Going over the list of options
#@          foreach option $procInfo($obj) {
#@             set updated_option {}
#@             unset -nocomplain type qualifiers
#@             while { [llength $option] > 0 } {
#@                set option_name_full [::parseOpt::varPop option]
#@                regsub {^\-} $option_name_full {} option_name
#@ 
#@                # Ignore epmty variables
#@                if { [regexp {^[[:space:]]*$} $option_name] } { continue }
#@ 
#@                # Check that this is a valid option
#@                if { [lsearch -exact $validOpt $option_name] < 0 } {
#@                   # this is an unknown option so ignore
#@                   # i.e. this could be:  -proc -qualifiers or other.
#@                   if { $option_name eq "qualifiers" } {
#@                      # record qualifier - swap to one_of_string later
#@                      set qualifiers [lindex [::parseOpt::varPop option] 1]
#@                   }
#@                   continue
#@                }
#@ 
#@                set value [::parseOpt::varPop option]
#@ 
#@                if { $option_name eq "type" } {
#@                   set type $value
#@                } else {
#@                   lappend updated_option $option_name_full $value
#@                }
#@             }
#@             if { [info exists type] && $type eq "string" && [info exists qualifiers] } {
#@                lappend updated_option "-type" "one_of_string" "-values" $qualifiers
#@             } elseif { [info exists type] } {
#@                lappend updated_option "-type" $type
#@             }
#@             lappend updated_procInfo_obj $updated_option
#@          }
#@          set procInfo($obj) $updated_procInfo_obj
#@ 
#@       }
#@ 
#@       # uplevel & run the equivalent ::parseOpt::cmdSpec command
#@       # (parseOpt shouldn't actually need the uplevel)
#@       set ::__flexfill_procName $procName
#@       set ::__flexfill_procInfo [array get procInfo]
#@       uplevel 1 { ::parseOpt::cmdSpec $::__flexfill_procName $::__flexfill_procInfo}
#@ 
#@       unset -nocomplain ::__flexfill_procName ::__flexfill_procInfo
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- parseOptions
#@ # -------------------------------------------------------------------
#@ proc parseOptions { args } {
#@       # allow for embedded call to ::parseOpt::parseOptions
#@       # parseOptions takes: args ?caller?
#@       #    args is a single argument that give the list of arguments
#@       #    ?caller? is optional giving the name of the calling proc
#@       unset -nocomplain ::__flexfill_parseOpts_opts __flexfill_parseOpts_args
#@       unset -nocomplain ::__flexfill_procName
#@       set ::__flexfill_procName "parseOptions"
#@       set proc_level [info level]
#@ 
#@       if { [lsearch -exact [lindex $args 0] "-help"] != -1 } {
#@          set print_help 1
#@       } elseif { [lsearch -exact $args "-help"] != -1 } {
#@          set args [lsearch -exact -all -inline -not $args "-help"]
#@          set print_help 1
#@       }
#@ 
#@       # check for ?caller?
#@       if { [llength $args] > 2 } {
#@          unset -nocomplain ::__flexfill_procName
#@          uplevel 1 {error {wrong # args: should be "parseOptions args ?caller?"}}
#@       } elseif { [llength $args] == 2 } {
#@          set ::__flexfill_procName [namespace which [lindex $args 1]]
#@          if { $::__flexfill_procName eq "" } {
#@             set ::__flexfill_procName [lindex $args 1]
#@          }
#@          set args [lindex $args 0]
#@       } elseif { $proc_level < 2 } {
#@          # not in a proc the caller is considered parseOptions
#@       } else {
#@          set ::__flexfill_procName [namespace which [lindex [info level [expr $proc_level - 1]] 0]]
#@          # make sure that the package was defined.
#@          # May need to strip leading :: from the command/namespace
#@          if { ![info exist parseOpt::procInfo(${::__flexfill_procName}:Init)] } {
#@             set ::__flexfill_procName [regsub {^::} $::__flexfill_procName {}]
#@          }
#@           
#@       }
#@ 
#@       if { [info exists print_help] } {
#@          uplevel 1 {
#@             unset -nocomplain opts
#@             ::parseOpt::parseOpts $::__flexfill_procName ::__flexfill_parseOpts_opts "-help"
#@             unset -nocomplain ::__flexfill_procName :: __flexfill_parseOpts_opts
#@             return -code return 1
#@          }
#@       }
#@ 
#@       set ::__flexfill_parseOpts_args $args
#@       set parseOpt_return [uplevel 1 {unset -nocomplain opts ; ::parseOpt::parseOpts $::__flexfill_procName ::__flexfill_parseOpts_opts $::__flexfill_parseOpts_args }]
#@ 
#@       upvar opts return_opts
#@ 
#@       # remove leading '-' in returned opts
#@       foreach opt_name [array names ::__flexfill_parseOpts_opts] {
#@          set return_opts([regsub -- {^-} $opt_name {}]) $::__flexfill_parseOpts_opts($opt_name)
#@       }
#@       unset -nocomplain ::__flexfill_parseOpts_opts ::__flexfill_parseOpts_args
#@ 
#@       if { ! $parseOpt_return } {
#@          uplevel 1 { error "parseOptions - incorrect procedure arguments for $::__flexfill_procName"}
#@       }
#@       unset -nocomplain ::__flexfill_procName
#@ 
#@       return $parseOpt_return
#@ 
#@ }
#@ # end of 'proc parseOptions { args } '
#@ 
#@ }
#@ # end of 'if { [info exists ICV_MFILL_FOR_ICC] && ([info commands ::CmdSpec] eq "")'
#@ 
#@ # -------------------------------------------------------------------
#@ # --- End Header
#@ # -------------------------------------------------------------------
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- ::dtDfm namespace
#@ # -------------------------------------------------------------------
#@ namespace eval ::dtDfm {
#@ }
#@ 
#@ 
#@ CmdSpec ::dtDfm::read_stm {
#@     -help "::dtDfm::read_stm -from_cell test_fill -to_cell test -layers {metal1 metal2 metal3} ... "
#@     -opts {
#@         {-optname     from_cell
#@             -type     string
#@             -default  ""
#@             -help     "name of STM cell from which contents need to be read"
#@         }
#@         {-optname     from_view
#@             -type     string
#@             -default  "stm"
#@             -help     "view name of from_cell"
#@         }
#@         {-optname     to_cell
#@             -type     string
#@             -default  ""
#@             -help     "name of cell into which contents need to be read"
#@         }
#@         {-optname     to_view
#@             -type     string
#@             -default  "lnf"
#@             -help     "view name of the to_cell"
#@         }
#@         {-optname     layers
#@             -type     string
#@             -default  ""
#@             -help     "list of fill layers"
#@         }
#@         {-optname     path
#@             -type     string
#@             -default  ""
#@             -help     "path to the input STM file"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  "1272"
#@             -help     "Techname of the cell"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "net to be assigned to stubs; by default the stubs are assigned syn* nets"
#@         }
#@         {-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "propery to be assigned to fill metal"
#@         }
#@         {-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "propery to be assigned to stubs"
#@         }
#@         {-optname     rename_nets
#@             -type     string
#@             -default  ""
#@             -help     "nets are renamed as per these specs\n\t\t\t\texample { {drv_floatiss_ floatiss_} {near_floatiss_ floatiss_} {far_floatiss_ flaotiss_} }"
#@         }
#@         {-optname     netname_for_untexted_objects
#@             -type     string
#@             -default  "floatiss_"
#@             -help     "netname for untexted objects"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::read_stm { args } {
#@   global env
#@   parseOptions $args
#@   set layers $opts(layers)
#@   set from_cell $opts(from_cell)
#@   set from_view $opts(from_view)
#@   set to_cell $opts(to_cell)
#@   set to_view $opts(to_view)
#@   set from_path $opts(path)
#@   set to_tech p$opts(techname)
#@   set stubnet $opts(stubnet)
#@   set property $opts(property)
#@   set stub_property $opts(stub_property)
#@   set rename_nets $opts(rename_nets)
#@   set netname_for_untexted_objects $opts(netname_for_untexted_objects)
#@  
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view] != "" } {
#@     cell_mgr_rem_cell [cell_mgr_get_mgr] "{$from_cell,$from_view}"
#@   }
#@ 
#@   set cmd "Read -cellname $from_cell -viewname $from_view -nowindow 1"
#@   if { $from_path != "" } {
#@     if {[file exists $from_path] != 0} {
#@       append cmd " -path $from_path"
#@     } else {
#@       ::dtDfm::fill_metal_icv_print_error "Cound not find file $from_path"
#@       return "0"
#@     }
#@   }
#@ 
#@   set openret [eval $cmd]
#@   if { $openret == 0 } {
#@     puts "Fail to open $from_cell, $from_view."
#@     return "0"
#@   }
#@ 
#@   set src [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view]
#@   if { "" == $src } {
#@     puts "Fail to load in ISS result stream file."
#@     return "0"
#@   }
#@ 
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $to_cell $to_view] == "" } {
#@     puts "did not find $to_cell,$to_view"
#@     set cell_boundary [cell_get_boundary "{$from_cell,$from_view}"]
#@     if { [cell_create $to_cell $to_tech $cell_boundary $to_view] == "" } {
#@       puts "failed to create $to_cell,$to_view"
#@       return "0"
#@     }
#@     puts "created $to_cell,$to_view"
#@     Display -cellname $to_cell -viewname $to_view
#@   }
#@ 
#@ 
#@   set objIdList [::dtDfm::copyFromSTMToTop $from_cell                                            $from_view                                            $to_cell                                            $to_view                                            $layers                                            $stubnet                                            $property                                            $stub_property                                            $netname_for_untexted_objects                                            $rename_nets]
#@   if { [cell_mgr_get_cell [cell_mgr_get_mgr] $from_cell $from_view ] != "" } {
#@     cell_mgr_rem_cell [cell_mgr_get_mgr] "{$from_cell,$from_view}"
#@   }
#@ 
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_run_streamlined ###########################################
#@ proc ::dtDfm::runFillFlow { cellname                             flowname                             stminputdir                             stmoutputdir                             uininputdir                             icv_options                             use_lnf_input                             use_pds 			    launch_script                             nbpool                             nbclass                             nbslot                             perlFlowLogPath                             {background 1}                             {explicit_parallel 0} } {
#@   global env
#@   set fillFlowPlPath ""
#@   set flowfile "fillflow.pl"
#@   if { $explicit_parallel >= 1 } {
#@     set flowfile "fillflow_snap.pl"
#@   }
#@ 
#@ 
#@   if {[info exists  env(MY_DFM_DIR)] && [file exists "$env(MY_DFM_DIR)/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(MY_DFM_DIR)/$flowfile"
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists "$env(PDS_ISS_OVRRD)/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(PDS_ISS_OVRRD)/flexfill/templates/$flowfile"
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists "$env(PDS_ISS_OVRRD)/DTS/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(PDS_ISS_OVRRD)/DTS/flexfill/templates/$flowfile"
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists "$env(CDS_ISS_OVRRD)/flexfill/templates/$flowfile"] != 0} {
#@     set fillFlowPlPath "$env(CDS_ISS_OVRRD)/flexfill/templates/$flowfile"
#@   } 
#@ 
#@   #
#@   # Runset Directory
#@   #
#@ 
#@   set runsetDir {}
#@ 
#@   if {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/flexfill] != 0} {
#@     set runsetDir $env(PDS_ISS_OVRRD)
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/DTS/flexfill] != 0} {
#@     set runsetDir $env(PDS_ISS_OVRRD)/DTS
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/flexfill] != 0} {
#@     set runsetDir $env(CDS_ISS_OVRRD)
#@   }
#@ 
#@ 
#@   #
#@   # Return pid = 0 to indicate error
#@   #
#@   if {$runsetDir == {}} {
#@     ::dtDfm::fill_metal_icv_print_error "ISS runset directory could not be set. Please check your environment settings."
#@     return 0
#@   }
#@ 
#@ 
#@   #
#@   # PXL Directory
#@   #
#@ 
#@   set pxlDir {}
#@   if {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/PXL] != 0} {
#@     set pxlDir $env(PDS_ISS_OVRRD)/PXL
#@   } elseif {[info exists  env(PDS_ISS_OVRRD)] && [file exists $env(PDS_ISS_OVRRD)/DTS/PXL] != 0} {
#@     set pxlDir $env(PDS_ISS_OVRRD)/DTS/PXL
#@   } elseif {[info exists  env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/PXL] != 0} {
#@     set pxlDir $env(CDS_ISS_OVRRD)/PXL
#@   }
#@ 
#@   #
#@   # Return pid = 0 to indicate error
#@   #
#@   if {$pxlDir == {}} {
#@     ::dtDfm::fill_metal_icv_print_error "PXL directory could not be set. Please check your environment settings."
#@     return 0
#@   }
#@ 
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@   set noclean ""
#@   if { $save_workdir } {
#@     set noclean "--noclean"
#@   }
#@ 
#@   set cmd ""
#@   set runmode "local"
#@   if { $nbpool != "" } {
#@     set runmode "netbatch"
#@   }
#@ 
#@   if { $fillFlowPlPath != "" } {
#@        if { $explicit_parallel >= 1 } {
#@           set opt_nbpool  ""
#@           set opt_nbclass ""
#@           set opt_nbslot  ""
#@           if { $nbpool != "" } {
#@             regsub -all "\'" $nbclass "\"" nbclass
#@             set opt_nbpool  "--nb_pool $nbpool"
#@             set opt_nbclass "--nb_class $nbclass"
#@             set opt_nbslot  "--nb_slot $nbslot"
#@           }
#@           set cmd "$fillFlowPlPath  --layout $cellname --layout_path ${stminputdir} --work_uin $uininputdir --max_jobs $explicit_parallel --output_path ${stmoutputdir} $opt_nbpool $opt_nbclass $opt_nbslot $noclean >& $perlFlowLogPath "
#@        } else {
#@           set cmd "$fillFlowPlPath $cellname                                 $flowname                                 ${stminputdir}                                 ${stmoutputdir}                                 $uininputdir                                 $runsetDir                                 $pxlDir                                 \"$icv_options\"                                 $use_lnf_input                                 $use_pds                                 $runmode                                 \"$launch_script\"                                 $nbpool                                 $nbclass                                 $nbslot >& $perlFlowLogPath " 
#@         }
#@ 
#@         
#@       if { $background == 1 } {
#@           set cmd "$cmd &"
#@       }
#@       
#@       ::dtDfm::fill_metal_icv_print_info "$cmd"
#@       
#@       set pid [eval exec "$cmd"]
#@       return $pid
#@      
#@  } else {
#@     ::dtDfm::fill_metal_icv_print_error "flexfill runset not found -- Please get help from DFM owner"
#@     return 0
#@  }
#@ }
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv_run_streamlined {
#@     -help "::dtDfm::fill_metal_icv -layer {metal1 metal2 metal3 ...} "
#@     -opts {
#@         {-optname     layers
#@             -type     string
#@             -default  ""
#@             -help     "list of fill layers"
#@         }
#@         {-optname     layer_opts
#@             -type     string
#@             -default  ""
#@             -help     "list of opts for each layer"
#@         }
#@         {-optname     prune_cells_lists
#@             -type     string
#@             -default  ""
#@             -help     "list of cells to be pruned each layer"
#@         }
#@         {-optname     tiling_opts
#@             -type     string
#@             -default  ""
#@             -help     "list of tiling opts for each layer"
#@         }
#@    }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_run_streamlined {args} {
#@   global env
#@   parseOptions $args
#@   set layers $opts(layers)
#@   set layer_opts $opts(layer_opts)
#@   set prune_cells_lists $opts(prune_cells_lists)
#@   set tiling_opts $opts(tiling_opts)
#@ 
#@   if { $layers == "" } {
#@     puts "::dtDfm::fill_metal_icv_run_streamlined: empty layers list"
#@     return 0
#@   }
#@ 
#@   set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@   set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@   set fillinmw [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@   set fillincelview [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@   set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@   set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@ 
#@   set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@   set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@   set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@   set techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@   set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@   set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@   set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@   set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@   set explicit_parallel [::dtDfm::keylget ::dtDfm::fill_metal_icv_data EXPLICIT_PARALLEL]
#@   set text_extensions [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TEXT_EXTENSIONS]
#@   set do_final_texting [::dtDfm::keylget ::dtDfm::fill_metal_icv_data DO_FINAL_TEXTING]
#@   set skip_dummy_250 [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SKIP_DUMMY_250]
#@   set no_tracks_file [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NO_TRACKS_FILE]
#@   set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@   set launch_script [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@   if { $explicit_parallel >= 1 } {
#@     set use_pds false
#@   }
#@ 
#@   set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@   set flowname fill_layers
#@   set uinfilename "${cellname}_${flowname}.uin"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   set writeuin_success [::dtDfm::fill_metal_icv_streamlined_writeuin $cellname                                                 $layers                                                 $techname                                                 $uinfilepath                                                 $fillinmw                                                 $fillincelview                                                 $mwoutpath                                                 $mwlibrary                                                 $icvtopworkarea                                                 $write_stm_output                                                 $layer_opts                                                 $tiling_opts                                                 $prune_cells_lists                                                 $text_extensions                                                 $do_final_texting                                                 $skip_dummy_250                                                 $no_tracks_file ]
#@ 
#@   if { $writeuin_success == 0 } {
#@     puts "writeuin failed"
#@     return 1
#@   }
#@   
#@     if { $only_write_uin } {
#@ 	#puts "Writing uin file ${cellname}_fill_layers.uin."
#@ 	return ""
#@     }
#@ 
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@ 
#@   if { [file exists $icvworkarea] != 0 } {
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   foreach  fillLayer $layers {
#@     if { $fillLayer == "poly" } {
#@       set layer_uin_extension "_polyfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_polyfill.rs
#@     } elseif { $fillLayer == "polycon" } {
#@       set layer_uin_extension "_polyconfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_polyconfill.rs
#@     } elseif { $fillLayer == "diffusion" } {
#@       set layer_uin_extension "_diffusionfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_diffusionfill.rs
#@     } elseif { $fillLayer == "libdfmg" } {
#@       set layer_uin_extension "_libdfmgfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_libdfmgfill.rs
#@     } elseif { $fillLayer == "diffcon" } {
#@       set layer_uin_extension "_diffconfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_diffconfill.rs
#@     } elseif { $fillLayer == "tv0" } {
#@       set layer_uin_extension "_tv0fill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_tv0fill.rs
#@     } elseif { $fillLayer == "viat" } {
#@       set layer_uin_extension "_vcgfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_vfillvcg.rs
#@     } elseif { $fillLayer == "viag" } {
#@       set layer_uin_extension "_vctfill"
#@       set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@       set layer_uinfilepath "$uindir/$layer_uinfilename"
#@       file copy -force $layer_uinfilepath ./flexuin_vfillvct.rs
#@     } else {
#@       set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@       if { $result != 0 } {
#@         set layer_uin_extension "_fill${level}"
#@         set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@         set layer_uinfilepath "$uindir/$layer_uinfilename"
#@         file copy -force $layer_uinfilepath ./flexuin_fill${level}.rs
#@       } else {
#@         set result [regexp {via(\d+)} $fillLayer fullstring level]
#@         if { $result != 0 } {
#@           set layer_uin_extension "_vfill${level}"
#@           set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@           set layer_uinfilepath "$uindir/$layer_uinfilename"
#@           file copy -force $layer_uinfilepath ./flexuin_vfill${level}.rs
#@         } else {
#@           set result [regexp {tm(\d+)} $fillLayer fullstring level]
#@           if { $result != 0 } {
#@             set layer_uin_extension "_filltm1"
#@             set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@             set layer_uinfilepath "$uindir/$layer_uinfilename"
#@             file copy -force $layer_uinfilepath ./flexuin_filltm1.rs
#@           } else {
#@             set result [regexp {rdl} $fillLayer fullstring level]
#@             if { $result != 0 } {
#@               set layer_uin_extension "_fillrdl"
#@               set layer_uinfilename "${cellname}${layer_uin_extension}.uin"
#@               set layer_uinfilepath "$uindir/$layer_uinfilename"
#@               file copy -force $layer_uinfilepath ./flexuin_fillrdl.rs
#@             }
#@           }
#@         }
#@       }
#@     }
#@   }
#@   file copy -force $uinfilepath ./flexuin_fill_layers.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@     cd $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set background 1
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath                              $background                              $explicit_parallel ]
#@ 
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   set interrupted 0
#@   if { $use_pds } {
#@     ::dtDfm::wait_on_pds_job $cellname                              "flexfill"
#@   } else {
#@     set remainingProcesses  [list $pid]   
#@     set pidsover [getTerminatedProcess $remainingProcesses]
#@     if { $pidsover == "" } {
#@ 	   set interrupted 1
#@     }
#@     if { $interrupted == 1 } {
#@       puts "job interrupted"
#@       set cmd "kill SIGKILL {$remainingProcesses}"
#@       puts "$cmd"
#@       catch { eval $cmd }
#@     }
#@   }
#@ 
#@   cd $old_dir
#@ 
#@   if { $interrupted == 1 } {
#@     puts "skipping ::dtDfm::fill_metal_icv_readresults"
#@     return 0
#@   }
#@ 
#@ 
#@   set jobInfo ""
#@   set container_extension "_fill"
#@ 
#@   # ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $layers
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@ 
#@   # ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   if { [::dtDfm::fill_metal_icv_readresults $jobInfo $save_workdir ] == 0 } {
#@           puts "mfill failed for $layers"
#@   }
#@ 
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_streamlined_writeuin { cellname                                                     layers                                                     techname                                                     uinfilepath                                                     fillinmw                                                     fillincelview                                                     mwoutpath                                                     mwlibrary                                                     icvtopworkarea                                                     write_stm_output                                                     layer_opts                                                     tiling_opts                                                     prune_cells_lists                                                     text_extensions 													do_final_texting                                                     skip_dummy_250                                                     no_tracks_file } {
#@   set f [open "$uinfilepath" w]
#@ 
#@   set write_milkyway_output $fillinmw
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fillincelview                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set dfm_via_fast_density [::dtDfm::keylget ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY]
#@   if {$dfm_via_fast_density} {
#@       puts $f "#define DFM_VIA_FAST_DENSITY"
#@   } else {
#@       puts $f "//#define DFM_VIA_FAST_DENSITY"
#@   }
#@ 
#@   set i 0
#@   foreach  fillLayer $layers {
#@     set my_opts [lindex $layer_opts $i]
#@     set my_tiling_opts [lindex $tiling_opts $i]
#@     if { $fillLayer == "poly" } {
#@       puts $f "#define DFM_POLYFILL"
#@     } elseif { $fillLayer == "polycon" } {
#@       puts $f "#define DFM_POLYCONFILL"
#@     } elseif { $fillLayer == "diffusion" } {
#@       puts $f "#define DFM_DIFFUSIONFILL"
#@     } elseif { $fillLayer == "diffcon" } {
#@       puts $f "#define DFM_DIFFCONFILL"
#@     } elseif { $fillLayer == "tv0" } {
#@       puts $f "#define DFM_TV0FILL"
#@     } elseif { $fillLayer == "viat" } {
#@       puts $f "#define DFM_VCTFILL"
#@     } elseif { $fillLayer == "viag" } {
#@       puts $f "#define DFM_VCGFILL"
#@     } else {
#@       set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@       if { $result != 0 } {
#@         puts $f "#define DFM_M${level}FILL $my_opts"
#@         if { $my_tiling_opts != "" } {
#@           puts $f "#define DFM_M${level}FILL_TILE $my_tiling_opts"
#@         }
#@       } else {
#@         set result [regexp {via(\d+)} $fillLayer fullstring level]
#@         if { $result != 0 } {
#@           puts $f "#define DFM_V${level}FILL $my_opts"
#@         } else {
#@           set result [regexp {tm(\d+)} $fillLayer fullstring level]
#@           if { $result != 0 } {
#@            puts $f "#define DFM_TM1FILL $my_opts"
#@           } else {
#@             ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@             return 0
#@           }
#@         }
#@       }
#@     }
#@     incr i
#@   }
#@ 
#@   set i 0
#@   foreach  fillLayer $layers {
#@     set prune_cells_list [lindex $prune_cells_lists $i]
#@     set result [regexp {metal(\d+)} $fillLayer fullstring level]
#@     if { $result != 0 } {
#@       set cell_list_option_name "m${level}_prune_cells_list";
#@       ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $prune_cells_list;
#@     }
#@     incr i
#@   }
#@ 
#@   puts $f "text_extensions = $text_extensions;";
#@   puts $f "do_final_texting = $do_final_texting;";
#@   if { $skip_dummy_250 } {
#@     puts $f "#define SKIP_DUMMY_250";
#@   }
#@   if { $no_tracks_file } {
#@     puts $f "#define NO_TRACKS_FILE";
#@   }
#@   puts $f "process_name = \"$techname\";"
#@ 
#@   close $f
#@   return 1
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_init ######################################################
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv_init {
#@     -help "::dtDfm::fill_metal_icv -cellname abc"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell on which fill is to be performed"
#@         }
#@         {-optname     outputcellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell where fill results should be placed"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  "lnf"
#@             -help     "Viewname of the cell"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  "1272"
#@             -help     "Techname of the cell"
#@         }
#@         {-optname  skip_output
#@          -type     bool
#@          -default  false
#@          -help     "Skip STM output"
#@         }
#@         {-optname  use_lnf_input
#@          -type     bool
#@          -default  false
#@          -help     "Uses LNF from disk as input format for the flow"
#@         }
#@         {-optname  save_workdir
#@          -type     bool
#@          -default  false
#@          -help     "Saves ICV work directory for debugging purpose"
#@         }
#@         {-optname  only_write_uin
#@          -type     bool
#@          -default  false
#@          -help     "When this option is used fill_metal_icv only writes out UIN file"
#@         }
#@         {-optname  streamlined
#@          -type     bool
#@          -default  false
#@          -help     "Do necessary setup to run streamlined metal/via fill\n\t\t\t\tAutomatically turns ON only_write_uin"
#@         }
#@         {-optname  text_extensions
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use real net names for the extensions on the wires of top level nets; only used gy streamlined mode at present"
#@         }
#@         {-optname  do_final_texting
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "do_final_texting for streamlined flow"
#@         }
#@         {-optname  skip_dummy_250
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "skips writing dummy-fill on data-type 250"
#@         }
#@         {-optname  no_tracks_file
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "skips writing tracks files"
#@         }
#@         {-optname  explicit_parallel
#@          -type     int
#@          -default  0
#@          -help     "Run streamlined explicitly parallel (multiple ICV jobs) with specified max number of LOCAL jobs"
#@         }
#@         {-optname  launch_script
#@          -type     string
#@          -default  "null"
#@          -help     "Specify a launch script for particular ICV version"
#@         }
#@         {-optname  nbpool
#@          -type     string
#@          -default  ""
#@          -help     "Enable Netbatch on -explict_parallel max number of Netbatch jobs using pool specified (ie: pdx_dts)"
#@         }
#@         {-optname  nbslot
#@          -type     string
#@          -default  "null"
#@          -help     "Submit netbatch jobs to this specified queue slot (ie: cds)"
#@         }
#@         {-optname  nbclass
#@          -type     string
#@          -default  "SLES10_EM64T_16G"
#@          -help     "Request this type of netbatch machine (default: SLES10_EM64T_16G)"
#@         }
#@         {-optname  uindir
#@          -type     string
#@          -default  "default"
#@          -help     "Location to save UIN files, default location $env(WORK_AREA_ROOT_DIR)/pds/uins"
#@         }
#@         {-optname  stream
#@          -type     string
#@          -default  ""
#@          -help     "Path to an existing stream file, skips generating a new stream file"
#@         }
#@         {-optname  fillinmw
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW"
#@         }
#@         {-optname  fillincelview
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW CEL view"
#@         }
#@         {-optname  mwoutpath
#@          -type     string
#@          -default  ""
#@          -help     "ICC specific option: directory in which MW library resides"
#@         }
#@         {-optname  mwlibrary
#@          -type     string
#@          -default  ""
#@          -help     "ICC specific option: MW library name"
#@         }
#@         {-optname     layer_map_for_mw
#@             -type     string
#@             -default  ""
#@             -help     "ICC specific option: layer map for MW"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "Genesys specific option: net name to be used for stubs\n\t\t\t\tOtherwise stubs are created on syn* nets"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  "Dmi:none:Dmi"
#@             -help     "Genesys specific option: fill metal property info"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  "Stub:Stub:test"
#@             -help     "Genesys specific option: stub property info"
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of options to be used with ICV"
#@         }
#@         {-optname     rename_nets
#@             -type     string
#@             -default  ""
#@             -help     "List of nets to be renamed { {from1 to1} {from2 to2} ... }"
#@         }
#@         {-optname     netname_for_untexted_objects
#@             -type     string
#@             -default  "floatiss_"
#@             -help     "netname for untexted objects"
#@         }
#@         {-optname  skip_result_stm_output
#@          -type     bool
#@          -default  false
#@          -help     "Skip writing final/result layout in GDSII/STM (default output format; only useful when in MW mode)"
#@         }
#@         {-optname  use_pds
#@          -type     bool
#@          -default  false
#@          -help     "Use PDS to launch ICV job; required to support netbatch in non -explict_parallel mode"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_init {args} {
#@   global env
#@   parseOptions $args
#@   set cellname $opts(cellname)
#@ 
#@   set outputcellname $opts(outputcellname)
#@   if {$outputcellname == ""} {
#@     set outputcellname $cellname
#@   }
#@ 
#@   set layer_map_for_mw $opts(layer_map_for_mw)
#@   set fillinmw $opts(fillinmw)
#@   set fillincelview $opts(fillincelview)
#@   set mwoutpath $opts(mwoutpath)
#@   set mwlibrary $opts(mwlibrary)
#@   set skip_output $opts(skip_output)
#@   set use_lnf_input $opts(use_lnf_input)
#@   if { $use_lnf_input } {
#@     set skip_output true
#@   } 
#@   set use_pds $opts(use_pds)
#@   set nbpool  $opts(nbpool)
#@   set nbclass $opts(nbclass)
#@   set nbslot  $opts(nbslot)
#@   set launch_script $opts(launch_script)
#@   set save_workdir $opts(save_workdir)
#@   set uindir $opts(uindir)
#@   set only_write_uin $opts(only_write_uin)
#@   set streamlined $opts(streamlined)
#@   set text_extensions $opts(text_extensions)
#@   set do_final_texting $opts(do_final_texting)
#@   set skip_dummy_250 $opts(skip_dummy_250)
#@   set no_tracks_file $opts(no_tracks_file)
#@   set explicit_parallel $opts(explicit_parallel)
#@   set viewname $opts(viewname)
#@   set techname $opts(techname)
#@   set stubnet $opts(stubnet)
#@   set property $opts(property)
#@   set stub_property $opts(stub_property)
#@   set icv_options $opts(icv_options)
#@   set rename_nets $opts(rename_nets)
#@   set netname_for_untexted_objects $opts(netname_for_untexted_objects)
#@   set stream $opts(stream)
#@   set write_stm_output true
#@   if { $opts(skip_result_stm_output) } {
#@     set write_stm_output false
#@   }
#@ 
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   if { $uindir == "default" } {
#@     set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     if { ![file exists $uindir] } {
#@       puts "$uindir does not exist"
#@       return 0
#@     }
#@     if { [file type $uindir] != "directory" } {
#@       puts "$uindir is not a directory"
#@       return 0
#@     }
#@   }
#@ 
#@   set pid [pid]
#@ 
#@   set icvtopworkarea $env(PDSWORKROOT)/$env(USER).${cellname}.${pid}.iss
#@ 
#@   set ::dtDfm::fill_metal_icv_data ""
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA $icvtopworkarea
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data SAVEWORKDIR    $save_workdir
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data INITIALIZED 1
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLINMW $fillinmw
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLINCELVIEW $fillincelview
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data MWOUTPATH $mwoutpath
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data MWLIBRARY $mwlibrary
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data UINDIR $uindir
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data CELLNAME $cellname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data VIEWNAME $viewname
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TECHNAME $techname
#@   set techname [::dtDfm::fill_metal_icv_get_tech $techname] 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TECHNAME $techname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STUBNET $stubnet
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PROPERTY $property
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME $outputcellname
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS {}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY false
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data RENAME_NETS $rename_nets
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT $write_stm_output
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data USE_LNF_INPUT $use_lnf_input
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data USE_PDS $use_pds
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBPOOL  $nbpool
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBCLASS $nbclass
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NBSLOT  $nbslot
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT  $launch_script
#@ 
#@   
#@ 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STREAMLINED $streamlined
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TEXT_EXTENSIONS $text_extensions
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DO_FINAL_TEXTING $do_final_texting
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data SKIP_DUMMY_250 $skip_dummy_250
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data NO_TRACKS_FILE $no_tracks_file
#@   # ED
#@   #if { $streamlined } {
#@   #  set only_write_uin true
#@   #}
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ONLYWRITEUIN $only_write_uin
#@ 
#@   if { $streamlined } {
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data EXPLICIT_PARALLEL $explicit_parallel
#@   } elseif { $explicit_parallel >= 1 } {
#@     ::dtDfm::fill_metal_icv_print_error "Explicit_Parallel mode only valid in Streamlined mode"
#@   }
#@ 
#@   if { $streamlined && $explicit_parallel == 0 && $icv_options == "" } {
#@     set icv_options "-ndg -turbo"
#@   } 
#@ 
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@ 
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVOPTIONS $icv_options
#@   
#@   # set ::dtDfm::fill_metal_icv_icvtopworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${pid}.iss"
#@   # set ::dtDfm::fill_metal_icv_jobs {}
#@   # set ::dtDfm::fill_metal_icv_correctly 1
#@ 
#@   if { [file exists $icvtopworkarea ] != 0 } {
#@     file delete -force $icvtopworkarea
#@   }
#@   # puts "creating $icvtopworkarea"
#@   file mkdir $icvtopworkarea
#@   file mkdir $icvtopworkarea/input
#@   # file mkdir $icvtopworkarea/output
#@ 
#@   if { $use_pds } {
#@     set stminputdir $env(PDSSTM)
#@   } else {
#@     set stminputdir $icvtopworkarea/input
#@   }
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data STMINPUTDIR $stminputdir
#@ 
#@   if { $stream != "" } {
#@     set skip_output 1
#@     if { ([file exists $stream ] != 0) } {
#@       file copy -force $stream $stminputdir
#@       puts "copying file from $stream to $stminputdir"
#@     }
#@   }
#@ 
#@   if { !$skip_output } {
#@     set old_dir [pwd]
#@     cd $icvtopworkarea/input
#@     # set saveret [::dtDfm::fill_metal_icv_saveas $cellname stm $icvtopworkarea/input/${cellname}.stm $layer_map_for_mw]
#@     set saveret [::dtDfm::fill_metal_icv_saveas $cellname stm $stminputdir/${cellname}.stm $layer_map_for_mw]
#@     if { $saveret == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Save Failed"
#@       ::dtDfm::keylset ::dtDfm::fill_metal_icv_data INITIALIZED 0
#@       # set ::dtDfm::fill_metal_icv_correctly 0
#@     }
#@     cd $old_dir
#@   }
#@ 
#@ }
#@ 
#@ set ::dtDfm::region_grids_legal_option_names {region grid_pattern                                               offset                                               period                                               relative_offset                                               break_pattern                                               break_offset                                               break_period                                               break_min_length \    
#@                                               break_pattern_offset_increment                                               far_fill_ete_distance                                               far_fill_sts_distance                                               fill_non_preferred                                               transition_pattern                                               transition_offset                                               transition_period                                               far_fill_ete_distance                                               far_fill_sts_distance                                               is_grating_hole_violation_risk_pattern }
#@ 
#@ 
#@ #
#@ # NOTE: when changing metal or via fill options, keep the 
#@ # the documentation for customers in sync on this Wiki:
#@ #
#@ # https://intelpedia.intel.com/PD-DFM/internal/antares_sg
#@ #
#@ 
#@ CmdSpec ::dtDfm::fill_metal_icv {
#@     -help "::dtDfm::fill_metal_icv -cellname abc -viewname -lnf -techname 1272.0 -layer metal2 -offset 0.012 -pattern VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.038C"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "\tName of the cell on which fill is to be performed\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     outputcellname
#@             -type     string
#@             -default  ""
#@             -help     "\tName of the cell where fill is to be placed"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  ""
#@             -help     "Viewname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  ""
#@             -help     "Techname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "Fill metal property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "Stub property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     stubnet
#@             -type     string
#@             -default  ""
#@             -help     "Genesys specific feature: net name to be used for stubs\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Metal layer to fill - i.e. metal2"
#@         }
#@         {-optname  do_ungridded_fill
#@          -type     bool
#@          -default  false
#@          -help     "Do ungridded fill"
#@         }
#@         {-optname  hybrid
#@          -type     bool
#@          -default  false
#@          -help     "Do hybrid fill"
#@         }
#@         {-optname     pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Pattern has the format triplet1:triplet2:.....\n\t\t\t\twhere triplet has the format netname:width:spacing\n\t\t\t\twidth and spacing are specified in microns\n\t\t\t\twidth may also have a B or C suffix\n\t\t\t\tPattern must be complete including power lines\n\t\t\t\tIn absence of pattern and region_grids ungridded (KLM style) fill is performed"
#@         }
#@ 	{-optname     offset
#@             -type     float
#@             -default  0.0
#@             -help     "Fill pattern offset wrt left/bottom boundary of the cell"
#@         }
#@         {-optname     break_pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Break pattern for the fill wires\n\t\t\t\tWorks with both gridded as well as ungridded fill modes\n\t\t\t\tFormat: pair1:pair2:.....\n\t\t\t\twhere pair has the format wire_length:ete_spacing\n\t\t\t\twire_length and ete_spacing are specified in microns\n\t\t\t\tIn absence of break_pattern wires are broken every fill_length"
#@         }
#@ 	{-optname     break_offset
#@             -type     float
#@             -default  0.0
#@             -help     "Break pattern offset"
#@         }
#@ 	{-optname     break_min_length
#@             -type     float
#@             -default  0.0
#@             -help     "Break pattern min length of wires to apply breaks to"
#@         }
#@         {-optname     transition_pattern
#@             -type     string
#@             -proc     ""
#@             -help     "Transition pattern has the format spacing:width\n\t\t\t\tspacing is spacing from offset or from previous transition\n\t\t\t\twidth is the width of the transition boundary"
#@         }
#@ 	{-optname     transition_offset
#@             -type     float
#@             -default  0.0
#@             -help     "Transition pattern offset"
#@         }
#@ 	{-optname     transition_period
#@             -type     float
#@             -default  0.0
#@             -help     "Transition pattern period"
#@         }
#@         {-optname     grid_patterns
#@          -type        string
#@          -default     ""
#@          -help        "Grid definitions to be used with region grids\n\t\t\t\t{ {grid_name1 grid_pattern1}\n\t\t\t\t{grid_name2 grid_pattern2} ... }"
#@         }
#@         {-optname     break_patterns
#@          -type        string
#@          -default     ""
#@          -help        "Break pattern definitions to be used with region grids\n\t\t\t\t{ {break_pattern_name1 break_pattern1}\n\t\t\t\t{break_pattern_name2 break_pattern2} ... }"
#@         }
#@         {-optname     transition_patterns
#@          -type        string
#@          -default     ""
#@          -help        "transition pattern definitions to be used with region grids\n\t\t\t\t{ {transition_pattern_name1 transition_pattern1}\n\t\t\t\t{transition_pattern_name2 transition_pattern2} ... }"
#@         }
#@         {-optname     region_grids
#@          -type        string
#@          -default     ""
#@          -help        "region grids\n\t\t\t\tfollowing is the old format\n\t\t\t\t{ {polygons_set1 grid_name1 offset1 relative_offset <break_pattern1 break_offset1>}\n\t\t\t\t  {polygons_set2 grid_name2 offset2 relative_offset <break_pattern2 break_offset2>}  ... }\n\t\t\t\tpolygons_set can be CELLBOUNDARY or V3PITCHID or { ply1 ply2 ply3....}\n\t\t\t\teach ply has the format {x1,y1 x2,y2 x3,y3 x4,y4 ....}\n\t\t\t\ta two point polygon is assumed to be a rectangle {xl,yl xh,yh}\n\t\t\t\trelative_offset take boolean values true/false values\n\t\t\t\t\n\t\t\t\tfollowing is the new format\n\t\t\t\t{ option_value_pairs { {option1 value1} {option2 value2} ... }\n\t\t\t\t\t\t{ {option1 value1} {option2 value2} ... } }\n\t\t\t\tallowed options include $::dtDfm::region_grids_legal_option_names\n\t\t\t\t"
#@         }
#@ 	{-optname     fill_length
#@             -type     float
#@             -default  10000.0
#@             -help     "Max fill length: fill wires will be broken every fill_length distance"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@        {-optname     exclCells
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\twires in these cells are not to be extended"
#@        }
#@ 
#@        {-optname  prune_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tlayout from the interior of these cells will be pruned for performance gains"
#@        }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@ 
#@         {-optname  half_dr_end_to_end 
#@          -type     float
#@          -default  -1.0
#@          -help     "EOL spacing from the cell boundary"
#@         }
#@ 
#@         {-optname  output_resolution
#@          -type     float
#@          -default  0.0
#@          -help     "output resolution"
#@         }
#@ 
#@         {-optname     ply
#@          -type     string
#@          -default  ""
#@          -help     "Polygon region based fill, i.e {0.0,0.04 0.0,182.36 207.32,182.36 ...}"
#@         }
#@ 
#@         {-optname     plys
#@          -type     string
#@          -default  ""
#@          -help     "Multiple polygon region based fill, i.e { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  write_sid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write S wires as B wires with overlapping SID layer on it"
#@         }
#@         {-optname  write_cid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write C wires as B wires with overlapping CID layer on it"
#@         }
#@         {-optname  write_bid_layer
#@          -type     bool
#@          -default  false
#@          -help     "Write overlapping BID layer on B wires"
#@         }
#@         {-optname  onestep
#@          -type     bool
#@          -default  false
#@          -help     "Run mfill in one step (also calls _init and _end procedures)"
#@         }
#@         {-optname  near_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Near fill density target"
#@         }
#@         {-optname  far_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill density target"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  15.0
#@          -help     "Density window size"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@         {-optname  metal_density_before_via
#@          -type     bool
#@          -default  false
#@          -help     "Do target metal density before via"
#@         }
#@ 
#@         {-optname  use_fill_markers
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use fill markers, applicable only for M0/M1 fill"
#@         }
#@         {-optname  strict_bc_identification
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  false
#@          -help     "turns on the use of the B/C color of existing wires for matching of the grid pattern\n\t\t\t\tthe normal behavior of fill is to ignore the color of wires in the layout."
#@         }
#@         {-optname  consider_off_grid
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Fill an area even if the layout in that area is off-grid"
#@         }
#@         {-optname  dfmg_extensions
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Add dfmg extensions to improve via landing/coverage"
#@         }
#@         {-optname  verbatim
#@          -type     string
#@          -default  ""
#@          -help     "Adds PXL code to UIN file verbatim"
#@         }
#@         {-optname  post_fill_operation
#@          -type     string
#@          -default  ""
#@          -help     "Post fill operation (eg. fill4cmp)"
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of ICV options specific to this layer when run in -explicit_parallel mode (default: -dp1 -turbo-lite)"
#@         }
#@        {-optname     power_nets
#@         -type     string
#@         -default  ""
#@         -help     "Power net names; wires of the specified power nets will be merged in DR clean manner whenever possible"
#@        }
#@         {-optname  fill_container_name
#@          -type     string
#@          -default  ""
#@          -help     "Fill container name; fill from this container is removed in the ECO mode"
#@         }
#@         {-optname  eco_region
#@          -type     string
#@          -default  ""
#@          -help     "ECO is performed in these polygon regions { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  tiling_options
#@          -type     string
#@          -default  ""
#@          -help     "X=microns Y=microns OVERBITE=mirons UNDERBITE=mirons LAYOUT_X=microns LAYOUT_Y=microns\n\t\t\t\texample: X=16 Y=10.5 OVERBITE=1 UNDERBITE=1 LAYOUT_X=16 LAYOUT_Y=42\n\t\t\t\tX and Y are the tile dimensions, LAYOUT_X and LAYOUT_Y are layout dimensions\n\t\t\t\tOVERBITE is the distance beyound the tile boundary the layout is looked up during fill for DR checks while filling individual tile\n\t\t\t\tUNDERBITE is the distance inside the tile boundary from which layout is removed and refilled during tile stitching."
#@         }
#@         {-optname  far_fill_ete_distance
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill region end-to-end distance from existing metal"
#@         }
#@         {-optname  far_fill_sts_distance
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill region side-to-side distance from existing metal"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set cellname $opts(cellname)
#@     set outputcellname $opts(outputcellname)
#@     set property $opts(property)
#@     set stub_property $opts(stub_property)
#@     set temp_techname $opts(techname)
#@ 
#@     set pattern $opts(pattern)
#@     set offset $opts(offset)
#@ 
#@     set break_pattern $opts(break_pattern)
#@     set break_offset $opts(break_offset)
#@ 
#@     set transition_pattern $opts(transition_pattern)
#@     set transition_offset  $opts(transition_offset)
#@     set transition_period  $opts(transition_period)
#@ 
#@     set grid_patterns $opts(grid_patterns)
#@     set break_patterns $opts(break_patterns)
#@     set transition_patterns $opts(transition_patterns)
#@     set region_grids  $opts(region_grids)
#@ 
#@     set far_fill_ete_distance $opts(far_fill_ete_distance)
#@     set far_fill_sts_distance $opts(far_fill_sts_distance)
#@ 
#@     set fill_length $opts(fill_length)
#@     set onestep $opts(onestep)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set do_ungridded_fill $opts(do_ungridded_fill)
#@     set hybrid $opts(hybrid)
#@     set write_sid_layer $opts(write_sid_layer)
#@     set write_cid_layer $opts(write_cid_layer)
#@     set write_bid_layer $opts(write_bid_layer)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@     set half_dr_end_to_end $opts(half_dr_end_to_end)
#@     set output_resolution $opts(output_resolution)
#@     set plys $opts(plys)
#@     set ply $opts(ply)
#@     set exclCells $opts(exclCells)
#@     set prune_cells_list $opts(prune_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set viewname $opts(viewname)
#@     set fillLayer $opts(layer)
#@     set stubnet $opts(stubnet)
#@     set near_fill_density_target $opts(near_fill_density_target)
#@     set far_fill_density_target  $opts(far_fill_density_target)
#@     set density_window_size $opts(density_window_size)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@     set metal_density_before_via $opts(metal_density_before_via)
#@     set icv_options $opts(icv_options)
#@     set power_nets $opts(power_nets)
#@     set eco_region $opts(eco_region)
#@     set fill_container_name $opts(fill_container_name)
#@     set tiling_options $opts(tiling_options)
#@ 
#@ # density_window_y_size, density_window_x_offset , density_window_y_offset, density_window_x_stepping, density_window_y_stepping, density_boundary_assumption, density_kor_assumption metal_density_before_via
#@ 
#@     set use_fill_markers $opts(use_fill_markers)
#@     set strict_bc_identification $opts(strict_bc_identification)
#@     set consider_off_grid $opts(consider_off_grid)
#@     set dfmg_extensions $opts(dfmg_extensions)
#@     set verbatim $opts(verbatim)
#@     set post_fill_operation $opts(post_fill_operation)
#@ 
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     if {$cellname == ""} {
#@       set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     }
#@     if {$outputcellname == ""} {
#@       set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     }
#@     if {$viewname == ""} {
#@       set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     }
#@     if {$temp_techname == ""} {
#@       set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     }
#@     if {$stubnet == ""} {
#@       set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     }
#@     if {$property == ""} {
#@       set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     }
#@     if {$stub_property == ""} {
#@       set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     }
#@     if {$icv_options == ""} {
#@       set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     }
#@ 
#@     set techname [::dtDfm::fill_metal_icv_get_tech $temp_techname]
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@ 
#@     if { $onestep } {
#@       ::dtDfm::fill_metal_icv_init -cellname $cellname
#@     }
#@ 
#@     if { $ply != "" } {
#@       lappend plys $ply
#@     }
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No metal layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set is_metal [regexp {metal(\d+)} $fillLayer fullstring level]
#@     set is_thick_metal [regexp {(tm\d+)} $fillLayer fullstring level]
#@     set is_rdl [regexp {rdl} $fillLayer fullstring level]
#@ 
#@     if { ($is_metal == 0) && ($is_thick_metal ==  0) && ($is_rdl == 0) } {
#@          ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@          return 0
#@     }
#@ 
#@     if { $is_metal } {
#@       set flowName "m${level}fill"
#@       set container_extension "_fill${level}"
#@     }
#@ 
#@     if { $is_thick_metal } {
#@       set flowName "tm1fill"
#@       set container_extension "_filltm1"
#@     }
#@ 
#@     if { $is_rdl } {
#@       set flowName "rdlfill"
#@       set container_extension "_fillrdl"
#@     }
#@ 
#@ 
#@   # write uin file
#@   # <cellname>_fill_layers.uin is written in proc fill_metal_icv_run_streamlined
#@ 
#@   set uinfilename "${cellname}${container_extension}.uin"
#@ #puts "Writing uin file $uinfilename"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   set error_code [::dtDfm::fill_metal_icv_writeuin $cellname                                    $viewname                                    $techname                                    $fillLayer                                    $write_sid_layer                                    $write_cid_layer                                    $write_bid_layer                                    $do_ungridded_fill                                    $hybrid                                    $pattern                                    $offset                                    $break_pattern                                    $break_offset                                    $transition_pattern                                    $transition_offset                                    $transition_period                                    $grid_patterns                                    $break_patterns                                    $transition_patterns                                    $region_grids                                    $fill_length                                    $excludeKOR 				   $top_level_only_kor                                    $korspX                                    $korspY                                    $half_dr_end_to_end                                    $output_resolution                                    $plys                                    $exclCells                                    $keepout_cells_list                                    $keepout_cells_x_space                                    $keepout_cells_y_space                                    $uinfilepath                                    $write_milkyway_output                                    $fill_in_cel_view                                    $mwoutpath                                    $mwlibrary 				   $near_fill_density_target 				   $far_fill_density_target                                    $density_window_size 				   $density_window_y_size 				   $density_window_x_offset                                    $density_window_y_offset                                    $density_window_x_stepping                                    $density_window_y_stepping                                    $density_boundary_assumption                                    $density_kor_assumption                                    $metal_density_before_via                                    $use_fill_markers                                    $strict_bc_identification 				   $consider_off_grid 				   $dfmg_extensions                                   $write_stm_output                                    $verbatim                                    $post_fill_operation                                    $power_nets                                    $eco_region                                    $fill_container_name                                    $far_fill_ete_distance                                    $far_fill_sts_distance ]
#@ 
#@   if { $error_code == 0 } {
#@    return 0
#@   }
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   lappend fillLayers_opts $icv_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@   set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@   lappend prune_cells_lists $prune_cells_list
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS $prune_cells_lists
#@ 
#@   set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   lappend tiling_opts $tiling_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data ICVOPTIONS $icv_options
#@ 
#@   if { $only_write_uin || $streamlined } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                             $flowName                                             $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   if { $onestep } {
#@       ::dtDfm::fill_metal_icv_end
#@   }
#@   return $jobInfo
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- fill_metal_icv_writeuin
#@ #
#@ # Note.  For region_grids old format is depricated.  One is to use
#@ #        the following {option_value_pairs {{opt1_1 val1_1} {opt2_1 val2_1}...} {{opt1_2 val1_2} {opt2_2 val2_2}...} ...}
#@ #
#@ # For instance,
#@ #   [list option_value_pairs
#@ #      [list 
#@ #        [list region polygons({ {{-0.056,-0.040}, {58.856,-0.040}, {58.856,34.354}, {-0.056,34.354}}, })]
#@ #        [list grid_pattern grid_pattern_1]
#@ #        [list offset 0.656]
#@ #        [list period 117.600]
#@ #        [list relative_offset false]
#@ #        [list transition_pattern transition_pattern_1]
#@ #        [list transition_offset -0.040]
#@ #        [list transition_period 58.800]
#@ #        [list is_grating_hole_violation_risk_pattern true]
#@ #      ]
#@ #
#@ #      [list 
#@ #        [list region CELLBOUNDARY]
#@ #        [list grid_pattern grid_pattern_2]
#@ #        [list offset -0.016]
#@ #        [list period 0.672]
#@ #        [list relative_offset false]
#@ #        [list transition_pattern transition_pattern_2]
#@ #        [list transition_offset 0.102]
#@ #        [list transition_period 1.344]
#@ #        [list is_grating_hole_violation_risk_pattern true]
#@ #      ]
#@ #   ] 
#@ # -------------------------------------------------------------------
#@ proc ::dtDfm::fill_metal_icv_writeuin { cellname                                         viewname                                         techname                                         fillLayer                                         write_sid_layer                                         write_cid_layer                                         write_bid_layer                                         do_ungridded_fill                                         hybrid                                         pattern                                         offset                                         break_pattern                                         break_offset                                         transition_pattern                                         transition_offset                                         transition_period                                         grid_patterns                                         break_patterns                                         transition_patterns                                         region_grids                                         fill_length                                         excludeKOR                                         top_level_only_kor                                         korspX 					korspY 					half_dr_end_to_end 					output_resolution 					plys 					exclCells                                         keepout_cells_list                                         keepout_cells_x_space                                         keepout_cells_y_space 					uinfilepath 					write_milkyway_output 					fill_in_cel_view 					mwoutpath 					mwlibrary 					near_fill_density_target 					far_fill_density_target 					density_window_size 					density_window_y_size 					density_window_x_offset 					density_window_y_offset 					density_window_x_stepping 					density_window_y_stepping 					density_boundary_assumption 					density_kor_assumption 					metal_density_before_via 					use_fill_markers                                         strict_bc_identification 					consider_off_grid 					dfmg_extensions                                         write_stm_output                                         verbatim                                         post_fill_operation                                         power_nets                                         eco_region 				        fill_container_name                                         far_fill_ete_distance                                         far_fill_sts_distance } {
#@    set f [open "$uinfilepath" w]
#@ 
#@   if { $pattern != "" } {
#@     if { $plys == "" } {
#@       set grid_pattern_name "grid_pattern"
#@       set grid_pattern_name_with_type "${grid_pattern_name}"
#@     }  else {
#@       set grid_pattern_name "grid_pattern_ply"
#@       set grid_pattern_name_with_type "${grid_pattern_name}:track_pattern"
#@     }
#@     set grid_period($grid_pattern_name) [::dtDfm::fill_metal_icv_write_pattern_to_uin $f $grid_pattern_name_with_type $pattern]
#@     puts $f "offset = $offset;"
#@     puts $f "period = $grid_period($grid_pattern_name);"
#@   }
#@ 
#@   if { $break_pattern != "" } {
#@     set break_pattern_name "break_pattern"
#@     set grid_period($break_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $break_pattern_name $break_pattern]
#@     puts $f "break_offset     = $break_offset;"
#@     puts $f "break_period     = $grid_period($break_pattern_name);"
#@     puts $f "break_min_length = $grid_period($break_pattern_name);" 
#@   }
#@ 
#@   if { $transition_pattern != "" } {
#@     set transition_pattern_name "transition_pattern"
#@     set grid_period($transition_pattern_name) [::dtDfm::fill_metal_icv_write_transition_pattern_to_uin $f $transition_pattern_name $transition_pattern]
#@     puts $f "transition_offset = $transition_offset;"
#@     puts $f "transition_period = $transition_period;"
#@   }
#@ 
#@   if { $grid_patterns != "" } {
#@     foreach grid_def $grid_patterns {
#@       set grid_pattern_name [lindex $grid_def 0]
#@       set grid_pattern_name_with_type "${grid_pattern_name}:track_pattern"
#@       set pattern [lindex $grid_def 1]
#@       set grid_period($grid_pattern_name) [::dtDfm::fill_metal_icv_write_pattern_to_uin $f $grid_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@   if { $break_patterns != "" } {
#@     foreach break_def $break_patterns {
#@       set break_pattern_name [lindex $break_def 0]
#@       set break_pattern_name_with_type "${break_pattern_name}:track_pattern"
#@       set pattern [lindex $break_def 1]
#@       set grid_period($break_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $break_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@   if { $transition_patterns != "" } {
#@     foreach transition_def $transition_patterns {
#@       set transition_pattern_name [lindex $transition_def 0]
#@       set transition_pattern_name_with_type "${transition_pattern_name}:track_pattern"
#@       set pattern [lindex $transition_def 1]
#@       set grid_period($transition_pattern_name) [::dtDfm::fill_metal_icv_write_break_pattern_to_uin $f $transition_pattern_name_with_type $pattern]
#@     }
#@   }
#@ 
#@ 
#@ 
#@   if { $region_grids != "" || $plys != "" } {
#@     set gridded_fill 0
#@     puts $f "region_grids = {"
#@     if { [lindex $region_grids 0]== "option_value_pairs" } {
#@       set gridded_fill 1
#@       set region_grids [lrange $region_grids 1 end]
#@       foreach region_grid $region_grids {
#@         if { [::dtDfm::fill_metal_icv_write_region_grids_option_value_pair_to_uin $f $region_grid ] == 0 } {
#@           close $f
#@           return 0
#@         }
#@       }
#@     } else {
#@       foreach region_grid $region_grids {
#@         set gridded_fill 1
#@ 	set rg_plys [lindex $region_grid 0]
#@ 	set grid_pattern_name [lindex $region_grid 1]
#@ 	set offset [lindex $region_grid 2]
#@ 	set period $grid_period($grid_pattern_name)
#@ 	set relative_offset [lindex $region_grid 3]
#@ 	if { $relative_offset == "" } {
#@ 	  set relative_offset false
#@ 	}
#@ 	set break_pattern_name [lindex $region_grid 4]
#@ 	if { $break_pattern_name != "" } {
#@ 	  set break_pattern_offset [lindex $region_grid 5] 
#@ 	  if { $break_pattern_offset == "" } {
#@ 	    set break_pattern_offset 0.0
#@ 	  }
#@ 
#@      set break_pattern_period     $grid_period($break_pattern_name)
#@ 
#@      set break_pattern_min_length [lindex $region_grid 6]
#@      if {$break_pattern_min_length == "" } {    
#@        set break_pattern_min_length $grid_period($break_pattern_name)
#@      }
#@ 	} else {
#@ 	  set break_pattern_offset     0.0
#@ 	  set break_pattern_period     0.0
#@      set break_pattern_min_length 0.0
#@ 	}
#@ 	::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $rg_plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance       }
#@     }
#@ 
#@       if { $plys != "" } {
#@ 	 set grid_pattern_name "grid_pattern_ply"
#@          if { [info exists grid_period($grid_pattern_name) ] } {
#@            set gridded_fill 1
#@ 	   set period $grid_period($grid_pattern_name)
#@ 	   set relative_offset false
#@ 	   set break_pattern_name ""
#@ 	   set break_pattern_offset 0.0
#@ 	   set break_pattern_period 0.0
#@ 	  ::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance         }
#@       }
#@       puts $f "};"
#@ 
#@       if { $gridded_fill == 0 }  { 
#@         ::dtDfm::fill_metal_icv_write_kors_to_uin_whitebox_mode $f                                                                 $plys                                                                 $fillLayer
#@       }
#@   }
#@ 
#@   if { $techname != "" } {
#@     if { $techname == "1274" } {
#@       # puts $f "#include \"details/drconfig74.rs\" "
#@     }
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   if { $write_sid_layer } {
#@     puts $f "write_out_s_tracks = true;"
#@     puts $f "write_out_s_wires  = false;"
#@   }
#@ 
#@   if { $write_cid_layer } {
#@     puts $f "write_out_c_tracks = true;"
#@     puts $f "write_out_c_wires  = false;"
#@   }
#@ 
#@   if { $write_bid_layer } {
#@     puts $f "write_out_b_tracks = true;"
#@   }
#@ 
#@   puts $f "fill_length = $fill_length;"
#@ 
#@   if { $hybrid } {
#@       puts $f "hybrid = true;"
#@   } else {
#@       puts $f "hybrid = false;"
#@   }
#@ 
#@   if { $do_ungridded_fill } {
#@     puts $f "do_ungridded_fill = true;"
#@   }
#@ 
#@ 
#@   if { $half_dr_end_to_end >= 0.0 } {
#@     puts $f "half_dr_end_to_end = $half_dr_end_to_end;"
#@   }
#@ 
#@   if { $output_resolution >= 0.0 } {
#@     puts $f "output_resolution = $output_resolution;"
#@   }
#@  
#@ 
#@   if { $use_fill_markers == "true"  } {
#@     puts $f "use_fill_markers = true;"
#@   } else {
#@     puts $f "use_fill_markers = false;"
#@   }
#@ 
#@   if { $strict_bc_identification == "true"  } {
#@     puts $f "strict_bc_identification = true;"
#@   }
#@ 
#@   if { $consider_off_grid == "true" } {
#@     puts $f "consider_off_grid = true;"
#@   } else {
#@     puts $f "consider_off_grid = false;"
#@   }
#@ 
#@   if { $dfmg_extensions == "true" } {
#@     puts $f "dfmg_extensions = true;"
#@   } else {
#@     puts $f "dfmg_extensions = false;"
#@   }
#@ 
#@ 
#@   if { $verbatim != "" } {
#@     puts $f $verbatim
#@   }
#@ 
#@   if { $post_fill_operation != "" } {
#@     puts $f "post_fill_operation = \"$post_fill_operation\";"
#@   }
#@ 
#@ 
#@   if { $fill_container_name != "" } {
#@     puts $f "fill_container_name = \"$fill_container_name\";"
#@   }
#@ 
#@   if { $eco_region != "" } {
#@     set leading_string "eco_region = "
#@     set trailing_string ";"
#@     ::dtDfm::write_plys_to_uin $f                                $eco_region                                $leading_string                                $trailing_string
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_no_extend_cells_list_to_uin $f $exclCells;
#@   set cell_list_option_name "no_extend_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $exclCells;
#@ 
#@   set cell_list_option_name "power_nets"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $power_nets;
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f $keepout_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX $korspY;
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $near_fill_density_target                                                 $far_fill_density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@   close $f
#@ 
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_break_pattern_to_uin { f break_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   set period 0
#@   if { $pattern != "" } {
#@     set pattern_records ""
#@     set split_pattern [split $pattern ":"]
#@     set wire_cnt [expr [llength $split_pattern]/2 ]
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@       set wire_width [lindex $split_pattern [expr [expr $wire_num*2] + 0]]
#@       set next_space [lindex $split_pattern [expr [expr $wire_num*2] + 1]]
#@       lappend pattern_records [list $wire_width $next_space ]
#@     }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@     puts $f "$break_pattern_name = $OPEN_BRACE"
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@         set pattern_record [lindex $pattern_records $wire_num]
#@         puts $f "  {[lindex $pattern_record 0], [lindex $pattern_record 1]},"
#@       set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@     }
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@   return $period
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_transition_pattern_to_uin { f transition_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   set period 0
#@   if { $pattern != "" } {
#@     set pattern_records ""
#@     set split_pattern [split $pattern ":"]
#@     set wire_cnt [expr [llength $split_pattern]/2 ]
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@       set wire_width [lindex $split_pattern [expr [expr $wire_num*2] + 0]]
#@       set next_space [lindex $split_pattern [expr [expr $wire_num*2] + 1]]
#@       lappend pattern_records [list $wire_width $next_space ]
#@     }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@     puts $f "$transition_pattern_name = $OPEN_BRACE"
#@     for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@         set pattern_record [lindex $pattern_records $wire_num]
#@         puts $f "  {[lindex $pattern_record 0], [lindex $pattern_record 1]},"
#@       set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@     }
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@   return $period
#@ }
#@ 
#@ proc ::dtDfm::getPeriodFromPattern { pattern } {
#@   set period [::dtDfm::fill_metal_icv_write_pattern_to_uin "" "" $pattern]
#@   return $period
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_pattern_to_uin { f grid_pattern_name pattern } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@   if { $pattern != "" } {
#@   set pattern_records ""
#@   set split_pattern [split $pattern ":"]
#@   set wire_cnt [expr [llength $split_pattern]/3 ]
#@   for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@     set net_name [lindex $split_pattern [expr [expr $wire_num*3] + 0]]
#@     set wire_width_type [lindex $split_pattern [expr [expr $wire_num*3] + 1]]
#@     if { [regexp -nocase "(.*)C" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "C"
#@     } elseif { [regexp -nocase "(.*)B" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "B"
#@     } elseif { [regexp -nocase "(.*)S" $wire_width_type match width] }  {
#@       set wire_width $width
#@       set wire_type "S"
#@     } else {
#@       set wire_width $wire_width_type
#@       set wire_type ""
#@     }
#@     set next_space [lindex $split_pattern [expr [expr $wire_num*3] + 2]]
#@     lappend pattern_records [list $wire_width $next_space $wire_type $net_name ]
#@   }
#@ 
#@ 
#@   # puts $f "grid_pattern:track_pattern = "
#@ 
#@   if { $f != "" } {
#@     puts $f "$grid_pattern_name = $OPEN_BRACE"
#@   }
#@   set period 0
#@   for { set wire_num 0 } { $wire_num < $wire_cnt } { incr wire_num } {
#@     if { $wire_num == 0 }  {
#@       set pattern_record [lindex $pattern_records $wire_num]
#@       if { $f != "" } {
#@         puts $f "  {0.000, [lindex $pattern_record 0], \"[lindex $pattern_record 2]\", \"[lindex $pattern_record 3]\"},"
#@       }
#@     } else {
#@       set pattern_record [lindex $pattern_records $wire_num]
#@       set prev_pattern_record [lindex $pattern_records [expr $wire_num - 1]]
#@       if { $f != "" } {
#@         puts $f "  {[lindex $prev_pattern_record 1], [lindex $pattern_record 0], \"[lindex $pattern_record 2]\", \"[lindex $pattern_record 3]\"},"
#@       } 
#@     }
#@     set period [expr $period + [lindex $pattern_record 0] + [lindex $pattern_record 1]]
#@   }
#@   if { $f != "" } {
#@     puts $f "$CLOSE_BRACE;"
#@   }
#@  }
#@  return $period
#@ }
#@ 
#@ proc ::dtDfm::get_pxl_ply { ply  } {
#@   set plxpolygon "{"
#@   set pointcount 0
#@   foreach point $ply {
#@     if { $pointcount != 0 } {
#@      append plxpolygon ", "
#@     }
#@     incr pointcount
#@     append plxpolygon "{$point}"
#@   } 
#@   append plxpolygon "},"
#@   return $plxpolygon
#@ }
#@ 
#@ proc ::dtDfm::write_plys_to_uin { f plys {leading_string "region ="} {trailing_string ","} } {
#@     set specialRegions {"^TOPCELLBOUNDARY" "^CELLBOUNDARY" "V3PITCHID" "ULPPITCHID" }
#@     foreach spr $specialRegions {
#@       if { [regexp $spr $plys] } {
#@         puts $f " $leading_string $plys $trailing_string"
#@         return
#@       }
#@     }
#@ 
#@ #    if { [lsearch $specialRegions $plys] != -1 } {
#@ #      puts $f " $leading_string $plys ,"
#@ #      return
#@ #    }
#@ 
#@     puts $f " $leading_string polygons ({"
#@     set plycount 0
#@     foreach ply $plys {
#@       if { $plycount != 0 } {
#@         # puts -nonewline $f ", "
#@       }
#@       incr plycount
#@       set pxlpolygon [::dtDfm::get_pxl_ply $ply]
#@       puts $f "         $pxlpolygon"
#@     }
#@     puts $f " })$trailing_string"
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_kors_to_uin_whitebox_mode { f                                                           plys                                                           fillLayer } {
#@   set KORNAME [string toupper $fillLayer]KOR_ROUTE
#@   puts $f "$KORNAME = $KORNAME or (CELLBOUNDARY not "
#@   set leading_string ""
#@   set trailing_string ""
#@   ::dtDfm::write_plys_to_uin $f $plys $leading_string $trailing_string
#@   puts $f ");"
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_region_grids_to_uin { f                                                          plys                                                          grid_pattern_name                                                          offset                                                          period                                                          relative_offset                                                          break_pattern_name                                                          break_pattern_offset                                                          break_pattern_period                                                          break_pattern_min_length                                                          far_fill_ete_distance                                                          far_fill_sts_distance } {
#@ 
#@ # region_grids = {
#@ #         {
#@ #         rectangle(10, 10, 20, 20), //put arbitrary ICV code in UIN file for complex region definitions
#@ #         grid_pattern,
#@ #         offset,
#@ #         period,
#@ #         },
#@ # };
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "     $OPEN_BRACE"
#@     ::dtDfm::write_plys_to_uin $f $plys
#@     puts $f "         grid_pattern     = ${grid_pattern_name},"
#@     puts $f "         offset           = $offset,"
#@     puts $f "         period           = $period,"
#@     puts $f "         relative_offset  = $relative_offset,"
#@ if { $break_pattern_name != "" } {
#@     puts $f "         break_pattern    = ${break_pattern_name},"
#@     puts $f "         break_offset     = $break_pattern_offset,"
#@     puts $f "         break_period     = $break_pattern_period,"
#@     puts $f "         break_min_length = $break_pattern_min_length,"
#@ }
#@     puts $f "     $CLOSE_BRACE,"
#@ 
#@ }
#@ 
#@ 
#@ # -------------------------------------------------------------------
#@ # --- fill_metal_icv_writeuin
#@ #
#@ # Note.  Don't forget update ::dtDfm::region_grids_legal_option_names
#@ #        list w/ newly introduced options to support.
#@ # -------------------------------------------------------------------
#@ proc ::dtDfm::fill_metal_icv_write_region_grids_option_value_pair_to_uin { f region_grids } {
#@ 
#@ #  region : polygon_layer;
#@ #  grid_pattern:track_pattern = {};
#@ #  offset:double = 0.0;
#@ #  period:double = 0.0;
#@ #  relative_offset:boolean = false;
#@ #  break_pattern:track_pattern = {};
#@ #  break_offset:double = 0.0;
#@ #  break_period:double = 0.0;
#@ #  break_min_length:double = 0.0;
#@ #  fill_non_preferred:boolean = false;
#@ #  transition_pattern:track_pattern = {};
#@ #  transition_offset:double = 0.0;
#@ #  transition_period:double = 0.0;
#@ 
#@ 
#@     set period_found false
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "     $OPEN_BRACE"
#@     foreach opt_val_pair $region_grids {
#@       set option [lindex $opt_val_pair 0]
#@       set value [lindex $opt_val_pair 1]
#@       if { [lsearch $::dtDfm::region_grids_legal_option_names $option] == -1 } {
#@         puts "$option: Illegal option name in option-value pairs of region_grids"
#@         return 0
#@       }
#@       if { $option == "region" } {
#@         ::dtDfm::write_plys_to_uin $f $value
#@       } else { 
#@         puts $f "         $option = $value,"
#@       }
#@       if { $option == "period" } {
#@         set period_found true
#@       }
#@     }
#@     puts $f "     $CLOSE_BRACE,"
#@ }
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_base_layer ###########################################################
#@ CmdSpec ::dtDfm::fill_base_layer {
#@     -help "::dtDfm::fill_base_layer -layer poly "
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Metal layer to fill - i.e. poly"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@ 
#@         {-optname     ply
#@          -type     string
#@          -default  ""
#@          -help     "Polygon region based fill, i.e {0.0,0.04 0.0,182.36 207.32,182.36 ...}"
#@         }
#@ 
#@         {-optname     plys
#@          -type     string
#@          -default  ""
#@          -help     "Multiple polygon region based fill, i.e { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  near_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Near fill density target"
#@         }
#@         {-optname  far_fill_density_target
#@          -type     float
#@          -default  0.0
#@          -help     "Far fill density target"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window size"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@ 
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fill_base_layer {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@     set plys $opts(plys)
#@     set ply $opts(ply)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set fillLayer $opts(layer)
#@     set near_fill_density_target $opts(near_fill_density_target)
#@     set far_fill_density_target  $opts(far_fill_density_target)
#@     set density_window_size $opts(density_window_size)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@ 
#@ # density_window_y_size, density_window_x_offset , density_window_y_offset, density_window_x_stepping, density_window_y_stepping, density_boundary_assumption, density_kor_assumption 
#@ 
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@ 
#@     set techname [::dtDfm::fill_metal_icv_get_tech $temp_techname]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     if { $ply != "" } {
#@       lappend plys $ply
#@     }
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No metal layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set is_poly      [regexp "poly"       $fillLayer fullstring]
#@     set is_polycon   [regexp "polycon"    $fillLayer fullstring]
#@     set is_diffcon   [regexp "diffcon"    $fillLayer fullstring]
#@     set is_diffusion [regexp "diffusion"  $fillLayer fullstring]
#@     set is_libdfmg   [regexp "libdfmg"    $fillLayer fullstring]
#@ 
#@     if { ($is_poly == 0) && ($is_polycon == 0 ) && ($is_diffcon == 0 ) && ($is_diffusion == 0 ) && ($is_libdfmg == 0) } {
#@          ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@          return 0
#@     }
#@ 
#@     set flowName ${fillLayer}fill
#@     set container_extension _${flowName}
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   set uinfilepath "$uindir/$uinfilename"
#@   set error_code [::dtDfm::fill_base_layer_writeuin $cellname                                    $viewname                                    $techname                                    $fillLayer                                    $excludeKOR                                    $top_level_only_kor                                    $korspX                                    $korspY                                    $plys                                    $keepout_cells_list                                    $uinfilepath                                    $write_milkyway_output                                    $fill_in_cel_view                                    $mwoutpath                                    $mwlibrary 				   				   $near_fill_density_target 				   				   $far_fill_density_target                                    $density_window_size 				   				   $density_window_y_size 				   				   $density_window_x_offset                                    $density_window_y_offset                                    $density_window_x_stepping                                    $density_window_y_stepping                                    $density_boundary_assumption                                    $density_kor_assumption                                    $write_stm_output ]
#@ 
#@   if { $error_code == 0 } {
#@    return 0
#@   }
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   # set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   # lappend fillLayers_opts $icv_options
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@   set tiling_options ""
#@   # set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   # lappend tiling_opts $tiling_options
#@   # ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@ 
#@   if { $only_write_uin || $streamlined} {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   # fake level
#@   set level 0
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                             $flowName                                             $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fill_base_layer_writeuin { cellname                                         viewname                                         techname                                         fillLayer                                         excludeKOR                                         top_level_only_kor                                         korspX 					korspY 					plys                                         keepout_cells_list 					uinfilepath 					write_milkyway_output 					fill_in_cel_view 					mwoutpath 					mwlibrary 					near_fill_density_target 					far_fill_density_target 					density_window_size 					density_window_y_size 					density_window_x_offset 					density_window_y_offset 					density_window_x_stepping 					density_window_y_stepping 					density_boundary_assumption 					density_kor_assumption                     			write_stm_output } {
#@     set f [open "$uinfilepath" w]
#@     set period 0
#@     if { $plys != "" } {
#@         set grid_pattern_name "grid_pattern_ply"
#@         if { [info exists grid_period($grid_pattern_name) ] } {
#@             catch {set period $grid_period($grid_pattern_name)}
#@         }
#@         set relative_offset false
#@         set break_pattern_name ""
#@         set break_pattern_offset 0.0
#@         set break_pattern_period 0.0
#@         set far_fill_ete_distance 0.0 
#@         set far_fill_sts_distance 0.0
#@ 	::dtDfm::fill_metal_icv_write_region_grids_to_uin $f                                                           $plys                                                           $grid_pattern_name                                                           $offset                                                           $period                                                           $relative_offset                                                           $break_pattern_name                                                           $break_pattern_offset                                                           $break_pattern_period                                                           $break_pattern_min_length                                                           $far_fill_ete_distance                                                           $far_fill_sts_distance 
#@       }
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"p$techname\";"
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f $keepout_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary
#@ 
#@ 
#@   set metal_density_before_via false
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $near_fill_density_target                                                $far_fill_density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@   close $f
#@ 
#@   return 1
#@ }
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_via_icv ##############################################################
#@ set ::dtDfm::hookup_regions_legal_option_names {region nets_above nets_below break_above break_below density_target}
#@ 
#@ CmdSpec ::dtDfm::fill_via_icv {
#@ 
#@     -help "::dtDfm::fill_via_icv -cellname abc -viewname -lnf techname 1272.0 -layer via2"
#@     -opts {
#@         {-optname     cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the cell on which fill is to be performed\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     viewname
#@             -type     string
#@             -default  ""
#@             -help     "Viewname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     techname
#@             -type     string
#@             -default  ""
#@             -help     "Techname of the cell\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     property
#@             -type     string
#@             -default  ""
#@             -help     "Fill metal property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@ 	{-optname     stub_property
#@             -type     string
#@             -default  ""
#@             -help     "Stub property info\n\t\t\t\tRedundant option: use the one with fill_metal_icv_init"
#@         }
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via2"
#@         }
#@         {-optname     hookup_regions
#@          -type        string
#@          -default     ""
#@          -help        "Hookup regions\n\t\t\t\tfollowing is the old format\n\t\t\t\t{ {polygons_set1 nets_above1 nets_below1 break_above1 break_below1 density_target1}\n\t\t\t\t  {polygons_set2 nets_above2 nets_below2 break_above2 break_below2 density_target2} }\n\t\t\t\tpolygons_set can be CELLBOUNDARY or { ply1 ply2 ply3....}\n\t\t\t\teach ply has the format {x1,y1 x2,y2 x3,y3 x4,y4 ....}\n\t\t\t\ta two point polygon is assumed to be a rectangle {xl,yl xh,yh}\n\t\t\t\tbreak_above/break_below take boolean values true/false values\n\t\t\t\tdensity_target take a float value between 0 and 1\n\t\t\t\t\n\t\t\t\tfollowing is the new format\n\t\t\t\t{ option_value_pairs { {option1 value1} {option2 value2} ... }\n\t\t\t\t\t\t{ {option1 value1} {option2 value2} ... } }\n\t\t\t\tallowed options include $::dtDfm::hookup_regions_legal_option_names\n\t\t\t\t"
#@ 
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@        {-optname     exclCells
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\twires in these cells are not to be extended"
#@        }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname  fill_container_name
#@          -type     string
#@          -default  ""
#@          -help     "Name of the fill container"
#@         }
#@         {-optname  fill_net_names
#@          -type     string
#@          -default  ""
#@          -help     "Names of the fill nets"
#@         }
#@         {-optname  hv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the HV nets"
#@         }
#@         {-optname  ehv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the EHV nets"
#@         }
#@         {-optname  uhv_nets
#@          -type     string
#@          -default  ""
#@          -help     "Names of the UHV nets"
#@         }
#@ 
#@         {-optname  density_target
#@          -type     float
#@          -default  0.10
#@          -help     "Via density target (a number between 0 and 1 e.g. 0.02 is 2%)"
#@         }
#@         {-optname  density_window_size
#@          -type     float
#@          -default  30.0
#@          -help     "Density window size"
#@         }
#@         {-optname  fast_density
#@          -type     bool
#@          -default  false
#@          -help     "Use a simpler density algorithm to reduce memory / run time"
#@         }
#@         {-optname  density_fill_downto
#@          -type     bool
#@          -default  false
#@          -help     "Fill down to density as opposed up to to density"
#@         }
#@         {-optname  density_window_y_size
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y size"
#@         }
#@         {-optname  density_window_x_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x offset"
#@         }
#@         {-optname  density_window_y_offset 
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y offset"
#@         }
#@         {-optname  density_window_x_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window x stepping, values <= 0 means no stepping"
#@         }
#@         {-optname  density_window_y_stepping
#@          -type     float
#@          -default  0.0
#@          -help     "Density window y stepping, values <= 0 means no stepping "
#@         }
#@         {-optname  density_boundary_assumption
#@          -type     float
#@          -default  -1
#@          -help     "Density boundary assumption"
#@         }
#@         {-optname  density_kor_assumption
#@          -type     bool
#@          -default  false
#@          -help     "Density KOR assumption, "
#@         }
#@ 
#@         {-optname  iteration_count
#@          -type     integer
#@          -default  1
#@          -help     "Number of Via SG passes to maximize density (with deminising returns)"
#@         }
#@         {-optname  fillincelview
#@          -type     bool
#@          -default  false
#@          -help     "ICC specific option: saves fill in MW CEL view"
#@         }
#@         {-optname  hierarchical_nets  
#@          -type     bool
#@          -default  false
#@          -help     "Supports connections with nets in lower level of hierarchy; identified by names"
#@         }
#@         {-optname  consider_hv_violations
#@          -type     bool
#@          -default  false
#@          -help     "Check for HV rules in via fill."
#@         }
#@         {-optname     icv_options
#@             -type     string
#@             -default  ""
#@             -help     "List of ICV options specific to this layer when run in -explicit_parallel mode (default: -dp1 -turbo-lite)"
#@         }
#@         {-optname  eco_region
#@          -type     string
#@          -default  ""
#@          -help     "ECO is performed in these polygon regions { {polygon1} {polygon2} ... }"
#@         }
#@         {-optname  verbatim
#@          -type     string
#@          -default  ""
#@          -help     "Adds PXL code to UIN file verbatim"
#@         }
#@    }
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set cellname            $opts(cellname)
#@     set viewname            $opts(viewname)
#@     set temp_techname       $opts(techname)
#@     set fillLayer           $opts(layer)
#@     set hookup_regions      $opts(hookup_regions)
#@     set property            $opts(property)
#@     set stub_property       $opts(stub_property)
#@     set excludeKOR          $opts(excludeKOR)
#@     set top_level_only_kor  $opts(top_level_only_kor)
#@     set korspX              $opts(korspX)
#@     set korspY              $opts(korspY)
#@     set exclCells           $opts(exclCells)
#@     set fill_container_name $opts(fill_container_name)
#@     set fill_net_names      $opts(fill_net_names)
#@     set hv_nets      $opts(hv_nets)
#@     set ehv_nets      $opts(ehv_nets)
#@     set uhv_nets      $opts(uhv_nets)
#@     set density_target      $opts(density_target)
#@     set density_window_size $opts(density_window_size)
#@     set fast_density $opts(fast_density)
#@     set density_fill_upto $opts(density_fill_downto)
#@     set density_window_y_size $opts(density_window_y_size)
#@     set density_window_x_offset $opts(density_window_x_offset)
#@     set density_window_y_offset $opts(density_window_y_offset)
#@     set density_window_x_stepping $opts(density_window_x_stepping)
#@     set density_window_y_stepping $opts(density_window_y_stepping)
#@     set density_boundary_assumption $opts(density_boundary_assumption)
#@     set density_kor_assumption $opts(density_kor_assumption)
#@     set iteration_count     $opts(iteration_count)
#@     set fill_in_cel_view   $opts(fillincelview)
#@     set hierarchical_nets  $opts(hierarchical_nets)
#@     set consider_hv_violations $opts(consider_hv_violations)
#@     set icv_options $opts(icv_options)
#@     set eco_region $opts(eco_region)
#@     set verbatim $opts(verbatim)
#@ 
#@     if {$fast_density} {
#@         ::dtDfm::keylset ::dtDfm::fill_metal_icv_data DFM_VIA_FAST_DENSITY $fast_density
#@     }
#@ 
#@     if {$density_fill_upto} {
#@         set density_fill_upto false
#@     } else {
#@         set density_fill_upto true
#@     }
#@ 
#@     if {$cellname == ""} {
#@       set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     }
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     if {$viewname == ""} {
#@       set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     }
#@     if {$temp_techname == ""} {
#@       set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     }
#@ 
#@     set verbatim $opts(verbatim)
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     if { $streamlined } {
#@       set write_milkyway_output false
#@     }
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     if {$property == ""} {
#@       set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     }
#@     if {$stub_property == ""} {
#@       set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     }
#@ 
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set sleep_for_short_time 1
#@     if { $only_write_uin } {
#@       set sleep_for_short_time 0
#@     }
#@  
#@     if { $sleep_for_short_time } {
#@       exec sleep 2
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     if {$icv_options == ""} {
#@       set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     }
#@ 
#@     if { $techname != "" } {
#@       if { [regexp {^([0-9]+)(\.*)(.*)} $techname fullstring mainnode dot dotNum] } {
#@         lappend icv_options -D DR_DFM_PROCESS=$mainnode
#@       }
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No via layer specified"
#@ 	return 0
#@     }
#@ 
#@     if { $fillLayer == "tv0" } {
#@ 	set flowName "tv0fill"
#@ 	set container_extension "_tv0fill"
#@ 	set level "0"
#@     } elseif { $fillLayer == "viat" } {
#@ 	set flowName "vcgfill"
#@ 	set container_extension "_vcgfill"
#@ 	set level "0"
#@     } elseif { $fillLayer == "viag" } {
#@ 	set flowName "vctfill"
#@ 	set container_extension "_vctfill"
#@ 	set level "0"
#@     } else {
#@ 	set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@ 	set flowName "v${level}fill"
#@ 	set container_extension "_vfill${level}"
#@ 	if { $result == 0 } {
#@ 	  ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@ 	  return 0
#@ 	}
#@     }
#@ 
#@ #    set flowName "v${level}fill"
#@ #    set container_extension "_vfill${level}"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fill_via_icv_writeuin $cellname 				 $viewname 				 $techname 				 $fillLayer 				 $hookup_regions 				 $fill_container_name 				 $fill_net_names 				 $hv_nets 				 $ehv_nets 				 $uhv_nets 				 $density_target 				 $density_window_size 				 $fast_density 				 $density_fill_upto 				 $density_window_y_size 				 $density_window_x_offset 				 $density_window_y_offset 				 $density_window_x_stepping 				 $density_window_y_stepping 				 $density_boundary_assumption 				 $density_kor_assumption 				 $excludeKOR 				 $top_level_only_kor 				 $korspX 				 $korspY 				 $exclCells 				 $uinfilepath 				 $write_milkyway_output 				 $fill_in_cel_view 				 $mwoutpath 				 $mwlibrary 				 $write_stm_output 				 $iteration_count 				 $hierarchical_nets 				 $consider_hv_violations 				 $verbatim 				 $eco_region
#@ 
#@ 
#@   set fillLayers [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@   lappend fillLayers $fillLayer
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS $fillLayers
#@ 
#@   set fillLayers_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@   lappend fillLayers_opts $icv_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS $fillLayers_opts
#@ 
#@ 
#@   set prune_cells_list {};
#@   set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@   lappend prune_cells_lists $prune_cells_list
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS $prune_cells_lists
#@ 
#@   set tiling_options "" 
#@   set tiling_opts [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@   lappend tiling_opts $tiling_options
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data TILING_OPTS $tiling_opts
#@ 
#@   if { $only_write_uin || $streamlined } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@   set ::env(PDSSTM) $stminputdir
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname 					   $flowName 					   $container_extension 					   $level 					   $stminputdir 					   $uinfilepath 					   $icvworkarea 					   $icv_options 					   $use_lnf_input 					   $use_pds 					   $nbpool 					   $nbclass 					   $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@   set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_get_net_name_list { fill_net_names } {
#@   if { $fill_net_names != "" } {
#@     set fill_net_name_list ""
#@     regsub -all "," $fill_net_names " " fill_net_names
#@     foreach fill_net_name $fill_net_names {
#@       set fill_net_name_list [concat $fill_net_name_list \"$fill_net_name\",]
#@     }
#@     return "{$fill_net_name_list}"
#@   }
#@   return ""
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_write_hookup_regions_to_uin { f hookup_regions } {
#@ 
#@ # hookup_regions = {
#@ #     {
#@ #         region = CELLBOUNDARY,
#@ #         nets_above = {"*"},
#@ #         nets_below = {"*"},
#@ #         break_above = true,
#@ #         density_target = 0.005,
#@ #     },
#@ #     {
#@ #         region = CELLBOUNDARY,
#@ #         nets_above = {"*"},
#@ #         nets_below = {"*"},
#@ #         break_below = true,
#@ #         density_target = 0.005,
#@ #     }
#@ # };
#@ 
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     puts $f "hookup_regions = $OPEN_BRACE"
#@ 
#@     if { [lindex $hookup_regions 0]== "option_value_pairs" } {
#@       set hookup_regions [lrange $hookup_regions 1 end]
#@       foreach hookup_region $hookup_regions {
#@ 	puts $f "     $OPEN_BRACE"
#@         foreach opt_val_pair $hookup_region {
#@           set option [lindex $opt_val_pair 0]
#@           set value [lindex $opt_val_pair 1]
#@           if { [lsearch $::dtDfm::hookup_regions_legal_option_names $option] == -1 } {
#@             puts "$option: Illegal option name in option-value pairs of region_grids"
#@             return 0
#@           }
#@           if { $option == "nets_above" || $option == "nets_below" } {
#@ 	    set value [::dtDfm::fill_via_icv_get_net_name_list $value]
#@           }
#@ 
#@           if { $option == "region" } {
#@             ::dtDfm::write_plys_to_uin $f $value
#@           } else { 
#@             puts $f "         $option = $value,"
#@           }
#@         }
#@ 	puts $f "     $CLOSE_BRACE,"
#@       }
#@     } else {
#@       foreach hookup_region $hookup_regions {
#@ 	set plys [lindex $hookup_region 0]
#@ 	set nets_above [lindex $hookup_region 1]
#@ 	set nets_below [lindex $hookup_region 2]
#@ 	set break_above [lindex $hookup_region 3]
#@ 	set break_below [lindex $hookup_region 4]
#@ 	set density_target [lindex $hookup_region 5]
#@ 
#@ 	puts $f "     $OPEN_BRACE"
#@ 	::dtDfm::write_plys_to_uin $f $plys
#@ 
#@ 	set nets_above_list [::dtDfm::fill_via_icv_get_net_name_list $nets_above]
#@         if { $nets_above_list != "" } {
#@ 	  puts $f "nets_above = $nets_above_list,"
#@         }
#@ 
#@ 	set nets_below_list [::dtDfm::fill_via_icv_get_net_name_list $nets_below]
#@         if { $nets_below_list != "" } {
#@ 	  puts $f "nets_below = $nets_below_list,"
#@         }
#@ 
#@ 	if { $break_above } {
#@ 	  set break_above true
#@ 	} else {
#@ 	  set break_above false
#@ 	}
#@ 	puts $f "break_above = $break_above,"
#@ 
#@ 	if { $break_below } {
#@ 	  set break_below true
#@ 	} else {
#@ 	  set break_below false
#@ 	}
#@ 
#@ 	puts $f "break_below = $break_below,"
#@ 
#@ 	puts $f "density_target = $density_target,"
#@ 	puts $f "     $CLOSE_BRACE,"
#@      }
#@    } 
#@    puts $f "$CLOSE_BRACE;"
#@  
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_writeuin { cellname 				      viewname 				      techname 				      fillLayer                                       hookup_regions                                       fill_container_name                                       fill_net_names                                       hv_nets                                       ehv_nets                                       uhv_nets                                       density_target                                       density_window_size                                       fast_density                                       density_fill_upto 				      density_window_y_size 				      density_window_x_offset                                       density_window_y_offset                                       density_window_x_stepping                                       density_window_y_stepping                                       density_boundary_assumption                                       density_kor_assumption                                       excludeKOR                                       top_level_only_kor                                       korspX                                       korspY                                       exclCells                                       uinfilepath                                       write_milkyway_output                                       fill_in_cel_view                                       mwoutpath                                       mwlibrary                                       write_stm_output                                       iteration_count 				      hierarchical_nets                                        consider_hv_violations                                       verbatim 				      eco_region
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@ 
#@   if { $fill_container_name != "" } {
#@     puts $f "fill_container_name = \"$fill_container_name\";"
#@   }
#@ 
#@   if { $verbatim != "" } {
#@     puts $f $verbatim
#@   }
#@ 
#@   if { $eco_region != "" } {
#@     set leading_string "eco_region = "
#@     set trailing_string ";"
#@     ::dtDfm::write_plys_to_uin $f                                $eco_region                                $leading_string                                $trailing_string
#@   }
#@ 
#@ 
#@   set fill_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $fill_net_names]
#@   if { $fill_net_name_list != "" } {
#@     puts $f "fill_net_names = $fill_net_name_list;"
#@   }
#@   set hv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $hv_nets]
#@   if { $hv_net_name_list != "" } {
#@     puts $f "hv_nets = $hv_net_name_list;"
#@   }
#@   set ehv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $ehv_nets]
#@   if { $ehv_net_name_list != "" } {
#@     puts $f "ehv_nets = $ehv_net_name_list;"
#@   }
#@   set uhv_net_name_list [::dtDfm::fill_via_icv_get_net_name_list $uhv_nets]
#@   if { $uhv_net_name_list != "" } {
#@     puts $f "uhv_nets = $uhv_net_name_list;"
#@   }
#@ 
#@   if { $hookup_regions != "" } {
#@     ::dtDfm::fill_via_icv_write_hookup_regions_to_uin $f $hookup_regions
#@   }
#@ 
#@   if { $iteration_count > 0 } {
#@     puts $f "iteration_count = $iteration_count;"
#@   }
#@ 
#@   if { $hierarchical_nets  } {
#@     puts $f "hierarchical_nets  = true;"
#@   }
#@    if { $consider_hv_violations } {
#@     puts $f "consider_hv_violations = true;"
#@   }
#@   puts $f "density_fill_upto = $density_fill_upto;"
#@   puts $f "density_fill_upto = $density_fill_upto;"
#@ 
#@   if { $density_kor_assumption } {
#@     set density_kor_assumption "true"
#@   }
#@ 
#@   # ::dtDfm::fill_metal_icv_write_keepout_cells_list_to_uin $f  $exclCells;
#@ 
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $exclCells
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   puts $f "density_target = $density_target;"
#@ 
#@   set metal_density_before_via false
#@   ::dtDfm::fill_metal_icv_write_density_to_uin $f                                                $density_target                                                $density_target                                                $density_window_size                                                $density_window_y_size                                                $density_window_x_offset                                                $density_window_y_offset                                                $density_window_x_stepping                                                $density_window_y_stepping                                                $density_boundary_assumption                                                $density_kor_assumption                                                $metal_density_before_via
#@ 
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::upsz_via ##################################################################
#@ CmdSpec ::dtDfm::upsz_via {
#@ 
#@     -help "::dtDfm::upsz_via -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::upsz_via {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     if { $fillLayer == "" } {
#@ 	::dtDfm::printErr "No via layer specified"
#@ 	return 0
#@     }
#@ 
#@ 
#@     set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     if { $result == 0 || $level != 1 } {
#@       ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       return 0
#@     }
#@ 
#@     set flowName "v${level}upsz"
#@     set container_extension "_vupsz${level}"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::upsz_via_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin || $streamlined} {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::upsz_via_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fix_vcx250 ##################################################################
#@ CmdSpec ::dtDfm::fix_vcx250 {
#@ 
#@     -help "::dtDfm::fix_vcx250 -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fix_vcx250 {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     # if { $fillLayer == "" } {
#@ 	# ::dtDfm::printErr "No via layer specified"
#@ 	# return 0
#@     #}
#@ 
#@ 
#@     set fillLayer "viat"
#@     set level 0
#@     # set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     # if { $result == 0 || $level != 1 } {
#@       # ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       # return 0
#@     # }
#@ 
#@     set flowName "vcx250"
#@     set container_extension "_vcx250"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fix_vcx250_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary 
#@                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds 											$launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fix_vcx250_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::rename_mw_nets ##################################################################
#@ CmdSpec ::dtDfm::rename_nets {
#@ 
#@     -help "::dtDfm::rename_mw_nets "
#@     -opts {
#@         {-optname     mw_cellname
#@             -type     string
#@             -default  ""
#@             -help     "Name of the mw output cell"
#@         }
#@         {-optname     nets_to_rename
#@             -type     string
#@             -default  ""
#@             -help     "regular expression identifying nets to be renamed"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::rename_nets { args } {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set mw_cellname $opts(mw_cellname)
#@     set nets_to_rename $opts(nets_to_rename)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     # set print_cmd_str [info level [info level]]
#@     # ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     set flowName "renamenets"
#@     set container_extension "_renamenets"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::rename_nets_writeuin  $mw_cellname                                  $nets_to_rename                                  $viewname                                  $techname                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output
#@ 
#@  # if { $only_write_uin || $streamlined }
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set level 1 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@  set fillLayer metal1
#@ 
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@ #  ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::rename_nets_writeuin { cellname                                      nets_to_rename 				                     viewname 				                     techname                                      uinfilepath                                      write_milkyway_output                                      fill_in_cel_view                                      mwoutpath                                      mwlibrary                                      write_stm_output 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   if { $nets_to_rename != "" } {
#@     puts $f "nets_to_rename = \"$nets_to_rename\";"
#@   }
#@ 
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   close $f
#@ }
#@ 
#@ ##################################### Functions related to ::dtDfm::fill_metal_icv_end ########################################################
#@ 
#@ proc ::dtDfm::fill_metal_icv_end { } {
#@   set print_cmd_str [info level [info level]]
#@   ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@   set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@   if { $streamlined } {
#@     set fillLayers        [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS]
#@     set fillLayers_opts   [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLLAYERS_OPTS]
#@     set prune_cells_lists [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PRUNE_CELLS_LISTS]
#@     set tiling_opts       [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TILING_OPTS]
#@     return [::dtDfm::fill_metal_icv_run_streamlined -layers $fillLayers -layer_opts $fillLayers_opts -tiling_opts $tiling_opts -prune_cells_lists $prune_cells_lists ]
#@   }
#@ 
#@   set jobids ""
#@   # puts "fill_metal_icv_jobs : $::dtDfm::fill_metal_icv_jobs" 
#@   set save_workdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data SAVEWORKDIR]
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@ 
#@   foreach job $jobs {
#@     lappend jobids [::dtDfm::keylget job PID]
#@     set metalLayer [::dtDfm::keylget job LAYER]
#@     set resubmitCount($metalLayer) 0
#@   }
#@ 
#@   # puts $jobids
#@   set remainingProcesses $jobids
#@   set jobsidover ""
#@ 
#@   set interrupted 0
#@   while { [llength $jobids] != [llength $jobsidover] } {
#@ 
#@     # set exitstatus [wait]
#@     # set pidover [lindex $exitstatus 0]
#@     set pidsover [getTerminatedProcess $remainingProcesses]
#@ 	if { $pidsover == "" } {
#@ 	   set interrupted 1
#@ 	   break 
#@ 	}
#@     foreach pidover $pidsover {
#@       set remainingProcesses [::dtDfm::lremove $remainingProcesses $pidover]
#@       set jobindex [lsearch $jobids $pidover]
#@       if { $jobindex != -1 } {
#@         set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@         set jobinfo [lindex $jobs $jobindex]
#@         # puts $jobinfo
#@         set fillLayer [::dtDfm::keylget jobinfo LAYER]
#@         if { [::dtDfm::fill_metal_icv_readresults $jobinfo $save_workdir ] == 0 } {
#@           puts "mfill failed for $fillLayer"
#@           if { [info exists resubmitCount($fillLayer) ] == 0  || $resubmitCount($fillLayer) == 0 } {
#@             incr resubmitCount($fillLayer)
#@             set print_cmd_str [::dtDfm::keylget jobinfo CMD_STR]
#@             # puts "resubmitting $jobinfo $print_cmd_str"
#@             set newJobInfo [eval $print_cmd_str]
#@             set newJobPid [::dtDfm::keylget newJobInfo PID]
#@             lappend jobids $newJobPid
#@             lappend remainingProcesses $newJobPid
#@             puts "resubmitting $fillLayer: $newJobPid"
#@           }
#@         } else {
#@           puts "mfill succeded for $fillLayer"
#@         }
#@ 
#@         lappend jobsidover $pidover
#@       }
#@     }
#@   }
#@ 
#@   if { $interrupted == 1 } {
#@     puts "job interrupted"
#@     set cmd "kill SIGKILL {$remainingProcesses}"
#@     puts "$cmd"
#@     ::dtDfm::delete_all_fill
#@     catch { eval $cmd }
#@   }
#@ 
#@   # set ::dtDfm::fill_metal_icv_jobs ""
#@ 
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   if { !$save_workdir } {
#@     if { ([file exists $icvtopworkarea/input] != 0) } {
#@       file delete -force $icvtopworkarea/input
#@     }
#@   } else {
#@     puts "saving $icvtopworkarea"
#@   }
#@ 
#@ }
#@ 
#@ proc getTerminatedProcess { pids } {
#@   while { 1 } {
#@     if { [::dtDfm::interrupted] } {
#@       return ""
#@     }
#@ 
#@     set livepids ""
#@     catch { set livepids [eval exec "ps -o pid -p $pids"] }
#@     set terminatedPids ""
#@     foreach pid $pids {
#@        if { [lsearch $livepids $pid] == -1 } {
#@           lappend terminatedPids $pid
#@        }
#@     }
#@     if { [llength $terminatedPids] > 0 } {
#@       return $terminatedPids
#@     }
#@      exec sleep 1
#@   }
#@ 
#@ }
#@ 
#@ ##################################### Common functions used by several uin writers ############################################################
#@ proc ::dtDfm::fill_metal_icv_write_kor_options_to_uin { f                                             excludeKOR                                             top_level_only_kor                                             korspX                                             korspY } {
#@   set use_drawn_kor "true"
#@   if { $excludeKOR } { 
#@     set use_drawn_kor "false"
#@   }
#@ 
#@   puts $f "use_drawn_kor = $use_drawn_kor;"
#@   if { $use_drawn_kor == "true" } {
#@ 
#@     puts $f "top_level_only_kor = $top_level_only_kor;"
#@ 
#@     puts $f "drawn_kor_x_space = $korspX;"
#@     puts $f "drawn_kor_y_space = $korspY;"
#@   }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_density_to_uin {  f                                                  near_fill_density_target                                                  far_fill_density_target                                                  density_window_size                                                  density_window_y_size                                                  density_window_x_offset                                                  density_window_y_offset                                                  density_window_x_stepping                                                  density_window_y_stepping                                                  density_boundary_assumption                                                  density_kor_assumption                                                  metal_density_before_via } {
#@   set target_density_mode 0
#@   if { $near_fill_density_target > 0.0 } {
#@     puts $f "near_fill_density_target = $near_fill_density_target;"
#@     set target_density_mode 1
#@   }
#@ 
#@   if { $far_fill_density_target > 0.0 } {
#@     puts $f "far_fill_density_target = $far_fill_density_target;"
#@     set target_density_mode 1
#@   }
#@ 
#@   if { $target_density_mode } {
#@     if { $density_window_size > 0.0 } {
#@       puts $f "density_window_size = $density_window_size;"
#@     }
#@ 
#@     if { $density_window_y_size > 0.0 } {
#@       puts $f "density_window_y_size = $density_window_y_size;"
#@     }
#@ 
#@     if { $density_window_x_offset > 0.0 } {
#@       puts $f "density_window_x_offset= $density_window_x_offset;"
#@     }
#@ 
#@     if { $density_window_y_offset > 0.0 } {
#@       puts $f "density_window_y_offset = $density_window_y_offset;"
#@     }
#@ 
#@     if { $density_window_x_stepping > 0.0 } {
#@       puts $f "density_window_x_stepping = $density_window_x_stepping;"
#@     }
#@ 
#@     if { $density_window_y_stepping > 0.0 } {
#@       puts $f "density_window_y_stepping = $density_window_y_stepping;"
#@     }
#@ 
#@     if { $density_boundary_assumption != -1 } {
#@       puts $f "density_boundary_assumption = $density_boundary_assumption;"
#@     }
#@ 
#@     if { $density_kor_assumption } {
#@       puts $f "density_kor_assumption = $density_kor_assumption;"
#@     }
#@ 
#@     if { $metal_density_before_via } {
#@       puts $f "#define METAL_DENSITY_BEFORE_VIA"
#@     }
#@   }
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_output_options_to_uin {  f                                                 write_stm_output                                                 write_milkyway_output                                                 fill_in_cel_view                                                 mwoutpath                                                 cellname                                                 mwlibrary } {
#@ 
#@     if { [info exists ::env(PVPD_PIF_TOOL_NAME)] } {
#@         set toolname $::env(PVPD_PIF_TOOL_NAME)
#@         if {$toolname == "genesys" || $toolname == "genoa" || $toolname == "gena" || $toolname == "gend"} {
#@             puts $f "//set to true for cadworks"
#@             puts $f "write_stm_output = true;"
#@         } elseif { !$write_stm_output} {
#@             puts $f "write_stm_output = false;"
#@         }
#@     } elseif { !$write_stm_output} {
#@         puts $f "write_stm_output = false;"
#@     }
#@     
#@   if { $write_milkyway_output } {
#@     puts $f "write_milkyway_output = true;"
#@ 
#@     if { $fill_in_cel_view } {
#@       puts $f "mw_view = \"CEL\";"
#@     }
#@ 
#@     if { $mwoutpath != "" } {
#@       puts $f "mw_path = \"$mwoutpath\";"
#@     }
#@ 
#@     if { $cellname != "" } {
#@       puts $f "mw_cellname = \"$cellname\";"
#@     }
#@ 
#@     if { $mwlibrary != "" } {
#@       puts $f "mw_library = \"$mwlibrary\";"
#@     }
#@   }
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_write_cells_list_to_uin {  f  					                cell_list_option_name                                                         keepout_cells_list } {
#@ 
#@   if { $keepout_cells_list != "" } {
#@     set keepoutCellsList ""
#@     regsub -all "," $keepout_cells_list " " keepout_cells_list
#@     foreach keepoutCell $keepout_cells_list {
#@       set keepoutCellsList [concat $keepoutCellsList \"$keepoutCell\",]
#@     }
#@     puts $f "$cell_list_option_name = {$keepoutCellsList};"
#@   }
#@ }
#@ 
#@ ##################################### Function that calls fillflow.pl #########################################################################
#@ 
#@ proc ::dtDfm::fill_metal_icv_runflow { cellname                                        flowname                                        container_extension                                        level                                        stminputdir                                        uinfilepath                                        icvworkarea                                        icv_options                                        use_lnf_input 
#@                                        use_pds 				       				   launch_script                                        nbpool                                        nbclass                                        nbslot  } {
#@   global env
#@   # set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@   if { [file exists $icvworkarea] != 0 } {
#@     # puts "deleting $icvworkarea"
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   file mkdir $icvworkarea/output
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   # file copy $uinfilepath ./flexuin_fill${level}.rs
#@   file copy -force $uinfilepath ./flexuin${container_extension}.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@     cd $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath ]
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   cd $old_dir
#@   return $pid
#@ }
#@ 
#@ proc ::dtDfm::fill_via_icv_runflow { cellname                                      flowname                                      level                                      stminputdir                                      uinfilepath                                      icvworkarea                                      icv_options} {
#@   global env
#@   # set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowname}.iss"
#@   if { [file exists $icvworkarea] != 0 } {
#@     # puts "deleting $icvworkarea"
#@     file delete -force $icvworkarea
#@   }
#@   # puts "creating $icvworkarea"
#@   file mkdir $icvworkarea
#@   file mkdir $icvworkarea/output
#@   set old_dir [pwd]
#@   # pushd $icvworkarea
#@   cd $icvworkarea
#@   # file copy $uinfilepath ./flexuin.rs
#@   file copy -force $uinfilepath ./flexuin_vfill${level}.rs
#@ 
#@   set perlFlowLogPath "${icvworkarea}/$env(USER).${cellname}.${flowname}.log" 
#@   # set stminputdir  ${icvworkarea}/../input
#@   # set stmoutputdir ${icvworkarea}
#@   if { $use_pds } {
#@     set stmoutputdir $env(PDSSTM)
#@   } else {
#@     set stmoutputdir ${icvworkarea}
#@   }
#@   set uininputdir  ${icvworkarea}
#@ 
#@   set pid [::dtDfm::runFillFlow $cellname                              $flowname                              ${stminputdir}                              ${stmoutputdir}                              $uininputdir                              $icv_options                              $use_lnf_input                              $use_pds                              $launch_script                              $nbpool                              $nbclass                              $nbslot                              $perlFlowLogPath]
#@ 
#@   if { $pid == 0 } {
#@     return ""
#@   }
#@ 
#@   cd $old_dir
#@   return $pid
#@ }
#@ 
#@ ######################################### UDM DEPENDENT CODE STARTS HERE ######################################################################
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   printError $str
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   printInfo $str
#@ }
#@ 
#@ proc ::dtDfm::writeRegionGrids { f cellname viewname plys } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     set cell [get_cell "$cellname,$viewname"]
#@     set tech [cell_get_tech $cell]
#@ 
#@     puts $f "region_grids = $OPEN_BRACE "
#@     puts $f "                 $OPEN_BRACE "
#@ 
#@     set gigplys ""
#@     foreach ply $plys {
#@       set ply_gig [create_gigfig_from_ply $ply $tech]
#@       lappend gigplys $ply_gig
#@     }
#@     set ply_gig [gig_op_or_list $gigplys]
#@     set cell_boundary [cell_get_boundary $cell]
#@     if { $ply_gig != "" } {
#@       set ply_rects [gig_op_segment_list $ply_gig 4]
#@ 
#@       set writeor 0
#@       foreach ply_rect $ply_rects {
#@         set ply_box [gig_figure_get_bbox $ply_rect]
#@         set box_coord [ split $ply_box ":"]
#@ 
#@         set xl [tech_udm_to_micron $tech [lindex $box_coord 0]]
#@         set yl [tech_udm_to_micron $tech [lindex $box_coord 1]]
#@         set xh [tech_udm_to_micron $tech [lindex $box_coord 2]]
#@         set yh [tech_udm_to_micron $tech [lindex $box_coord 3]]
#@ 
#@         if { $writeor == 1 } {
#@           puts -nonewline $f "or "
#@         } else {
#@           set writeor 1
#@         }
#@         puts -nonewline $f "rectangle( $xl, $yl, $xh, $yh) "
#@       }
#@     }
#@     puts $f ","
#@     puts $f "grid_pattern1,"
#@     puts $f "offset,"
#@     puts $f "period,"
#@     puts $f "   $CLOSE_BRACE,"
#@     puts $f "$CLOSE_BRACE;"
#@ }
#@ 
#@ proc ::dtDfm::writeKORsToUIN { f cellname viewname plys } {
#@     set OPEN_BRACE "{"
#@     set CLOSE_BRACE "}"
#@ 
#@     set cell [get_cell "$cellname,$viewname"]
#@     set tech [cell_get_tech $cell]
#@ 
#@     puts $f "region_gids = $OPEN_BRACE "
#@     puts $f "                 $OPEN_BRACE "
#@ 
#@     set gigplys ""
#@     foreach ply $plys {
#@       set ply_gig [create_gigfig_from_ply $ply $tech]
#@       lappend gigplys $ply_gig
#@     }
#@     set ply_gig [gig_op_or_list $gigplys]
#@     set cell_boundary [cell_get_boundary $cell]
#@     # set ply_gig [create_gigfig_from_ply $ply $tech]
#@     # set kor_gig [gig_op_not_two_lists [list $cell_boundary] $ply_gig]
#@     set kor_gig $ply_gig
#@     if { $kor_gig != "" } {
#@       set kor_rects [gig_op_segment_list $kor_gig 4]
#@ 
#@       set firstkor 1
#@       foreach kor_rect $kor_rects {
#@         set ply_box [gig_figure_get_bbox $kor_rect]
#@         set box_coord [ split $ply_box ":"]
#@ 
#@         set xl [tech_udm_to_micron $tech [lindex $box_coord 0]]
#@         set yl [tech_udm_to_micron $tech [lindex $box_coord 1]]
#@         set xh [tech_udm_to_micron $tech [lindex $box_coord 2]]
#@         set yh [tech_udm_to_micron $tech [lindex $box_coord 3]]
#@ 
#@         if { !$firstkor } {
#@           puts -nonewline $f "or "
#@           set firstkor 0
#@         }
#@         puts -nonewline $f "rectangle( $xl, $yl, $xh, $yh) "
#@       }
#@     }
#@     puts $f ","
#@     puts $f "grid_pattern,"
#@     puts $f "offset,"
#@     puts $f "period,"
#@     puts $f "   $CLOSE_BRACE,"
#@     puts $f "$CLOSE_BRACE;"
#@ }
#@ 
#@ proc create_gigfig_from_ply { ply tech} {
#@  set vertex_list [split $ply " "]
#@  set num_of_vertex [llength $vertex_list]
#@ 
#@  set xlist_for_fig [list]
#@  set ylist_for_fig [list]
#@  for {set i 0} {$i < $num_of_vertex} {incr i} {
#@    set pt [lindex $vertex_list $i]
#@    lassign [split $pt ","] xpt ypt
#@    set xpt [tech_micron_to_udm $tech $xpt]
#@    set ypt [tech_micron_to_udm $tech $ypt]
#@    lappend xlist_for_fig $xpt
#@    lappend ylist_for_fig $ypt
#@  }
#@ 
#@  set orig_ply_gig_figure [gig_figure_create_polygon $xlist_for_fig $ylist_for_fig $num_of_vertex]
#@  return  $orig_ply_gig_figure
#@ }
#@ 
#@ proc ::dtDfm::is_via_layer_by_name { layername } {
#@     set result [regexp {via(\d+)} $layername fullstring level]
#@     if { $result == 0 } {
#@       set result [regexp {viaa(\d+)} $layername fullstring level]
#@     }
#@     if { $result == 0 } {
#@       set result [regexp {viab(\d+)} $layername fullstring level]
#@     }
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::is_via_layer { objLayer } {
#@     set layername [layer_get_name $objLayer]
#@     set result [::dtDfm::is_via_layer_by_name $layername]
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::is_dg_layer { objLayer } {
#@     set layername [layer_get_name $objLayer]
#@     set result [regexp {(\d+)dg} $layername fullstring level]
#@     return $result
#@ }
#@ 
#@ proc ::dtDfm::copyFromSTMToTop { srcCellName                                  srcViewName                                  destCellName                                  destViewName                                  layeNameList                                  stubnet                                  property                                  stub_property 								 netname_for_untexted_objects                                  {rename_nets ""}  }  {
#@   set from_nets {}
#@   set to_nets {}
#@   foreach from_to_net $rename_nets {
#@     lappend from_nets [lindex $from_to_net 0]
#@     lappend to_nets   [lindex $from_to_net 1]
#@   }
#@ 
#@   set prop_name_scope_value [split $property :]
#@   set propname  [lindex $prop_name_scope_value 0]
#@   set propscope [lindex $prop_name_scope_value 1]
#@   set propvalue [lindex $prop_name_scope_value 2]
#@ 
#@   set stub_prop_name_scope_value [split $stub_property :]
#@   set stub_propname  [lindex $stub_prop_name_scope_value 0]
#@   set stub_propscope [lindex $stub_prop_name_scope_value 1]
#@   set stub_propvalue [lindex $stub_prop_name_scope_value 2]
#@ 
#@   set src [cell_mgr_get_cell [cell_mgr_get_mgr] $srcCellName $srcViewName]
#@   set dest [cell_mgr_get_cell [cell_mgr_get_mgr] $destCellName $destViewName ]
#@   set tech [cell_get_tech $src]
#@   set layerList ""
#@ 
#@   foreach fillLayer $layeNameList {
#@   lappend layerList [tech_get_layer $tech $fillLayer]
#@   if { $fillLayer == "metal0" } {
#@     set metalc0Layer [tech_get_layer $tech metalc0]
#@     if { $metalc0Layer != "NULL" } {
#@       lappend layerList $metalc0Layer
#@     }
#@     set metals0Layer [tech_get_layer $tech metals0]
#@     if { $metals0Layer != "NULL" } {
#@       lappend layerList $metals0Layer
#@     }
#@   }
#@   if { $fillLayer == "metal1" } {
#@     set metal1dgLayer [tech_get_layer $tech metal1dg]
#@     if { $metal1dgLayer != "NULL" } {
#@       lappend layerList $metal1dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal2" } {
#@     set metalc2Layer [tech_get_layer $tech metalc2]
#@     if { $metalc2Layer != "NULL" } {
#@       lappend layerList $metalc2Layer
#@     }
#@     set metal2dgLayer [tech_get_layer $tech metal2dg]
#@     if { $metal2dgLayer != "NULL" } {
#@       lappend layerList $metal2dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal3" } {
#@     set metalc3Layer [tech_get_layer $tech metalc3]
#@     if { $metalc3Layer != "NULL" } {
#@       lappend layerList $metalc3Layer
#@     }
#@     set metal3dgLayer [tech_get_layer $tech metal3dg]
#@     if { $metal3dgLayer != "NULL" } {
#@       lappend layerList $metal3dgLayer
#@     }
#@   }
#@   if { $fillLayer == "metal4" } {
#@     set metalc4Layer [tech_get_layer $tech metalc4]
#@     if { $metalc4Layer != "NULL" } {
#@       lappend layerList $metalc4Layer
#@     }
#@   }
#@   if { $fillLayer == "metal5" } {
#@     set metalc5Layer [tech_get_layer $tech metalc5]
#@     if { $metalc5Layer != "NULL" } {
#@       lappend layerList $metalc5Layer
#@     }
#@   }
#@   if { $fillLayer == "via1" } {
#@     set viaa1Layer [tech_get_layer $tech viaa1]
#@     if { $viaa1Layer != "NULL" } {
#@       lappend layerList $viaa1Layer
#@     }
#@     set viab1Layer [tech_get_layer $tech viab1]
#@     if { $viab1Layer != "NULL" } {
#@       lappend layerList $viab1Layer
#@     }
#@     set viac1Layer [tech_get_layer $tech viac1]
#@     if { $viac1Layer != "NULL" } {
#@       lappend layerList $viac1Layer
#@     }
#@   }
#@   if { $fillLayer == "via2" } {
#@     set viaa2Layer [tech_get_layer $tech viaa2]
#@     if { $viaa2Layer != "NULL" } {
#@       lappend layerList $viaa2Layer
#@     }
#@     set viab2Layer [tech_get_layer $tech viab2]
#@     if { $viab2Layer != "NULL" } {
#@       lappend layerList $viab2Layer
#@     }
#@   }
#@   if { $fillLayer == "via3" } {
#@     set viaa3Layer [tech_get_layer $tech viaa3]
#@     if { $viaa3Layer != "NULL" } {
#@       lappend layerList $viaa3Layer
#@     }
#@     set viab3Layer [tech_get_layer $tech viab3]
#@     if { $viab3Layer != "NULL" } {
#@       lappend layerList $viab3Layer
#@     }
#@   }
#@   }
#@ 
#@   set bcPersona [udm_app_get_opt_layer_persona]
#@   if {[expr $bcPersona & 1]} {
#@     udm_app_change_opt_layer_persona 6
#@   }
#@   set objsIter  [cell_get_geo_objs_iter $src]
#@   set objCount 0
#@   set objIdList ""
#@   set stubList ""
#@ 
#@   while {[geo_obj_iter_advance $objsIter]} {
#@     set obj [geo_obj_iter_get_current $objsIter]
#@     set objLayer [geo_obj_get_layer $obj]
#@     incr objCount
#@     if { [lsearch $layerList $objLayer] != -1 } {
#@       if { [ isa_geo_poly $obj ] == 1 } {
#@         set syn 0
#@         set srcnet [geo_polygon_get_net $obj]
#@         if { $srcnet != "" } {
#@           set destnetname [net_get_name $srcnet]
#@         } else {
#@           if { $netname_for_untexted_objects == "unique_syn" } {
#@             set destnet [udm_utils_create_synth_net $dest]
#@             set destnetname  [net_get_name $destnet] 
#@           }  else {
#@             set destnetname $netname_for_untexted_objects
#@           }
#@         }
#@ 
#@         set destnet ""
#@         set this_is_stub false
#@         if { [regexp {syn_generated_([0-9\.]+)} $destnetname match num] } {
#@           if { $stubnet == "" } {
#@             set destnet [udm_utils_create_synth_net $dest]
#@           } else {
#@             set destnetname syn_stub
#@           }
#@           set this_is_stub true
#@         }
#@ 
#@ if { 0 } {
#@         if { [regexp {.*_floatiss_} $destnetname match num] } {
#@           set destnetname floatiss_
#@         }
#@ }
#@ 
#@         set net_index [lsearch $from_nets $destnetname]
#@         if { $net_index != -1 } {
#@           set destnetname [lindex $to_nets $net_index]
#@         }
#@ 
#@         if { $destnet == "" } {
#@           set destnet [cell_get_net $dest $destnetname ]
#@           if { $destnet == "" } {
#@             set destnet [cell_create_net $dest $destnetname ]
#@           }
#@         }
#@ 
#@         set bbox [::boo::new_BooBBox]
#@         geo_obj_get_bounding_box $obj $bbox
#@         set rect [new_rect_from_bbox $bbox $objLayer]
#@ 
#@         set this_is_a_wire true
#@ 
#@         if { [::dtDfm::is_via_layer $objLayer] } {
#@           set viapoly [new_polygon_from_bbox $bbox $objLayer]
#@           # set p [geo_polygon_create $dest $viapoly $destnet]
#@ 
#@          set enclist {}
#@          set p [via_create_general_via $destnet $enclist $viapoly]
#@          lappend objIdList [obj_get_obj_id $p]
#@          set this_is_a_wire false
#@         } elseif { [::dtDfm::is_dg_layer $objLayer] } {
#@           set dgpoly [new_polygon_from_bbox $bbox $objLayer]
#@           set p [geo_polygon_create $dest $dgpoly $destnet]
#@         } else {
#@           set w [wire_create $destnet $rect 0]
#@           lappend objIdList [obj_get_obj_id $w]
#@         }
#@         if {$syn == 1} {net_set_synth_net $destnet 1}
#@ 
#@         if { $this_is_stub && $this_is_a_wire } {
#@           lappend stubList  [obj_get_obj_id $w]
#@         }
#@       }
#@     }
#@   }
#@   if { [info commands Dfm] != {} && $objIdList != "" && $prop_name_scope_value != "" } {
#@     Dfm setCell -cell $destCellName
#@     Dfm setProp -name $propname -value $propvalue -scope $propscope -objIds $objIdList
#@     # puts "Dfm setProp -name $propname -value $propvalue -scope $propscope -objIds $objIdList"
#@   }
#@ 
#@   if { [info commands Dfm] != {} && $stubList != "" && $stub_prop_name_scope_value != "" } {
#@     Dfm setCell -cell $destCellName
#@     Dfm setProp -name $stub_propname -value $stub_propvalue -scope $stub_propscope -objIds $stubList
#@     # puts "Dfm setProp -name $stub_propname -value $stub_propvalue -scope $stub_propscope -objIds $stubList"
#@   }
#@ 
#@   udm_app_change_opt_layer_persona $bcPersona
#@   return $objIdList
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   # read and process results
#@   # set pid                 [::dtDfm::keylget jobInfo PID]
#@   set cellname            [::dtDfm::keylget jobInfo CELLNAME]
#@   set outputcellname      [::dtDfm::keylget jobInfo OUTPUT_CELL_NAME]
#@   set viewname            [::dtDfm::keylget jobInfo VIEWNAME]
#@   # set techname            [::dtDfm::keylget jobInfo TECHNAME]
#@   set container_extension [::dtDfm::keylget jobInfo EXTENSION]
#@   set fillLayers          [::dtDfm::keylget jobInfo LAYER]
#@   set stubnet             [::dtDfm::keylget jobInfo STUBNET]
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@   set property            [::dtDfm::keylget jobInfo PROPERTY]
#@   set stub_property       [::dtDfm::keylget jobInfo STUB_PROPERTY]
#@   set rename_nets         [::dtDfm::keylget jobInfo RENAME_NETS]
#@   set netname_for_untexted_objects [::dtDfm::keylget jobInfo NETNAME_FOR_UNTEXTED_OBJECTS]
#@   # set print_cmd_str       [::dtDfm::keylget jobInfo CMD_STR]
#@   
#@   # wait $pid
#@   # stm inputTechnology $tech
#@   set container_name ${cellname}${container_extension}
#@   set path ${icvworkarea}/${container_name}.stm
#@ 
#@   set readLayers ""
#@   foreach fillLayer $fillLayers {
#@     if { $fillLayer == "poly" } {
#@       lappend readLayers wirepoly
#@     } elseif { $fillLayer == "diffusion" || $fillLayer == "libdfmg" } {
#@       lappend readLayers nwirediff pwirediff wirepoly diffcon polycon
#@     } elseif { $fillLayer == "polycon" } {
#@       lappend readLayers polycon
#@     } elseif { $fillLayer == "diffcon" } {
#@       lappend readLayers diffcon
#@     } elseif { $fillLayer == "viat" } {
#@       lappend readLayers metal0 viat viag
#@     } else {
#@       lappend readLayers $fillLayer
#@     }
#@   }
#@   ::dtDfm::read_stm -from_cell $container_name                     -from_view stm                     -to_cell $outputcellname                     -to_view $viewname                     -path $path                     -layers $readLayers                     -stubnet $stubnet                     -property $property                     -stub_property $stub_property                     -rename_nets  $rename_nets  					-netname_for_untexted_objects $netname_for_untexted_objects
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   stm terminalProperty 126
#@   stm inputObjectProperties 1
#@   stm propertyAttributes 1
#@ 
#@   set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_checkcell { cellname viewname } {
#@     if {[info commands ::get_cell] != ""} {
#@         set cell [get_cell "$cellname,$viewname"]
#@         if {$cell == ""} {
#@             ::dtDfm::printErr "cell $cellname not found"
#@             return 0
#@         }
#@         set tech [cell_get_tech $cell]
#@         if {$tech == ""} {
#@             ::dtDfm::printErr "Failed to get udm tech"
#@             return 0
#@         }
#@     }
#@     return 1
#@ }
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   # puts "checking interrupt"
#@   set interrupted 0
#@   set interruptManager_ [::boo::BooInterruptMgr_getMgr]
#@   if {[::boo::BooInterruptMgr_interruptOccurred $interruptManager_]} {
#@     ::boo::BooInterruptMgr_clearInterrupt $interruptManager_
#@     set interrupted 1
#@   }
#@   return $interrupted
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   puts "Discarding partial fill objects"
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@ 
#@   set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@   if {$outputcellname != ""} {
#@     set cellname $outputcellname
#@   }
#@ 
#@   set properties {}
#@   foreach jobinfo $jobs {
#@     set property [::dtDfm::keylget jobinfo PROPERTY]
#@     if { [lsearch $properties $property] == -1 } {
#@       lappend properties $property
#@     }
#@     set stub_property [::dtDfm::keylget jobinfo STUB_PROPERTY]
#@     if { [lsearch $properties $stub_property] == -1 } {
#@       lappend properties $stub_property
#@     }
#@   }
#@ 
#@   Dfm setCell -cell $cellname
#@   set tbd_cell TO_BE_DELETED 
#@   Dfm createDfmCell -dfmCellName $tbd_cell
#@   foreach property $properties {
#@     set prop_name_scope_value [split $property :]
#@     set propname  [lindex $prop_name_scope_value 0]
#@     set propscope [lindex $prop_name_scope_value 1]
#@     set propvalue [lindex $prop_name_scope_value 2]
#@ 
#@     set cmd "Dfm objsByProp -command move -cell $tbd_cell -propName $propname -propScope $propscope -propValue $propvalue"
#@     set objs [eval $cmd]
#@     # puts "$cmd"
#@   }
#@   Discard -cellname $tbd_cell -noask
#@ }
#@ 
#@ ######################################### Parade DEPENDENT CODE STARTS HERE ####################################################################
#@ 
#@ 
#@ if { [info exists ICV_MFILL_FOR_PARADE] } {
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   set interrupted 0
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   # read and process results
#@   set pid                 [::dtDfm::keylget jobInfo PID]
#@   set cellname            [::dtDfm::keylget jobInfo CELLNAME]
#@   set outputcellname      [::dtDfm::keylget jobInfo OUTPUT_CELL_NAME]
#@   set viewname            [::dtDfm::keylget jobInfo VIEWNAME]
#@   set techname            [::dtDfm::keylget jobInfo TECHNAME]
#@   set container_extension [::dtDfm::keylget jobInfo EXTENSION]
#@   set fillLayer           [::dtDfm::keylget jobInfo LAYER]
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@   set property            [::dtDfm::keylget jobInfo PROPERTY]
#@   set stub_property       [::dtDfm::keylget jobInfo STUB_PROPERTY]
#@   set print_cmd_str       [::dtDfm::keylget jobInfo CMD_STR]
#@ 
#@   # wait $pid
#@   set container_name ${cellname}${container_extension}
#@ 
#@   # qb_node_create [pa_top_macro] vss 1
#@ 
#@   set old_dir [pwd]
#@   cd ${icvworkarea}
#@   set cmd "qb_gdsii_read_shapes ${icvworkarea}/${container_name}.stm vss"
#@ 
#@   # Open -cellname $container_name -viewname stm -nowindow 1
#@   set openret [eval $cmd]
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@ 
#@   if { $openret == 0 } {
#@     puts "Fail to load in ISS result stream file."
#@     return "0"
#@   }
#@  cd $old_dir
#@ 
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   # set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   set cmd "qb_write_gdsii \"\" \"\"  $path"
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ 
#@ proc ::dtDfm::fill_metal_icv_checkcell { cellname viewname } {
#@         return [expr {$cellname == [qb_macro_get_name [pa_top_macro]]}]
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   pa_log $str i
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   pa_log $str i
#@ }
#@ 
#@ 
#@ }
#@ 
#@ ######################################### ICC DEPENDENT CODE STARTS HERE #######################################################################
#@ 
#@ if { [info exists ICV_MFILL_FOR_ICC] } {
#@ 
#@ namespace eval ::boo {}; proc ::boo::EOUT {args} { puts $args }
#@ namespace eval ::boo {}; proc ::boo::IOUT {args} { puts $args }
#@ 
#@ proc ::dtDfm::interrupted { } {
#@   set interrupted 0
#@ }
#@ 
#@ proc ::dtDfm::delete_all_fill { } {
#@   return 0
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_readresults { jobInfo save_workdir } {
#@   set icvworkarea         [::dtDfm::keylget jobInfo ICVWORKAREA]
#@ 
#@   if { !$save_workdir } {
#@     if { ([file exists $icvworkarea] != 0) } {
#@       file delete -force $icvworkarea
#@     }
#@   }
#@   return 1
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_saveas { cellname viewname path layer_map_for_mw } {
#@   # set cmd "SaveAs -cellname $cellname -viewname $viewname -noask  -path $path"
#@   # set cmd "qb_write_gdsii \"\" \"\"  $path"
#@ 
#@ 
#@    set_write_stream_options          -output_first_same_name_cell          -skip_global_route_contact          -contact X          -child_depth 1000          -output_filling fill          -output_outdated_fill          -output_pin {geometry}          -keep_data_type          -flatten_via          -map_layer $layer_map_for_mw          -output_instance_name_as_property 112          -max_name_length 64          -output_net_name_as_property 126          -set_hier_net_name_long          -set_hier_instance_name_long
#@ 
#@   if { [info exists env(PROJ_RDT)] } {
#@     set cmd "P_write_layout_file -format gds -cell $cellname -output_file $path"
#@   } else {
#@     set cmd "write_stream -cells $cellname $path"
#@   }
#@ 
#@   puts $cmd
#@   set saveret [eval $cmd]
#@   return $saveret
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_info { str } {
#@   puts $str
#@ }
#@ 
#@ proc ::dtDfm::fill_metal_icv_print_error { str } {
#@   puts $str
#@ }
#@ 
#@ }
#@ 
#@ ################################################### General Functions ##########################################################################
#@ 
#@ proc ::dtDfm::get_cist_cmd_info {cmdname {filepath ""}} {
#@   set f ""
#@   if { $filepath != "" } {
#@     set f [open $filepath w]
#@   }
#@ 
#@   set cmd [[cist::cist_cmd_mgr::get_mgr] get_cmd $cmdname]
#@ 
#@   if {$cmd == ""} {
#@     return [list]
#@   }
#@ 
#@   set retval [list]
#@ 
#@   #
#@   # See also:  public variables in class cist::cist_input in /vobs/cadpax/cist/tcl/cist.tcl
#@   #
#@   foreach opt [$cmd get_inputs] {
#@     set name [$opt cget -optname]
#@     set def  [$opt cget -default]
#@     set desc [$opt cget -help]
#@     regsub -all "\n\t\t\t\t" $desc ";;;" desc
#@     if { $f != "" } { 
#@       puts $f "$name\t$def\t$desc"
#@     }
#@     lappend retval [list $name $def $desc]
#@   }
#@ 
#@   close $f
#@   return $retval
#@ }
#@ 
#@ proc ::dtDfm::keylset { instruct key value } {
#@   upvar 1 $instruct mystruct
#@   set found 0
#@   set index 0
#@   foreach info $mystruct {
#@     set info_key [lindex $info 0]
#@     if { $info_key == $key } {
#@       set found 1
#@       break;
#@     }
#@     incr index
#@   }
#@   if { $found == 1 } {
#@     set mystruct [lreplace $mystruct $index $index "$key $value"]
#@   } else {
#@     set mystruct [lappend mystruct "$key $value"]
#@   }
#@ }
#@ 
#@ proc ::dtDfm::keylget { instruct key } {
#@   upvar 1 $instruct mystruct
#@   set found 0
#@   set index 0
#@   foreach info $mystruct {
#@     set info_key [lindex $info 0]
#@     if { $info_key == $key } {
#@       return [lrange $info 1 end]
#@     }
#@     incr index
#@   }
#@   error "key $key not found in keyed list"
#@ }
#@ 
#@ proc ::dtDfm::lremove {args} {
#@      if {[llength $args] < 2} {
#@         puts stderr {Wrong # args: should be "lremove ?-all? list pattern"}
#@      }
#@      set list [lindex $args end-1]
#@      set elements [lindex $args end]
#@      if [string match -all [lindex $args 0]] {
#@         foreach element $elements {
#@             set list [lsearch -all -inline -not -exact $list $element]
#@         }
#@      } else {
#@         # Using lreplace to truncate the list saves having to calculate
#@         # ranges or offsets from the indexed element. The trimming is
#@         # necessary in cases where the first or last element is the
#@         # indexed element.
#@         foreach element $elements {
#@             set idx [lsearch $list $element]
#@             set list [string trim                 "[lreplace $list $idx end] [lreplace $list 0 $idx]"]
#@         }
#@      }
#@      return $list
#@ }
#@ proc ::dtDfm::fill_metal_icv_get_tech { temp_techname } {
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@     return $techname
#@ }
#@ 
#@ proc ::dtDfm::wait_on_pds_job { cellname flowname } {
#@   global env
#@ 
#@   set user $env(USER) 
#@   set supportfile "$env(PDSSUPPORT)/psicv_${user}.${cellname}.${flowname}.none.none"
#@   set currentfile "$env(PDSLOGS)/${cellname}.${flowname}.iss.current"
#@   set abortfile   "$env(PDSLOGS)/${cellname}.${flowname}.iss.abort"
#@   set logfile     "$env(PDSLOGS)/${cellname}.${flowname}.iss.log"
#@  
#@   exec sleep 2
#@   while { ([file exists $supportfile] != 0) } {
#@     exec sleep 2
#@   }
#@ 
#@   if { ([file exists $abortfile] != 0) } {
#@     return 1
#@   }
#@   return 0
#@ }
#@ 
#@ 
#@ ######################################### TEST PROCEDURE BELOW         #########################################################################
#@ proc my1272fill { cellname layers } {
#@ 
#@ set serial FALSE
#@ 
#@ ::dtDfm::fill_metal_icv_init -cellname $cellname
#@ 
#@ if { [lsearch $layers metal0] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal0 -offset 0.038 -pattern VSS_DUMMY:0.080B:0.028:VSS_DUMMY:0.032C:0.028 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal1] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal1 -offset 0.049 -pattern VSS_DUMMY:0.042:0.028 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal2] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspX 0.028 -layer metal2 -offset 0.038 -pattern VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.038C:0.024:VSS:0.074:0.024:VSS_DUMMY:0.038C:0.024:VSS_DUMMY:0.028B:0.024:VSS_DUMMY:0.028C:0.024 -property Dmi:test:Dmi
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal3] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -exclCells cx* -korspY 0.028 -layer metal3 -offset 0.066 -pattern VSS_DUMMY:0.048C:0.024:VSS_DUMMY:0.032B:0.024:VSS_DUMMY:0.032C:0.024:VSS_DUMMY:0.032B:0.024:VSS_DUMMY:0.048C:0.024:VCC:0.084:0.024
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal4] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -layer metal4 -pattern VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.040:VSS_DUMMY:0.044:0.208 -offset 0.104 -property Dmi:test:Dmi -korspX 0.04 -korspY 0 -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal5] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -layer metal5 -pattern VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.050:VSS_DUMMY:0.054:0.266 -offset 0.133 -property Dmi:test:Dmi -korspX 0 -korspY 0.045 -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal6] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal6 -pattern VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.080:VSS_DUMMY:0.092:0.388 -offset 0.194 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal7] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal7 -pattern VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.080:VSS_DUMMY:0.100:0.500 -offset 0.250 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal8] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal8 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.532 -offset 0.266 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal9] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal9 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.700 -offset 0.350 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ if { [lsearch $layers metal10] != -1 } {
#@ ::dtDfm::fill_metal_icv -cellname $cellname -viewname lnf -techname 1272 -layer metal10 -pattern VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:0.140:VSS_DUMMY:0.140:1.204 -offset 0.602 -property Dmi:Dmi:test -exclCells cx*
#@ if { $serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ 
#@ if { !$serial } {
#@   ::dtDfm::fill_metal_icv_end
#@ }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ ##################################### Functions related to ::dtDfm::fix_v0pax_dfmg ##################################################################
#@ CmdSpec ::dtDfm::fix_v0pax_dfmg {
#@ 
#@     -help "::dtDfm::fix_v0pax_dfmg -layer via1"
#@     -opts {
#@         {-optname     layer
#@             -type     string
#@             -default  ""
#@             -help     "Via layer to fill - i.e. via1"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@        {-optname  keepout_cells_list
#@         -type     string
#@         -default  ""
#@         -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@        }
#@         {-optname  keepout_cells_x_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname  keepout_cells_y_space
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     excludeKOR
#@          -type     bool
#@          -default  false
#@          -help     "Exclude KOR layer objs"
#@         }
#@         {-optname  top_level_only_kor
#@          -type     string
#@          -qualifiers {-radio {false true}}
#@          -default  true
#@          -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     korspX
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     korspY
#@          -type     float
#@          -default  0.0
#@          -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     result_container_name
#@          -type        string
#@          -default     ""
#@          -help        "Name of the fill container to which results are written out\n\t\t\t\tBy default the upsized vias will be read into the top cell"
#@         }
#@     }
#@ }
#@ 
#@ proc ::dtDfm::fix_v0pax_dfmg {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@ 
#@     set fillLayer $opts(layer)
#@     set keepin_cells_list $opts(keepin_cells_list)
#@     set keepout_cells_list $opts(keepout_cells_list)
#@     set keepout_cells_x_space $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space $opts(keepout_cells_y_space)
#@     set excludeKOR $opts(excludeKOR)
#@     set top_level_only_kor $opts(top_level_only_kor)
#@     set korspX $opts(korspX)
#@     set korspY $opts(korspY)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@ 
#@     ### If UDM, get tech from UDM cell
#@ 
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@       return 0
#@     }
#@ 
#@     #check if layer option is empty
#@     # if { $fillLayer == "" } {
#@ 	# ::dtDfm::printErr "No via layer specified"
#@ 	# return 0
#@     #}
#@ 
#@ 
#@     set fillLayer "viat"
#@     set level 0
#@     # set result [regexp {via(\d+)} $fillLayer fullstring level]
#@ 
#@     # if { $result == 0 || $level != 1 } {
#@       # ::dtDfm::printErr "$fillLayer is not supported by this flow"
#@       # return 0
#@     # }
#@ 
#@     set flowName "v0pax_dfmg"
#@     set container_extension "_v0pax_dfmg"
#@ 
#@   # write uin file
#@   set uinfilename "${cellname}${container_extension}.uin"
#@   # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@   set uinfilepath "$uindir/$uinfilename"
#@ 
#@   ::dtDfm::fix_v0pax_dfmg_writeuin     $cellname                                  $viewname                                  $techname                                  $fillLayer                                  $uinfilepath                                  $write_milkyway_output                                  $fill_in_cel_view                                  $mwoutpath                                  $mwlibrary                                  $write_stm_output 				 $keepin_cells_list 				 $keepout_cells_list 				 $keepout_cells_x_space 				 $keepout_cells_y_space                                  $excludeKOR                                  $top_level_only_kor                                  $korspX 				 $korspY 
#@ 
#@   if { $only_write_uin } {
#@     return ""
#@   }
#@ 
#@   # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@   set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@   set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@   set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@   set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@   set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@   set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@   set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@   set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@   set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@ 
#@   set pid [::dtDfm::fill_metal_icv_runflow $cellname                                            $flowName                                            $container_extension                                            $level                                            $stminputdir                                            $uinfilepath                                            $icvworkarea                                            $icv_options                                            $use_lnf_input                                            $use_pds 											$launch_script                                            $nbpool                                            $nbclass                                            $nbslot ]
#@ 
#@   # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@   # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@  set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@   set jobInfo ""
#@   ::dtDfm::keylset jobInfo PID         $pid
#@   ::dtDfm::keylset jobInfo CELLNAME    $cellname
#@   ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME    $outputcellname
#@   ::dtDfm::keylset jobInfo VIEWNAME    $viewname
#@   ::dtDfm::keylset jobInfo TECHNAME    $techname
#@   ::dtDfm::keylset jobInfo EXTENSION   $container_extension
#@   ::dtDfm::keylset jobInfo LAYER       $fillLayer
#@   ::dtDfm::keylset jobInfo ICVWORKAREA $icvworkarea
#@   ::dtDfm::keylset jobInfo PROPERTY    $property
#@   ::dtDfm::keylset jobInfo STUBNET     $stubnet
#@   ::dtDfm::keylset jobInfo STUB_PROPERTY    $stub_property
#@   ::dtDfm::keylset jobInfo RENAME_NETS $rename_nets
#@   ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@   ::dtDfm::keylset jobInfo CMD_STR     $print_cmd_str
#@ 
#@   set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@   lappend jobs $jobInfo
#@   ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@   return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::fix_v0pax_dfmg_writeuin { cellname 				  viewname 				  techname 				  fillLayer                                   uinfilepath                                   write_milkyway_output                                   fill_in_cel_view                                   mwoutpath                                   mwlibrary                                   write_stm_output 				  keepin_cells_list 				  keepout_cells_list 				  keepout_cells_x_space 				  keepout_cells_y_space                                   excludeKOR                                   top_level_only_kor                                   korspX 				  korspY 
#@ } {
#@ 
#@    set f [open "$uinfilepath" w]
#@ 
#@ 
#@   if { $techname != "" } {
#@     puts $f "process_name = \"$techname\";"
#@   }
#@ 
#@   ::dtDfm::fill_metal_icv_write_output_options_to_uin $f                                                       $write_stm_output                                                       $write_milkyway_output                                                       $fill_in_cel_view                                                       $mwoutpath                                                       $cellname                                                       $mwlibrary;
#@ 
#@   set cell_list_option_name "keepin_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepin_cells_list;
#@   set cell_list_option_name "keepout_cells_list"
#@   ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f                                                   $cell_list_option_name                                                   $keepout_cells_list;
#@ 
#@   puts $f "keepout_cells_x_space = $keepout_cells_x_space;"
#@   puts $f "keepout_cells_y_space = $keepout_cells_y_space;"
#@ 
#@   ::dtDfm::fill_metal_icv_write_kor_options_to_uin $f                                                    $excludeKOR                                                    $top_level_only_kor                                                    $korspX                                                    $korspY;
#@ 
#@   close $f
#@ }
#@ 
#@ # Functions related to ::dtDfm::powerhookup 
#@ # BMB 2012-10-14
#@ 
#@ CmdSpec ::dtDfm::powerhookup {
#@     -help "::dtDfm::powerhookup"
#@     -opts {
#@         {-optname     process_name
#@             -type     string
#@             -default  "p1274.0"
#@             -help     "process name"
#@         }
#@         {-optname  top_level_only_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use only top level KORs; ignore KORs at the lower levels of hierarchy"
#@         }
#@         {-optname     use_drawn_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use drawn KOR layers"
#@         }
#@         {-optname     use_route_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use route KOR layers"
#@         }
#@         {-optname     use_fill_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Use fill KOR layers"
#@         }
#@         {-optname     use_global_kor
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Use global KOR layers"
#@         }
#@         {-optname     drawn_kor_x_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to KOR X spacing in micron"
#@         }
#@         {-optname     drawn_kor_y_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to KOR Y spacing in micron"
#@         }
#@ 
#@         {-optname     dh_bonus_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "list of double-height bonus cells"
#@         }
#@         {-optname     force_hookup_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "force hookup of power on listed cells"
#@         }
#@         {-optname     hookup_cell_names_list
#@             -type     string
#@             -default  ""
#@             -help     "list of cells (with wildcards) to hookup"
#@         }
#@         {-optname     hookup_cell_names_list_xn
#@             -type     string
#@             -default  ""
#@             -help     "list of xn cells (with wildcards) to hookup"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "vias only from these cells will be upsized"
#@         }
#@         {-optname     keepout_cells_list
#@             -type     string
#@             -default  ""
#@             -help     "Wild card expression for the names of cells\n\t\t\t\tfill will not be done over these cells"
#@         }
#@         {-optname     keepout_cells_x_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to keepout-cell X spacing in micron"
#@         }
#@         {-optname     keepout_cells_y_space
#@             -type     float
#@             -default  0.0
#@             -help     "Fill to keepout-cell Y spacing in micron"
#@         }
#@         {-optname     powerhookup_grid_count
#@             -type     integer
#@             -default  0.0
#@             -help     "Grid count spacing for power hookup connections"
#@         }
#@         {-optname     powerhookup_empty_area
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Place power hookups in areas with no cell placements"
#@         }
#@         {-optname     powerhookup_cells_area
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Place power hookups in areas with cell placements"
#@         }
#@         {-optname     powerhookup_avoid_drv
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Avoid DRV and shorts when placing powerhookup vias"
#@         }
#@         {-optname     powerhookup_all_segments
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  true
#@             -help     "Ensure power hookups are on all segments of M2 power grid"
#@         }
#@         {-optname     powerhookup_drv_vias_cells_list 
#@             -type     string
#@             -default  "{\"*\"}"
#@             -help     "List of cells vias to consider for DRV"
#@         }
#@         {-optname     powerhookup_offset_locations
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Alternate the initial offset to place vias each M2 track"
#@         }
#@         {-optname     write_coord_file
#@             -type     string
#@             -default  ""
#@             -help     "Write center x,y cooridinates of power hookup to file"
#@         }
#@         {-optname     write_def_file_prefix
#@             -type     string
#@             -default  ""
#@             -help     "Write vias placements to DEF file"
#@         }
#@         {-optname     power_name
#@             -type     string
#@             -default  "vcc"
#@             -help     "Name of power rail (default = vcc)"
#@         }
#@         {-optname     ground_name
#@             -type     string
#@             -default  "vss"
#@             -help     "Name of ground rail (default = vss)"
#@         }
#@         {-optname     ground_rail_y_start
#@             -type     float
#@             -default  0.0
#@             -help     "y-value of center of first horizontal ground rail (default = 0.0)"
#@         }
#@         {-optname     power_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for power nets"
#@         }
#@         {-optname     ground_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for ground nets"
#@         }
#@         {-optname     dsn_core_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing core_area key=int_width and value=points_of_area for core_area"
#@         }
#@         {-optname     m2_rail_width
#@             -type     float
#@             -default  -1.0
#@             -help     "Width of m2 pwr/gnd rails" 
#@         }
#@         {-optname     cell_height
#@             -type     float
#@             -default  -1.0
#@             -help     "Height of single height stdcell" 
#@         }
#@         {-optname     v0_master
#@             -type     string
#@             -default  ""
#@             -help     "v0 via master" 
#@         }
#@         {-optname     v1_master
#@             -type     string
#@             -default  ""
#@             -help     "v1 via master" 
#@         }
#@         {-optname     hookup_via_settings
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing override settings for p1271-p1273 via masters and dimensions" 
#@         }
#@         {-optname     use_xll_grid
#@             -type     string
#@             -qualifiers {-radio {false true}}
#@             -default  false
#@             -help     "Use XLL grid"
#@         }
#@         {-optname     bndry_y_min
#@             -type     float
#@             -default  0.0
#@             -help     "block boundary lower-y (default = 0.0)"
#@         }
#@     }
#@ }
#@ 
#@ # BMB 2012-10-14
#@ proc ::dtDfm::powerhookup {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set dh_bonus_cells_list       $opts(dh_bonus_cells_list)
#@     set force_hookup_cells_list   $opts(force_hookup_cells_list)
#@     set hookup_cell_names_list    $opts(hookup_cell_names_list)
#@     set hookup_cell_names_list_xn $opts(hookup_cell_names_list_xn)
#@     set keepin_cells_list        $opts(keepin_cells_list)
#@     set keepout_cells_list       $opts(keepout_cells_list)
#@     set keepout_cells_x_space    $opts(keepout_cells_x_space)
#@     set keepout_cells_y_space    $opts(keepout_cells_y_space)
#@     set powerhookup_grid_count   $opts(powerhookup_grid_count)
#@     set powerhookup_empty_area   $opts(powerhookup_empty_area)
#@     set powerhookup_cells_area   $opts(powerhookup_cells_area)
#@     set powerhookup_avoid_drv    $opts(powerhookup_avoid_drv)
#@     set powerhookup_all_segments $opts(powerhookup_all_segments)
#@     set powerhookup_drv_vias_cells_list $opts(powerhookup_drv_vias_cells_list)
#@     set powerhookup_offset_locations $opts(powerhookup_offset_locations)
#@     set use_drawn_kor            $opts(use_drawn_kor)
#@     set top_level_only_kor       $opts(top_level_only_kor)
#@     set use_route_kor            $opts(use_route_kor)
#@     set use_fill_kor             $opts(use_fill_kor)
#@     set use_global_kor           $opts(use_global_kor)
#@     set drawn_kor_x_space        $opts(drawn_kor_x_space)
#@     set drawn_kor_y_space        $opts(drawn_kor_y_space)
#@     set write_coord_file         $opts(write_coord_file)
#@     set write_def_file_prefix    $opts(write_def_file_prefix)
#@     set power_name               $opts(power_name)
#@     set ground_name              $opts(ground_name)
#@     set ground_rail_y_start      $opts(ground_rail_y_start)
#@     if { $opts(power_voltage_areas) ne "" } {
#@        upvar $opts(power_voltage_areas) power_voltage_areas
#@        set pwr_va_areas [array get power_voltage_areas]
#@     } else {
#@        set pwr_va_areas ""
#@     }
#@     if { $opts(ground_voltage_areas) ne "" } {
#@        upvar $opts(ground_voltage_areas) ground_voltage_areas
#@        set gnd_va_areas [array get ground_voltage_areas]
#@     } else {
#@        set gnd_va_areas ""
#@     }
#@     if { $opts(dsn_core_areas) ne "" } {
#@        upvar $opts(dsn_core_areas) core_areas
#@        set dsn_core_areas [array get core_areas]
#@     } else {
#@        set dsn_core_areas ""
#@     }
#@     if { $opts(hookup_via_settings) ne "" } {
#@        upvar $opts(hookup_via_settings) hookup_masters
#@        set hookup_via_settings [array get hookup_masters]
#@     } else {
#@        set hookup_via_settings ""
#@     }
#@     set m2_rail_width            $opts(m2_rail_width)
#@     set cell_height              $opts(cell_height)
#@     set v0_master                $opts(v0_master)
#@     set v1_master                $opts(v1_master)
#@     set use_xll_grid             $opts(use_xll_grid)
#@     set dsn_y_min                $opts(bndry_y_min)
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     ### If UDM, get tech from UDM cell
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@         return 0
#@     }
#@ 
#@     set fillLayer           "via1" 
#@     if { [regexp {127[123]} $techname] } {
#@        set flowName            "powerhookup72"
#@     } else {
#@        set flowName            "powerhookup"
#@     }
#@     set container_extension "_powerhookup"
#@     
#@     # write uin file
#@     set uinfilename "${cellname}${container_extension}.uin"
#@     # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     set uinfilepath "$uindir/$uinfilename"
#@     
#@     ::dtDfm::powerhookup_writeuin $cellname         $viewname         $techname         $uinfilepath         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $mwlibrary         $write_stm_output         $write_coord_file         $write_def_file_prefix         $dh_bonus_cells_list         $force_hookup_cells_list         $hookup_cell_names_list         $hookup_cell_names_list_xn         $keepin_cells_list         $keepout_cells_list         $keepout_cells_x_space         $keepout_cells_y_space         $use_drawn_kor         $top_level_only_kor         $use_route_kor         $use_fill_kor         $use_global_kor         $drawn_kor_x_space         $drawn_kor_y_space         $powerhookup_grid_count         $powerhookup_empty_area         $powerhookup_cells_area         $powerhookup_avoid_drv         $powerhookup_all_segments         $powerhookup_drv_vias_cells_list         $powerhookup_offset_locations         $power_name         $ground_name         $ground_rail_y_start         $pwr_va_areas         $gnd_va_areas         $dsn_core_areas         $m2_rail_width         $cell_height         $v0_master         $v1_master         $hookup_via_settings         $use_xll_grid         $dsn_y_min
#@ 
#@     if { $only_write_uin || $streamlined } {
#@         return ""
#@     }
#@ 
#@     # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@     set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@     set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@     set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@     set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@     set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@     set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@     set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@     set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@     
#@     set pid [::dtDfm::fill_metal_icv_runflow $cellname                  $flowName                  $container_extension                  0                  $stminputdir                  $uinfilepath                  $icvworkarea                  $icv_options                  $use_lnf_input                  $use_pds                  $launch_script                  $nbpool                  $nbclass                  $nbslot ]
#@     
#@     # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@     # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@     
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set jobInfo ""
#@     ::dtDfm::keylset jobInfo PID           $pid
#@     ::dtDfm::keylset jobInfo CELLNAME      $cellname
#@     ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME      $outputcellname
#@     ::dtDfm::keylset jobInfo VIEWNAME      $viewname
#@     ::dtDfm::keylset jobInfo TECHNAME      $techname
#@     ::dtDfm::keylset jobInfo EXTENSION     $container_extension
#@     ::dtDfm::keylset jobInfo ICVWORKAREA   $icvworkarea
#@     ::dtDfm::keylset jobInfo PROPERTY      $property
#@     ::dtDfm::keylset jobInfo STUBNET       $stubnet
#@     ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@     ::dtDfm::keylset jobInfo RENAME_NETS   $rename_nets
#@     ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@     ::dtDfm::keylset jobInfo CMD_STR       $print_cmd_str
#@     ::dtDfm::keylset jobInfo LAYER         $fillLayer
#@ 
#@     set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@     lappend jobs $jobInfo
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@     
#@     return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::powerhookup_writeuin { cellname                                          viewname                                          techname                                          uinfilepath                                          write_milkyway_output                                          fill_in_cel_view                                          mwoutpath                                          mwlibrary                                          write_stm_output                                          write_coord_file                                          write_def_file_prefix                                          dh_bonus_cells_list                                          force_hookup_cells_list                                          hookup_cell_names_list                                          hookup_cell_names_list_xn                                          keepin_cells_list                                          keepout_cells_list                                          keepout_cells_x_space                                          keepout_cells_y_space                                          use_drawn_kor                                          top_level_only_kor                                          use_route_kor                                          use_fill_kor                                          use_global_kor                                          drawn_kor_x_space                                          drawn_kor_y_space                                          powerhookup_grid_count                                          powerhookup_empty_area                                          powerhookup_cells_area                                          powerhookup_avoid_drv                                          powerhookup_all_segments                                          powerhookup_drv_vias_cells_list                                          powerhookup_offset_locations                                          power_name                                          ground_name                                          ground_rail_y_start                                          {pwr_va_areas ""}                                          {gnd_va_areas ""}                                          {dsn_core_areas ""}                                          m2_rail_width                                          cell_height                                          v0_master                                          v1_master                                          hookup_via_settings                                          use_xll_grid                                          dsn_y_min                                  } {
#@ 
#@     set f [open "$uinfilepath" w]
#@     
#@     if { $techname != "" } {
#@         puts $f "process_name = \"$techname\";"
#@     }
#@     
#@     ::dtDfm::fill_metal_icv_write_output_options_to_uin $f         $write_stm_output         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $cellname         $mwlibrary;
#@ 
#@     set use_p1272_opts 0
#@     if { [regexp {127[123]} $techname] } {
#@        set use_p1272_opts 1
#@        if { $dh_bonus_cells_list ne "" } {
#@           set dh_bonus_option_name "dh_bonus_cells_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $dh_bonus_option_name               $dh_bonus_cells_list;
#@        }
#@ 
#@        if { $force_hookup_cells_list ne "" } {
#@           set force_hookup_option_name "force_hookup_cells_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $force_hookup_option_name               $force_hookup_cells_list;
#@        }
#@ 
#@        if { $hookup_cell_names_list ne "" } {
#@           set hookup_cells_option_name "hookup_cell_names_list"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $hookup_cells_option_name               $hookup_cell_names_list;
#@        }
#@ 
#@        if { $hookup_cell_names_list_xn ne "" } {
#@           set hookup_cells_xn_option_name "hookup_cell_names_list_xn"
#@           ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f               $hookup_cells_xn_option_name               $hookup_cell_names_list_xn;
#@        }
#@     }
#@ 
#@     set cell_list_option_name "keepin_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepin_cells_list;
#@     
#@     set cell_list_option_name "keepout_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepout_cells_list;    
#@ 
#@     puts $f "keepout_cells_x_space    = $keepout_cells_x_space;"
#@     puts $f "keepout_cells_y_space    = $keepout_cells_y_space;"
#@     puts $f "use_drawn_kor            = $use_drawn_kor;"
#@     puts $f "top_level_only_kor       = $top_level_only_kor;"
#@     puts $f "use_route_kor            = $use_route_kor;"
#@     puts $f "use_fill_kor             = $use_fill_kor;"
#@     puts $f "use_global_kor           = $use_global_kor;"
#@     puts $f "drawn_kor_x_space        = $drawn_kor_x_space;"
#@     puts $f "drawn_kor_y_space        = $drawn_kor_y_space;"
#@     puts $f "powerhookup_grid_count   = $powerhookup_grid_count;"
#@     puts $f "powerhookup_empty_area   = $powerhookup_empty_area;"
#@     puts $f "powerhookup_cells_area   = $powerhookup_cells_area;"
#@     puts $f "powerhookup_avoid_drv    = $powerhookup_avoid_drv;"
#@     puts $f "powerhookup_all_segments = $powerhookup_all_segments;"
#@     if { ! $use_p1272_opts } {
#@        puts $f "powerhookup_drv_vias_cells_list = $powerhookup_drv_vias_cells_list;"
#@        puts $f "powerhookup_offset_locations = $powerhookup_offset_locations;"
#@     }
#@     puts $f "write_coord_file         = \"$write_coord_file\";"
#@     if { $use_p1272_opts } {
#@        puts $f "write_def_file           = \"$write_def_file_prefix.def\";"
#@     } else {
#@        puts $f "write_def_file_prefix    = \"$write_def_file_prefix\";"
#@     }
#@ 
#@     puts $f "ground_rail_y_start      = $ground_rail_y_start;"
#@ 
#@     if { $pwr_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $pwr_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "pwr_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "power_name               = \"$power_name\";"
#@     }
#@     if { $gnd_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $gnd_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "gnd_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "ground_name              = \"$ground_name\";"
#@     }
#@ 
#@     if { $dsn_core_areas != "" } {
#@        foreach {int_width core_area} [regsub -all "," $dsn_core_areas " "] {
#@           # reformat core_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $core_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $core_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $core_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "core_area\[$int_width\] = {[join $fmt_area {,}]};"
#@        }
#@     }
#@ 
#@     if { $m2_rail_width > 0 } {
#@        puts $f "m2_rail_width            = $m2_rail_width;"
#@     }
#@     if { $cell_height > 0 } {
#@        puts $f "cell_height              = $cell_height;"
#@     }
#@     if { $v0_master != "" } {
#@        puts $f "v0_master                = \"$v0_master\";"
#@     }
#@     if { $v1_master != "" } {
#@        puts $f "v1_master                = \"$v1_master\";"
#@     }
#@ 
#@     if { $use_p1272_opts && ($hookup_via_settings != "") } {
#@        # hookup_via_settings are an array of array settings 
#@        # initial names: bndry_gnd_via_master bndry_gnd_via_w bndry_gnd_via_h
#@        #                bndry_pwr_via_master bndry_pwr_via_w bndry_pwr_via_h
#@        #                polyg_pwr_via_master polyg_pwr_via_w polyg_pwr_via_h
#@        # each set is then a string identifier for the arrays
#@        # via_master values are string, w & h values are double
#@        array set legacy_via_setup $hookup_via_settings
#@        foreach hookup_type {bndry_gnd_via bndry_pwr_via polyg_pwr} {
#@           foreach param {master w h} is_real_param {0 1 1} {
#@              set hookup_setting "${hookup_type}_${param}"
#@              if { ! [info exists legacy_via_setup($hookup_setting)] } {
#@                 continue
#@              }
#@              unset -nocomplain hookup_vias
#@              array set hookup_vias $legacy_via_setup($hookup_setting)
#@              foreach key [array names hookup_vias] {
#@                 set value $hookup_vias($key)
#@                 if { $value eq "" } {
#@                    continue
#@                 }
#@                 if { $is_real_param } {
#@                    puts $f "${hookup_setting}\[\"${key}\"\] = $value ;"
#@                 } else {
#@                    puts $f "${hookup_setting}\[\"${key}\"\] = \"$value\";"
#@                 }
#@              }
#@           }
#@        }
#@     }
#@ 
#@     puts $f "use_xll_grid             = $use_xll_grid;"
#@     puts $f "dsn_y_min                = $dsn_y_min;"
#@ 
#@     close $f
#@ }
#@ 
#@ 
#@ # Functions related to ::dtDfm::V0_328_vss_fixing
#@ # JEH 2014-01-31
#@ CmdSpec ::dtDfm::V0_328_vss_fixing {
#@     -help "::dtDfm::V0_328_vss_fixing"
#@     -opts {
#@         {-optname     process_name
#@             -type     string
#@             -default  "p1273.1"
#@             -help     "process name"
#@         }
#@         {-optname     keepin_cells_list
#@             -type     string
#@             -default  "*"
#@             -help     "only allow fixing in these cells"
#@         }
#@         {-optname     write_def_file
#@             -type     string
#@             -default  ""
#@             -help     "Write vias placements to DEF file"
#@         }
#@         {-optname     power_name
#@             -type     string
#@             -default  "vcc"
#@             -help     "Name of power rail (default = vcc)"
#@         }
#@         {-optname     ground_name
#@             -type     string
#@             -default  "vss"
#@             -help     "Name of ground rail (default = vss)"
#@         }
#@         {-optname     power_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for power nets"
#@         }
#@         {-optname     ground_voltage_areas
#@             -type     string
#@             -default  ""
#@             -help     "Reference array name containing voltage_area key=name and value=points_of_area for ground nets"
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # JEH 2014-01-31
#@ proc ::dtDfm::V0_328_vss_fixing {args} {
#@     global env
#@     # get/set variables
#@     parseOptions $args
#@     set keepin_cells_list        $opts(keepin_cells_list)
#@     set write_def_file           $opts(write_def_file)
#@     set power_name               $opts(power_name)
#@     set ground_name              $opts(ground_name)
#@     if { $opts(power_voltage_areas) ne "" } {
#@        upvar $opts(power_voltage_areas) power_voltage_areas
#@        set pwr_va_areas [array get power_voltage_areas]
#@     } else {
#@        set pwr_va_areas ""
#@     }
#@     if { $opts(ground_voltage_areas) ne "" } {
#@        upvar $opts(ground_voltage_areas) ground_voltage_areas
#@        set gnd_va_areas [array get ground_voltage_areas]
#@     } else {
#@        set gnd_va_areas ""
#@     }
#@ 
#@     set cellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data CELLNAME]
#@     set outputcellname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data OUTPUT_CELL_NAME]
#@     set viewname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data VIEWNAME]
#@     set temp_techname [::dtDfm::keylget ::dtDfm::fill_metal_icv_data TECHNAME]
#@     set initialized [::dtDfm::keylget ::dtDfm::fill_metal_icv_data INITIALIZED]
#@     set write_coord_file ""
#@     set write_milkyway_output  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINMW]
#@     set write_stm_output [::dtDfm::keylget ::dtDfm::fill_metal_icv_data WRITE_STM_OUTPUT ]
#@ 
#@     set fill_in_cel_view [::dtDfm::keylget ::dtDfm::fill_metal_icv_data FILLINCELVIEW]
#@     set mwoutpath [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWOUTPATH]
#@     set mwlibrary [::dtDfm::keylget ::dtDfm::fill_metal_icv_data MWLIBRARY]
#@     set uindir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data UINDIR]
#@     set only_write_uin [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ONLYWRITEUIN]
#@     set streamlined [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STREAMLINED]
#@ 
#@     set property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data PROPERTY]
#@     set stub_property [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUB_PROPERTY]
#@     set rename_nets [::dtDfm::keylget ::dtDfm::fill_metal_icv_data RENAME_NETS]
#@     # set netname_for_untexted_objects [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NETNAME_FOR_UNTEXTED_OBJECTS]
#@ 
#@     if { $initialized == 0 } {
#@       ::dtDfm::fill_metal_icv_print_error "Exiting because ::dtDfm::fill_metal_icv_init was not run successfully"
#@       return 0
#@     }
#@ 
#@     # set print_cmd_str [::cist::get_cmd_str]
#@     set print_cmd_str [info level [info level]]
#@     ::dtDfm::fill_metal_icv_print_info $print_cmd_str
#@ 
#@     if {$cellname == ""} {
#@         return 0
#@     }
#@ 
#@     set result [regexp {^p(.+)} $temp_techname fullstring technum]
#@     if { $result == 1 } {
#@       set techname $technum
#@     } else {
#@       set techname $temp_techname
#@     }
#@ 
#@     ### If UDM, get tech from UDM cell
#@     if { [::dtDfm::fill_metal_icv_checkcell $cellname $viewname] == 0 } {
#@         return 0
#@     }
#@ 
#@     set fillLayer           "via0"
#@     set flowName            "v0_328vssFix"
#@     set container_extension "_v0_328vssFix"
#@ 
#@     # write uin file
#@     set uinfilename "${cellname}${container_extension}.uin"
#@     # set uindir "$env(WORK_AREA_ROOT_DIR)/pds/uins"
#@     set uinfilepath "$uindir/$uinfilename"
#@ 
#@     ::dtDfm::V0_328_vss_fixing_writeuin $cellname         $viewname         $techname         $uinfilepath         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $mwlibrary         $write_stm_output         $write_coord_file         $write_def_file         $keepin_cells_list         $power_name         $ground_name         $pwr_va_areas         $gnd_va_areas
#@ 
#@     if { $only_write_uin || $streamlined } {
#@         return ""
#@     }
#@ 
#@     # set icvworkarea "$env(PDSWORKROOT)/$env(USER).${cellname}.${flowName}.iss"
#@     set icvtopworkarea [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVTOPWORKAREA]
#@     set icvworkarea "$icvtopworkarea/$env(USER).${cellname}.${flowName}.iss"
#@     set icv_options [::dtDfm::keylget ::dtDfm::fill_metal_icv_data ICVOPTIONS]
#@     set use_lnf_input [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_LNF_INPUT]
#@     set use_pds [::dtDfm::keylget ::dtDfm::fill_metal_icv_data USE_PDS]
#@     set nbpool  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBPOOL]
#@     set nbclass [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBCLASS]
#@     set nbslot  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data NBSLOT]
#@     set stminputdir [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STMINPUTDIR]
#@     set launch_script  [::dtDfm::keylget ::dtDfm::fill_metal_icv_data LAUNCH_SCRIPT]
#@ 
#@     set pid [::dtDfm::fill_metal_icv_runflow $cellname                  $flowName                  $container_extension                  0                  $stminputdir                  $uinfilepath                  $icvworkarea                  $icv_options                  $use_lnf_input                  $use_pds                  $launch_script                  $nbpool                  $nbclass                  $nbslot ]
#@ 
#@     # return [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope ]
#@     # set jobInfo [list $pid $cellname $viewname $techname $container_extension $fillLayer $icvworkarea $propname $propvalue $propscope $print_cmd_str ]
#@ 
#@     set stubnet [::dtDfm::keylget ::dtDfm::fill_metal_icv_data STUBNET]
#@     set jobInfo ""
#@     ::dtDfm::keylset jobInfo PID           $pid
#@     ::dtDfm::keylset jobInfo CELLNAME      $cellname
#@     ::dtDfm::keylset jobInfo OUTPUT_CELL_NAME      $outputcellname
#@     ::dtDfm::keylset jobInfo VIEWNAME      $viewname
#@     ::dtDfm::keylset jobInfo TECHNAME      $techname
#@     ::dtDfm::keylset jobInfo EXTENSION     $container_extension
#@     ::dtDfm::keylset jobInfo ICVWORKAREA   $icvworkarea
#@     ::dtDfm::keylset jobInfo PROPERTY      $property
#@     ::dtDfm::keylset jobInfo STUBNET       $stubnet
#@     ::dtDfm::keylset jobInfo STUB_PROPERTY $stub_property
#@     ::dtDfm::keylset jobInfo RENAME_NETS   $rename_nets
#@     # ::dtDfm::keylset jobInfo NETNAME_FOR_UNTEXTED_OBJECTS $netname_for_untexted_objects
#@     ::dtDfm::keylset jobInfo CMD_STR       $print_cmd_str
#@     ::dtDfm::keylset jobInfo LAYER         $fillLayer
#@ 
#@     set jobs [::dtDfm::keylget ::dtDfm::fill_metal_icv_data JOBS]
#@     lappend jobs $jobInfo
#@     ::dtDfm::keylset ::dtDfm::fill_metal_icv_data JOBS $jobs
#@ 
#@     return $jobInfo
#@ }
#@ 
#@ proc ::dtDfm::V0_328_vss_fixing_writeuin { cellname                                          viewname                                          techname                                          uinfilepath                                          write_milkyway_output                                          fill_in_cel_view                                          mwoutpath                                          mwlibrary                                          write_stm_output                                          write_coord_file                                          write_def_file                                          keepin_cells_list                                          power_name                                          ground_name                                          {pwr_va_areas ""}                                          {gnd_va_areas ""}                                  } {
#@ 
#@     set f [open "$uinfilepath" w]
#@ 
#@     if { $techname != "" } {
#@         puts $f "process_name = \"$techname\";"
#@     }
#@ 
#@     ::dtDfm::fill_metal_icv_write_output_options_to_uin $f         $write_stm_output         $write_milkyway_output         $fill_in_cel_view         $mwoutpath         $cellname         $mwlibrary;
#@ 
#@     set cell_list_option_name "keepin_cells_list"
#@     ::dtDfm::fill_metal_icv_write_cells_list_to_uin $f         $cell_list_option_name         $keepin_cells_list;
#@ 
#@     puts $f "write_def_file           = \"$write_def_file\";"
#@ 
#@     if { $pwr_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $pwr_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "pwr_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "power_name               = \"$power_name\";"
#@     }
#@     if { $gnd_va_areas != "" } {
#@        foreach {net_name va_area} [regsub -all "," $gnd_va_areas " "] {
#@           # reformat va_area to separate list elements with commas
#@           set fmt_area {}
#@           if { [string is double -strict [lindex $va_area 0 1]] } {
#@              set fmt_shape {}
#@              foreach coord $va_area {
#@                 lappend fmt_shape "{[join $coord {,}]}"
#@              }
#@              lappend fmt_area "{[join $fmt_shape {,}]}"
#@           } else {
#@              foreach shape $va_area {
#@                 set fmt_shape {}
#@                 foreach coord $shape {
#@                    lappend fmt_shape "{[join $coord {,}]}"
#@                 }
#@                 lappend fmt_area "{[join $fmt_shape {,}]}"
#@              }
#@           }
#@           puts $f "gnd_va_areas\[\"$net_name\"\] = {[join $fmt_area {,}]};"
#@        }
#@     } else {
#@        puts $f "ground_name              = \"$ground_name\";"
#@     }
#@ 
#@     close $f
#@ }
#@ 
#@ if {[info exists env(CDS_ISS_OVRRD)] && [file exists $env(CDS_ISS_OVRRD)/flexfill/templates/via_color_wrapper.tcl]} {
#@     source $env(CDS_ISS_OVRRD)/flexfill/templates/via_color_wrapper.tcl
#@ }
#@ # -- End source /p/fdk/fdk73/builds/pdk733_r1.7/fill/icv/flexfill/templates/dtDfmFillMetalICV.tcl

#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/add_pg_hookup.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_detailroute.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ #Better results seen with smaller iterations
#@ P_msg_info "Running detail route and final DRC clean up"
#@ eval $INTEL_INCR_DETAIL_ROUTE_OPT_CMD
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/incr_detailroute.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/verify_zrt_route.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ if {[info exists INTEL_ZROUTE_FIX_ANTENNA] && $INTEL_ZROUTE_FIX_ANTENNA ==1} {
#@   P_msg_info "Running verify_zrt_route - Antenna check enabled"
#@   verify_zrt_route -antenna true -check_from_frozen_shapes true
#@ } else {
#@   P_msg_info "Running verify_zrt_route - Antenna check disabled"
#@   verify_zrt_route -antenna false -check_from_frozen_shapes true
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/verify_zrt_route.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_route.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ # 2. P_msg_warn
#@ # 3. P_check_cells
#@ # 4. P_check_place_overlap
#@ # 5. P_check_power_ground_nets
#@ 
#@ ##############################################################################
#@ ## Flag overlap cells in the design                                         ##
#@ ##############################################################################
#@ P_check_place_overlap
#@ 
#@ set clk_logic "d04cgc* d04scb* d04cgm* d04scb* d04gbf* d04gin*"
#@ 
#@ ################################################################################
#@ ## Dont_use cells except clock cells                                          ##
#@ ################################################################################
#@ P_msg_info "CHECK_ROUTE.tcl: dont_use cells except clock cells"
#@ set ref_list $dont_use_list
#@ set icc_local_dont_use_list [list ]
#@ 
#@ set clock_cell_min_delay [list ]
#@ foreach {cell_types cell_description} $ref_list {
#@   set icc_local_dont_use_list [concat $icc_local_dont_use_list "${cell_types} "]
#@ }
#@ 
#@ foreach cell $clk_logic {
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $cell]
#@ }
#@ #User may filter out if there is bogus error by removing the refercence cells
#@ #set other_cell [list <d04??????> <d04?????> ]
#@ #foreach cell $other_cell {
#@ #    set icc_local_dont_use_list [lminus $icc_local_dont_use_list $cell]
#@ #}
#@ set clock_cell_min_delay "$INTEL_CTS_CELLS_DEFAULT $INTEL_CTS_CELLS_SIZE $INTEL_CTS_CELLS_DELAY_INSERT $INTEL_CTS_CELL_BOUNDARY $INTEL_DELAY_CELL_LIST d04bfn1* d04inn12*"
#@ set icc_local_dont_use_list [lminus $icc_local_dont_use_list $clock_cell_min_delay]
#@ 
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_cells "d04slc* d04swa00* d04swo00* d04pws* d04pws10* d04sc* d04dly0* d04swi00* d04swb00* d04slg* d04sv*"
#@   set icc_local_dont_use_list [lminus $icc_local_dont_use_list $pm_cells]
#@ }
#@ 
#@ set ref_list $icc_local_dont_use_list
#@ set inst_list [get_cells -hierarchical]
#@ set msg "dont_use cell found in design:"
#@ set flag "err"
#@ P_check_cells $ref_list $inst_list $msg $flag
#@ 
#@ 
#@ ##################################################################################
#@ ## Checking Power Groung pin/net connections. by proc P_check_power_ground_nets ##
#@ ##################################################################################
#@ P_check_power_ground_nets
#@ 
#@ 
#@ ##################################################################################
#@ ## Checking the Max Routing Layer                                               ##
#@ ##################################################################################
#@ P_msg_info "Checking the max routing layer..."
#@ set list_layer_info {}
#@ foreach_in_collection temp_i [get_layers -filter "is_routing_layer==true"] {
#@   set var_layer_number [get_layer_attribute -layer $temp_i layer_number]
#@   set var_layer_name [get_layer_attribute -layer $temp_i name]
#@   set list_layer_info [concat $list_layer_info "$var_layer_number $var_layer_name"]
#@ }
#@ 
#@ set max_routing_layer_number [get_layer_attribute -layer $INTEL_MAX_ROUTING_LAYER layer_number]
#@ foreach {layer_number layer_name} $list_layer_info {
#@   if { $layer_number > $max_routing_layer_number } {
#@     set coll_shape [get_net_shape -filter "owner_net!=$INTEL_MW_GROUND_NET && owner_net!=$INTEL_MW_POWER_NET && layer==$layer_name" -quiet]
#@     if { [sizeof_collection $coll_shape] } {
#@       P_msg_warn "INTEL_MAX_ROUTING_LAYER is set to $INTEL_MAX_ROUTING_LAYER, but $layer_name layer routing exist in the design."
#@     }
#@   }
#@ }
#@ P_msg_info "Done: Checking the max routing layer"
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/dot3/d04/check_route.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ ##############################################################################
#@ 
#@ #####################################
#@ # List of procs used in script
#@ # None
#@ ################################
#@ 
#@ 
#@ ## making the net names case insensitive to avoid false violation from LVS
#@ define_name_rules standard_netnames -case_insensitive -type net
#@ 
#@ if {$synopsys_program_name == "icc_shell" && $INTEL_ECO_TYPE != 0 } {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ } else {
#@ 
#@   if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != ""} {
#@     set change_name_log_file ./logs/${INTEL_STEP_CURR}.change_names.log
#@   } else {
#@     set change_name_log_file ./logs/change_names.log
#@   }
#@ }
#@ 
#@ 
#@ puts "==>INFORMATION: Running default verilog rule , check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules verilog >> $change_name_log_file
#@ 
#@ puts "==>INFORMATION: Running name rule 'standard_netnames_verilog', check log file $change_name_log_file"
#@ change_names -hierarchy -verbose -rules standard_netnames >> $change_name_log_file
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/change_names.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ ##############################################################################
#@ #Script: tool_constraints.tcl
#@ # List of procs used by this tcl
#@ # 1. P_lminus
#@ # 2. P_msg_info
#@ # 3. get_completed_steps
#@ 
#@ # Density screening
#@ #
#@ # set_congestion_options
#@ #       [-max_util value]: Specifies the layer name whose availability is reduced.
#@ #       [-layer name]: Specifies the availability of the routing resource for the layer
#@ #       [-availability value]: Specifies the availability of the routing resource for the layer
#@ #       [-coordinate {X1 Y1 X2 Y2}]: Specifies the lower left and upper right coordinates
#@ #                                    for which the congestion options will apply.
#@ #                                    The numbers are in microns.
#@ # Example: set_congestion_options -max_util 0.5 -coordinate {0 0 2560 155}
#@ 
#@ 
#@ # Soft blockage (0% utilization during initial place, but allows for buffering later)
#@ #
#@ # create_placement_blockage
#@ #       -bbox rectangle: Specifies the coordinates of the bounding box of the blockage.
#@ #                        rectangle  x1 y1 x2 y2
#@ #       -type soft: Specifies the type of blockage to be created as soft.
#@ #                   With a soft blockage, the placer tries not to place standard cells
#@ #                   or hard macros in the specified region but will do so if the congestion
#@ #                   is too high.
#@ #       [-name blockage_name]: Specifies the optional name of the blockage.
#@ #                              If you  specify  a name  for  the blockage,
#@ #                              you can use it later in the flow to get the blockage by name.
#@ # Example: create_placement_blockage -name hot_corner_plcmnt_blkg_1 -bbox {{4066 259.2} {4096 459.2}} -type soft
#@ # Example: create_placement_blockage -name KO_idv4 -bbox { 540.4 1094.56 579.6  1225.28} -type soft
#@ 
#@ 
#@ # Cells inserted during each flow will have a prefix of the flow name. For ex. placement will have "place" prefix
#@ # If Intel flow variables are not defined, then the default prefix will be used
#@ if {[lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0] != ""} {
#@   set_app_var compile_instance_name_prefix [lindex [P_lminus $INTEL_APR_STEPS [get_completed_steps]] 0]
#@ }
#@ 
#@ # Enables congestion removal with the global router
#@ set_app_var placer_enable_enhanced_router true
#@ 
#@ #To prevent side load on output ports
#@ set_isolate_ports -type buffer [filter_collection [all_outputs] "direction=~out"]
#@ 
#@ # Congestion removal effort during coarse placement
#@ set_app_var placer_enable_high_effort_congestion true
#@ 
#@ # Congestion effort during place_opt (default is auto)
#@ # Setting to medium/high, ICC always uses the Zroute global route for congestion-driven placement
#@ set_app_var placer_congestion_effort medium
#@ 
#@ # Prints out Zroute global routing information during congestion-driven placement
#@ set_app_var placer_show_zroutegr_output true
#@ 
#@ # Ensure cells are placed close together for low-utilization blocks
#@ # Recommended setings are somewhere between 0.5 and 0.65
#@ set_app_var placer_max_cell_density_threshold 0.6
#@ 
#@ # Set critical range
#@ set_critical_range $INTEL_CRITICAL_RANGE [get_designs]
#@ 
#@ # Pre-route area and power critical range values
#@ if {[info exists INTEL_AREA_CRITICAL_RANGE] && $INTEL_AREA_CRITICAL_RANGE!="not_set"} {
#@   set_app_var physopt_area_critical_range $INTEL_AREA_CRITICAL_RANGE
#@ }
#@ if {[info exists INTEL_POWER_CRITICAL_RANGE] && $INTEL_POWER_CRITICAL_RANGE != "not_set" } {
#@   set_app_var physopt_power_critical_range $INTEL_POWER_CRITICAL_RANGE
#@ }
#@ 
#@ # Avoid excessive buffering
#@ set_buffer_opt_strategy -effort medium
#@ 
#@ # Set auto high fanout synthesis options
#@ set_ahfs_options     -constant_nets true     -port_map_file outputs/${INTEL_DESIGN_NAME}_ahfs_port_map.txt
#@ 
#@ # Set routing layers
#@ remove_ignored_layers -all
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set min_routing_layer $INTEL_MIN_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set max_routing_layer $INTEL_MAX_ROUTING_LAYER
#@ }
#@ if {[info exists INTEL_STEP_CURR] && $INTEL_STEP_CURR != "" && [info exists INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})] && $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR}) != ""} {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS_OVERRIDE(${INTEL_STEP_CURR})
#@ } else {
#@   set rc_ignore_layer $INTEL_RC_IGNORE_LAYERS
#@ }
#@ P_msg_info "Setting min_routing_layer: $min_routing_layer"
#@ P_msg_info "Setting max_routing_layer: $max_routing_layer"
#@ P_msg_info "Setting rc_ignore_layer:   $rc_ignore_layer"
#@ set_ignored_layers      -min_routing_layer $min_routing_layer     -max_routing_layer $max_routing_layer     -rc_congestion_ignored_layers $rc_ignore_layer
#@ 
#@ 
#@ # Setting default Toggle Rate and Static Probability for power optmization in the absence of SAIF
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   if {[info exists INTEL_SAIF] && $INTEL_SAIF==1} {
#@     P_msg_info "Input saif file will be used for dynamic power optmization"
#@   } else {
#@     P_msg_info "Setting default toggle rate $INTEL_POWER_TR and default static probability $INTEL_POWER_SP for dynamic power optimization"
#@     set_app_var power_default_toggle_rate $INTEL_POWER_TR
#@     set_app_var power_default_static_probability $INTEL_POWER_SP
#@   }
#@ }
#@ 
#@ # Power optimization options (turn on dynamic power opt if INTEL_DYNAMIC_POWER is set to 1)
#@ if {[info exists INTEL_DYNAMIC_POWER] && $INTEL_DYNAMIC_POWER==1} {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement true
#@ } else {
#@   set_optimize_pre_cts_power_options       -merge_clock_gates true       -low_power_placement false
#@ }
#@ 
#@ #Enable DRC on constant nets
#@ set_auto_disable_drc_nets -constant false
#@ 
#@ #Ensure the tool observes max_cap constraints during tie-off optimization
#@ set_app_var physopt_new_fix_constants true
#@ 
#@ # Enable via resistance estimation
#@ set_app_var physopt_enable_via_res_support true
#@ 
#@ # Uses alternate name styles to solve name mismatching issues in read_def
#@ set_app_var def_enable_no_legalize_name true
#@ 
#@ # Set multiple port nets options
#@ #        [-feedthroughs]        (fix feedthroughs)
#@ #        [-outputs]             (fix multiple output port nets)
#@ #        [-buffer_constants]    (buffer constants driving multiple ports)
#@ # Without this option, feedthrough ports can be connected directly to each other
#@ # and create text short error in LVS.
#@ set_fix_multiple_port_nets -feedthroughs -outputs -buffer_constants
#@ 
#@ ################################
#@ # Placement
#@ ################################
#@ # Use Zrouter to drive peroute optimization.
#@ if { $::sh_product_version > {I-2013.12-ICC-SP2} } {
#@   set_place_opt_strategy -consider_routing true
#@ }
#@ 
#@ ####################################
#@ # Setting Delay Calculation Options
#@ ####################################
#@ P_msg_info "Setting Delay Calculation as follows :\n Pre-route : Elmore\n Routed Clock : Arnoldi\n Post-route : Arnoldi"
#@ set_delay_calculation_options -preroute elmore -routed_clock arnoldi -postroute arnoldi
#@ 
#@ ####################################
#@ # CTS
#@ ####################################
#@ # The following are used to force CTS to fix more max_cap drcs.
#@ set         ctdn_enable_ccs_low_cap true
#@ set_app_var cto_enable_drc_fixing   true
#@ set         cts_low_power           false
#@ 
#@ ####################################
#@ # Extraction Options
#@ ####################################
#@ 
#@ if { [lsearch -exact [get_completed_steps] fill] > 0} {
#@   set_extraction_options       -real_metalfill_extraction FLOATING       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ } else {
#@   set_extraction_options       -real_metalfill_extraction none       -max_net_ccap_threshold 0.0001       -min_net_ccap_threshold 0.0001       -max_net_ccap_ratio 0.03       -min_net_ccap_ratio 0.03       -virtual_shield_extraction false
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/tool_constraints.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options.tcl

#@ ##############################################################################
#@ # Script: route_options.tcl
#@ # Description:
#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_info
#@ 
#@ ###################################################
#@ # Set up for hold-fix on all dominate scenarios
#@ ###################################################
#@ if {[info exists INTEL_MCMM] && $INTEL_MCMM == 1} {
#@   foreach scenario [all_active_scenarios] {
#@     current_scenario $scenario
#@     set_fix_hold [all_clocks]
#@     P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@     set min_delay_cells ""
#@     foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@       set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@     }
#@     if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@       set_prefer -min $min_delay_cells
#@       set_fix_hold_options -default
#@       set_fix_hold_options -preferred_buffer
#@     }
#@   }
#@   current_scenario $INTEL_MCMM_SCENARIO_DEFAULT
#@ } else {
#@   set_fix_hold [all_clocks]
#@   P_msg_info "Removing dont_use attributes on hold-buffers and inverters"
#@   set min_delay_cells ""
#@   foreach delay_cell $INTEL_DELAY_CELL_LIST {
#@     set min_delay_cells [add_to_collection $min_delay_cells [get_lib_cells "*/$delay_cell"]]
#@   }
#@   if { [info exists min_delay_cells] == 1 && $min_delay_cells != "" } {
#@     set_prefer -min $min_delay_cells
#@     set_fix_hold_options -default
#@     set_fix_hold_options -preferred_buffer
#@   }
#@ }
#@ 
#@ # Route-opt strategy - this setting is non-persistent
#@ P_msg_info "Setting route_opt strategy"
#@ set_route_opt_strategy     -fix_hold_mode route_base     -search_repair_loops 10     -eco_route_search_repair_loops 10
#@ 
#@ # SI Strategy
#@ # Set SI options to enable the zroute crosstalk reduction and fix violations
#@ P_msg_info "Setting SI parameters"
#@ set_si_options     -route_xtalk_prevention true     -route_xtalk_prevention_threshold 0.25     -timing_window true     -delta_delay true     -min_delta_delay true     -max_transition_mode normal_slew     -analysis_effort medium     -reselect true
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ ##############################################################################
#@ # Script: route_options_drc.tcl
#@ # Description: Sets Z-Route options to achieve DRV convergence
#@ ##############################################################################
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Common Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_common_options -default true
#@ 
#@ # specifies the routing clock topology - normal routing of clock nets(default : normal)
#@ set_route_zrt_common_options -clock_topology normal
#@ 
#@ #switch forces the router to only allow a single connection to be made to any cell pin
#@ set_route_zrt_common_options -single_connection_to_pins all_pins
#@ 
#@ # control strength of min layer constraint
#@ set_route_zrt_common_options -global_min_layer_mode allow_pin_connection
#@ set_route_zrt_common_options -net_min_layer_mode soft
#@ 
#@ # control strength of max layer constraint
#@ set_route_zrt_common_options -global_max_layer_mode hard
#@ set_route_zrt_common_options -net_max_layer_mode hard
#@ 
#@ 
#@ # amount of information in logfile - range 0 1 2 (default : 0)
#@ set_route_zrt_common_options -verbose_level 1
#@ 
#@ # no documentation on this switch
#@ set_route_zrt_common_options -connect_tie_off true
#@ 
#@ # Ensures route connections are made within the pins
#@ # If connections need to be made to ends of pins this should not be set
#@ #set_route_zrt_common_options -connect_within_pins_by_layer_name {{m1 via_standard_cell_pins}}
#@ 
#@ # control whether or not to rotate the default vias
#@ set_route_zrt_common_options -rotate_default_vias false
#@ 
#@ # control reading in shapes on metal blockage layer
#@ set_route_zrt_common_options -read_user_metal_blockage_layer true
#@ 
#@ # set route_m1ExtraCost 20
#@ #set_route_zrt_common_options -extra_preferred_direction_wire_cost_multiplier_by_layer_name {{m1 20}}
#@ 
#@ # mark clock tree nets as minor-change only (default : true)
#@ set_route_zrt_common_options -mark_clock_nets_minor_change true
#@ 
#@ # reroute clock net shapes  (default : false)
#@ set_route_zrt_common_options -reroute_clock_shapes false
#@ 
#@ # reroute user created shapes (default : false)
#@ set_route_zrt_common_options -reroute_user_shapes false
#@ 
#@ # Redundant via insertion
#@ if {[info exists INTEL_ZROUTE_VIA_DBL] && $INTEL_ZROUTE_VIA_DBL ==1} {
#@   ## Setting this option prior to routing, starts the via doubling,
#@   ## without the need for the standalone command
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion medium
#@ } else {
#@   set_route_zrt_common_options -post_detail_route_redundant_via_insertion off
#@ }
#@ 
#@ # Enable RC driven layer assignment
#@ if {[info exists INTEL_LAYER_PROMOTION] && $INTEL_LAYER_PROMOTION == 1} {
#@   set_route_zrt_common_options -rc_driven_setup_effort_level high
#@ }
#@ 
#@ # Enable reshielding of modified nets
#@ if {[info exists INTEL_ENABLE_CLOCK_NDR] && $INTEL_ENABLE_CLOCK_NDR} {
#@   set_route_zrt_common_options -reshield_modified_nets reshield
#@ }
#@ 
#@ ###################################################
#@ #ZRT: Global Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_global_options -default true
#@ 
#@ # enables (true) or disables (false) timing-driven global routing (default : false)
#@ set_route_zrt_global_options -timing_driven true
#@ 
#@ # option -macro_corner_track_utilization limits the utilization of tracks
#@ # available in the gcells near a macro corner to a specified  percentage.
#@ # This  variable is used to control the accessibility of pins and conges-
#@ # tion at the macro corners. By default, the router uses 100  percent  of
#@ # available tracks in the macro boundary width.
#@ set_route_zrt_global_options -macro_corner_track_utilization 95
#@ 
#@ ### performs global routing using effort level (low,medium,high) - tool defualt medium
#@ set_route_zrt_global_options -effort medium
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Track Assignment Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_track_options -default true
#@ 
#@ # Enables  (true)  or disables (false) timing-driven track assign (default : false)
#@ set_route_zrt_track_options -timing_driven true
#@ 
#@ 
#@ ###################################################
#@ #ZRT: Detail Route Options
#@ ###################################################
#@ # Set the tool defaults
#@ set_route_zrt_detail_options -default true
#@ 
#@ # Initially turn off antenna (if INTEL_ZROUTE_FIX_ANTENNA is set, fix antenna later)
#@ set_route_zrt_detail_options -antenna false
#@ 
#@ # DRC convergence effort level (default : medium)
#@ set_route_zrt_detail_options -drc_convergence_effort_level medium
#@ 
#@ # controls whether the router ignores specific design rule
#@ # The setting says "DO NOT" ignore same_net_metal_space DRV's
#@ set_route_zrt_detail_options -ignore_drc {{same_net_metal_space false}}
#@ 
#@ # specifies whether variable routing rule spacing is ignored against blockages
#@ set_route_zrt_common_options -ignore_var_spacing_to_blockage false
#@ 
#@ # specifies whether variable routing rule spacing is ignored against p/g nets
#@ set_route_zrt_common_options -ignore_var_spacing_to_pg true
#@ 
#@ # specifies whether timing-driven routing is enabled (default : false)
#@ set_route_zrt_detail_options -timing_driven true
#@ 
#@ # Ensure that there is no illegal tapering from NDR width to default width
#@ #set_route_zrt_detail_options -use_wide_wire_to_input_pin true -use_wide_wire_to_output_pin true
#@ 
#@ ## Set this to reduce the initial amount of vias.  The default tool setting is low.
#@ set_route_zrt_detail_options -optimize_wire_via_effort_level medium
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/route_options_drc.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/adr.tcl

#@ ##############################################################################
#@ # Description: This TCL procedure will use the ICC ADR flow using the
#@ #              signoff_autofix_drc ICC function to use a custom ICValidator
#@ #              runset to identify M1, RMSR and other DRC violations, and
#@ #              have ICC route work to fix the ICV based violations.  Uses
#@ #              INTEL_ADR_RUNSET_FILE - pointer to icv runset flow name
#@ #              INTEL_ADR_CONFIG_FILE - pointer to config file to tell which ICV violations to work on
#@ #              INTEL_ADR_USER_DEF_OPT - A variable to specify ICV command line settings
#@ ##########################################################################
#@ 
#@ ###################################################
#@ # Source ICV Fill procedures
#@ ###################################################
#@ source $env(INTEL_ASIC)/asicflows/synopsys/fill/fill_icv_procs.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/fill_icv_procs.tcl

#@ 
#@ 
#@ source $env(INTEL_ASIC)/asicflows/synopsys/fill/track2uin.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/track2uin.tcl

#@ #TCL scipt to convert track plan data structure to uin
#@ #
#@ global INTEL_ASIC
#@ source $env(INTEL_ASIC)/asicflows/synopsys/fill/gen_trackplan.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/gen_trackplan.tcl

#@ #TCL script to extract trackplan info from set_wiretracks.tcl
#@ #set_wiretrack.tcl -> $trackplan, $ndrtrackplan
#@ #$trackplan -> $offsetPeriodDict, $gridPatternDict
#@ #$ndrtrackplan -> $ndrOffsetPeriodDict, $ndrGridPatternDict
#@ 
#@ global fdk_lib
#@ global INTEL_ASIC
#@ global INTEL_DFM_RELEASE_DIR
#@ #The set_wiretracks.tcl path is found from the ICC shell procedure P_source_if_exists. When running outside ICC shell the path to set_wiretracks.tcl has to be set manually
#@ redirect -variable infile_name {P_source_if_exists -display set_wiretracks.tcl}
#@ set infile_name [lindex $infile_name 0]
#@ set lib [file tail [file dirname $infile_name]]
#@ #set infile [open "$env(INTEL_ASIC)/asicflows/synopsys/apr/dot6/$lib/set_wiretracks.tcl" r]
#@ set infile [open $infile_name r]
#@ set file_buffer [read $infile]
#@ close $infile
#@ 
#@ set dict_name_regexp {remove_track -layer ([a-zA-Z][0-9]+)}
#@ set dict_values_regexp {.*layer ([a-zA-Z][0-9]+).*coord (\d+\.\d+).*space (\d+\.\d+).*width (\d+\.\d+)}
#@ set dict_ndr_name_regexp {INTEL_ENABLE_CLOCK_NDR}
#@ set data [split $file_buffer "\n"]
#@ 
#@ set colorDict ${lib}ColorDict
#@ 
#@ ##Color values for M0,2,3,4 tracks##{{{
#@ dict set d04ColorDict m0 odd "B"
#@ dict set d04ColorDict m0 even "C"
#@ dict set d04ColorDict m2 odd "C"
#@ dict set d04ColorDict m2 even "B"
#@ dict set d04ColorDict m3 odd "C"
#@ dict set d04ColorDict m3 even "B"
#@ dict set d04ColorDict m4 odd "C"
#@ dict set d04ColorDict m4 even "B"
#@ ##
#@ dict set d04_tp1ColorDict m0 odd "B"
#@ dict set d04_tp1ColorDict m0 even "C"
#@ dict set d04_tp1ColorDict m2 odd "C"
#@ dict set d04_tp1ColorDict m2 even "B"
#@ dict set d04_tp1ColorDict m3 odd "C"
#@ dict set d04_tp1ColorDict m3 even "B"
#@ dict set d04_tp1ColorDict m4 odd "C"
#@ dict set d04_tp1ColorDict m4 even "B"
#@ ##
#@ dict set df0ColorDict m0 odd "C"
#@ dict set df0ColorDict m0 even "B"
#@ dict set df0ColorDict m2 odd "B"
#@ dict set df0ColorDict m2 even "C"
#@ dict set df0ColorDict m3 odd "B"
#@ dict set df0ColorDict m3 even "C"
#@ dict set df0ColorDict m4 odd "B"
#@ dict set df0ColorDict m4 even "C"
#@ ##Color values for M0,2,3,4 tracks##}}}
#@ 
#@ ##Read File and define trackplan and ndrtrackplan dict##{{{
#@ set gridPatternDict [dict create]
#@ set ndrGridPatternDict [dict create]
#@ set ndrOffsetPeriodDict [dict create]
#@ set ndrtrackplan [dict create]
#@ set offsetPeriodDict [dict create]
#@ set trackplan [dict create]
#@ 
#@ foreach line $data {
#@     if {[regexp $dict_name_regexp $line match match_layer]} {
#@ 	set dict_key 1
#@ 	set tp_flag 1
#@ 	set ndrtp_flag 0
#@     }
#@     if {[regexp $dict_ndr_name_regexp $line]} {
#@ 	set dict_ndr_key 1
#@ 	set ndrtp_flag 1
#@ 	set tp_flag 0
#@ 	set prev_dict_layer_flag 1
#@ 	set prev_dict_layer "defined"
#@     }
#@ 
#@     if {[regexp $dict_values_regexp $line match dict_layer dict_coord dict_space dict_width]} {
#@ 	if {$tp_flag == 1 && $ndrtp_flag == 0} {
#@ 	    if {$dict_layer eq $match_layer} {
#@ 		dict set trackplan $dict_layer $dict_key coord $dict_coord
#@ 		dict set trackplan $dict_layer $dict_key space $dict_space
#@ 		dict set trackplan $dict_layer $dict_key width $dict_width
#@ 		incr dict_key
#@ 	    } else {
#@ 		puts "Error - layer names do not match $dict_layer $match_layer"
#@ 		exit 1
#@ 	    }
#@ 	} elseif {$ndrtp_flag == 1 && $tp_flag == 0 } {
#@ 	    if { $dict_layer ne $prev_dict_layer } {
#@ 		set prev_dict_layer $dict_layer
#@ 		set dict_ndr_key 1
#@ 	    }
#@ 		dict set ndrtrackplan $dict_layer $dict_ndr_key coord $dict_coord
#@ 		dict set ndrtrackplan $dict_layer $dict_ndr_key space $dict_space
#@ 		dict set ndrtrackplan $dict_layer $dict_ndr_key width $dict_width
#@ 		incr dict_ndr_key
#@ 			    
#@ 	} else {
#@ 		puts "Error No default or ndr track-plan found"
#@ 		exit 1
#@ 	    }
#@     }
#@ }
#@ ##Read File and define trackplan and ndrtrackplan dict##}}}
#@ 
#@ ##Convert trackplan dict to gridPatternDict and offsetPeriodDict##{{{
#@ foreach {metal track} $trackplan {
#@     dict for {track_no csw} $track {
#@ 	dict with csw {
#@ 	     if {$track_no == 1} {
#@ 		set uin_space 0
#@ 		set uin_width $width
#@ 		set uin_offset [format "%.3f" [expr $coord - $width/2]]
#@ 		set uin_period $space
#@ 		dict set offsetPeriodDict $metal offset $uin_offset
#@ 		dict set offsetPeriodDict $metal period $uin_period
#@ 
#@ 	    } else {
#@ 		set prev_coord [dict get $trackplan $metal [expr $track_no - 1] coord]
#@ 		set prev_width [dict get $trackplan $metal [expr $track_no - 1] width]
#@ 		set uin_space [format "%.3f" [expr $coord - $prev_coord - ($width/2.0 + $prev_width/2.0) ]]
#@ 		set uin_width $width
#@ 	    }
#@ 	    
#@ 	    dict set gridPatternDict $metal $track_no space $uin_space
#@ 	    dict set gridPatternDict $metal $track_no width $uin_width
#@ 	    dict set gridPatternDict $metal $track_no netName floatiss_
#@ 	    if {$track_no % 2} {
#@ 		if {[dict exists [subst $$colorDict] $metal odd]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal odd]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    } else {
#@ 		if {[dict exists [subst $$colorDict] $metal even]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal even]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@ }
#@ ##Convert trackplan dict to gridPatternDict and offsetPeriodDict##}}}
#@ 
#@ ##Convert ndrtrackplan dict to ndrGridPatternDict and ndrOffsetPeriodDict##{{{
#@ foreach {metal track} $ndrtrackplan {
#@     dict for {track_no csw} $track {
#@ 	dict with csw {
#@ 	     if {$track_no == 1} {
#@ 		set uin_space 0
#@ 		set uin_width $width
#@ 		set uin_offset [format "%.3f" [expr $coord - $width/2]]
#@ 		set uin_period $space
#@ 		dict set ndrOffsetPeriodDict $metal offset $uin_offset
#@ 		dict set ndrOffsetPeriodDict $metal period $uin_period
#@ 
#@ 	    } else {
#@ 		set prev_coord [dict get $ndrtrackplan $metal [expr $track_no - 1] coord]
#@ 		set prev_width [dict get $ndrtrackplan $metal [expr $track_no - 1] width]
#@ 		set uin_space [format "%.3f" [expr $coord - $prev_coord - ($width/2.0 + $prev_width/2.0) ]]
#@ 		set uin_width $width
#@ 	    }
#@ 
#@ 	    dict set ndrGridPatternDict $metal $track_no space $uin_space
#@ 	    dict set ndrGridPatternDict $metal $track_no width $uin_width
#@ 	    dict set ndrGridPatternDict $metal $track_no netName floatiss_
#@ 	    if {$track_no % 2} {
#@ 		if {[dict exists [subst $$colorDict] $metal odd]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal odd]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    } else {
#@ 		if {[dict exists [subst $$colorDict] $metal even]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal even]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@ }
#@ ##Convert ndrtrackplan dict to ndrGridPatternDict and ndrOffsetPeriodDict##}}}
#@ 
#@ ##Repeat or delete track##{{{
#@ #Pseudo Code
#@ #if [period  - spaceWidthSum] < 0  {
#@ #   Remove last track
#@ #   }
#@ #
#@ #Check again
#@ #if period - spaceWidthSum  > 0 {  
#@ #   If  Check for first and last track to be of same color {
#@ #       Y : Repeat tracks (M0)
#@ #   } else {
#@ #       N: Good
#@ #   }
#@ #   } else {
#@ #      Error
#@ #   }
#@ 
#@ #For all colored layers min tracks is 2. if 1 then add same track with diff color and change period*2 accordingly
#@ foreach {metal track} $gridPatternDict {
#@     set spaceWidthSum 0
#@     set tracknoArray [list]
#@     set spaceArray [list]
#@     set colorArray [list]
#@     set widthArray [list]
#@     dict for {track_no csw} $track {
#@ 	dict with csw {
#@ 	    lappend spaceArray $space
#@ 	    lappend colorArray $color
#@ 	    lappend widthArray $width
#@ 	    set spaceWidthSum [format "%.3f" [expr $spaceWidthSum + $space + $width]]
#@ 	}
#@ 	#puts "-D- $metal $spaceWidthSum"
#@ 	lappend tracknoArray $track_no
#@     }
#@     #puts "Color array $colorArray"
#@     set period [dict get $offsetPeriodDict $metal period]
#@     if {$spaceWidthSum > $period} {
#@ 	#puts "deleting [lindex $tracknoArray end]"
#@ 	dict unset gridPatternDict $metal [lindex $tracknoArray end] 
#@ 	set spaceWidthSum [expr $spaceWidthSum - [lindex $spaceArray end] - [lindex $widthArray end]]
#@ 	set spaceArray [lreplace $spaceArray end end]
#@ 	set colorArray [lreplace $colorArray end end]
#@ 	set widthArray [lreplace $widthArray end end]
#@ 	set tracknoArray [lreplace $tracknoArray end end]
#@ 	#puts "-D- $metal,Delete tast track"
#@     } elseif {$spaceWidthSum < $period} {
#@ 	if {([lindex $colorArray 0] eq [lindex $colorArray end]) && ([lindex $colorArray 0] ne "") && ([llength $tracknoArray] > 1) } {
#@ 	    dict for {track_no csw} $track {
#@ 		#puts "track_no $track_no"
#@ 		dict with csw {
#@ 		    #puts "adding track $metal [llength $tracknoArray] [dict get $gridPatternDict $metal [llength $tracknoArray] space]"
#@ 		    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] space [dict get $gridPatternDict $metal [llength $tracknoArray] space]
#@ 		    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] width [dict get $gridPatternDict $metal $track_no width]
#@ 		    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] netName [dict get $gridPatternDict $metal $track_no netName]
#@ 		    if {[expr $track_no + [llength $tracknoArray]] % 2} {
#@ 			if {[dict exists [subst $$colorDict] $metal odd]} {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color [dict get [subst $$colorDict] $metal odd]
#@ 			} else {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color ""
#@ 			}
#@ 		    } else {
#@ 			if {[dict exists [subst $$colorDict] $metal even]} {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color [dict get [subst $$colorDict] $metal even]
#@ 			} else {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color ""
#@ 			}
#@ 		    }
#@ 		}
#@ 	    }
#@ 	    dict set offsetPeriodDict $metal period [expr [dict get $offsetPeriodDict $metal period] * 2]
#@ 	    #puts "$metal,$spaceWidthSum,$period,[lindex $colorArray 0],[lindex $colorArray end],Double the period and repeat tracks"
#@ 	} else {
#@ 	    #puts "$metal,No Change"
#@ 	}
#@     } else {
#@         puts "ERROR : $metal,Tried to remove last two tracks, still spaceWidthSum is greater than period"
#@ 	exit 1
#@     }
#@     set spaceWidthSum 0
#@ }
#@ ##Repeat or delete track##}}}
#@ 
#@ #For all colored layers min tracks is 2. if 1 then add same track with diff color and change period*2 accordingly
#@ dict for {metal ov} [subst $$colorDict] {
#@     set tracknoArray [dict keys [dict get $gridPatternDict $metal]]
#@     if {[llength $tracknoArray] == 1} {
#@ 	#puts "$metal,adding 1 more track"
#@ 	dict set gridPatternDict $metal 2 space [format "%.3f" [expr [dict get $offsetPeriodDict $metal period] - [dict get $gridPatternDict $metal 1 width]]]
#@ 	dict set gridPatternDict $metal 2 width [dict get $gridPatternDict $metal 1 width]
#@ 	dict set gridPatternDict $metal 2 netName floatiss_
#@ 	dict set gridPatternDict $metal 2 color [dict get [subst $$colorDict] $metal even]
#@ 	dict set offsetPeriodDict $metal period [expr [dict get $offsetPeriodDict $metal period] * 2]
#@     }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ ##old pseudo code ignore
#@ ##if period - spaceWidthSum < 0 then delete last track
#@ #if > 0 and diff = one of the space then if color of first and last track, change period*2 is same then repeat else OK
#@ #if > 0 and diff is not one of the space then report ERROR
#@ 
#@ #For all colored layers min tracks is 2. if 1 then add same track with diff color and change period*2 accordingly
#@ 
#@ 
#@ #foreach {metal_g track} $gridPatternDict {metal_o op } $offsetPeriodDict {
#@ #    puts "UIN $metal_g :"
#@ #    puts "UIN $metal_o :"
#@ #    dict with op {
#@ #        puts "    offset = $offset"
#@ #        puts "    period = $period"
#@ #    }
#@ #    dict for {track_no csw} $track {
#@ #	dict with csw {
#@ #	    puts "    space: $space"
#@ #	}
#@ #    }
#@ #}
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/gen_trackplan.tcl

#@ set uin_dir [exec pwd]
#@ append uin_dir "/asic_uin/$lib"
#@ file delete -force $uin_dir
#@ file mkdir $uin_dir
#@ set pdk_path "${INTEL_DFM_RELEASE_DIR}/uin/$lib" 
#@ set uin_files [glob -nocomplain -directory $pdk_path *]
#@ foreach ufile $uin_files {
#@     file copy -force $ufile "$uin_dir"
#@ } 
#@ exec chmod -R 755 $uin_dir
#@ set INTEL_DFM_AUTO_UIN_DIR $uin_dir
#@ 
#@ # Procedure to copy the uin config settings from PDK 
#@ # Currently it copies ndr_tp as well. Need to test if ndr_tp calculated from set_wiretracks will work or not
#@ proc getUinSettings { pdk_uin_path metal } {
#@ 	set tp_flag 0
#@ 	set uin_fp [open "$pdk_uin_path/flexuin_fill${metal}.rs" "r"]
#@ 	set rg_flag 0
#@ 	set gp_flag 0
#@ 	set ndr_flag 0
#@ 	set ndrPeriod_flag 0
#@ 	set uinSettings "" 
#@ 	set ndrTp ""
#@ 	set ndrPeriodOffset ""
#@ 	foreach line [split [read $uin_fp] \n ] {
#@ 	    if { [regexp {(grid_pattern.*=.*\{)|(default_tp.*track_pattern.*=)} $line] } {
#@ 		    #puts "setting gp_flag $line $metal"
#@ 		set gp_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { [regexp {region_grids.*=} $line] && ![regexp {//region_grids.*=} $line]} {
#@ 		#puts "  setting rg_flag $line $metal"
#@ 		set rg_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { [regexp {ndr_tp.*track_pattern.*=} $line] } {
#@ 		#puts "    setting ndr_flag $line $metal"
#@ 		set ndr_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { $rg_flag == 1  && [regexp {grid_pattern.*ndr_tp} $line] } {
#@ 		#puts "      setting ndrPeriod_flag $line $metal"
#@ 		set ndrPeriod_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { $gp_flag == 1 || $rg_flag == 1 || $ndr_flag ==1 } {
#@ 		if { [regexp {;} $line] } {
#@ 		    set gp_flag [expr $gp_flag & 0]
#@ 		    set rg_flag [expr $rg_flag & 0]
#@ 		    set ndr_flag [expr $ndr_flag & 0]
#@ 		    set ndrPeriod_flag [expr $ndrPeriod_flag & 0]
#@ 		    continue
#@ 		} elseif { $rg_flag == 1 && [regexp {\},} $line] } {
#@ 		    set ndrPeriod_flag [expr $ndrPeriod_flag & 0]
#@ 		    continue
#@ 		} else {
#@ 		    if {$ndrPeriod_flag == 1 && ([regexp {period} $line] || [regexp {offset} $line])} {
#@ 			append ndrPeriodOffset "$line\n"
#@ 			continue
#@ 		    }
#@ 		    if { $ndr_flag == 1} {
#@ 			append ndrTp "$line\n"
#@ 			continue
#@ 		    }
#@ 		}
#@ 	    } elseif { ![regexp {(^offset.*.;)|(\soffset.*.;)|(^period.*.;)|(\speriod.*.;) } $line ] } {
#@ 		append uinSettings "$line\n"
#@ 	    } 
#@     } 
#@     close $uin_fp
#@     return [list $uinSettings $ndrTp $ndrPeriodOffset]
#@ }
#@ 
#@ foreach {metal_g track_g} $gridPatternDict {
#@     regexp {\w(\d+)} $metal_g match metal_no
#@     set settings [getUinSettings "$pdk_path" $metal_no]
#@     lassign $settings uinSettings ndrTp ndrPeriodOffset
#@     set outfile [open "$uin_dir/flexuin_fill$metal_no.rs" w]
#@     if {[dict exists $ndrGridPatternDict $metal_g]} {  
#@ 	set track_n [dict get $ndrGridPatternDict $metal_g]
#@ 	puts $outfile "default_tp: track_pattern = \{"
#@ 	dict for {track_no csw} $track_g {
#@ 	    dict with csw {
#@ 		puts $outfile "    {$space, $width, \"$color\", \"$netName\"},"
#@ 	    }
#@ 	}
#@ 	puts $outfile "\};"
#@ 	
#@ 	#Copy ndr trackplan from pdk_path uin
#@ 	puts $outfile "ndr_tp1: track_pattern = \{"
#@ 	puts -nonewline $outfile $ndrTp
#@ 	puts $outfile "\};"
#@ 
#@ 	##Write calculated period and offset for default tp if NDR is true
#@ 	puts $outfile "region_grids = \{"
#@ 	puts $outfile "    \{"
#@ 	puts $outfile "        region = CELLBOUNDARY,"
#@ 	puts $outfile "        grid_pattern = default_tp,"
#@ 	puts $outfile "        period = [dict get $offsetPeriodDict $metal_g period],"
#@ 	puts $outfile "        offset = [dict get $offsetPeriodDict $metal_g offset],"
#@ 	puts $outfile "    \},"
#@ 
#@ 	##Copy ndr_tp period and offset from pdk_path uin
#@ 	puts $outfile "#ifdef ENABLE_NDR_UIN"
#@ 	puts $outfile "    \{"
#@ 	puts $outfile "        region = CELLBOUNDARY,"
#@ 	puts $outfile "        grid_pattern = ndr_tp1,"
#@ 	puts -nonewline $outfile $ndrPeriodOffset
#@ 	puts $outfile "     \},"
#@ 
#@ 	## Write calculated period and offset for default tp if NDR is true
#@ 	puts $outfile "    \{"
#@ 	puts $outfile "        region = CELLBOUNDARY,"
#@ 	puts $outfile "        grid_pattern = default_tp,"
#@ 	puts $outfile "        period = [dict get $offsetPeriodDict $metal_g period],"
#@ 	puts $outfile "        offset = [dict get $offsetPeriodDict $metal_g offset],"
#@ 	puts $outfile "     \},"
#@ 	puts $outfile "#endif"
#@ 	puts $outfile "\};"
#@     } else {
#@ 	## Write calculated grid pattern, period and offset for default tp
#@ 	puts $outfile "grid_pattern = \{"
#@ 	dict for {track_no csw} $track_g {
#@ 	    dict with csw {
#@ 		puts $outfile "    {$space, $width, \"$color\", \"$netName\"},"
#@ 	    }
#@ 	}
#@ 	puts $outfile "\};"
#@ 	puts $outfile "offset = [dict get $offsetPeriodDict $metal_g offset];"
#@ 	puts $outfile "period = [dict get $offsetPeriodDict $metal_g period];"
#@     }
#@ 
#@ ## Copy uin config settings from pdk_path uin
#@     puts -nonewline $outfile $uinSettings
#@     close $outfile
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/track2uin.tcl

#@ global INTEL_DFM_AUTO_UIN_DIR 
#@ set INTEL_DFM_UIN_DIR  $INTEL_DFM_AUTO_UIN_DIR 
#@ 
#@ 
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : set_fill_layers 
#@ # Description : This procedure reads the INTEL_MAX_ROUTING_LAYER to set the INTEL_DFM_M*_FILL variables automatically. 
#@ # 		To turn on via fill please set INTEL_DFM_NO_VIA_FILL to false and then run the above procedure. By default there is no via fill.
#@ # 
#@ # Required Variables:
#@ # INTEL_MAX_ROUTING_LAYER
#@ #
#@ 
#@ # Call tracks2uin.tcl and generate the uin folder on the fly locally uin // Creating all track pattern settings. I will add the command to write in the config settings
#@ # set INTEL_DFM_UIN_DIR <local_uin_files_that_was_created>
#@ 
#@ proc set_fill_layers {} {
#@ 	global INTEL_MAX_ROUTING_LAYER
#@ 	global INTEL_DFM_MAX_FILL_LAYER
#@ 	global INTEL_DFM_ZONE_VIA_FILL
#@ 	global INTEL_DFM_NO_VIA_FILL
#@ 	if { [info exists INTEL_DFM_ZONE_VIA_FILL] } {
#@ 		if {$INTEL_DFM_ZONE_VIA_FILL} {
#@ 			set INTEL_DFM_NO_VIA_FILL false
#@ 		}
#@ 	}
#@ 
#@ 	for {set j 0} { $j<=15} { incr j} {
#@ 		global INTEL_DFM_M$j\_FILL
#@ 		global INTEL_DFM_V$j\_FILL
#@ 	}
#@ 	global INTEL_DFM_V0PAXFILL
#@ 	if {![info exists INTEL_DFM_V0PAXFILL]} {
#@ 		set INTEL_DFM_V0PAXFILL true
#@ 	}
#@ 	if { ![info exists INTEL_DFM_MAX_FILL_LAYER] } {
#@ 		set INTEL_DFM_MAX_FILL_LAYER $INTEL_MAX_ROUTING_LAYER
#@ 	}
#@ 	  regsub -all {m} $INTEL_DFM_MAX_FILL_LAYER {} maxlayer
#@ 	  puts $maxlayer
#@ 
#@ 	for {set i 0} { $i<=12 } { incr i} {
#@ 		if {$i <= $maxlayer} {
#@ 		set INTEL_DFM_M$i\_FILL true
#@ 		} else {
#@ 			if {[info exists INTEL_DFM_M$i\_FILL]} {
#@ 				unset INTEL_DFM_M$i\_FILL
#@ 			}
#@ 		}
#@ 		if { $i<$maxlayer } {
#@ 			if { [info exists INTEL_DFM_NO_VIA_FILL] } {
#@ 				if {!$INTEL_DFM_NO_VIA_FILL} {
#@ 					set INTEL_DFM_V$i\_FILL true
#@ 				}
#@ 			}
#@ 		} else {
#@ 			if {[info exists INTEL_DFM_V$i\_FILL]} {
#@ 				unset INTEL_DFM_V$i\_FILL
#@ 			}
#@ 		}
#@ 	}
#@ }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : apr_write_layout_file 
#@ # Description : A function to write out gds/oas files
#@ #               apr_write_layout_file -help for all switches and descriptions.
#@ #
#@ proc apr_write_layout_file args {
#@ 	set proc_name apr_write_layout_file
#@ 	#Define proc vars
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_GDS_OUT_LAYER_MAP
#@ 	lappend proc_globals INTEL_DESIGN_NAME
#@ 
#@ 	foreach global_var $proc_globals {
#@ 	global $global_var
#@ 	}
#@ 
#@ 	set INTEL_MAX_NAME_LENGTH 64
#@ 	set INTEL_COMPRESSION_LEVEL 5
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				#puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 				#puts "hello $ref $ref_mod $val"
#@ 			}
#@ 		}
#@ 	} else {
#@ 		puts "parseOpt package is not loaded, load it before executing $proc_name"
#@ 		error "Errors detected with messages printed above.  Exiting..."
#@ 	}
#@ 
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if { $cell == "not_set" } {
#@ 		set cell $INTEL_DESIGN_NAME
#@ 	}
#@ 
#@ 	if { $output_file == "not_set" } {
#@ 		set output_file "[pwd]/$cell.gds"
#@ 		if { $compress == 1 } {
#@ 			set output_file "[pwd]/$cell.gds.gz"
#@ 		}
#@ 	}
#@ 	if { [regexp {^/} $output_file r] == 0 } {
#@ 		set output_file "[pwd]/$output_file"
#@ 	}
#@ 	if { $lib == "not_set" } {
#@ 		set lib ""
#@ 	} else {
#@ 		set lib "-lib $lib"
#@ 	}
#@ 
#@ 	## reset the stream options, since it is an additive option command.
#@ 	set_write_stream_options -reset
#@ 
#@ 	if { [regexp -all -inline {gds} $format ] != "" } {
#@ 		set_write_stream_options 		-map_fill_data 		-output_first_same_name_cell 		-skip_global_route_contact 		-contact_prefix X 		-child_depth 1000 		-output_filling fill 		-output_outdated_fill 		-output_pin {text geometry} 		-keep_data_type 		-map_layer $INTEL_GDS_OUT_LAYER_MAP 		-output_instance_name_as_property 112 		-max_name_length $INTEL_MAX_NAME_LENGTH 		-output_net text 		-set_hier_net_name_long 		-set_hier_instance_name_long
#@ 
#@ 		#stream options are additive
#@ 		if { $compress == 1 } {
#@ 			set_write_stream_options -compressed 
#@ 		}
#@ 		if { $net_prop == 1 } {
#@ 			set_write_stream_options -output_net_name_as_property 126
#@ 		}
#@ 		if { $flattenvia == 1 } {
#@ 			set_write_stream_options -flatten_via
#@ 		}
#@ 		eval write_stream $lib -cells ${cell} $output_file
#@ 	}
#@ 
#@ 	#if no merge var, do the normal ICC oasis out, that has bugs , that cannot be read into calibre or icwbev due to property errors
#@ 	if { [regexp -all -inline {oas} $format ] != "" && [info exists INTEL_MERGE_LAYOUT_LIST] == 0} {
#@ 		set_write_stream_options 		-map_fill_data 		-output_first_same_name_cell 		-skip_global_route_contact 		-contact_prefix X 		-child_depth 1000 		-output_filling fill 		-output_outdated_fill 		-output_pin {text geometry} 		-keep_data_type 		-oasis_compression_level $INTEL_COMPRESSION_LEVEL 		-map_layer $INTEL_GDS_OUT_LAYER_MAP 		-output_instance_name_as_property 112 		-max_name_length $INTEL_MAX_NAME_LENGTH 		-output_net text 		-set_hier_net_name_long 		-set_hier_instance_name_long
#@ 
#@ 		if { $net_prop == 1 } {
#@ 			set_write_stream_options -output_net_name_as_property 126
#@ 		}
#@ 		if { $flattenvia == 1 } {
#@ 			set_write_stream_options -flatten_via
#@ 		}
#@ 		eval write_stream -format oasis $lib -cells $cell $output_file
#@ 	}
#@ 
#@ 	#if there is a merge var, and oas format, first write gds, then have calibre translate to oas, to work around ICC bug
#@ 	#The INTEL_MERGE_LAYOUT_LIST can simply be empty, and no merging will be done, and calibre will read in gds and write out oas, 
#@ 	#as a simple translation.
#@ 	if { [regexp -all -inline {oas} $format ] != "" && [info exists INTEL_MERGE_LAYOUT_LIST] == 1} {
#@ 		set_write_stream_options 		-map_fill_data 		-output_first_same_name_cell 		-skip_global_route_contact 		-contact X 		-child_depth 1000 		-output_filling fill 		-output_outdated_fill 		-output_pin {text geometry} 		-keep_data_type 		-map_layer $INTEL_GDS_OUT_LAYER_MAP 		-output_instance_name_as_property 112 		-max_name_length $INTEL_MAX_NAME_LENGTH 		-output_net text 		-set_hier_net_name_long 		-set_hier_instance_name_long
#@ 
#@ 		#stream options are additive
#@ 		if { $compress == 1 } {
#@ 			set_write_stream_options -compressed 
#@ 		}
#@ 		if { $net_prop == 1 } {
#@ 			set_write_stream_options -output_net_name_as_property 126
#@ 		}
#@ 		if { $flattenvia == 1 } {
#@ 			set_write_stream_options -flatten_via
#@ 		}
#@ 		eval write_stream $lib -cells ${cell} $output_file
#@ 	}
#@ 
#@ 	## Calibredrv merge method
#@ 
#@ 
#@ 
#@ 
#@ }
#@ 
#@ 
#@ ####
#@ #### cmdSpec
#@ ####
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec apr_write_layout_file {
#@       -help "apr_write_layout_file - procedure to write gds/oas layout files."
#@       -opt {
#@          {-optname format  -type one_of_string   -values {{gds} {oas}}  -required 1 -help "Specify fill flow to operate on oasis or gds output from MWDB"}
#@          {-optname output_file -type string   -default "not_set" -required 0 -help "Specify the filename of the layout file. "}
#@          {-optname cell         -type string   -default "not_set" -required 0 -help "Specify the mwdb cell for the layout file. It will default to block.gds, where block is the current open cel"}
#@          {-optname lib         -type string   -default "not_set" -required 0 -help "Specify the mwdb lib for the cell to include in the layout file.  It will default to use the current open mwdb library."}
#@          {-optname compress       -type bool   -default 0             -required 0 -help "Specify if gds is to be compressed.  Oasis is compressed by default"}
#@          {-optname net_prop       -type bool   -default 0             -required 0 -help "Specify if the output should have net_prop 126 added."}
#@          {-optname flattenvia     -type bool   -default 0             -required 0 -help "Specify if the vias should be flattened."}
#@       }
#@    }
#@ }
#@ 
#@ 
#@ proc get_icv_list { x } {
#@ set l "{"
#@ foreach i $x {
#@ append l "\"$i\","
#@ 
#@ }
#@ append l "}"
#@ return $l
#@ }
#@ 
#@ proc write_to_file_with_replace {filename searchstring replacestring} {
#@ 	if {[file exists $filename]} {
#@ 		set uinfile [open $filename "r"]
#@ 		#puts $filename
#@ 		#puts $searchstring
#@ 		#puts $replacestring
#@ 		set temp "tmp_uin.rs"
#@ 		set tempuin [open   $temp w]
#@ 		while {[gets $uinfile line]  != -1} {
#@ 			#puts $line
#@ 			regsub "$searchstring" $line "$replacestring" line
#@ 			#puts $line
#@ 			puts $tempuin $line
#@ 		}
#@ 		close $uinfile
#@ 		close $tempuin
#@ 		exec cp $temp $filename
#@ 		exec rm -rf tmp_uin
#@ 	}
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : apr_layer_fill 
#@ # Description : The main function to launch the ICV based fill flow.  See
#@ #               apr_layer_fill -help for all switches and descriptions.
#@ #
#@ #               The flow counts on the following Parameters being set :
#@ #
#@ # Required Parameters :
#@ # INTEL_DFM_UIN_DIR 
#@ # INTEL_DFM_RELEASE_DIR
#@ # INTEL_GDS_OUT_LAYER_MAP
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ # -fill_release_dir  : The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run
#@ # -rundir : Run directory
#@ # -uindir : uin file directory that ICV command points to
#@ # -input_format : Input layout format. gds/oas/milkyway 
#@ # -milkyway_variables : If input_format=milkyway, specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath>} 
#@ 
#@ 
#@ proc apr_layer_fill args {
#@ 	set proc_name apr_layer_fill
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_LOCAL_UIN_PATH
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 	
#@ 	lappend proc_globals INTEL_GDS_OUT_LAYER_MAP
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	
#@ 	global env
#@    
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		} 
#@ 		if { $fill_release_dir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RELEASE_DIR]} {
#@ 				set fill_release_dir $INTEL_DFM_RELEASE_DIR
#@ 			} else {
#@ 				set fill_release_dir $env(INTEL_PDK)/fill/icv/
#@ 			}	    
#@ 		}	    
#@ 		if { $rundir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RUN_DIR]} {
#@ 				set rundir $INTEL_DFM_RUN_DIR
#@ 			} else {
#@ 				set rundir [pwd]
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			
#@ 			if {[info exists INTEL_DFM_LOCAL_UIN_PATH]} {
#@ 				set uindir $INTEL_DFM_LOCAL_UIN_PATH
#@ 			} elseif {[info exists INTEL_DFM_UIN_DIR]} {
#@ 				set uindir  $INTEL_DFM_UIN_DIR
#@ 			} else {	
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04
#@ 			}
#@ 		}
#@ 		if { $input_format!= "not_set"} {
#@ 			set INTEL_DFM_INPUT_FORMAT $input_format
#@ 		} else {
#@ 			unset input_format
#@ 		}
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $input_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 			}	
#@ 		}
#@ 	} else {
#@ 		puts "Warning : parseOpt package is not loaded, load it before executing $proc_name for the flow to accept commandline switches"
#@ 	}
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	#defaults
#@ 	set error_status 0
#@ 	set rundir ${rundir}/${DESIGN_NAME}_icv
#@ 	if { [file exists $rundir] == 0 } {
#@ 		exec mkdir -p ${rundir}
#@ 		exec chmod 750 ${rundir}
#@ 	}   
#@ 	exec cp -r $uindir $rundir
#@ 	set uin_dir_name  [file tail $uindir]
#@ 	set uindir $rundir/$uin_dir_name
#@ 	exec  chmod -R +w  $rundir/
#@ 	# Unsetting the intermediate variable INTEL_DFM_LOCAL_UIN_PATH and removing the duplicate local uin directories
#@ 	if {[info exists INTEL_DFM_LOCAL_UIN_PATH]} {
#@ 		exec rm -rf $INTEL_DFM_LOCAL_UIN_PATH
#@ 		unset INTEL_DFM_LOCAL_UIN_PATH
#@ 	}
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set CELLNAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set CELLNAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	if { [info exists INTEL_DFM_INPUT_FORMAT] } {
#@ 		if { $INTEL_DFM_INPUT_FORMAT == "milkyway" } {
#@ 			set LAYOUT_TYPE "-f Milkyway"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				set libname $INTEL_DFM_MW_LIBNAME
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				set libpath $INTEL_DFM_MW_LIBPATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 			}
#@ 			set LAYOUTPATH "$libname -p $libpath -lf $INTEL_GDS_OUT_LAYER_MAP "
#@ 		} elseif { $INTEL_DFM_INPUT_FORMAT == "gds"} {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.gds
#@ 				set LAYOUT_TYPE "-f GDSII"
#@ 				puts "Streaming out gds"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format gds -output_file $LAYOUTPATH -net_prop
#@ 			} 
#@ 		} else {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 				set LAYOUT_TYPE "-f OASIS"
#@ 				puts "Streaming out oasis"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 			}
#@ 		}
#@ 	} else {
#@ 		if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 			set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 		} else {
#@ 			set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 			puts "Streaming out oasis"
#@ 			apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 		}
#@ 		set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 		set libname [get_attribute [current_mw_lib] name]
#@ 		set LAYOUT_TYPE "-f OASIS"
#@ 	}
#@ 
#@ 	redirect /dev/null {set library_open [current_mw_lib]}
#@ 	if { $library_open != ""} {
#@ 		close_mw_lib    
#@ 	}   
#@ 	if {[info exists  INTEL_DFM_ICV_COMMAND_LINE_OPTIONS]} {
#@ 		set COMMAND_LINE_OPTIONS $INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	}  else {
#@ 		set COMMAND_LINE_OPTIONS "-dp8 -turbo"
#@ 	}  
#@ 	set icv_command "icv -i $LAYOUTPATH -c $CELLNAME $LAYOUT_TYPE $COMMAND_LINE_OPTIONS -I $fill_release_dir/flexfill -I $fill_release_dir/PXL/ -I $uindir $fill_release_dir/flexfill/mfill_streamlined.rs"
#@ 
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	puts "Running ICV fill runsets $rundir"
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	set LAUNCHSCRIPT [open "$rundir/${DESIGN_NAME}_launch.csh" w]
#@ 	set fill_start_time [clock seconds]
#@ 	puts $LAUNCHSCRIPT  "#!/bin/tcsh -f"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_DISABLE_RUNSET_CACHE"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_MW_WRITE_FILL_POLY_AS_RECT 1"
#@ 	puts $LAUNCHSCRIPT "setenv PDSSTM ./"
#@ 	puts $LAUNCHSCRIPT "cd $rundir/"
#@ 	puts $LAUNCHSCRIPT "if ( -d icv_fill ) rm -rf icv_fill/*"
#@ 	puts $LAUNCHSCRIPT "sleep 5"
#@ 	puts $LAUNCHSCRIPT "mkdir -p icv_fill"
#@ 	puts $LAUNCHSCRIPT "cd icv_fill"
#@ 	puts $LAUNCHSCRIPT "$icv_command >& fill.log"
#@ 
#@ 	set curdir [pwd]
#@ 	puts $LAUNCHSCRIPT "cd $curdir"
#@ 	puts $LAUNCHSCRIPT "exit 0"
#@ 	#  set cmd "perl $runsetpath/scripts/run_icv.pl $nbflag -f \"metviafill\" -c $DESIGN_NAME -lay $lay_file $cfg_flag $mw_flag"
#@ 	close $LAUNCHSCRIPT
#@ 	exec chmod +x $rundir/${DESIGN_NAME}_launch.csh
#@ 	set cmd "$rundir/${DESIGN_NAME}_launch.csh"
#@ 	puts "Running: $cmd"
#@ 
#@ 	exec $rundir/${DESIGN_NAME}_launch.csh
#@ 	set elapsed_time [expr [clock seconds] - $fill_start_time]
#@ 	set clock_hours [expr $elapsed_time / 3600]
#@ 	set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ 	set fill_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ 
#@ 	puts ""
#@ 	puts ""
#@ 	puts "ICV Fill job Runtime(hh:mm:ss) $fill_clock_elapsed "
#@ 	puts ""
#@ 	puts ""
#@ 	exec sleep 10
#@ 	if { $library_open != ""} {
#@ 		open_mw_cel -lib $libpath/${libname} $DESIGN_NAME
#@ 	}
#@ }
#@ 
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec apr_layer_fill {
#@    -help "apr_layer_fill - Creates a folder named <block name>_icv. Creates a shell script and executes the ICV command in the shell script."
#@    -opt {
#@       {-optname fill_release_dir	-type string -default "not_set"             -required 0 -help "The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run."}
#@       {-optname rundir 	-type string -default "not_set"             -required 0 -help "Directory where Folder is created and ICV executes."}
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "uin file directory that ICV command points to"}
#@       {-optname input_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Input format for fill flow"}
#@      {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath> }"}
#@       }
#@    }
#@    }
#@ 
#@ ################################################################################
#@ # Procedure   : create_uin_dir 
#@ # Description : This procedure will create the uin dir based on Kit Uin files, Global variables and input arguments. It does the following.
#@ #		Copies INTEL_DFM_UIN_DIR to a folder named d04_uin and reset the INTEL_DFM_UIN_DIR the local directory path.
#@ #		Change the layer switches in the uin file.
#@ #		Set the variables for the fill output database.
#@ #		Set the keepout cell list based on the global variables
#@ #		Set the fill lengths.
#@ #
#@ # Required Variable:
#@ # INTEL_DFM_UIN_DIR
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ #  -uindir 			: Directory where the custom uin files are included.  Default is to use kit uin dir
#@ #  -fill_length 		: Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20} 
#@ #  -metal_layers_to_fill 	: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -via_fill			: Turns on via fill
#@ #  -via_layers_to_fill 		: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -output_format 		: Specify fill flow to output either a gds or oas or  milkyway
#@ #  -milkyway_variables 		: Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}
#@ 
#@ proc create_uin_dir args {
#@ 
#@ 	set proc_name create_uin_dir
#@ 	#Define proc vars
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_ENABLE_CLOCK_NDR 
#@ 	lappend proc_globals INTEL_HALO_INTERFACE 
#@ 	##non-optional variables
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 
#@ 	global  INTEL_DFM_LOCAL_UIN_PATH 
#@ 
#@ 	lappend proc_globals INTEL_DFM_WRITE_GDS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_OASIS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_MW_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_MW_OUTPUTVIEW   
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_DFM_M0_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M1_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M2_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M3_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M4_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M5_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M6_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M7_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M8_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M9_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M10_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M11_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M12_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M0_FILL
#@ 	lappend proc_globals INTEL_DFM_M1_FILL
#@ 	lappend proc_globals INTEL_DFM_M2_FILL
#@ 	lappend proc_globals INTEL_DFM_M3_FILL
#@ 	lappend proc_globals INTEL_DFM_M4_FILL
#@ 	lappend proc_globals INTEL_DFM_M5_FILL
#@ 	lappend proc_globals INTEL_DFM_M6_FILL
#@ 	lappend proc_globals INTEL_DFM_M7_FILL
#@ 	lappend proc_globals INTEL_DFM_M8_FILL
#@ 	lappend proc_globals INTEL_DFM_M9_FILL
#@ 	lappend proc_globals INTEL_DFM_M10_FILL
#@ 	lappend proc_globals INTEL_DFM_M11_FILL
#@ 	lappend proc_globals INTEL_DFM_M12_FILL
#@ 	lappend proc_globals INTEL_DFM_NO_VIA_FILL
#@ 	lappend proc_globals INTEL_DFM_V0_FILL
#@ 	lappend proc_globals INTEL_DFM_V1_FILL
#@ 	lappend proc_globals INTEL_DFM_V2_FILL
#@ 	lappend proc_globals INTEL_DFM_V3_FILL
#@ 	lappend proc_globals INTEL_DFM_V4_FILL
#@ 	lappend proc_globals INTEL_DFM_V5_FILL
#@ 	lappend proc_globals INTEL_DFM_V6_FILL
#@ 	lappend proc_globals INTEL_DFM_V7_FILL
#@ 	lappend proc_globals INTEL_DFM_V8_FILL
#@ 	lappend proc_globals INTEL_DFM_V9_FILL
#@ 	lappend proc_globals INTEL_DFM_V10_FILL
#@ 	lappend proc_globals INTEL_DFM_V11_FILL
#@ 	lappend proc_globals INTEL_DFM_V12_FILL
#@ 	lappend proc_globals INTEL_DFM_V0PAXFILL
#@ 
#@ 
#@ 	lappend proc_globals INTEL_DFM_M1_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M2_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M3_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M4_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M5_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M6_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M7_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M8_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M9_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M10_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M11_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M12_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_ZONE_VIA_FILL
#@ 
#@ 
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			if { [info exists INTEL_DFM_UIN_DIR] } {
#@ 				set uindir $INTEL_DFM_UIN_DIR
#@ 			} else {
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04/
#@ 			}
#@ 		}
#@ 		if { $via_fill  } {
#@ 			set INTEL_DFM_NO_VIA_FILL false
#@ 		}
#@ 		if { $nopax_fill } {
#@ 			set INTEL_DFM_V0PAXFILL false
#@ 		}	
#@ 		if { $metal_layers_to_fill != "not_set" } {
#@ 			foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 				set INTEL_DFM_M$i\_FILL false
#@ 			} 
#@ 			foreach i $metal_layers_to_fill {
#@ 				set INTEL_DFM_M$i\_FILL true
#@ 			}
#@ 		} 
#@ 		if { $via_layers_to_fill != "not_set" } {
#@ 			if { $INTEL_DFM_NO_VIA_FILL =="false" } {
#@ 				foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 					set INTEL_DFM_V$i\_FILL false
#@ 				}
#@ 				foreach i $via_layers_to_fill {
#@ 					set INTEL_DFM_V$i\_FILL true
#@ 				}
#@ 			} 
#@ 		}
#@ 		if { $fill_length != "not_set" } {
#@ 			for { set i 0 } { $i < [llength $fill_length] } {incr i 2} {
#@ 				set val [lindex  $fill_length [expr $i+1]]
#@ 				regsub -all {m} [lindex $fill_length $i] {} met
#@ 				set INTEL_DFM_M$met\_FILL_LENGTH $val
#@ 			}
#@ 		} 
#@ 		if { $output_format != "not_set" } {
#@ 			if { $output_format == "gds"} {
#@ 				set INTEL_DFM_WRITE_GDS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "oas"} {
#@ 				set INTEL_DFM_WRITE_OASIS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_WRITE_MW_OUTPUT true
#@ 			}
#@ 		} 
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_OUTPUTVIEW [lindex $milkyway_variables 2]
#@ 			} 
#@ 		} 
#@ 	} else {
#@ 		puts "warning : parseOpt package is not loaded"
#@ 	}
#@ 
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 	global env
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 	#defaults
#@ 	set error_status 0
#@ 	# set rundir [pwd]
#@ 	set uin_dir_name  [file tail $uindir]
#@ 	exec rm -rf $uin_dir_name
#@ 	exec mkdir $uin_dir_name;  
#@ 	foreach i [glob $uindir/*] {
#@ 		exec  cp  $i $uin_dir_name/
#@ 	}
#@ 	set INTEL_DFM_LOCAL_UIN_PATH [pwd]
#@ 	append INTEL_DFM_LOCAL_UIN_PATH /$uin_dir_name
#@ 	set uindir $INTEL_DFM_LOCAL_UIN_PATH
#@ 	exec  chmod -R +w  $uindir/
#@ 	exec touch $uindir/flexuin_fill_layers.rs
#@ 	set IOFILE [open $uindir/flexuin_fill_layers.rs "w"]
#@ 
#@ 	foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 		set x INTEL_DFM_M$i\_FILL
#@ 		if {[info exists [subst $x]]} {
#@ 			if {[subst $[subst $x]]} {
#@ 				puts $IOFILE "#define DFM_M$i\FILL"
#@ 			}
#@ 		}
#@ 		set y INTEL_DFM_V$i\_FILL 
#@ 		if {[info exists INTEL_DFM_NO_VIA_FILL]} {
#@ 			if {!$INTEL_DFM_NO_VIA_FILL} {
#@ 				if {[info exists [subst $y]]} {
#@ 					if {[subst $[subst $y]]} {
#@ 						puts $IOFILE "#define DFM_V$i\FILL"
#@ 					} 
#@ 				}
#@ 			}
#@ 		} 
#@ 	}
#@ 	if {[info exists INTEL_DFM_V0PAXFILL]} { 
#@ 		if { $INTEL_DFM_V0PAXFILL} {
#@ 			puts $IOFILE "#define DFM_V0PAXFILL"
#@ 		}
#@ 	}
#@ 	if {[info exists INTEL_ENABLE_CLOCK_NDR] } { 
#@ 		if {$INTEL_ENABLE_CLOCK_NDR == 1} {
#@ 			puts $IOFILE "#define ENABLE_NDR_UIN"
#@ 		}
#@ 	}	
#@ 	if {[info exists INTEL_HALO_INTERFACE] } { 
#@ 		if {[regexp "d2xn" $INTEL_HALO_INTERFACE]} {
#@ 			puts $IOFILE "#define ENABLE_D2XN_OFFSET"
#@ 		}
#@ 	}
#@ 	set sampleuinfile [open $uindir/flexuin_fill0.rs "r"]
#@ 	while {[gets $sampleuinfile line]  != -1} {
#@ 		#puts $line
#@ 		if {[regexp {^\s*process_name*} $line ] } {
#@ 			puts $IOFILE  $line
#@ 		}
#@ 	}
#@ 	close $sampleuinfile
#@ 	if {[info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_GDS_OUTPUT} {
#@ 			puts $IOFILE "write_stm_output = true;"
#@ 		} else {
#@ 			puts $IOFILE "write_stm_output = false;"
#@ 		}  
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_OASIS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_OASIS_OUTPUT} {
#@ 			puts $IOFILE "write_oas_output = true;"
#@ 		} 
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_MW_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_MW_OUTPUT} {    
#@ 			if {![info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 				puts $IOFILE "write_stm_output = false;"
#@ 			}
#@ 			puts $IOFILE "write_milkyway_output = true;"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				puts $IOFILE "mw_library = \"$INTEL_DFM_MW_LIBNAME\" ;"
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				puts $IOFILE "mw_library = \"$libname\" ;"
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				puts $IOFILE "mw_path = \"$INTEL_DFM_MW_LIBPATH\" ;"
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				puts $IOFILE "mw_path = \"$libpath\" ;"
#@ 			}
#@ 			puts $IOFILE "mw_append = true;"
#@ 			if {[info exists  INTEL_DFM_MW_OUTPUTVIEW]} {
#@ 				puts $IOFILE "mw_view = \"$INTEL_DFM_MW_OUTPUTVIEW\";"
#@ 			} else {
#@ 				puts $IOFILE "mw_view = \"FILL\";"
#@ 			}
#@ 		} 
#@ 	}
#@ 	puts $IOFILE "do_final_texting = false;"
#@ 	puts $IOFILE "write_fill_on_dummy_layer_only = true;"
#@ 	puts $IOFILE "#define SPLIT_FILL_AS_EXTENSIONS_AND_FLOAT "
#@ 	if { [info exists INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if { [string equal $INTEL_DFM_WRITE_GDS_OUTPUT == "false"] && (![info exists INTEL_DFM_WRITE_OASIS_OUTPUT] || [string equal $INTEL_DFM_WRITE_OASIS_OUTPUT == "false"]) && (![info exists INTEL_DFM_WRITE_MW_OUTPUT] || [string equal $INTEL_DFM_WRITE_MW_OUTPUT == "false"]) } {
#@ 			error "all output set to null. please set either of INTEL_DFM_WRITE_GDS_OUTPUT or INTEL_DFM_WRITE_OASIS_OUTPUT or INTEL_DFM_WRITE_MW_OUTPUT to true. unset all in which case default output will be a gds output."
#@ 		}
#@ 	}
#@ 	foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 		set x INTEL_DFM_M$i\_KEEPOUT_CELLS
#@ 		if {[info exists [subst $x]]} {
#@ 			if {[llength [subst $[subst $x]]] > 0} {
#@ 				set keepout_cells [get_icv_list [subst $[subst $x]]]
#@ 				puts $IOFILE "m$i\_prune_cells_list = $keepout_cells ;"
#@ 				write_to_file_with_replace "$uindir/flexuin_fill$i\.rs" "keepout_cells_list\\s*=\\s*\.*;" "keepout_cells_list = $keepout_cells ;"
#@ 			} else {
#@ 				puts $IOFILE "m$i\_prune_cells_list = {\"\"} ;"
#@ 			}
#@ 		} else {
#@ 			puts $IOFILE "m$i\_prune_cells_list = {\"\"} ;"
#@ 		} 
#@ 	}
#@ 	close $IOFILE
#@ 	foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 		set x INTEL_DFM_M$i\_FILL_LENGTH
#@ 		if {[info exists [subst $x]]} {
#@ 			if {[subst $[subst $x]] > 0} {
#@ 				fill_length = [subst $[subst $x]]
#@ 				write_to_file_with_replace "$uindir/flexuin_fill${i}.rs" "fill_length\\s*=\\s*\.*;" "fill_length = $fill_length ;"
#@ 			} 
#@ 		} 
#@ 	} 
#@ 
#@ 	if { [info exists INTEL_DFM_ZONE_VIA_FILL] } {
#@ 		if { $INTEL_DFM_ZONE_VIA_FILL } {
#@ 			foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 				set y INTEL_DFM_V$i\_FILL 
#@ 				if {[info exists $y]} {
#@ 					set kor_space  0.001
#@ 					set density_target 0.06
#@ 					set vfill_uin  ""
#@ 					set vfile [open "$uindir/flexuin_vfill${i}.rs" r]
#@ 					set hookup_regions  "hookup_regions = { \n {\n VIA${i}ZONE,\n{\"floatiss_\"},\n {\"*\"},\n true,\n false,\n density_target,\n},\n};"
#@ 					set tmp_cnt 0	
#@ 					foreach line [split [read $vfile] \n ] {
#@ 						if { [regexp {^\/\/|^\s+\/\/} $line res ]  } {
#@ 							append vfill_uin "$line\n" 
#@ 						} elseif { $tmp_cnt == 1 }	{
#@ 							#puts $line
#@ 							if { [regexp {\};} $line res1 ] } { 
#@ 								set tmp_cnt 0
#@ 								append vfill_uin $hookup_regions
#@ 							}
#@ 						} else {
#@ 							if { [ regexp {drawn_kor_[x|y]_space} $line res2 ] } {
#@ 								append vfill_uin "$res2=$kor_space;\n"
#@ 							} elseif { [regexp {^.*.density_target\s*=} $line res3] } { 
#@ 								append vfill_uin "$res3 $density_target;\n"
#@ 							} elseif { [regexp {hookup_regions} $line res4 ] } {
#@ 								set tmp_cnt 1
#@ 							} else {
#@ 								append vfill_uin "$line\n"
#@ 							}
#@ 						}
#@ 					}
#@ 					close $vfile
#@ 					set vfile_new [open "$uindir/flexuin_vfill${i}.rs" w]
#@ 					puts $vfile_new $vfill_uin
#@ 					close $vfile_new
#@ 				
#@ 				}
#@ 			}
#@ 		}
#@ 	}
#@ }
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec create_uin_dir {
#@    -help "create_uin_dir - Creates UIN directory with changes to files on layer switches, keepout cells, fill_lengths and output control."
#@    -opt {
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "Directory where the custom uin files are included.  Default is to use kit uin dir"}
#@       {-optname fill_length  	-type list   -default {not_set}             -required 0 -help "Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20}"} 
#@       {-optname metal_layers_to_fill	-type list   -default {not_set}             -required 0 -help "Specify the layers to perform fill on I.e. {0 1 2 3 4 }"}
#@       {-optname via_fill	-type bool   -default 0	             -required 0 -help "Turns on via fill "}   
#@       {-optname nopax_fill	-type bool   -default 0	             -required 0 -help "Turns off bridge via fill "}   
#@       {-optname via_layers_to_fill	-type list   -default {not_set}             -required 0 -help "Specify the layers to perform fill on I.e. {0 1 2 3 4 }"}
#@       {-optname output_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Specify fill flow to output either a gds or oas or  milkyway"}
#@       {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}"}
#@       }
#@    }
#@    }
#@ ################################################################################
#@ # Procedure   : apr_set_cell_keepout_variables #{{{
#@ # Description : The procedure reads the milkyway layout macros and appends the macro names to the global variables DFM_Mx_KEEPOUT_CELLS.
#@ 
#@ 
#@ proc set_cell_keepout_variables args {
#@ 
#@ 	set proc_name "apr_set_cell_keepout_variables"
#@ 	if { [llength [info command running_from_synopsys]] > 0 } {
#@ 		if {[running_from_synopsys]} {  } else { run_fm_in_synopsys; return }
#@ 	}
#@ 
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_DFM_M0_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M1_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M2_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M3_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M4_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M5_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M6_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M7_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M8_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M9_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M10_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M11_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M12_KEEPOUT_CELLS
#@ 	lappend proc_globals gui_suppress_auto_layout
#@ 
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 	#Get command line args.
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals { 
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 	set macro_names {}
#@ 
#@ 	if { [info exists help] == 1} {
#@ 		set printout "This function sets cell list variables for apr_layer_fill \n"
#@ 		append printout "procedure.  It sets variables  that are used to  \n"
#@ 		append printout "specify that no fill on the layer within the boundary of the cells specified\n"
#@ 		append printout "  \n"
#@ 		append printout "\n"
#@ 		append printout "USAGE:\n"
#@ 		append printout "$proc_name "
#@ 		append printout "\t THe global variables INTEL_DFM_Mx_KEEPOUT_CELLS will be automatically set based on the \n"
#@ 		append printout "\t macro properties of the blocks within the milkyway database. \n"
#@ 		puts $printout
#@ 		return
#@ 	}
#@ 	puts ""
#@ 	puts ""
#@ 	puts "Macro instances:"
#@ 	puts "========================================================="
#@ 	puts ""
#@ 
#@ 	foreach_in_collection c [get_cells -quiet -all  -hierarchical  -filter "@is_hard_macro==true"] {
#@ 		puts "[get_attribute $c name] [get_attribute $c ref_name] [get_attribute $c full_name]"
#@ 		set name [get_attribute $c ref_name]
#@ 		lappend macro_names $name
#@ 	}
#@ 	puts ""
#@ 	#Prevent GUI popups of the fram view
#@ 
#@ 	set gui_suppress_auto_layout true
#@ 	foreach name [lsort -unique $macro_names] {
#@ 		open_mw_cel $name.FRAM -readonly
#@ 		foreach metal {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 			if { [sizeof_collection [get_user_shapes -quiet -filter "@layer==\"m$metal\""]] > 0 || [sizeof_collection [get_ports  -quiet -filter "@layer==\"m$metal\""]] } {
#@ 				if {[info exists INTEL_DFM_M$metal\_KEEPOUT_CELLS]} {
#@ 					lappend INTEL_DFM_M$metal\_KEEPOUT_CELLS $name
#@ 				} else {
#@ 					set INTEL_DFM_M$metal\_KEEPOUT_CELLS $name
#@ 				}
#@ 			}
#@ 		}
#@ 		close_mw_cel $name.FRAM
#@ 	}
#@ }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : fill_view_purge
#@ # Description : This procedure is a utility procedure to selectively remove layers on the FILL view or to completely remove the FILL view.
#@ #
#@ # INTEL_DFM_PURGE_ALL - Set by default and it is to remove the complete Fill view
#@ # INTEL_DFM_PURGE_Mx  - Set this variable and set INTEL_DFM_PURGE_ALL false to selectively remove layers from FILL view
#@ 
#@ proc fill_view_purge args {
#@ 
#@ 	set proc_globals {}
#@ 
#@ 	##non-optional variables
#@ 	lappend proc_globals INTEL_DFM_PURGE_ALL
#@ 	lappend proc_globals INTEL_DFM_PURGE_M0
#@ 	lappend proc_globals INTEL_DFM_PURGE_M1
#@ 	lappend proc_globals INTEL_DFM_PURGE_M2
#@ 	lappend proc_globals INTEL_DFM_PURGE_M3
#@ 	lappend proc_globals INTEL_DFM_PURGE_M4
#@ 	lappend proc_globals INTEL_DFM_PURGE_M5
#@ 	lappend proc_globals INTEL_DFM_PURGE_M6
#@ 	lappend proc_globals INTEL_DFM_PURGE_M7
#@ 	lappend proc_globals INTEL_DFM_PURGE_M8
#@ 	lappend proc_globals INTEL_DFM_PURGE_M9
#@ 	lappend proc_globals INTEL_DFM_PURGE_M10
#@ 	lappend proc_globals INTEL_DFM_PURGE_M11
#@ 	lappend proc_globals INTEL_DFM_PURGE_M12
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 
#@ 	set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 	set libname [get_attribute [current_mw_lib] name]
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	}
#@ 	if { [info exists INTEL_DFM_PURGE_ALL]} {
#@ 		set purge_all $INTEL_DFM_PURGE_ALL
#@ 	} else {
#@ 		set purge_all true
#@ 	}
#@ 
#@ 	if { $purge_all } {
#@ 		set fill_view [glob -nocomplain ${libpath}/${libname}/FILL/${DESIGN_NAME}:*]
#@ 		if {[llength $fill_view] > 0 } {
#@ 			puts "Purging fill data from [lindex $fill_view [expr [llength $fill_view]-1]]"
#@ 			puts "=================================================="
#@ 			#temporary fix to remove FILL view until polygons w/ vertice >4 issue resolved
#@ 			# The polygons w/ >4 vertices do not get fill_track attribute
#@ 			# Possibly will be fixed w/ use of ICV 2008+ with icc 2008+
#@ 			remove_mw_cel -verbose -version_kept 0 ${DESIGN_NAME}.FILL
#@ 			#open_mw_cel ${DESIGN_NAME}.FILL
#@ 			#insert_metal_filler -purge
#@ 			#save_mw_cel
#@ 			#close_mw_cel
#@ 		}
#@ 		puts "Purging fill data from the CEL view"
#@ 		puts "=================================================="
#@ 		#insert_metal_filler -purge
#@ 		# not using the command above, since when writing fill as wires, it will not purge.
#@ 		set fill_net_coll [get_net_shapes -quiet -filter "route_type == \"Fill Track\""]
#@ 		if { [sizeof_collection $fill_net_coll] > 0} {
#@ 			remove_objects $fill_net_coll
#@ 		}
#@ 		set fill_user_coll [get_user_shapes -quiet -filter "route_type == \"Fill Track\""]
#@ 		if { [sizeof_collection $fill_user_coll] > 0} {
#@ 			remove_objects $fill_user_coll
#@ 		}
#@ 		if { [info exists INTEL_MCMM] == 1 } {
#@ 			if {$INTEL_MCMM == 1} {  
#@ 				save_mw_cel -scenarios [all_scenarios]
#@ 			} else {
#@ 				save_mw_cel
#@ 			}
#@ 		} else {
#@ 			save_mw_cel
#@ 		}
#@ 	} else {
#@ 		if { [llength  [glob -nocomplain ${libpath}/${libname}/FILL/${DESIGN_NAME}:*]] } {
#@ 			open_mw_cel ${DESIGN_NAME}.FILL
#@ 			foreach i { 0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 				set x INTEL_DFM_PURGE_M$i 
#@ 				if { [info exists INTEL_DFM_PURGE_M$i]} {
#@ 					if { [subst $[subst $x]] } {
#@ 						set x [get_net_shapes -filter "layer==m$i"]
#@ 						if { [llength $x ] >0 } {
#@ 							remove_objects $x
#@ 							save_mw_cel
#@ 						}
#@ 						set y [get_user_shapes -filter "layer==m$i"]
#@ 						if { [llength $y ] >0 } {
#@ 							remove_objects $y
#@ 							save_mw_cel
#@ 						}
#@ 					}			
#@ 				}
#@ 			}
#@ 			close_mw_cel ${DESIGN_NAME}.FILL
#@ 		}
#@ 	}
#@ }
#@ 
#@ 
#@ #if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@ #  ::parseOpt::cmdSpec fill_view_purge {
#@ # -help "fill_view_purge - Creates a folder named <block name>_icv. Creates a shell script and executes the ICV command in the shell script."
#@ # -opt {
#@ #  {-optname purge_list  	-type list   -default {not_set} #          -required 0 -help "Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20}"}   
#@ # }
#@ # }
#@ #}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : create_uin_dir_implant for implant fill
#@ # Description : This procedure will create the uin dir based on Kit Uin files, Global variables and input arguments. It does the following.
#@ #		Copies INTEL_DFM_UIN_DIR to a folder named d04_uin and reset the INTEL_DFM_UIN_DIR the local directory path.
#@ #		Change the layer switches in the uin file.
#@ #		Set the variables for the fill output database.
#@ #		Set the keepout cell list based on the global variables
#@ #		Set the fill lengths.
#@ #
#@ # Required Variable:
#@ # INTEL_DFM_UIN_DIR
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ #  -uindir 			: Directory where the custom uin files are included.  Default is to use kit uin dir
#@ #  -fill_length 		: Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20} 
#@ #  -metal_layers_to_fill 	: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -via_fill			: Turns on via fill
#@ #  -via_layers_to_fill 		: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -output_format 		: Specify fill flow to output either a gds or oas or  milkyway
#@ #  -milkyway_variables 		: Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}
#@ 
#@ proc create_uin_dir_implant args {
#@ 
#@ 	set proc_name create_uin_dir_implant
#@ 	#Define proc vars
#@ 	set proc_globals {}
#@ 	##non-optional variables
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 
#@ 	global  INTEL_DFM_LOCAL_IMPLANT_UIN_PATH 
#@ 
#@ 	lappend proc_globals INTEL_DFM_WRITE_GDS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_OASIS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_MW_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_MW_OUTPUTVIEW   
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_EBB_CELLS_LIST
#@ 	
#@ 
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			if { [info exists INTEL_DFM_UIN_DIR] } {
#@ 				set uindir $INTEL_DFM_UIN_DIR
#@ 			} else {
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04/
#@ 			}
#@ 		}
#@ 		
#@ 		if { $output_format != "not_set" } {
#@ 			if { $output_format == "gds"} {
#@ 				set INTEL_DFM_WRITE_GDS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "oas"} {
#@ 				set INTEL_DFM_WRITE_OASIS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_WRITE_MW_OUTPUT true
#@ 			}
#@ 		} 
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_OUTPUTVIEW [lindex $milkyway_variables 2]
#@ 			} 
#@ 		} 
#@ 	} else {
#@ 		puts "warning : parseOpt package is not loaded"
#@ 	}
#@ 
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 	global env
#@ 
#@ 	#defaults
#@ 	set error_status 0
#@ 	# set rundir [pwd]
#@ 	set uin_dir_name  [file tail $uindir]_implant
#@ 	if { [file exists $uin_dir_name] == 0 } {
#@     		exec mkdir $uin_dir_name;  
#@ 	}
#@ 	exec cp  $uindir/uin_implant.rs $uin_dir_name/
#@ 	
#@ 	set INTEL_DFM_LOCAL_IMPLANT_UIN_PATH [pwd]
#@ 	append INTEL_DFM_LOCAL_IMPLANT_UIN_PATH /$uin_dir_name
#@ 	set uindir $INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 	exec  chmod -R +w  $uindir/
#@ 	exec touch $uindir/uin_implant.rs
#@ 	set IOFILE [open $uindir/uin_implant.rs "w"]
#@ 
#@   
#@   if { [info exists INTEL_EBB_CELLS_LIST] } {
#@     puts $IOFILE "ebb_cells_list = \"$INTEL_EBB_CELLS_LIST\" ;"
#@   } else {
#@     puts $IOFILE "ebb_cells_list = \"\" ;"
#@   }		
#@ 	
#@ 	if {[info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_GDS_OUTPUT} {
#@ 			puts $IOFILE "write_gds_output = true;"
#@ 		} else {
#@ 			puts $IOFILE "write_gds_output = false;"
#@ 		}  
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_OASIS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_OASIS_OUTPUT} {
#@ 			puts $IOFILE "write_oas_output = true;"
#@ 		} else {
#@ 			puts $IOFILE "write_oas_output = false;"
#@ 		} 
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_MW_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_MW_OUTPUT} {    
#@ 			if {![info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 				puts $IOFILE "write_gds_output = false;"
#@ 			}
#@       if {![info exists  INTEL_DFM_WRITE_OASIS_OUTPUT]} {
#@ 				puts $IOFILE "write_oas_output = false;"
#@ 			}
#@ 			puts $IOFILE "write_milkyway_output = true;"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				puts $IOFILE "mw_library = \"$INTEL_DFM_MW_LIBNAME\" ;"
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				puts $IOFILE "mw_library = \"$libname\" ;"
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				puts $IOFILE "mw_path = \"$INTEL_DFM_MW_LIBPATH\" ;"
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				puts $IOFILE "mw_path = \"$libpath\" ;"
#@ 			}
#@ 			puts $IOFILE "mw_append = true;"
#@ 			if {[info exists  INTEL_DFM_MW_OUTPUTVIEW]} {
#@ 				puts $IOFILE "mw_view = \"$INTEL_DFM_MW_OUTPUTVIEW\";"
#@ 			} else {
#@ 				puts $IOFILE "mw_view = \"FILL\";"
#@ 			}
#@ 		} 
#@ 	}
#@ 	
#@ 	if { [info exists INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if { [string equal $INTEL_DFM_WRITE_GDS_OUTPUT == "false"] && (![info exists INTEL_DFM_WRITE_OASIS_OUTPUT] || [string equal $INTEL_DFM_WRITE_OASIS_OUTPUT == "false"]) && (![info exists INTEL_DFM_WRITE_MW_OUTPUT] || [string equal $INTEL_DFM_WRITE_MW_OUTPUT == "false"]) } {
#@ 			error "all output set to null. please set either of INTEL_DFM_WRITE_GDS_OUTPUT or INTEL_DFM_WRITE_OASIS_OUTPUT or INTEL_DFM_WRITE_MW_OUTPUT to true. unset all in which case default output will be a gds output."
#@ 		}
#@ 	}
#@ 	close $IOFILE
#@ }
#@ 
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec create_uin_dir_implant {
#@    -help "create_uin_dir_implant - Creates UIN directory with changes to files on layer switches, keepout cells, fill_lengths and output control."
#@    -opt {
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "Directory where the custom uin files are included.  Default is to use kit uin dir"}
#@       {-optname output_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Specify fill flow to output either a gds or oas or  milkyway"}
#@       {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}"}
#@       }
#@    }
#@    }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : apr_layer_fill for implant
#@ # Description : The main function to launch the ICV based fill flow.  See
#@ #               apr_layer_fill -help for all switches and descriptions.
#@ #
#@ #               The flow counts on the following Parameters being set :
#@ #
#@ # Required Parameters :
#@ # INTEL_DFM_UIN_DIR 
#@ # INTEL_DFM_RELEASE_DIR
#@ # INTEL_GDS_OUT_LAYER_MAP
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ # -fill_release_dir  : The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run
#@ # -rundir : Run directory
#@ # -uindir : uin file directory that ICV command points to
#@ # -input_format : Input layout format. gds/oas/milkyway 
#@ # -milkyway_variables : If input_format=milkyway, specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath>} 
#@ 
#@ 
#@ proc apr_layer_fill_implant args {
#@ 	set proc_name apr_layer_fill_implant
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 	
#@ 	lappend proc_globals INTEL_GDS_OUT_LAYER_MAP
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	
#@ 	global env
#@    
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		} 
#@ 		if { $fill_release_dir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RELEASE_DIR]} {
#@ 				set fill_release_dir $INTEL_DFM_RELEASE_DIR
#@ 			} else {
#@ 				set fill_release_dir $env(INTEL_PDK)/fill/icv/implantfill
#@ 			}	    
#@ 		}	    
#@ 		if { $rundir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RUN_DIR]} {
#@ 				set rundir $INTEL_DFM_RUN_DIR
#@ 			} else {
#@ 				set rundir [pwd]
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			
#@ 			if {[info exists INTEL_DFM_LOCAL_IMPLANT_UIN_PATH]} {
#@ 				set uindir $INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 			} elseif {[info exists INTEL_DFM_UIN_DIR]} {
#@ 				set uindir  $INTEL_DFM_UIN_DIR
#@ 			} else {	
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04
#@ 			}
#@ 		}
#@ 		if { $input_format!= "not_set"} {
#@ 			set INTEL_DFM_INPUT_FORMAT $input_format
#@ 		} else {
#@ 			unset input_format
#@ 		}
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $input_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 			}	
#@ 		}
#@ 	} else {
#@ 		puts "Warning : parseOpt package is not loaded, load it before executing $proc_name for the flow to accept commandline switches"
#@ 	}
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	#defaults
#@ 	set error_status 0
#@ 	set rundir ${rundir}/${DESIGN_NAME}_icv
#@ 	if { [file exists $rundir] == 0 } {
#@ 		exec mkdir -p ${rundir}
#@ 		exec chmod 750 ${rundir}
#@ 	}  
#@ 
#@   set uin_dir_name  [file tail $uindir]
#@   if { [file exists $rundir/$uin_dir_name] == 0 } {
#@     exec cp -r $uindir $rundir
#@   }
#@ 	
#@ 	set uindir $rundir/$uin_dir_name
#@ 	exec  chmod -R +w  $rundir/
#@ 	# Unsetting the intermediate variable INTEL_DFM_LOCAL_IMPLANT_UIN_PATH and removing the duplicate local uin directories
#@ 	if {[info exists INTEL_DFM_LOCAL_IMPLANT_UIN_PATH]} {
#@ 		exec rm -rf $INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 		unset INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 	}
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set CELLNAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set CELLNAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	if { [info exists INTEL_DFM_INPUT_FORMAT] } {
#@ 		if { $INTEL_DFM_INPUT_FORMAT == "milkyway" } {
#@ 			set LAYOUT_TYPE "-f Milkyway"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				set libname $INTEL_DFM_MW_LIBNAME
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				set libpath $INTEL_DFM_MW_LIBPATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 			}
#@ 			set LAYOUTPATH "$libname -p $libpath -lf $INTEL_GDS_OUT_LAYER_MAP "
#@ 		} elseif { $INTEL_DFM_INPUT_FORMAT == "gds"} {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.gds
#@ 				set LAYOUT_TYPE "-f GDSII"
#@ 				puts "Streaming out gds"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format gds -output_file $LAYOUTPATH -net_prop
#@ 			} 
#@ 		} else {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 				set LAYOUT_TYPE "-f OASIS"
#@ 				puts "Streaming out oasis"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 			}
#@ 		}
#@ 	} else {
#@ 		if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 			set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 		} else {
#@ 			set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 			puts "Streaming out oasis"
#@ 			apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 		}
#@ 		set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 		set libname [get_attribute [current_mw_lib] name]
#@ 		set LAYOUT_TYPE "-f OASIS"
#@ 	}
#@ 
#@ 	redirect /dev/null {set library_open [current_mw_lib]}
#@ 	if { $library_open != ""} {
#@ 		close_mw_lib    
#@ 	}   
#@ 	if {[info exists  INTEL_DFM_ICV_COMMAND_LINE_OPTIONS]} {
#@ 		set COMMAND_LINE_OPTIONS $INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	}  else {
#@ 		set COMMAND_LINE_OPTIONS "-dp8 -turbo"
#@ 	}  
#@ 
#@ 	set icv_command "icv -i $LAYOUTPATH -c $CELLNAME $LAYOUT_TYPE $COMMAND_LINE_OPTIONS -I $fill_release_dir/implantfill -I $uindir $fill_release_dir/implantfill/filluv12_withyn.rs"
#@ 
#@ 	
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	puts "Running ICV fill runsets $rundir"
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	set LAUNCHSCRIPT [open "$rundir/${DESIGN_NAME}_launch_implant.csh" w]
#@ 	set fill_start_time [clock seconds]
#@ 	puts $LAUNCHSCRIPT  "#!/bin/tcsh -f"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_DISABLE_RUNSET_CACHE"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_MW_WRITE_FILL_POLY_AS_RECT 1"
#@ 	puts $LAUNCHSCRIPT "setenv PDSSTM ./"
#@ 	puts $LAUNCHSCRIPT "cd $rundir/"
#@ 	puts $LAUNCHSCRIPT "if ( -d icv_fill_implant ) rm -rf icv_fill_implant/*"
#@ 	puts $LAUNCHSCRIPT "sleep 5"
#@ 	puts $LAUNCHSCRIPT "mkdir -p icv_fill_implant"
#@ 	puts $LAUNCHSCRIPT "cd icv_fill_implant"
#@ 	puts $LAUNCHSCRIPT "$icv_command >& fill_implant.log"
#@ 	
#@ 
#@ 	set curdir [pwd]
#@ 	puts $LAUNCHSCRIPT "cd $curdir"
#@ 	puts $LAUNCHSCRIPT "exit 0"
#@ 	#  set cmd "perl $runsetpath/scripts/run_icv.pl $nbflag -f \"metviafill\" -c $DESIGN_NAME -lay $lay_file $cfg_flag $mw_flag"
#@ 	close $LAUNCHSCRIPT
#@ 	exec chmod +x $rundir/${DESIGN_NAME}_launch_implant.csh
#@ 	set cmd "$rundir/${DESIGN_NAME}_launch_implant.csh"
#@ 	puts "Running: $cmd"
#@ 
#@ 	exec $rundir/${DESIGN_NAME}_launch_implant.csh
#@ 	set elapsed_time [expr [clock seconds] - $fill_start_time]
#@ 	set clock_hours [expr $elapsed_time / 3600]
#@ 	set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ 	set fill_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ 
#@ 	puts ""
#@ 	puts ""
#@ 	puts "ICV Fill job Runtime(hh:mm:ss) $fill_clock_elapsed "
#@ 	puts ""
#@ 	puts ""
#@ 	exec sleep 10
#@ 	if { $library_open != ""} {
#@ 		open_mw_cel -lib $libpath/${libname} $DESIGN_NAME
#@ 	}
#@ }
#@ 
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec apr_layer_fill_implant {
#@    -help "apr_layer_fill_implant - Creates a folder named <block name>_icv. Creates a shell script and executes the ICV command in the shell script."
#@    -opt {
#@       {-optname fill_release_dir	-type string -default "not_set"             -required 0 -help "The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run."}
#@       {-optname rundir 	-type string -default "not_set"             -required 0 -help "Directory where Folder is created and ICV executes."}
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "uin file directory that ICV command points to"}
#@       {-optname input_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Input format for fill flow"}
#@      {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath> }"}
#@       }
#@    }
#@    }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/fill_icv_procs.tcl

#@ 
#@ set adr_start_time [clock seconds]
#@ 
#@ P_msg_info "Running ADR..."
#@ 
#@ #setup group path so ICV runs quicker
#@ set usr $env(USER)
#@ set grpdir "/tmp/${usr}_adr_[pid]"
#@ if { [file isdirectory $grpdir] } {
#@   exec rm -rf $grpdir
#@ }
#@ if { [file exists $grpdir] == 0 } {
#@   exec mkdir -p $grpdir
#@   exec chmod 750 $grpdir
#@ }
#@ if {[file isdirectory /[pwd]/adr_work]} {
#@   exec rm -rf [pwd]/adr_work
#@ }
#@ 
#@ #make ADR control file, reuse fill flow cell list function
#@ set_cell_keepout_variables
#@ exec mkdir -p [pwd]/adr_work/adr_control
#@ set adr_file  "[pwd]/adr_work/adr_control/adr_control.rs"
#@ 
#@ set fileId2 [open $adr_file "a"]
#@ puts $fileId2 ""
#@ if { [info exists INTEL_XN_LIBRARY] == 1 } {
#@   if {$INTEL_XN_LIBRARY == 1} {
#@     puts $fileId2 "G_XN_LIBRARY : integer = 1;"
#@   } else {
#@     puts $fileId2 "G_XN_LIBRARY : integer = 0;"
#@   }
#@ } else {
#@   puts $fileId2 "G_XN_LIBRARY : integer = 0;"
#@ }
#@ 
#@ if { [info exists INTEL_TG_LIBRARY] == 1 } {
#@   if {$INTEL_TG_LIBRARY == 1} {
#@     puts $fileId2 "G_TG_LIBRARY : integer = 1;"
#@   } else {
#@     puts $fileId2 "G_TG_LIBRARY : integer = 0;"
#@   }
#@ } else {
#@   puts $fileId2 "G_TG_LIBRARY : integer = 0;"
#@ }
#@ 
#@ puts $fileId2 ""
#@ puts $fileId2 "// Needed to reuse fill uin files"
#@ puts $fileId2 "DFM_M2_MAX_FILL_LENGTH : double = 30;"
#@ puts $fileId2 "DFM_M3_MAX_FILL_LENGTH : double = 30;"
#@ puts $fileId2 "DFM_FILL_METAL2_TARG :double     = 45;"
#@ puts $fileId2 "DFM_FILL_METAL3_TARG :double     = 45;"
#@ puts $fileId2 "// Need following definition when reading in uin"
#@ puts $fileId2 "keepout_cells_list:list of string = {\"\"};"
#@ puts $fileId2 "overlong_fill_thresh_buckets:list of double = {};"
#@ 
#@ close $fileId2
#@ 
#@ 
#@ P_msg_info "DRVs before ADR:"
#@ verify_zrt_route -voltage_area false
#@ set adr_path ./adr_work
#@ if { ![file isdirectory $adr_path] } { sh mkdir -p $adr_path }
#@ set_physical_signoff_options -mapfile $INTEL_GDS_OUT_LAYER_MAP -exec_cmd icv -drc_runset $INTEL_ADR_RUNSET_FILE
#@ 
#@ echo ""
#@ report_physical_signoff_options
#@ save_mw_cel
#@ 
#@ #  Initial ADR DRC check, to see the starting ADR runset violations
#@ set adr_initdrc_start_time [clock seconds]
#@ P_msg_info "Running initial ADR ICV job to identify initial errors"
#@ 
#@ signoff_drc -read_cel_view -run_dir $adr_path/signoff_drc_initial -user_defined_options "$INTEL_ADR_USER_DEF_OPT -g $grpdir" -ignore_child_cell_errors -max_errors_per_rule 9000
#@ 
#@ set elapsed_time [expr [clock seconds] - $adr_initdrc_start_time]
#@ set clock_hours [expr $elapsed_time / 3600]
#@ set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ set adr_initdrc_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ P_msg_info "ADR Initial DRC Runtime(hh:mm:ss) $adr_initdrc_clock_elapsed "
#@ 
#@ #  This is the ADR loop
#@ set adr_adrloop_start_time [clock seconds]
#@ P_msg_info "Running ADR loops (signoff_autofix_drc) for fixing errors identified in the ICV ADR job"
#@ 
#@ signoff_autofix_drc -config_file $INTEL_ADR_CONFIG_FILE -init_drc_error_db $adr_path/signoff_drc_initial -incremental_level off -run_dir $adr_path/signoff_autofix -max_errors_per_rule 9000 -start_repair_loop 1 -end_repair_loop $INTEL_ADR_LOOPS -user_defined_options "$INTEL_ADR_USER_DEF_OPT -g $grpdir"
#@ 
#@ set elapsed_time [expr [clock seconds] - $adr_adrloop_start_time]
#@ set clock_hours [expr $elapsed_time / 3600]
#@ set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ set adr_adrloop_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ P_msg_info "ADR Fixing Loop Runtime(hh:mm:ss) $adr_adrloop_clock_elapsed "
#@ 
#@ save_mw_cel
#@ 
#@ #  Final ADR DRC check, to see the ending ADR runset violations
#@ set adr_enddrc_start_time [clock seconds]
#@ P_msg_info "Running ICV ADR check after the ADR fixing loops"
#@ 
#@ signoff_drc -read_cel_view -run_dir $adr_path/signoff_drc_final -user_defined_options "$INTEL_ADR_USER_DEF_OPT -g $grpdir" -ignore_child_cell_errors -max_errors_per_rule 9000
#@ 
#@ set elapsed_time [expr [clock seconds] - $adr_enddrc_start_time]
#@ set clock_hours [expr $elapsed_time / 3600]
#@ set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ set adr_enddrc_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ P_msg_info "ADR End DRC Runtime(hh:mm:ss) $adr_enddrc_clock_elapsed "
#@ 
#@ P_msg_info "Running verify_zrt_route after the ADR fixing loops were completed"
#@ verify_zrt_route -voltage_area false
#@ 
#@ set elapsed_time [expr [clock seconds] - $adr_start_time]
#@ set clock_hours [expr $elapsed_time / 3600]
#@ set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ set adr_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ 
#@ 
#@ 
#@ P_msg_info "Initial ICV ADR check    Runtime(hh:mm:ss) $adr_initdrc_clock_elapsed "
#@ P_msg_info "ADR Fixing Loop(s)       Runtime(hh:mm:ss) $adr_adrloop_clock_elapsed "
#@ P_msg_info "Ending ICV ADR check     Runtime(hh:mm:ss) $adr_enddrc_clock_elapsed "
#@ P_msg_info ""
#@ P_msg_info ""
#@ P_msg_info "Overall ADR flow         Runtime(hh:mm:ss) $adr_clock_elapsed "
#@ P_msg_info ""
#@ P_msg_info ""
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/adr.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ ##############################################################################
#@ # Script: derive_pg.tcl
#@ # Description: This script is used to connect all unconnected power, ground
#@ #              and tie-off pins to the power and ground nets.
#@ ##############################################################################
#@ 
#@ 
#@ # Connect logically PG pins of cells ot PG nets.
#@ if { [info exists INTEL_UPF] && $INTEL_UPF } {
#@ 
#@   if { [info exists INTEL_STEP_CURR] && [regexp import_design $INTEL_STEP_CURR -match] } {
#@     # Only need to create_net once at the begining after reading upf.
#@     derive_pg_connection -create_nets
#@     derive_pg_connection -reconnect
#@     derive_pg_connection -tie
#@   }
#@ 
#@   # UPF based flow must run derive_pg_connection without any option.
#@   derive_pg_connection -all
#@ 
#@ } else {
#@ 
#@   # Connect primary supplies to pins on standard cells
#@   derive_pg_connection -power_net $INTEL_MW_POWER_NET -power_pin vcc       -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@   # Logical tie-low and tie-high connections
#@   #derive_pg_connection -power_net $INTEL_MW_POWER_NET   #    -ground_net $INTEL_MW_GROUND_NET   #    -tie
#@ 
#@   # Macro cells with different power port name
#@   # User needs to provide local copy of derive_pg.tcl for each design having macro's with different power pin name
#@   # An example is shown below
#@   #derive_pg_connection -cells [all_macro_cells]      #                     -power_net  $INTEL_MW_POWER_NET -power_pin vccsocvidxxx_1p03       #                     -ground_net $INTEL_MW_GROUND_NET -ground_pin vss 
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/derive_pg.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ ##############################################################################
#@ 
#@ ###############################################
#@ # List of procs used by this script
#@ # 1. P_msg_info
#@ #
#@ ##################################################
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@ 
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] base_name -quiet]
#@ 
#@ } else {
#@   set max_cap_zero_cells [get_attribute [get_lib_cells -of_objects [get_lib_pins */*/* -filter " max_capacitance == 0" -quiet] -quiet] name -quiet]
#@ }
#@ # List the dont_use_list in the following format
#@ # {cell_names} {reason of not using them}
#@ 
#@ set dont_use_rtl [list "vcc" {SPECIAL: voltage pins}                       "vss" {SPECIAL: voltage pins}                       "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                       "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                       "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_default [list "vcc" {SPECIAL: voltage pins}                           "vss" {SPECIAL: voltage pins}                           "${fdk_lib}bfn00*ua5"  {HIGH_COST: Buffer count increases and synthesis uses only this drive strength if allowed}                           "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                           "${fdk_lib}hgy*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                           "${fdk_lib}hhy*" { SPECIAL:Synchronizer Cell} 													"${fdk_lib}nob03wn0c0" { Incorrect transition value is library}                           "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                           "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                           "${fdk_lib}bfn00?nua5" {LOW_DRIVE CELL}                           "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                           "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                           "${fdk_lib}bfn1*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}inn12*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                           "${fdk_lib}gbf*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gin*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                           "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                           "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                           "${fdk_lib}cgc00*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc02*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgc03*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}cgm22*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                           "${fdk_lib}frt03?d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                           "${fdk_lib}f2*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}f4*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                           "${fdk_lib}qct01*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}qct00*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                           "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                           "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ set dont_use_sign_off_hard [list "vcc" {SPECIAL: voltage pins}                                 "vss" {SPECIAL: voltage pins}                                 "${fdk_lib}bfn00?n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "${fdk_lib}bfn00?n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set dont_use_sign_off_cond [list "${fdk_lib}hgy.*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                                 "${fdk_lib}bbf*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bca*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bco*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bfy*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bin*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bly*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bmb*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bna*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bno*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bth*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bxo*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                                 "${fdk_lib}bdc*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bgn*" {FILL_ONLY:Functional bonus cells}                                 "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                                 "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                                 "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                                 "${fdk_lib}gan*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gna*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gno*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gor*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}gmx22*" {RTL_ONLY:RTL instantition required. Clock logical cells}                                 "${fdk_lib}cdc03*" {RTL_ONLY:RTL instantition required. Clock divider.}                                 "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ 
#@ set dont_use_sign_off [concat $dont_use_sign_off_hard $dont_use_sign_off_cond]
#@ set dont_use_pt_eco [list "vcc" {SPECIAL: voltage pins}                          "${fdk_lib}bfn00?*n0b3" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}bfn00?*n0b4" {SPECIAL:b3 and b4 were pruned to maintain cell P/N timing, area, totalZ across the family}                          "${fdk_lib}hgy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}hhy?*" {SPECIAL:Synchronizers and Metastable Hardened DFFs}                          "${fdk_lib}slc?*" {Level shifters , used in upf flow}                          "${fdk_lib}swa00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}swo00?*" {MPD_ONLY:AND/OR type firewall cells}                          "${fdk_lib}pws?*" {MPD_ONLY:Power switches}                          "${fdk_lib}pws10?*" {MPD_ONLY:Power switches}                          "${fdk_lib}sc?*" {MPD_ONLY:Always-on self-isolated clock buffers/inverters.  Used in the UPF flow}                          "${fdk_lib}dly0?*" {MPD_ONLY:Always-on delay cells.  Used in the UPF flow}                          "${fdk_lib}swi00?*" {MPD_ONLY:Isolation inverter.  Used in the UPF flow}                          "${fdk_lib}swb00?*" {MPD_ONLY:Isolation buffer.  Used in the UPF flow}                          "${fdk_lib}slg?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}sv?*" {MPD_ONLY:Level Shifter.  Used in the UPF flow}                          "${fdk_lib}bbf?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bca?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bco?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bfy?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bin?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bly?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bmb?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bna?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bno?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bth?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bxo?*" {FILL_ONLY:Functional bonus cells. Used during ECO mode}                          "${fdk_lib}bdc?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bgn?*" {FILL_ONLY:Functional bonus cells}                          "${fdk_lib}bfn00?*nua5" {LOW DRIVE CELL}                          "${fdk_lib}ann04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}ann04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}con01?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nab03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}nan02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}nan04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non02?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non03?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}non04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn03?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0a5" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b0" {DRC COST: HPD Cells}                          "${fdk_lib}orn04?n0b5" {DRC COST: HPD Cells}                          "${fdk_lib}bfn1?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}inn12?*" {ROUTE_ONLY:Min delay buffers/inverters.  Used during hold fixing}                          "${fdk_lib}gbf?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gin?*" {CTS_ONLY:Clock buffers and inverters.  Used during CTS}                          "${fdk_lib}gan?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gna?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gno?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gor?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}gmx22?*" {RTL_ONLY:RTL instantition required. Clock logical cells}                          "${fdk_lib}cdc03?*" {RTL_ONLY:RTL instantition required. Clock divider.}                          "${fdk_lib}cgc00?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc02?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgc03?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}cgm22?*" {CTS_ONLY:Gated clock buffers.  CTS uses cgc01}                          "${fdk_lib}frt03?*d0k0" {Retention flop : incorrect embedded well tap causes DRC violation }                          "${fdk_lib}f2?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}f4?*" {HIGH_COST:Multi Bit Flop: Need special flow to use it. }                          "${fdk_lib}qct01?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}qct00?*" {SPECIAL:Inconsitent direction of lib pins b/w logical and physical library}                          "${fdk_lib}cab13?d0b5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "${fdk_lib}cab13?d0c5" {HIGH_COST:Have implant layers missing, and cause drcd NV*_UV* violations}                          "$max_cap_zero_cells" {SPECIAL: Cells with max_capacitance=0 in the lib file} ]
#@ 
#@ set _dont_use_cells ""
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name != "pt_shell"} {
#@   P_msg_info "Setting APR dont_use cells"
#@   # Set dont_use list
#@ 
#@   set dont_use_list [set dont_use_default]
#@   # First lets remove existing dont_use
#@   # now lets put dont use on the cells for the given step of the flow.
#@   P_msg_info "Setting dont_use on seleted cells based on dont_use_default the ASIC flow"
#@   foreach {cell_type cell_description} $dont_use_list {
#@     P_msg_info "Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set _dont_use_cells [get_lib_cells */$cell_name -quiet]
#@       if {[sizeof_collection $_dont_use_cells] > 0} {
#@         set_dont_use $_dont_use_cells
#@         foreach_in_collection lib_pin [get_lib_pins -of_objects $_dont_use_cells] {
#@           set attribute [get_attribute $lib_pin clock_gate_out_pin -quiet]
#@           if {$attribute == "true"} {
#@             set_dont_use $_dont_use_cells -power
#@           }
#@         }
#@ 
#@       } else {
#@         P_msg_info " no '$cell_name' cells found in libraries loaded in the design "
#@       }
#@     }
#@   }
#@ 
#@ 
#@ 
#@ } elseif {[info exists synopsys_program_name] && $synopsys_program_name == "pt_shell"} {
#@   define_user_attribute pt_dont_use -quiet -type boolean -class lib_cell
#@ 
#@   set dont_use_list $dont_use_pt_eco
#@   set dont_use_collection ""
#@ 
#@   foreach {cell_type cell_description} $dont_use_list {
#@     echo  "INFO: Setting dont_use on $cell_type\n   because $cell_description"
#@     foreach cell_name $cell_type {
#@       set dont_use_collection [add_to_collection $dont_use_collection [get_lib_cells  */$cell_name -quiet]]
#@     }
#@   }
#@ 
#@   foreach_in_collection  current_dont_use_cell $dont_use_collection {
#@     set_user_attribute -class lib_cell [get_lib_cells -quiet  $current_dont_use_cell] pt_dont_use true
#@   }
#@ }
#@ 
#@ ########################################
#@ #Remove dont use on PM cells in UPF mode
#@ ########################################
#@ if {[info exists INTEL_UPF] && $INTEL_UPF} {
#@   set pm_libcells [get_lib_cells -quiet -filter "(is_isolation_cell == true || defined(level_shifter_type) || retention_cell =~ * || always_on == true) && (name !~ d04ani*) && (name !~ d04ori*)" */$fdk_lib*]
#@   set pm_libs [get_libs -of_objects $pm_libcells]
#@ 
#@   foreach attr_name {dont_use dont_touch} {
#@     set bad_pm_libcells [filter_collection $pm_libcells "$attr_name == true"]
#@ 
#@     if { [sizeof_collection $bad_pm_libcells] > 0 } {
#@       P_msg_warn "Detected power-management (isolation, level-shifter, retention & always-on non-clock) lib cells in that have attribute '$attr_name' set to 'true'!  Removing their attribute '$attr_name' as they are necessary for UPF flow ..."
#@       remove_attribute $bad_pm_libcells $attr_name
#@     }
#@   }
#@ }
#@ 
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/common/dot3/d04/dont_use.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/check_fill_view.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. P_msg_warn
#@ 
#@ ###################################################
#@ # Check if fill view exists and is open
#@ ###################################################
#@ set curr_lib [get_object_name [current_mw_lib]]
#@ if {[llength [glob -nocomplain mwdb/${curr_lib}/FILL/*:*]] > 0} {
#@   if {[llength [lsearch -all [get_attribute [get_mw_cel *.FILL] is_open] true]] > 0} {
#@     P_msg_warn "At least one FILL view is open. Closing all FILL views before starting metal fill."
#@     close_mw_cel *.FILL
#@   }
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/check_fill_view.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/metal_via_fill.tcl

#@ ##############################################################################
#@ # List of procs used by the script
#@ # 1. set_fill_layers
#@ # 2. set_cell_keepout_variables
#@ # 3. fill_view_purge
#@ # 4. create_uin_dir
#@ # 5. apr_layer_fill
#@ 
#@ ###################################################
#@ # Source ICV Fill procedures
#@ ###################################################
#@ lappend auto_path $env(INTEL_ASIC)/asicflows/synopsys/fill/
#@ package require parseOpt
#@ source $env(INTEL_ASIC)/asicflows/synopsys/fill/fill_icv_procs.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/fill_icv_procs.tcl

#@ 
#@ 
#@ source $env(INTEL_ASIC)/asicflows/synopsys/fill/track2uin.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/track2uin.tcl

#@ #TCL scipt to convert track plan data structure to uin
#@ #
#@ global INTEL_ASIC
#@ source $env(INTEL_ASIC)/asicflows/synopsys/fill/gen_trackplan.tcl
#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/gen_trackplan.tcl

#@ #TCL script to extract trackplan info from set_wiretracks.tcl
#@ #set_wiretrack.tcl -> $trackplan, $ndrtrackplan
#@ #$trackplan -> $offsetPeriodDict, $gridPatternDict
#@ #$ndrtrackplan -> $ndrOffsetPeriodDict, $ndrGridPatternDict
#@ 
#@ global fdk_lib
#@ global INTEL_ASIC
#@ global INTEL_DFM_RELEASE_DIR
#@ #The set_wiretracks.tcl path is found from the ICC shell procedure P_source_if_exists. When running outside ICC shell the path to set_wiretracks.tcl has to be set manually
#@ redirect -variable infile_name {P_source_if_exists -display set_wiretracks.tcl}
#@ set infile_name [lindex $infile_name 0]
#@ set lib [file tail [file dirname $infile_name]]
#@ #set infile [open "$env(INTEL_ASIC)/asicflows/synopsys/apr/dot6/$lib/set_wiretracks.tcl" r]
#@ set infile [open $infile_name r]
#@ set file_buffer [read $infile]
#@ close $infile
#@ 
#@ set dict_name_regexp {remove_track -layer ([a-zA-Z][0-9]+)}
#@ set dict_values_regexp {.*layer ([a-zA-Z][0-9]+).*coord (\d+\.\d+).*space (\d+\.\d+).*width (\d+\.\d+)}
#@ set dict_ndr_name_regexp {INTEL_ENABLE_CLOCK_NDR}
#@ set data [split $file_buffer "\n"]
#@ 
#@ set colorDict ${lib}ColorDict
#@ 
#@ ##Color values for M0,2,3,4 tracks##{{{
#@ dict set d04ColorDict m0 odd "B"
#@ dict set d04ColorDict m0 even "C"
#@ dict set d04ColorDict m2 odd "C"
#@ dict set d04ColorDict m2 even "B"
#@ dict set d04ColorDict m3 odd "C"
#@ dict set d04ColorDict m3 even "B"
#@ dict set d04ColorDict m4 odd "C"
#@ dict set d04ColorDict m4 even "B"
#@ ##
#@ dict set d04_tp1ColorDict m0 odd "B"
#@ dict set d04_tp1ColorDict m0 even "C"
#@ dict set d04_tp1ColorDict m2 odd "C"
#@ dict set d04_tp1ColorDict m2 even "B"
#@ dict set d04_tp1ColorDict m3 odd "C"
#@ dict set d04_tp1ColorDict m3 even "B"
#@ dict set d04_tp1ColorDict m4 odd "C"
#@ dict set d04_tp1ColorDict m4 even "B"
#@ ##
#@ dict set df0ColorDict m0 odd "C"
#@ dict set df0ColorDict m0 even "B"
#@ dict set df0ColorDict m2 odd "B"
#@ dict set df0ColorDict m2 even "C"
#@ dict set df0ColorDict m3 odd "B"
#@ dict set df0ColorDict m3 even "C"
#@ dict set df0ColorDict m4 odd "B"
#@ dict set df0ColorDict m4 even "C"
#@ ##Color values for M0,2,3,4 tracks##}}}
#@ 
#@ ##Read File and define trackplan and ndrtrackplan dict##{{{
#@ set gridPatternDict [dict create]
#@ set ndrGridPatternDict [dict create]
#@ set ndrOffsetPeriodDict [dict create]
#@ set ndrtrackplan [dict create]
#@ set offsetPeriodDict [dict create]
#@ set trackplan [dict create]
#@ 
#@ foreach line $data {
#@     if {[regexp $dict_name_regexp $line match match_layer]} {
#@ 	set dict_key 1
#@ 	set tp_flag 1
#@ 	set ndrtp_flag 0
#@     }
#@     if {[regexp $dict_ndr_name_regexp $line]} {
#@ 	set dict_ndr_key 1
#@ 	set ndrtp_flag 1
#@ 	set tp_flag 0
#@ 	set prev_dict_layer_flag 1
#@ 	set prev_dict_layer "defined"
#@     }
#@ 
#@     if {[regexp $dict_values_regexp $line match dict_layer dict_coord dict_space dict_width]} {
#@ 	if {$tp_flag == 1 && $ndrtp_flag == 0} {
#@ 	    if {$dict_layer eq $match_layer} {
#@ 		dict set trackplan $dict_layer $dict_key coord $dict_coord
#@ 		dict set trackplan $dict_layer $dict_key space $dict_space
#@ 		dict set trackplan $dict_layer $dict_key width $dict_width
#@ 		incr dict_key
#@ 	    } else {
#@ 		puts "Error - layer names do not match $dict_layer $match_layer"
#@ 		exit 1
#@ 	    }
#@ 	} elseif {$ndrtp_flag == 1 && $tp_flag == 0 } {
#@ 	    if { $dict_layer ne $prev_dict_layer } {
#@ 		set prev_dict_layer $dict_layer
#@ 		set dict_ndr_key 1
#@ 	    }
#@ 		dict set ndrtrackplan $dict_layer $dict_ndr_key coord $dict_coord
#@ 		dict set ndrtrackplan $dict_layer $dict_ndr_key space $dict_space
#@ 		dict set ndrtrackplan $dict_layer $dict_ndr_key width $dict_width
#@ 		incr dict_ndr_key
#@ 			    
#@ 	} else {
#@ 		puts "Error No default or ndr track-plan found"
#@ 		exit 1
#@ 	    }
#@     }
#@ }
#@ ##Read File and define trackplan and ndrtrackplan dict##}}}
#@ 
#@ ##Convert trackplan dict to gridPatternDict and offsetPeriodDict##{{{
#@ foreach {metal track} $trackplan {
#@     dict for {track_no csw} $track {
#@ 	dict with csw {
#@ 	     if {$track_no == 1} {
#@ 		set uin_space 0
#@ 		set uin_width $width
#@ 		set uin_offset [format "%.3f" [expr $coord - $width/2]]
#@ 		set uin_period $space
#@ 		dict set offsetPeriodDict $metal offset $uin_offset
#@ 		dict set offsetPeriodDict $metal period $uin_period
#@ 
#@ 	    } else {
#@ 		set prev_coord [dict get $trackplan $metal [expr $track_no - 1] coord]
#@ 		set prev_width [dict get $trackplan $metal [expr $track_no - 1] width]
#@ 		set uin_space [format "%.3f" [expr $coord - $prev_coord - ($width/2.0 + $prev_width/2.0) ]]
#@ 		set uin_width $width
#@ 	    }
#@ 	    
#@ 	    dict set gridPatternDict $metal $track_no space $uin_space
#@ 	    dict set gridPatternDict $metal $track_no width $uin_width
#@ 	    dict set gridPatternDict $metal $track_no netName floatiss_
#@ 	    if {$track_no % 2} {
#@ 		if {[dict exists [subst $$colorDict] $metal odd]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal odd]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    } else {
#@ 		if {[dict exists [subst $$colorDict] $metal even]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal even]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@ }
#@ ##Convert trackplan dict to gridPatternDict and offsetPeriodDict##}}}
#@ 
#@ ##Convert ndrtrackplan dict to ndrGridPatternDict and ndrOffsetPeriodDict##{{{
#@ foreach {metal track} $ndrtrackplan {
#@     dict for {track_no csw} $track {
#@ 	dict with csw {
#@ 	     if {$track_no == 1} {
#@ 		set uin_space 0
#@ 		set uin_width $width
#@ 		set uin_offset [format "%.3f" [expr $coord - $width/2]]
#@ 		set uin_period $space
#@ 		dict set ndrOffsetPeriodDict $metal offset $uin_offset
#@ 		dict set ndrOffsetPeriodDict $metal period $uin_period
#@ 
#@ 	    } else {
#@ 		set prev_coord [dict get $ndrtrackplan $metal [expr $track_no - 1] coord]
#@ 		set prev_width [dict get $ndrtrackplan $metal [expr $track_no - 1] width]
#@ 		set uin_space [format "%.3f" [expr $coord - $prev_coord - ($width/2.0 + $prev_width/2.0) ]]
#@ 		set uin_width $width
#@ 	    }
#@ 
#@ 	    dict set ndrGridPatternDict $metal $track_no space $uin_space
#@ 	    dict set ndrGridPatternDict $metal $track_no width $uin_width
#@ 	    dict set ndrGridPatternDict $metal $track_no netName floatiss_
#@ 	    if {$track_no % 2} {
#@ 		if {[dict exists [subst $$colorDict] $metal odd]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal odd]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    } else {
#@ 		if {[dict exists [subst $$colorDict] $metal even]} {
#@ 		    dict set gridPatternDict $metal $track_no color [dict get [subst $$colorDict] $metal even]
#@ 		} else {
#@ 		    dict set gridPatternDict $metal $track_no color ""
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@ }
#@ ##Convert ndrtrackplan dict to ndrGridPatternDict and ndrOffsetPeriodDict##}}}
#@ 
#@ ##Repeat or delete track##{{{
#@ #Pseudo Code
#@ #if [period  - spaceWidthSum] < 0  {
#@ #   Remove last track
#@ #   }
#@ #
#@ #Check again
#@ #if period - spaceWidthSum  > 0 {  
#@ #   If  Check for first and last track to be of same color {
#@ #       Y : Repeat tracks (M0)
#@ #   } else {
#@ #       N: Good
#@ #   }
#@ #   } else {
#@ #      Error
#@ #   }
#@ 
#@ #For all colored layers min tracks is 2. if 1 then add same track with diff color and change period*2 accordingly
#@ foreach {metal track} $gridPatternDict {
#@     set spaceWidthSum 0
#@     set tracknoArray [list]
#@     set spaceArray [list]
#@     set colorArray [list]
#@     set widthArray [list]
#@     dict for {track_no csw} $track {
#@ 	dict with csw {
#@ 	    lappend spaceArray $space
#@ 	    lappend colorArray $color
#@ 	    lappend widthArray $width
#@ 	    set spaceWidthSum [format "%.3f" [expr $spaceWidthSum + $space + $width]]
#@ 	}
#@ 	#puts "-D- $metal $spaceWidthSum"
#@ 	lappend tracknoArray $track_no
#@     }
#@     #puts "Color array $colorArray"
#@     set period [dict get $offsetPeriodDict $metal period]
#@     if {$spaceWidthSum > $period} {
#@ 	#puts "deleting [lindex $tracknoArray end]"
#@ 	dict unset gridPatternDict $metal [lindex $tracknoArray end] 
#@ 	set spaceWidthSum [expr $spaceWidthSum - [lindex $spaceArray end] - [lindex $widthArray end]]
#@ 	set spaceArray [lreplace $spaceArray end end]
#@ 	set colorArray [lreplace $colorArray end end]
#@ 	set widthArray [lreplace $widthArray end end]
#@ 	set tracknoArray [lreplace $tracknoArray end end]
#@ 	#puts "-D- $metal,Delete tast track"
#@     } elseif {$spaceWidthSum < $period} {
#@ 	if {([lindex $colorArray 0] eq [lindex $colorArray end]) && ([lindex $colorArray 0] ne "") && ([llength $tracknoArray] > 1) } {
#@ 	    dict for {track_no csw} $track {
#@ 		#puts "track_no $track_no"
#@ 		dict with csw {
#@ 		    #puts "adding track $metal [llength $tracknoArray] [dict get $gridPatternDict $metal [llength $tracknoArray] space]"
#@ 		    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] space [dict get $gridPatternDict $metal [llength $tracknoArray] space]
#@ 		    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] width [dict get $gridPatternDict $metal $track_no width]
#@ 		    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] netName [dict get $gridPatternDict $metal $track_no netName]
#@ 		    if {[expr $track_no + [llength $tracknoArray]] % 2} {
#@ 			if {[dict exists [subst $$colorDict] $metal odd]} {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color [dict get [subst $$colorDict] $metal odd]
#@ 			} else {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color ""
#@ 			}
#@ 		    } else {
#@ 			if {[dict exists [subst $$colorDict] $metal even]} {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color [dict get [subst $$colorDict] $metal even]
#@ 			} else {
#@ 			    dict set gridPatternDict $metal [expr $track_no + [llength $tracknoArray]] color ""
#@ 			}
#@ 		    }
#@ 		}
#@ 	    }
#@ 	    dict set offsetPeriodDict $metal period [expr [dict get $offsetPeriodDict $metal period] * 2]
#@ 	    #puts "$metal,$spaceWidthSum,$period,[lindex $colorArray 0],[lindex $colorArray end],Double the period and repeat tracks"
#@ 	} else {
#@ 	    #puts "$metal,No Change"
#@ 	}
#@     } else {
#@         puts "ERROR : $metal,Tried to remove last two tracks, still spaceWidthSum is greater than period"
#@ 	exit 1
#@     }
#@     set spaceWidthSum 0
#@ }
#@ ##Repeat or delete track##}}}
#@ 
#@ #For all colored layers min tracks is 2. if 1 then add same track with diff color and change period*2 accordingly
#@ dict for {metal ov} [subst $$colorDict] {
#@     set tracknoArray [dict keys [dict get $gridPatternDict $metal]]
#@     if {[llength $tracknoArray] == 1} {
#@ 	#puts "$metal,adding 1 more track"
#@ 	dict set gridPatternDict $metal 2 space [format "%.3f" [expr [dict get $offsetPeriodDict $metal period] - [dict get $gridPatternDict $metal 1 width]]]
#@ 	dict set gridPatternDict $metal 2 width [dict get $gridPatternDict $metal 1 width]
#@ 	dict set gridPatternDict $metal 2 netName floatiss_
#@ 	dict set gridPatternDict $metal 2 color [dict get [subst $$colorDict] $metal even]
#@ 	dict set offsetPeriodDict $metal period [expr [dict get $offsetPeriodDict $metal period] * 2]
#@     }
#@ }
#@ 
#@ 
#@ 
#@ 
#@ ##old pseudo code ignore
#@ ##if period - spaceWidthSum < 0 then delete last track
#@ #if > 0 and diff = one of the space then if color of first and last track, change period*2 is same then repeat else OK
#@ #if > 0 and diff is not one of the space then report ERROR
#@ 
#@ #For all colored layers min tracks is 2. if 1 then add same track with diff color and change period*2 accordingly
#@ 
#@ 
#@ #foreach {metal_g track} $gridPatternDict {metal_o op } $offsetPeriodDict {
#@ #    puts "UIN $metal_g :"
#@ #    puts "UIN $metal_o :"
#@ #    dict with op {
#@ #        puts "    offset = $offset"
#@ #        puts "    period = $period"
#@ #    }
#@ #    dict for {track_no csw} $track {
#@ #	dict with csw {
#@ #	    puts "    space: $space"
#@ #	}
#@ #    }
#@ #}
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/gen_trackplan.tcl

#@ set uin_dir [exec pwd]
#@ append uin_dir "/asic_uin/$lib"
#@ file delete -force $uin_dir
#@ file mkdir $uin_dir
#@ set pdk_path "${INTEL_DFM_RELEASE_DIR}/uin/$lib" 
#@ set uin_files [glob -nocomplain -directory $pdk_path *]
#@ foreach ufile $uin_files {
#@     file copy -force $ufile "$uin_dir"
#@ } 
#@ exec chmod -R 755 $uin_dir
#@ set INTEL_DFM_AUTO_UIN_DIR $uin_dir
#@ 
#@ # Procedure to copy the uin config settings from PDK 
#@ # Currently it copies ndr_tp as well. Need to test if ndr_tp calculated from set_wiretracks will work or not
#@ proc getUinSettings { pdk_uin_path metal } {
#@ 	set tp_flag 0
#@ 	set uin_fp [open "$pdk_uin_path/flexuin_fill${metal}.rs" "r"]
#@ 	set rg_flag 0
#@ 	set gp_flag 0
#@ 	set ndr_flag 0
#@ 	set ndrPeriod_flag 0
#@ 	set uinSettings "" 
#@ 	set ndrTp ""
#@ 	set ndrPeriodOffset ""
#@ 	foreach line [split [read $uin_fp] \n ] {
#@ 	    if { [regexp {(grid_pattern.*=.*\{)|(default_tp.*track_pattern.*=)} $line] } {
#@ 		    #puts "setting gp_flag $line $metal"
#@ 		set gp_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { [regexp {region_grids.*=} $line] && ![regexp {//region_grids.*=} $line]} {
#@ 		#puts "  setting rg_flag $line $metal"
#@ 		set rg_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { [regexp {ndr_tp.*track_pattern.*=} $line] } {
#@ 		#puts "    setting ndr_flag $line $metal"
#@ 		set ndr_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { $rg_flag == 1  && [regexp {grid_pattern.*ndr_tp} $line] } {
#@ 		#puts "      setting ndrPeriod_flag $line $metal"
#@ 		set ndrPeriod_flag 1
#@ 		continue
#@ 	    }
#@ 	    if { $gp_flag == 1 || $rg_flag == 1 || $ndr_flag ==1 } {
#@ 		if { [regexp {;} $line] } {
#@ 		    set gp_flag [expr $gp_flag & 0]
#@ 		    set rg_flag [expr $rg_flag & 0]
#@ 		    set ndr_flag [expr $ndr_flag & 0]
#@ 		    set ndrPeriod_flag [expr $ndrPeriod_flag & 0]
#@ 		    continue
#@ 		} elseif { $rg_flag == 1 && [regexp {\},} $line] } {
#@ 		    set ndrPeriod_flag [expr $ndrPeriod_flag & 0]
#@ 		    continue
#@ 		} else {
#@ 		    if {$ndrPeriod_flag == 1 && ([regexp {period} $line] || [regexp {offset} $line])} {
#@ 			append ndrPeriodOffset "$line\n"
#@ 			continue
#@ 		    }
#@ 		    if { $ndr_flag == 1} {
#@ 			append ndrTp "$line\n"
#@ 			continue
#@ 		    }
#@ 		}
#@ 	    } elseif { ![regexp {(^offset.*.;)|(\soffset.*.;)|(^period.*.;)|(\speriod.*.;) } $line ] } {
#@ 		append uinSettings "$line\n"
#@ 	    } 
#@     } 
#@     close $uin_fp
#@     return [list $uinSettings $ndrTp $ndrPeriodOffset]
#@ }
#@ 
#@ foreach {metal_g track_g} $gridPatternDict {
#@     regexp {\w(\d+)} $metal_g match metal_no
#@     set settings [getUinSettings "$pdk_path" $metal_no]
#@     lassign $settings uinSettings ndrTp ndrPeriodOffset
#@     set outfile [open "$uin_dir/flexuin_fill$metal_no.rs" w]
#@     if {[dict exists $ndrGridPatternDict $metal_g]} {  
#@ 	set track_n [dict get $ndrGridPatternDict $metal_g]
#@ 	puts $outfile "default_tp: track_pattern = \{"
#@ 	dict for {track_no csw} $track_g {
#@ 	    dict with csw {
#@ 		puts $outfile "    {$space, $width, \"$color\", \"$netName\"},"
#@ 	    }
#@ 	}
#@ 	puts $outfile "\};"
#@ 	
#@ 	#Copy ndr trackplan from pdk_path uin
#@ 	puts $outfile "ndr_tp1: track_pattern = \{"
#@ 	puts -nonewline $outfile $ndrTp
#@ 	puts $outfile "\};"
#@ 
#@ 	##Write calculated period and offset for default tp if NDR is true
#@ 	puts $outfile "region_grids = \{"
#@ 	puts $outfile "    \{"
#@ 	puts $outfile "        region = CELLBOUNDARY,"
#@ 	puts $outfile "        grid_pattern = default_tp,"
#@ 	puts $outfile "        period = [dict get $offsetPeriodDict $metal_g period],"
#@ 	puts $outfile "        offset = [dict get $offsetPeriodDict $metal_g offset],"
#@ 	puts $outfile "    \},"
#@ 
#@ 	##Copy ndr_tp period and offset from pdk_path uin
#@ 	puts $outfile "#ifdef ENABLE_NDR_UIN"
#@ 	puts $outfile "    \{"
#@ 	puts $outfile "        region = CELLBOUNDARY,"
#@ 	puts $outfile "        grid_pattern = ndr_tp1,"
#@ 	puts -nonewline $outfile $ndrPeriodOffset
#@ 	puts $outfile "     \},"
#@ 
#@ 	## Write calculated period and offset for default tp if NDR is true
#@ 	puts $outfile "    \{"
#@ 	puts $outfile "        region = CELLBOUNDARY,"
#@ 	puts $outfile "        grid_pattern = default_tp,"
#@ 	puts $outfile "        period = [dict get $offsetPeriodDict $metal_g period],"
#@ 	puts $outfile "        offset = [dict get $offsetPeriodDict $metal_g offset],"
#@ 	puts $outfile "     \},"
#@ 	puts $outfile "#endif"
#@ 	puts $outfile "\};"
#@     } else {
#@ 	## Write calculated grid pattern, period and offset for default tp
#@ 	puts $outfile "grid_pattern = \{"
#@ 	dict for {track_no csw} $track_g {
#@ 	    dict with csw {
#@ 		puts $outfile "    {$space, $width, \"$color\", \"$netName\"},"
#@ 	    }
#@ 	}
#@ 	puts $outfile "\};"
#@ 	puts $outfile "offset = [dict get $offsetPeriodDict $metal_g offset];"
#@ 	puts $outfile "period = [dict get $offsetPeriodDict $metal_g period];"
#@     }
#@ 
#@ ## Copy uin config settings from pdk_path uin
#@     puts -nonewline $outfile $uinSettings
#@     close $outfile
#@ }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/track2uin.tcl

#@ global INTEL_DFM_AUTO_UIN_DIR 
#@ set INTEL_DFM_UIN_DIR  $INTEL_DFM_AUTO_UIN_DIR 
#@ 
#@ 
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : set_fill_layers 
#@ # Description : This procedure reads the INTEL_MAX_ROUTING_LAYER to set the INTEL_DFM_M*_FILL variables automatically. 
#@ # 		To turn on via fill please set INTEL_DFM_NO_VIA_FILL to false and then run the above procedure. By default there is no via fill.
#@ # 
#@ # Required Variables:
#@ # INTEL_MAX_ROUTING_LAYER
#@ #
#@ 
#@ # Call tracks2uin.tcl and generate the uin folder on the fly locally uin // Creating all track pattern settings. I will add the command to write in the config settings
#@ # set INTEL_DFM_UIN_DIR <local_uin_files_that_was_created>
#@ 
#@ proc set_fill_layers {} {
#@ 	global INTEL_MAX_ROUTING_LAYER
#@ 	global INTEL_DFM_MAX_FILL_LAYER
#@ 	global INTEL_DFM_ZONE_VIA_FILL
#@ 	global INTEL_DFM_NO_VIA_FILL
#@ 	if { [info exists INTEL_DFM_ZONE_VIA_FILL] } {
#@ 		if {$INTEL_DFM_ZONE_VIA_FILL} {
#@ 			set INTEL_DFM_NO_VIA_FILL false
#@ 		}
#@ 	}
#@ 
#@ 	for {set j 0} { $j<=15} { incr j} {
#@ 		global INTEL_DFM_M$j\_FILL
#@ 		global INTEL_DFM_V$j\_FILL
#@ 	}
#@ 	global INTEL_DFM_V0PAXFILL
#@ 	if {![info exists INTEL_DFM_V0PAXFILL]} {
#@ 		set INTEL_DFM_V0PAXFILL true
#@ 	}
#@ 	if { ![info exists INTEL_DFM_MAX_FILL_LAYER] } {
#@ 		set INTEL_DFM_MAX_FILL_LAYER $INTEL_MAX_ROUTING_LAYER
#@ 	}
#@ 	  regsub -all {m} $INTEL_DFM_MAX_FILL_LAYER {} maxlayer
#@ 	  puts $maxlayer
#@ 
#@ 	for {set i 0} { $i<=12 } { incr i} {
#@ 		if {$i <= $maxlayer} {
#@ 		set INTEL_DFM_M$i\_FILL true
#@ 		} else {
#@ 			if {[info exists INTEL_DFM_M$i\_FILL]} {
#@ 				unset INTEL_DFM_M$i\_FILL
#@ 			}
#@ 		}
#@ 		if { $i<$maxlayer } {
#@ 			if { [info exists INTEL_DFM_NO_VIA_FILL] } {
#@ 				if {!$INTEL_DFM_NO_VIA_FILL} {
#@ 					set INTEL_DFM_V$i\_FILL true
#@ 				}
#@ 			}
#@ 		} else {
#@ 			if {[info exists INTEL_DFM_V$i\_FILL]} {
#@ 				unset INTEL_DFM_V$i\_FILL
#@ 			}
#@ 		}
#@ 	}
#@ }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : apr_write_layout_file 
#@ # Description : A function to write out gds/oas files
#@ #               apr_write_layout_file -help for all switches and descriptions.
#@ #
#@ proc apr_write_layout_file args {
#@ 	set proc_name apr_write_layout_file
#@ 	#Define proc vars
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_GDS_OUT_LAYER_MAP
#@ 	lappend proc_globals INTEL_DESIGN_NAME
#@ 
#@ 	foreach global_var $proc_globals {
#@ 	global $global_var
#@ 	}
#@ 
#@ 	set INTEL_MAX_NAME_LENGTH 64
#@ 	set INTEL_COMPRESSION_LEVEL 5
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				#puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 				#puts "hello $ref $ref_mod $val"
#@ 			}
#@ 		}
#@ 	} else {
#@ 		puts "parseOpt package is not loaded, load it before executing $proc_name"
#@ 		error "Errors detected with messages printed above.  Exiting..."
#@ 	}
#@ 
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if { $cell == "not_set" } {
#@ 		set cell $INTEL_DESIGN_NAME
#@ 	}
#@ 
#@ 	if { $output_file == "not_set" } {
#@ 		set output_file "[pwd]/$cell.gds"
#@ 		if { $compress == 1 } {
#@ 			set output_file "[pwd]/$cell.gds.gz"
#@ 		}
#@ 	}
#@ 	if { [regexp {^/} $output_file r] == 0 } {
#@ 		set output_file "[pwd]/$output_file"
#@ 	}
#@ 	if { $lib == "not_set" } {
#@ 		set lib ""
#@ 	} else {
#@ 		set lib "-lib $lib"
#@ 	}
#@ 
#@ 	## reset the stream options, since it is an additive option command.
#@ 	set_write_stream_options -reset
#@ 
#@ 	if { [regexp -all -inline {gds} $format ] != "" } {
#@ 		set_write_stream_options 		-map_fill_data 		-output_first_same_name_cell 		-skip_global_route_contact 		-contact_prefix X 		-child_depth 1000 		-output_filling fill 		-output_outdated_fill 		-output_pin {text geometry} 		-keep_data_type 		-map_layer $INTEL_GDS_OUT_LAYER_MAP 		-output_instance_name_as_property 112 		-max_name_length $INTEL_MAX_NAME_LENGTH 		-output_net text 		-set_hier_net_name_long 		-set_hier_instance_name_long
#@ 
#@ 		#stream options are additive
#@ 		if { $compress == 1 } {
#@ 			set_write_stream_options -compressed 
#@ 		}
#@ 		if { $net_prop == 1 } {
#@ 			set_write_stream_options -output_net_name_as_property 126
#@ 		}
#@ 		if { $flattenvia == 1 } {
#@ 			set_write_stream_options -flatten_via
#@ 		}
#@ 		eval write_stream $lib -cells ${cell} $output_file
#@ 	}
#@ 
#@ 	#if no merge var, do the normal ICC oasis out, that has bugs , that cannot be read into calibre or icwbev due to property errors
#@ 	if { [regexp -all -inline {oas} $format ] != "" && [info exists INTEL_MERGE_LAYOUT_LIST] == 0} {
#@ 		set_write_stream_options 		-map_fill_data 		-output_first_same_name_cell 		-skip_global_route_contact 		-contact_prefix X 		-child_depth 1000 		-output_filling fill 		-output_outdated_fill 		-output_pin {text geometry} 		-keep_data_type 		-oasis_compression_level $INTEL_COMPRESSION_LEVEL 		-map_layer $INTEL_GDS_OUT_LAYER_MAP 		-output_instance_name_as_property 112 		-max_name_length $INTEL_MAX_NAME_LENGTH 		-output_net text 		-set_hier_net_name_long 		-set_hier_instance_name_long
#@ 
#@ 		if { $net_prop == 1 } {
#@ 			set_write_stream_options -output_net_name_as_property 126
#@ 		}
#@ 		if { $flattenvia == 1 } {
#@ 			set_write_stream_options -flatten_via
#@ 		}
#@ 		eval write_stream -format oasis $lib -cells $cell $output_file
#@ 	}
#@ 
#@ 	#if there is a merge var, and oas format, first write gds, then have calibre translate to oas, to work around ICC bug
#@ 	#The INTEL_MERGE_LAYOUT_LIST can simply be empty, and no merging will be done, and calibre will read in gds and write out oas, 
#@ 	#as a simple translation.
#@ 	if { [regexp -all -inline {oas} $format ] != "" && [info exists INTEL_MERGE_LAYOUT_LIST] == 1} {
#@ 		set_write_stream_options 		-map_fill_data 		-output_first_same_name_cell 		-skip_global_route_contact 		-contact X 		-child_depth 1000 		-output_filling fill 		-output_outdated_fill 		-output_pin {text geometry} 		-keep_data_type 		-map_layer $INTEL_GDS_OUT_LAYER_MAP 		-output_instance_name_as_property 112 		-max_name_length $INTEL_MAX_NAME_LENGTH 		-output_net text 		-set_hier_net_name_long 		-set_hier_instance_name_long
#@ 
#@ 		#stream options are additive
#@ 		if { $compress == 1 } {
#@ 			set_write_stream_options -compressed 
#@ 		}
#@ 		if { $net_prop == 1 } {
#@ 			set_write_stream_options -output_net_name_as_property 126
#@ 		}
#@ 		if { $flattenvia == 1 } {
#@ 			set_write_stream_options -flatten_via
#@ 		}
#@ 		eval write_stream $lib -cells ${cell} $output_file
#@ 	}
#@ 
#@ 	## Calibredrv merge method
#@ 
#@ 
#@ 
#@ 
#@ }
#@ 
#@ 
#@ ####
#@ #### cmdSpec
#@ ####
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec apr_write_layout_file {
#@       -help "apr_write_layout_file - procedure to write gds/oas layout files."
#@       -opt {
#@          {-optname format  -type one_of_string   -values {{gds} {oas}}  -required 1 -help "Specify fill flow to operate on oasis or gds output from MWDB"}
#@          {-optname output_file -type string   -default "not_set" -required 0 -help "Specify the filename of the layout file. "}
#@          {-optname cell         -type string   -default "not_set" -required 0 -help "Specify the mwdb cell for the layout file. It will default to block.gds, where block is the current open cel"}
#@          {-optname lib         -type string   -default "not_set" -required 0 -help "Specify the mwdb lib for the cell to include in the layout file.  It will default to use the current open mwdb library."}
#@          {-optname compress       -type bool   -default 0             -required 0 -help "Specify if gds is to be compressed.  Oasis is compressed by default"}
#@          {-optname net_prop       -type bool   -default 0             -required 0 -help "Specify if the output should have net_prop 126 added."}
#@          {-optname flattenvia     -type bool   -default 0             -required 0 -help "Specify if the vias should be flattened."}
#@       }
#@    }
#@ }
#@ 
#@ 
#@ proc get_icv_list { x } {
#@ set l "{"
#@ foreach i $x {
#@ append l "\"$i\","
#@ 
#@ }
#@ append l "}"
#@ return $l
#@ }
#@ 
#@ proc write_to_file_with_replace {filename searchstring replacestring} {
#@ 	if {[file exists $filename]} {
#@ 		set uinfile [open $filename "r"]
#@ 		#puts $filename
#@ 		#puts $searchstring
#@ 		#puts $replacestring
#@ 		set temp "tmp_uin.rs"
#@ 		set tempuin [open   $temp w]
#@ 		while {[gets $uinfile line]  != -1} {
#@ 			#puts $line
#@ 			regsub "$searchstring" $line "$replacestring" line
#@ 			#puts $line
#@ 			puts $tempuin $line
#@ 		}
#@ 		close $uinfile
#@ 		close $tempuin
#@ 		exec cp $temp $filename
#@ 		exec rm -rf tmp_uin
#@ 	}
#@ }
#@ 
#@ ################################################################################
#@ # Procedure   : apr_layer_fill 
#@ # Description : The main function to launch the ICV based fill flow.  See
#@ #               apr_layer_fill -help for all switches and descriptions.
#@ #
#@ #               The flow counts on the following Parameters being set :
#@ #
#@ # Required Parameters :
#@ # INTEL_DFM_UIN_DIR 
#@ # INTEL_DFM_RELEASE_DIR
#@ # INTEL_GDS_OUT_LAYER_MAP
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ # -fill_release_dir  : The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run
#@ # -rundir : Run directory
#@ # -uindir : uin file directory that ICV command points to
#@ # -input_format : Input layout format. gds/oas/milkyway 
#@ # -milkyway_variables : If input_format=milkyway, specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath>} 
#@ 
#@ 
#@ proc apr_layer_fill args {
#@ 	set proc_name apr_layer_fill
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_LOCAL_UIN_PATH
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 	
#@ 	lappend proc_globals INTEL_GDS_OUT_LAYER_MAP
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	
#@ 	global env
#@    
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		} 
#@ 		if { $fill_release_dir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RELEASE_DIR]} {
#@ 				set fill_release_dir $INTEL_DFM_RELEASE_DIR
#@ 			} else {
#@ 				set fill_release_dir $env(INTEL_PDK)/fill/icv/
#@ 			}	    
#@ 		}	    
#@ 		if { $rundir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RUN_DIR]} {
#@ 				set rundir $INTEL_DFM_RUN_DIR
#@ 			} else {
#@ 				set rundir [pwd]
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			
#@ 			if {[info exists INTEL_DFM_LOCAL_UIN_PATH]} {
#@ 				set uindir $INTEL_DFM_LOCAL_UIN_PATH
#@ 			} elseif {[info exists INTEL_DFM_UIN_DIR]} {
#@ 				set uindir  $INTEL_DFM_UIN_DIR
#@ 			} else {	
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04
#@ 			}
#@ 		}
#@ 		if { $input_format!= "not_set"} {
#@ 			set INTEL_DFM_INPUT_FORMAT $input_format
#@ 		} else {
#@ 			unset input_format
#@ 		}
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $input_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 			}	
#@ 		}
#@ 	} else {
#@ 		puts "Warning : parseOpt package is not loaded, load it before executing $proc_name for the flow to accept commandline switches"
#@ 	}
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	#defaults
#@ 	set error_status 0
#@ 	set rundir ${rundir}/${DESIGN_NAME}_icv
#@ 	if { [file exists $rundir] == 0 } {
#@ 		exec mkdir -p ${rundir}
#@ 		exec chmod 750 ${rundir}
#@ 	}   
#@ 	exec cp -r $uindir $rundir
#@ 	set uin_dir_name  [file tail $uindir]
#@ 	set uindir $rundir/$uin_dir_name
#@ 	exec  chmod -R +w  $rundir/
#@ 	# Unsetting the intermediate variable INTEL_DFM_LOCAL_UIN_PATH and removing the duplicate local uin directories
#@ 	if {[info exists INTEL_DFM_LOCAL_UIN_PATH]} {
#@ 		exec rm -rf $INTEL_DFM_LOCAL_UIN_PATH
#@ 		unset INTEL_DFM_LOCAL_UIN_PATH
#@ 	}
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set CELLNAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set CELLNAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	if { [info exists INTEL_DFM_INPUT_FORMAT] } {
#@ 		if { $INTEL_DFM_INPUT_FORMAT == "milkyway" } {
#@ 			set LAYOUT_TYPE "-f Milkyway"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				set libname $INTEL_DFM_MW_LIBNAME
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				set libpath $INTEL_DFM_MW_LIBPATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 			}
#@ 			set LAYOUTPATH "$libname -p $libpath -lf $INTEL_GDS_OUT_LAYER_MAP "
#@ 		} elseif { $INTEL_DFM_INPUT_FORMAT == "gds"} {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.gds
#@ 				set LAYOUT_TYPE "-f GDSII"
#@ 				puts "Streaming out gds"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format gds -output_file $LAYOUTPATH -net_prop
#@ 			} 
#@ 		} else {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 				set LAYOUT_TYPE "-f OASIS"
#@ 				puts "Streaming out oasis"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 			}
#@ 		}
#@ 	} else {
#@ 		if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 			set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 		} else {
#@ 			set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 			puts "Streaming out oasis"
#@ 			apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 		}
#@ 		set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 		set libname [get_attribute [current_mw_lib] name]
#@ 		set LAYOUT_TYPE "-f OASIS"
#@ 	}
#@ 
#@ 	redirect /dev/null {set library_open [current_mw_lib]}
#@ 	if { $library_open != ""} {
#@ 		close_mw_lib    
#@ 	}   
#@ 	if {[info exists  INTEL_DFM_ICV_COMMAND_LINE_OPTIONS]} {
#@ 		set COMMAND_LINE_OPTIONS $INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	}  else {
#@ 		set COMMAND_LINE_OPTIONS "-dp8 -turbo"
#@ 	}  
#@ 	set icv_command "icv -i $LAYOUTPATH -c $CELLNAME $LAYOUT_TYPE $COMMAND_LINE_OPTIONS -I $fill_release_dir/flexfill -I $fill_release_dir/PXL/ -I $uindir $fill_release_dir/flexfill/mfill_streamlined.rs"
#@ 
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	puts "Running ICV fill runsets $rundir"
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	set LAUNCHSCRIPT [open "$rundir/${DESIGN_NAME}_launch.csh" w]
#@ 	set fill_start_time [clock seconds]
#@ 	puts $LAUNCHSCRIPT  "#!/bin/tcsh -f"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_DISABLE_RUNSET_CACHE"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_MW_WRITE_FILL_POLY_AS_RECT 1"
#@ 	puts $LAUNCHSCRIPT "setenv PDSSTM ./"
#@ 	puts $LAUNCHSCRIPT "cd $rundir/"
#@ 	puts $LAUNCHSCRIPT "if ( -d icv_fill ) rm -rf icv_fill/*"
#@ 	puts $LAUNCHSCRIPT "sleep 5"
#@ 	puts $LAUNCHSCRIPT "mkdir -p icv_fill"
#@ 	puts $LAUNCHSCRIPT "cd icv_fill"
#@ 	puts $LAUNCHSCRIPT "$icv_command >& fill.log"
#@ 
#@ 	set curdir [pwd]
#@ 	puts $LAUNCHSCRIPT "cd $curdir"
#@ 	puts $LAUNCHSCRIPT "exit 0"
#@ 	#  set cmd "perl $runsetpath/scripts/run_icv.pl $nbflag -f \"metviafill\" -c $DESIGN_NAME -lay $lay_file $cfg_flag $mw_flag"
#@ 	close $LAUNCHSCRIPT
#@ 	exec chmod +x $rundir/${DESIGN_NAME}_launch.csh
#@ 	set cmd "$rundir/${DESIGN_NAME}_launch.csh"
#@ 	puts "Running: $cmd"
#@ 
#@ 	exec $rundir/${DESIGN_NAME}_launch.csh
#@ 	set elapsed_time [expr [clock seconds] - $fill_start_time]
#@ 	set clock_hours [expr $elapsed_time / 3600]
#@ 	set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ 	set fill_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ 
#@ 	puts ""
#@ 	puts ""
#@ 	puts "ICV Fill job Runtime(hh:mm:ss) $fill_clock_elapsed "
#@ 	puts ""
#@ 	puts ""
#@ 	exec sleep 10
#@ 	if { $library_open != ""} {
#@ 		open_mw_cel -lib $libpath/${libname} $DESIGN_NAME
#@ 	}
#@ }
#@ 
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec apr_layer_fill {
#@    -help "apr_layer_fill - Creates a folder named <block name>_icv. Creates a shell script and executes the ICV command in the shell script."
#@    -opt {
#@       {-optname fill_release_dir	-type string -default "not_set"             -required 0 -help "The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run."}
#@       {-optname rundir 	-type string -default "not_set"             -required 0 -help "Directory where Folder is created and ICV executes."}
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "uin file directory that ICV command points to"}
#@       {-optname input_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Input format for fill flow"}
#@      {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath> }"}
#@       }
#@    }
#@    }
#@ 
#@ ################################################################################
#@ # Procedure   : create_uin_dir 
#@ # Description : This procedure will create the uin dir based on Kit Uin files, Global variables and input arguments. It does the following.
#@ #		Copies INTEL_DFM_UIN_DIR to a folder named d04_uin and reset the INTEL_DFM_UIN_DIR the local directory path.
#@ #		Change the layer switches in the uin file.
#@ #		Set the variables for the fill output database.
#@ #		Set the keepout cell list based on the global variables
#@ #		Set the fill lengths.
#@ #
#@ # Required Variable:
#@ # INTEL_DFM_UIN_DIR
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ #  -uindir 			: Directory where the custom uin files are included.  Default is to use kit uin dir
#@ #  -fill_length 		: Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20} 
#@ #  -metal_layers_to_fill 	: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -via_fill			: Turns on via fill
#@ #  -via_layers_to_fill 		: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -output_format 		: Specify fill flow to output either a gds or oas or  milkyway
#@ #  -milkyway_variables 		: Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}
#@ 
#@ proc create_uin_dir args {
#@ 
#@ 	set proc_name create_uin_dir
#@ 	#Define proc vars
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_ENABLE_CLOCK_NDR 
#@ 	lappend proc_globals INTEL_HALO_INTERFACE 
#@ 	##non-optional variables
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 
#@ 	global  INTEL_DFM_LOCAL_UIN_PATH 
#@ 
#@ 	lappend proc_globals INTEL_DFM_WRITE_GDS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_OASIS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_MW_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_MW_OUTPUTVIEW   
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_DFM_M0_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M1_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M2_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M3_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M4_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M5_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M6_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M7_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M8_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M9_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M10_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M11_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M12_KEEPOUT_CELLS
#@ 	lappend proc_globals INTEL_DFM_M0_FILL
#@ 	lappend proc_globals INTEL_DFM_M1_FILL
#@ 	lappend proc_globals INTEL_DFM_M2_FILL
#@ 	lappend proc_globals INTEL_DFM_M3_FILL
#@ 	lappend proc_globals INTEL_DFM_M4_FILL
#@ 	lappend proc_globals INTEL_DFM_M5_FILL
#@ 	lappend proc_globals INTEL_DFM_M6_FILL
#@ 	lappend proc_globals INTEL_DFM_M7_FILL
#@ 	lappend proc_globals INTEL_DFM_M8_FILL
#@ 	lappend proc_globals INTEL_DFM_M9_FILL
#@ 	lappend proc_globals INTEL_DFM_M10_FILL
#@ 	lappend proc_globals INTEL_DFM_M11_FILL
#@ 	lappend proc_globals INTEL_DFM_M12_FILL
#@ 	lappend proc_globals INTEL_DFM_NO_VIA_FILL
#@ 	lappend proc_globals INTEL_DFM_V0_FILL
#@ 	lappend proc_globals INTEL_DFM_V1_FILL
#@ 	lappend proc_globals INTEL_DFM_V2_FILL
#@ 	lappend proc_globals INTEL_DFM_V3_FILL
#@ 	lappend proc_globals INTEL_DFM_V4_FILL
#@ 	lappend proc_globals INTEL_DFM_V5_FILL
#@ 	lappend proc_globals INTEL_DFM_V6_FILL
#@ 	lappend proc_globals INTEL_DFM_V7_FILL
#@ 	lappend proc_globals INTEL_DFM_V8_FILL
#@ 	lappend proc_globals INTEL_DFM_V9_FILL
#@ 	lappend proc_globals INTEL_DFM_V10_FILL
#@ 	lappend proc_globals INTEL_DFM_V11_FILL
#@ 	lappend proc_globals INTEL_DFM_V12_FILL
#@ 	lappend proc_globals INTEL_DFM_V0PAXFILL
#@ 
#@ 
#@ 	lappend proc_globals INTEL_DFM_M1_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M2_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M3_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M4_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M5_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M6_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M7_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M8_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M9_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M10_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M11_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_M12_FILL_LENGTH
#@ 	lappend proc_globals INTEL_DFM_ZONE_VIA_FILL
#@ 
#@ 
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			if { [info exists INTEL_DFM_UIN_DIR] } {
#@ 				set uindir $INTEL_DFM_UIN_DIR
#@ 			} else {
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04/
#@ 			}
#@ 		}
#@ 		if { $via_fill  } {
#@ 			set INTEL_DFM_NO_VIA_FILL false
#@ 		}
#@ 		if { $nopax_fill } {
#@ 			set INTEL_DFM_V0PAXFILL false
#@ 		}	
#@ 		if { $metal_layers_to_fill != "not_set" } {
#@ 			foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 				set INTEL_DFM_M$i\_FILL false
#@ 			} 
#@ 			foreach i $metal_layers_to_fill {
#@ 				set INTEL_DFM_M$i\_FILL true
#@ 			}
#@ 		} 
#@ 		if { $via_layers_to_fill != "not_set" } {
#@ 			if { $INTEL_DFM_NO_VIA_FILL =="false" } {
#@ 				foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 					set INTEL_DFM_V$i\_FILL false
#@ 				}
#@ 				foreach i $via_layers_to_fill {
#@ 					set INTEL_DFM_V$i\_FILL true
#@ 				}
#@ 			} 
#@ 		}
#@ 		if { $fill_length != "not_set" } {
#@ 			for { set i 0 } { $i < [llength $fill_length] } {incr i 2} {
#@ 				set val [lindex  $fill_length [expr $i+1]]
#@ 				regsub -all {m} [lindex $fill_length $i] {} met
#@ 				set INTEL_DFM_M$met\_FILL_LENGTH $val
#@ 			}
#@ 		} 
#@ 		if { $output_format != "not_set" } {
#@ 			if { $output_format == "gds"} {
#@ 				set INTEL_DFM_WRITE_GDS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "oas"} {
#@ 				set INTEL_DFM_WRITE_OASIS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_WRITE_MW_OUTPUT true
#@ 			}
#@ 		} 
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_OUTPUTVIEW [lindex $milkyway_variables 2]
#@ 			} 
#@ 		} 
#@ 	} else {
#@ 		puts "warning : parseOpt package is not loaded"
#@ 	}
#@ 
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 	global env
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 	#defaults
#@ 	set error_status 0
#@ 	# set rundir [pwd]
#@ 	set uin_dir_name  [file tail $uindir]
#@ 	exec rm -rf $uin_dir_name
#@ 	exec mkdir $uin_dir_name;  
#@ 	foreach i [glob $uindir/*] {
#@ 		exec  cp  $i $uin_dir_name/
#@ 	}
#@ 	set INTEL_DFM_LOCAL_UIN_PATH [pwd]
#@ 	append INTEL_DFM_LOCAL_UIN_PATH /$uin_dir_name
#@ 	set uindir $INTEL_DFM_LOCAL_UIN_PATH
#@ 	exec  chmod -R +w  $uindir/
#@ 	exec touch $uindir/flexuin_fill_layers.rs
#@ 	set IOFILE [open $uindir/flexuin_fill_layers.rs "w"]
#@ 
#@ 	foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 		set x INTEL_DFM_M$i\_FILL
#@ 		if {[info exists [subst $x]]} {
#@ 			if {[subst $[subst $x]]} {
#@ 				puts $IOFILE "#define DFM_M$i\FILL"
#@ 			}
#@ 		}
#@ 		set y INTEL_DFM_V$i\_FILL 
#@ 		if {[info exists INTEL_DFM_NO_VIA_FILL]} {
#@ 			if {!$INTEL_DFM_NO_VIA_FILL} {
#@ 				if {[info exists [subst $y]]} {
#@ 					if {[subst $[subst $y]]} {
#@ 						puts $IOFILE "#define DFM_V$i\FILL"
#@ 					} 
#@ 				}
#@ 			}
#@ 		} 
#@ 	}
#@ 	if {[info exists INTEL_DFM_V0PAXFILL]} { 
#@ 		if { $INTEL_DFM_V0PAXFILL} {
#@ 			puts $IOFILE "#define DFM_V0PAXFILL"
#@ 		}
#@ 	}
#@ 	if {[info exists INTEL_ENABLE_CLOCK_NDR] } { 
#@ 		if {$INTEL_ENABLE_CLOCK_NDR == 1} {
#@ 			puts $IOFILE "#define ENABLE_NDR_UIN"
#@ 		}
#@ 	}	
#@ 	if {[info exists INTEL_HALO_INTERFACE] } { 
#@ 		if {[regexp "d2xn" $INTEL_HALO_INTERFACE]} {
#@ 			puts $IOFILE "#define ENABLE_D2XN_OFFSET"
#@ 		}
#@ 	}
#@ 	set sampleuinfile [open $uindir/flexuin_fill0.rs "r"]
#@ 	while {[gets $sampleuinfile line]  != -1} {
#@ 		#puts $line
#@ 		if {[regexp {^\s*process_name*} $line ] } {
#@ 			puts $IOFILE  $line
#@ 		}
#@ 	}
#@ 	close $sampleuinfile
#@ 	if {[info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_GDS_OUTPUT} {
#@ 			puts $IOFILE "write_stm_output = true;"
#@ 		} else {
#@ 			puts $IOFILE "write_stm_output = false;"
#@ 		}  
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_OASIS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_OASIS_OUTPUT} {
#@ 			puts $IOFILE "write_oas_output = true;"
#@ 		} 
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_MW_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_MW_OUTPUT} {    
#@ 			if {![info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 				puts $IOFILE "write_stm_output = false;"
#@ 			}
#@ 			puts $IOFILE "write_milkyway_output = true;"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				puts $IOFILE "mw_library = \"$INTEL_DFM_MW_LIBNAME\" ;"
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				puts $IOFILE "mw_library = \"$libname\" ;"
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				puts $IOFILE "mw_path = \"$INTEL_DFM_MW_LIBPATH\" ;"
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				puts $IOFILE "mw_path = \"$libpath\" ;"
#@ 			}
#@ 			puts $IOFILE "mw_append = true;"
#@ 			if {[info exists  INTEL_DFM_MW_OUTPUTVIEW]} {
#@ 				puts $IOFILE "mw_view = \"$INTEL_DFM_MW_OUTPUTVIEW\";"
#@ 			} else {
#@ 				puts $IOFILE "mw_view = \"FILL\";"
#@ 			}
#@ 		} 
#@ 	}
#@ 	puts $IOFILE "do_final_texting = false;"
#@ 	puts $IOFILE "write_fill_on_dummy_layer_only = true;"
#@ 	puts $IOFILE "#define SPLIT_FILL_AS_EXTENSIONS_AND_FLOAT "
#@ 	if { [info exists INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if { [string equal $INTEL_DFM_WRITE_GDS_OUTPUT == "false"] && (![info exists INTEL_DFM_WRITE_OASIS_OUTPUT] || [string equal $INTEL_DFM_WRITE_OASIS_OUTPUT == "false"]) && (![info exists INTEL_DFM_WRITE_MW_OUTPUT] || [string equal $INTEL_DFM_WRITE_MW_OUTPUT == "false"]) } {
#@ 			error "all output set to null. please set either of INTEL_DFM_WRITE_GDS_OUTPUT or INTEL_DFM_WRITE_OASIS_OUTPUT or INTEL_DFM_WRITE_MW_OUTPUT to true. unset all in which case default output will be a gds output."
#@ 		}
#@ 	}
#@ 	foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 		set x INTEL_DFM_M$i\_KEEPOUT_CELLS
#@ 		if {[info exists [subst $x]]} {
#@ 			if {[llength [subst $[subst $x]]] > 0} {
#@ 				set keepout_cells [get_icv_list [subst $[subst $x]]]
#@ 				puts $IOFILE "m$i\_prune_cells_list = $keepout_cells ;"
#@ 				write_to_file_with_replace "$uindir/flexuin_fill$i\.rs" "keepout_cells_list\\s*=\\s*\.*;" "keepout_cells_list = $keepout_cells ;"
#@ 			} else {
#@ 				puts $IOFILE "m$i\_prune_cells_list = {\"\"} ;"
#@ 			}
#@ 		} else {
#@ 			puts $IOFILE "m$i\_prune_cells_list = {\"\"} ;"
#@ 		} 
#@ 	}
#@ 	close $IOFILE
#@ 	foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 		set x INTEL_DFM_M$i\_FILL_LENGTH
#@ 		if {[info exists [subst $x]]} {
#@ 			if {[subst $[subst $x]] > 0} {
#@ 				fill_length = [subst $[subst $x]]
#@ 				write_to_file_with_replace "$uindir/flexuin_fill${i}.rs" "fill_length\\s*=\\s*\.*;" "fill_length = $fill_length ;"
#@ 			} 
#@ 		} 
#@ 	} 
#@ 
#@ 	if { [info exists INTEL_DFM_ZONE_VIA_FILL] } {
#@ 		if { $INTEL_DFM_ZONE_VIA_FILL } {
#@ 			foreach i {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 				set y INTEL_DFM_V$i\_FILL 
#@ 				if {[info exists $y]} {
#@ 					set kor_space  0.001
#@ 					set density_target 0.06
#@ 					set vfill_uin  ""
#@ 					set vfile [open "$uindir/flexuin_vfill${i}.rs" r]
#@ 					set hookup_regions  "hookup_regions = { \n {\n VIA${i}ZONE,\n{\"floatiss_\"},\n {\"*\"},\n true,\n false,\n density_target,\n},\n};"
#@ 					set tmp_cnt 0	
#@ 					foreach line [split [read $vfile] \n ] {
#@ 						if { [regexp {^\/\/|^\s+\/\/} $line res ]  } {
#@ 							append vfill_uin "$line\n" 
#@ 						} elseif { $tmp_cnt == 1 }	{
#@ 							#puts $line
#@ 							if { [regexp {\};} $line res1 ] } { 
#@ 								set tmp_cnt 0
#@ 								append vfill_uin $hookup_regions
#@ 							}
#@ 						} else {
#@ 							if { [ regexp {drawn_kor_[x|y]_space} $line res2 ] } {
#@ 								append vfill_uin "$res2=$kor_space;\n"
#@ 							} elseif { [regexp {^.*.density_target\s*=} $line res3] } { 
#@ 								append vfill_uin "$res3 $density_target;\n"
#@ 							} elseif { [regexp {hookup_regions} $line res4 ] } {
#@ 								set tmp_cnt 1
#@ 							} else {
#@ 								append vfill_uin "$line\n"
#@ 							}
#@ 						}
#@ 					}
#@ 					close $vfile
#@ 					set vfile_new [open "$uindir/flexuin_vfill${i}.rs" w]
#@ 					puts $vfile_new $vfill_uin
#@ 					close $vfile_new
#@ 				
#@ 				}
#@ 			}
#@ 		}
#@ 	}
#@ }
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec create_uin_dir {
#@    -help "create_uin_dir - Creates UIN directory with changes to files on layer switches, keepout cells, fill_lengths and output control."
#@    -opt {
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "Directory where the custom uin files are included.  Default is to use kit uin dir"}
#@       {-optname fill_length  	-type list   -default {not_set}             -required 0 -help "Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20}"} 
#@       {-optname metal_layers_to_fill	-type list   -default {not_set}             -required 0 -help "Specify the layers to perform fill on I.e. {0 1 2 3 4 }"}
#@       {-optname via_fill	-type bool   -default 0	             -required 0 -help "Turns on via fill "}   
#@       {-optname nopax_fill	-type bool   -default 0	             -required 0 -help "Turns off bridge via fill "}   
#@       {-optname via_layers_to_fill	-type list   -default {not_set}             -required 0 -help "Specify the layers to perform fill on I.e. {0 1 2 3 4 }"}
#@       {-optname output_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Specify fill flow to output either a gds or oas or  milkyway"}
#@       {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}"}
#@       }
#@    }
#@    }
#@ ################################################################################
#@ # Procedure   : apr_set_cell_keepout_variables #{{{
#@ # Description : The procedure reads the milkyway layout macros and appends the macro names to the global variables DFM_Mx_KEEPOUT_CELLS.
#@ 
#@ 
#@ proc set_cell_keepout_variables args {
#@ 
#@ 	set proc_name "apr_set_cell_keepout_variables"
#@ 	if { [llength [info command running_from_synopsys]] > 0 } {
#@ 		if {[running_from_synopsys]} {  } else { run_fm_in_synopsys; return }
#@ 	}
#@ 
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_DFM_M0_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M1_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M2_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M3_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M4_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M5_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M6_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M7_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M8_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M9_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M10_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M11_KEEPOUT_CELLS 
#@ 	lappend proc_globals INTEL_DFM_M12_KEEPOUT_CELLS
#@ 	lappend proc_globals gui_suppress_auto_layout
#@ 
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 	#Get command line args.
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals { 
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 	set macro_names {}
#@ 
#@ 	if { [info exists help] == 1} {
#@ 		set printout "This function sets cell list variables for apr_layer_fill \n"
#@ 		append printout "procedure.  It sets variables  that are used to  \n"
#@ 		append printout "specify that no fill on the layer within the boundary of the cells specified\n"
#@ 		append printout "  \n"
#@ 		append printout "\n"
#@ 		append printout "USAGE:\n"
#@ 		append printout "$proc_name "
#@ 		append printout "\t THe global variables INTEL_DFM_Mx_KEEPOUT_CELLS will be automatically set based on the \n"
#@ 		append printout "\t macro properties of the blocks within the milkyway database. \n"
#@ 		puts $printout
#@ 		return
#@ 	}
#@ 	puts ""
#@ 	puts ""
#@ 	puts "Macro instances:"
#@ 	puts "========================================================="
#@ 	puts ""
#@ 
#@ 	foreach_in_collection c [get_cells -quiet -all  -hierarchical  -filter "@is_hard_macro==true"] {
#@ 		puts "[get_attribute $c name] [get_attribute $c ref_name] [get_attribute $c full_name]"
#@ 		set name [get_attribute $c ref_name]
#@ 		lappend macro_names $name
#@ 	}
#@ 	puts ""
#@ 	#Prevent GUI popups of the fram view
#@ 
#@ 	set gui_suppress_auto_layout true
#@ 	foreach name [lsort -unique $macro_names] {
#@ 		open_mw_cel $name.FRAM -readonly
#@ 		foreach metal {0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 			if { [sizeof_collection [get_user_shapes -quiet -filter "@layer==\"m$metal\""]] > 0 || [sizeof_collection [get_ports  -quiet -filter "@layer==\"m$metal\""]] } {
#@ 				if {[info exists INTEL_DFM_M$metal\_KEEPOUT_CELLS]} {
#@ 					lappend INTEL_DFM_M$metal\_KEEPOUT_CELLS $name
#@ 				} else {
#@ 					set INTEL_DFM_M$metal\_KEEPOUT_CELLS $name
#@ 				}
#@ 			}
#@ 		}
#@ 		close_mw_cel $name.FRAM
#@ 	}
#@ }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : fill_view_purge
#@ # Description : This procedure is a utility procedure to selectively remove layers on the FILL view or to completely remove the FILL view.
#@ #
#@ # INTEL_DFM_PURGE_ALL - Set by default and it is to remove the complete Fill view
#@ # INTEL_DFM_PURGE_Mx  - Set this variable and set INTEL_DFM_PURGE_ALL false to selectively remove layers from FILL view
#@ 
#@ proc fill_view_purge args {
#@ 
#@ 	set proc_globals {}
#@ 
#@ 	##non-optional variables
#@ 	lappend proc_globals INTEL_DFM_PURGE_ALL
#@ 	lappend proc_globals INTEL_DFM_PURGE_M0
#@ 	lappend proc_globals INTEL_DFM_PURGE_M1
#@ 	lappend proc_globals INTEL_DFM_PURGE_M2
#@ 	lappend proc_globals INTEL_DFM_PURGE_M3
#@ 	lappend proc_globals INTEL_DFM_PURGE_M4
#@ 	lappend proc_globals INTEL_DFM_PURGE_M5
#@ 	lappend proc_globals INTEL_DFM_PURGE_M6
#@ 	lappend proc_globals INTEL_DFM_PURGE_M7
#@ 	lappend proc_globals INTEL_DFM_PURGE_M8
#@ 	lappend proc_globals INTEL_DFM_PURGE_M9
#@ 	lappend proc_globals INTEL_DFM_PURGE_M10
#@ 	lappend proc_globals INTEL_DFM_PURGE_M11
#@ 	lappend proc_globals INTEL_DFM_PURGE_M12
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 
#@ 	set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 	set libname [get_attribute [current_mw_lib] name]
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	}
#@ 	if { [info exists INTEL_DFM_PURGE_ALL]} {
#@ 		set purge_all $INTEL_DFM_PURGE_ALL
#@ 	} else {
#@ 		set purge_all true
#@ 	}
#@ 
#@ 	if { $purge_all } {
#@ 		set fill_view [glob -nocomplain ${libpath}/${libname}/FILL/${DESIGN_NAME}:*]
#@ 		if {[llength $fill_view] > 0 } {
#@ 			puts "Purging fill data from [lindex $fill_view [expr [llength $fill_view]-1]]"
#@ 			puts "=================================================="
#@ 			#temporary fix to remove FILL view until polygons w/ vertice >4 issue resolved
#@ 			# The polygons w/ >4 vertices do not get fill_track attribute
#@ 			# Possibly will be fixed w/ use of ICV 2008+ with icc 2008+
#@ 			remove_mw_cel -verbose -version_kept 0 ${DESIGN_NAME}.FILL
#@ 			#open_mw_cel ${DESIGN_NAME}.FILL
#@ 			#insert_metal_filler -purge
#@ 			#save_mw_cel
#@ 			#close_mw_cel
#@ 		}
#@ 		puts "Purging fill data from the CEL view"
#@ 		puts "=================================================="
#@ 		#insert_metal_filler -purge
#@ 		# not using the command above, since when writing fill as wires, it will not purge.
#@ 		set fill_net_coll [get_net_shapes -quiet -filter "route_type == \"Fill Track\""]
#@ 		if { [sizeof_collection $fill_net_coll] > 0} {
#@ 			remove_objects $fill_net_coll
#@ 		}
#@ 		set fill_user_coll [get_user_shapes -quiet -filter "route_type == \"Fill Track\""]
#@ 		if { [sizeof_collection $fill_user_coll] > 0} {
#@ 			remove_objects $fill_user_coll
#@ 		}
#@ 		if { [info exists INTEL_MCMM] == 1 } {
#@ 			if {$INTEL_MCMM == 1} {  
#@ 				save_mw_cel -scenarios [all_scenarios]
#@ 			} else {
#@ 				save_mw_cel
#@ 			}
#@ 		} else {
#@ 			save_mw_cel
#@ 		}
#@ 	} else {
#@ 		if { [llength  [glob -nocomplain ${libpath}/${libname}/FILL/${DESIGN_NAME}:*]] } {
#@ 			open_mw_cel ${DESIGN_NAME}.FILL
#@ 			foreach i { 0 1 2 3 4 5 6 7 8 9 10 11 12} {
#@ 				set x INTEL_DFM_PURGE_M$i 
#@ 				if { [info exists INTEL_DFM_PURGE_M$i]} {
#@ 					if { [subst $[subst $x]] } {
#@ 						set x [get_net_shapes -filter "layer==m$i"]
#@ 						if { [llength $x ] >0 } {
#@ 							remove_objects $x
#@ 							save_mw_cel
#@ 						}
#@ 						set y [get_user_shapes -filter "layer==m$i"]
#@ 						if { [llength $y ] >0 } {
#@ 							remove_objects $y
#@ 							save_mw_cel
#@ 						}
#@ 					}			
#@ 				}
#@ 			}
#@ 			close_mw_cel ${DESIGN_NAME}.FILL
#@ 		}
#@ 	}
#@ }
#@ 
#@ 
#@ #if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@ #  ::parseOpt::cmdSpec fill_view_purge {
#@ # -help "fill_view_purge - Creates a folder named <block name>_icv. Creates a shell script and executes the ICV command in the shell script."
#@ # -opt {
#@ #  {-optname purge_list  	-type list   -default {not_set} #          -required 0 -help "Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20}"}   
#@ # }
#@ # }
#@ #}
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : create_uin_dir_implant for implant fill
#@ # Description : This procedure will create the uin dir based on Kit Uin files, Global variables and input arguments. It does the following.
#@ #		Copies INTEL_DFM_UIN_DIR to a folder named d04_uin and reset the INTEL_DFM_UIN_DIR the local directory path.
#@ #		Change the layer switches in the uin file.
#@ #		Set the variables for the fill output database.
#@ #		Set the keepout cell list based on the global variables
#@ #		Set the fill lengths.
#@ #
#@ # Required Variable:
#@ # INTEL_DFM_UIN_DIR
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ #  -uindir 			: Directory where the custom uin files are included.  Default is to use kit uin dir
#@ #  -fill_length 		: Specify max fill length per layer I.e {m0 30 m1 0.357 m2 20} 
#@ #  -metal_layers_to_fill 	: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -via_fill			: Turns on via fill
#@ #  -via_layers_to_fill 		: Specify the layers to perform fill on I.e. {0 1 2 3 4 }
#@ #  -output_format 		: Specify fill flow to output either a gds or oas or  milkyway
#@ #  -milkyway_variables 		: Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}
#@ 
#@ proc create_uin_dir_implant args {
#@ 
#@ 	set proc_name create_uin_dir_implant
#@ 	#Define proc vars
#@ 	set proc_globals {}
#@ 	##non-optional variables
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 
#@ 	global  INTEL_DFM_LOCAL_IMPLANT_UIN_PATH 
#@ 
#@ 	lappend proc_globals INTEL_DFM_WRITE_GDS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_OASIS_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_WRITE_MW_OUTPUT
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_MW_OUTPUTVIEW   
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_EBB_CELLS_LIST
#@ 	
#@ 
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			if { [info exists INTEL_DFM_UIN_DIR] } {
#@ 				set uindir $INTEL_DFM_UIN_DIR
#@ 			} else {
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04/
#@ 			}
#@ 		}
#@ 		
#@ 		if { $output_format != "not_set" } {
#@ 			if { $output_format == "gds"} {
#@ 				set INTEL_DFM_WRITE_GDS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "oas"} {
#@ 				set INTEL_DFM_WRITE_OASIS_OUTPUT true
#@ 			}
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_WRITE_MW_OUTPUT true
#@ 			}
#@ 		} 
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $output_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_OUTPUTVIEW [lindex $milkyway_variables 2]
#@ 			} 
#@ 		} 
#@ 	} else {
#@ 		puts "warning : parseOpt package is not loaded"
#@ 	}
#@ 
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 	global env
#@ 
#@ 	#defaults
#@ 	set error_status 0
#@ 	# set rundir [pwd]
#@ 	set uin_dir_name  [file tail $uindir]_implant
#@ 	if { [file exists $uin_dir_name] == 0 } {
#@     		exec mkdir $uin_dir_name;  
#@ 	}
#@ 	exec cp  $uindir/uin_implant.rs $uin_dir_name/
#@ 	
#@ 	set INTEL_DFM_LOCAL_IMPLANT_UIN_PATH [pwd]
#@ 	append INTEL_DFM_LOCAL_IMPLANT_UIN_PATH /$uin_dir_name
#@ 	set uindir $INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 	exec  chmod -R +w  $uindir/
#@ 	exec touch $uindir/uin_implant.rs
#@ 	set IOFILE [open $uindir/uin_implant.rs "w"]
#@ 
#@   
#@   if { [info exists INTEL_EBB_CELLS_LIST] } {
#@     puts $IOFILE "ebb_cells_list = \"$INTEL_EBB_CELLS_LIST\" ;"
#@   } else {
#@     puts $IOFILE "ebb_cells_list = \"\" ;"
#@   }		
#@ 	
#@ 	if {[info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_GDS_OUTPUT} {
#@ 			puts $IOFILE "write_gds_output = true;"
#@ 		} else {
#@ 			puts $IOFILE "write_gds_output = false;"
#@ 		}  
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_OASIS_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_OASIS_OUTPUT} {
#@ 			puts $IOFILE "write_oas_output = true;"
#@ 		} else {
#@ 			puts $IOFILE "write_oas_output = false;"
#@ 		} 
#@ 	} 
#@ 	if {[info exists  INTEL_DFM_WRITE_MW_OUTPUT]} {
#@ 		if {$INTEL_DFM_WRITE_MW_OUTPUT} {    
#@ 			if {![info exists  INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 				puts $IOFILE "write_gds_output = false;"
#@ 			}
#@       if {![info exists  INTEL_DFM_WRITE_OASIS_OUTPUT]} {
#@ 				puts $IOFILE "write_oas_output = false;"
#@ 			}
#@ 			puts $IOFILE "write_milkyway_output = true;"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				puts $IOFILE "mw_library = \"$INTEL_DFM_MW_LIBNAME\" ;"
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				puts $IOFILE "mw_library = \"$libname\" ;"
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				puts $IOFILE "mw_path = \"$INTEL_DFM_MW_LIBPATH\" ;"
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				puts $IOFILE "mw_path = \"$libpath\" ;"
#@ 			}
#@ 			puts $IOFILE "mw_append = true;"
#@ 			if {[info exists  INTEL_DFM_MW_OUTPUTVIEW]} {
#@ 				puts $IOFILE "mw_view = \"$INTEL_DFM_MW_OUTPUTVIEW\";"
#@ 			} else {
#@ 				puts $IOFILE "mw_view = \"FILL\";"
#@ 			}
#@ 		} 
#@ 	}
#@ 	
#@ 	if { [info exists INTEL_DFM_WRITE_GDS_OUTPUT]} {
#@ 		if { [string equal $INTEL_DFM_WRITE_GDS_OUTPUT == "false"] && (![info exists INTEL_DFM_WRITE_OASIS_OUTPUT] || [string equal $INTEL_DFM_WRITE_OASIS_OUTPUT == "false"]) && (![info exists INTEL_DFM_WRITE_MW_OUTPUT] || [string equal $INTEL_DFM_WRITE_MW_OUTPUT == "false"]) } {
#@ 			error "all output set to null. please set either of INTEL_DFM_WRITE_GDS_OUTPUT or INTEL_DFM_WRITE_OASIS_OUTPUT or INTEL_DFM_WRITE_MW_OUTPUT to true. unset all in which case default output will be a gds output."
#@ 		}
#@ 	}
#@ 	close $IOFILE
#@ }
#@ 
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec create_uin_dir_implant {
#@    -help "create_uin_dir_implant - Creates UIN directory with changes to files on layer switches, keepout cells, fill_lengths and output control."
#@    -opt {
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "Directory where the custom uin files are included.  Default is to use kit uin dir"}
#@       {-optname output_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Specify fill flow to output either a gds or oas or  milkyway"}
#@       {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname libpath and view I.e. {<libname> <libpath> <view>}"}
#@       }
#@    }
#@    }
#@ 
#@ 
#@ ################################################################################
#@ # Procedure   : apr_layer_fill for implant
#@ # Description : The main function to launch the ICV based fill flow.  See
#@ #               apr_layer_fill -help for all switches and descriptions.
#@ #
#@ #               The flow counts on the following Parameters being set :
#@ #
#@ # Required Parameters :
#@ # INTEL_DFM_UIN_DIR 
#@ # INTEL_DFM_RELEASE_DIR
#@ # INTEL_GDS_OUT_LAYER_MAP
#@ #
#@ ############################
#@ # Switches for the procedure
#@ ############################
#@ #
#@ # -fill_release_dir  : The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run
#@ # -rundir : Run directory
#@ # -uindir : uin file directory that ICV command points to
#@ # -input_format : Input layout format. gds/oas/milkyway 
#@ # -milkyway_variables : If input_format=milkyway, specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath>} 
#@ 
#@ 
#@ proc apr_layer_fill_implant args {
#@ 	set proc_name apr_layer_fill_implant
#@ 	set proc_globals {}
#@ 	lappend proc_globals INTEL_DFM_UIN_DIR
#@ 	lappend proc_globals INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 	lappend proc_globals INTEL_DFM_RELEASE_DIR
#@ 	
#@ 	lappend proc_globals INTEL_GDS_OUT_LAYER_MAP
#@ 	lappend proc_globals INTEL_DFM_DESIGN_NAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBNAME
#@ 	lappend proc_globals INTEL_DFM_MW_LIBPATH
#@ 	lappend proc_globals INTEL_DFM_DESIGN_PATH
#@ 	lappend proc_globals INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	
#@ 	global env
#@    
#@ 	foreach global_var $proc_globals {
#@ 		global $global_var
#@ 	}
#@ 
#@ 
#@ 	#Get command line args.
#@ 	if { [llength [info command ::parseOpt::parseOpt]] > 0 } {
#@ 		if {![::parseOpt::parseOpt $proc_name $args]} { return 0 }
#@ 		#Print out command line args.
#@ 		puts "=============================="
#@ 		puts "Options given to $proc_name:"
#@ 		puts "==============================" 
#@ 		if { [info exists opt] == 1 } {
#@ 			foreach {ref val} [array get opt] {
#@ 				puts "[format "%-30s\t%-70s" $ref $val]"
#@ 				regsub -all {^-} $ref {} ref_mod
#@ 				set $ref_mod $val
#@ 			}
#@ 		} 
#@ 		if { $fill_release_dir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RELEASE_DIR]} {
#@ 				set fill_release_dir $INTEL_DFM_RELEASE_DIR
#@ 			} else {
#@ 				set fill_release_dir $env(INTEL_PDK)/fill/icv/implantfill
#@ 			}	    
#@ 		}	    
#@ 		if { $rundir == "not_set"} {
#@ 			if {[info exists INTEL_DFM_RUN_DIR]} {
#@ 				set rundir $INTEL_DFM_RUN_DIR
#@ 			} else {
#@ 				set rundir [pwd]
#@ 			}
#@ 		}
#@ 		if { $uindir == "not_set"} {
#@ 			
#@ 			if {[info exists INTEL_DFM_LOCAL_IMPLANT_UIN_PATH]} {
#@ 				set uindir $INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 			} elseif {[info exists INTEL_DFM_UIN_DIR]} {
#@ 				set uindir  $INTEL_DFM_UIN_DIR
#@ 			} else {	
#@ 				set uindir $INTEL_DFM_RELEASE_DIR/uin/d04
#@ 			}
#@ 		}
#@ 		if { $input_format!= "not_set"} {
#@ 			set INTEL_DFM_INPUT_FORMAT $input_format
#@ 		} else {
#@ 			unset input_format
#@ 		}
#@ 		if { $milkyway_variables !="not_set" } {
#@ 			if { $input_format == "milkyway"} {
#@ 				set INTEL_DFM_MW_LIBPATH [lindex $milkyway_variables 1]
#@ 				set INTEL_DFM_MW_LIBNAME [lindex $milkyway_variables 0]
#@ 			}	
#@ 		}
#@ 	} else {
#@ 		puts "Warning : parseOpt package is not loaded, load it before executing $proc_name for the flow to accept commandline switches"
#@ 	}
#@ 	puts "\n============================================="
#@ 	puts "Global Variables used:"
#@ 	puts "============================================="
#@ 	foreach global_var $proc_globals {
#@ 		if {[info exists $global_var] == 1 } {
#@ 			puts -nonewline [format "%-30s\t" $global_var]
#@ 			puts [eval puts -nonewline $$global_var]
#@ 		} else {
#@ 			puts "$global_var "
#@ 		}
#@ 	}
#@ 
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set DESIGN_NAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set DESIGN_NAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	#defaults
#@ 	set error_status 0
#@ 	set rundir ${rundir}/${DESIGN_NAME}_icv
#@ 	if { [file exists $rundir] == 0 } {
#@ 		exec mkdir -p ${rundir}
#@ 		exec chmod 750 ${rundir}
#@ 	}  
#@ 
#@   set uin_dir_name  [file tail $uindir]
#@   if { [file exists $rundir/$uin_dir_name] == 0 } {
#@     exec cp -r $uindir $rundir
#@   }
#@ 	
#@ 	set uindir $rundir/$uin_dir_name
#@ 	exec  chmod -R +w  $rundir/
#@ 	# Unsetting the intermediate variable INTEL_DFM_LOCAL_IMPLANT_UIN_PATH and removing the duplicate local uin directories
#@ 	if {[info exists INTEL_DFM_LOCAL_IMPLANT_UIN_PATH]} {
#@ 		exec rm -rf $INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 		unset INTEL_DFM_LOCAL_IMPLANT_UIN_PATH
#@ 	}
#@ 	if {[info exists  INTEL_DFM_DESIGN_NAME]} {
#@ 		set CELLNAME $INTEL_DFM_DESIGN_NAME
#@ 	} else {
#@ 		set CELLNAME [get_attribute [current_mw_cel] name]
#@ 	} 
#@ 
#@ 	if { [info exists INTEL_DFM_INPUT_FORMAT] } {
#@ 		if { $INTEL_DFM_INPUT_FORMAT == "milkyway" } {
#@ 			set LAYOUT_TYPE "-f Milkyway"
#@ 			if {[info exists  INTEL_DFM_MW_LIBNAME]} {
#@ 				set libname $INTEL_DFM_MW_LIBNAME
#@ 			} else {
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 			}
#@ 			if {[info exists  INTEL_DFM_MW_LIBPATH]} {
#@ 				set libpath $INTEL_DFM_MW_LIBPATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 			}
#@ 			set LAYOUTPATH "$libname -p $libpath -lf $INTEL_GDS_OUT_LAYER_MAP "
#@ 		} elseif { $INTEL_DFM_INPUT_FORMAT == "gds"} {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.gds
#@ 				set LAYOUT_TYPE "-f GDSII"
#@ 				puts "Streaming out gds"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format gds -output_file $LAYOUTPATH -net_prop
#@ 			} 
#@ 		} else {
#@ 			if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 				set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 			} else {
#@ 				set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 				set libname [get_attribute [current_mw_lib] name]
#@ 				set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 				set LAYOUT_TYPE "-f OASIS"
#@ 				puts "Streaming out oasis"
#@ 				apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 			}
#@ 		}
#@ 	} else {
#@ 		if {[info exists  INTEL_DFM_DESIGN_PATH]} {
#@ 			set LAYOUTPATH $INTEL_DFM_DESIGN_PATH
#@ 		} else {
#@ 			set LAYOUTPATH $rundir/${CELLNAME}.mwnofill.oas
#@ 			puts "Streaming out oasis"
#@ 			apr_write_layout_file -cell ${CELLNAME} -format oas -output_file $LAYOUTPATH -net_prop 
#@ 		}
#@ 		set libpath [file dirname [get_attribute [current_mw_lib] path] ]
#@ 		set libname [get_attribute [current_mw_lib] name]
#@ 		set LAYOUT_TYPE "-f OASIS"
#@ 	}
#@ 
#@ 	redirect /dev/null {set library_open [current_mw_lib]}
#@ 	if { $library_open != ""} {
#@ 		close_mw_lib    
#@ 	}   
#@ 	if {[info exists  INTEL_DFM_ICV_COMMAND_LINE_OPTIONS]} {
#@ 		set COMMAND_LINE_OPTIONS $INTEL_DFM_ICV_COMMAND_LINE_OPTIONS
#@ 	}  else {
#@ 		set COMMAND_LINE_OPTIONS "-dp8 -turbo"
#@ 	}  
#@ 
#@ 	set icv_command "icv -i $LAYOUTPATH -c $CELLNAME $LAYOUT_TYPE $COMMAND_LINE_OPTIONS -I $fill_release_dir/implantfill -I $uindir $fill_release_dir/implantfill/filluv12_withyn.rs"
#@ 
#@ 	
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	puts "Running ICV fill runsets $rundir"
#@ 	puts ""
#@ 	puts ""
#@ 	puts "=================================================="
#@ 	puts ""
#@ 	puts ""
#@ 	set LAUNCHSCRIPT [open "$rundir/${DESIGN_NAME}_launch_implant.csh" w]
#@ 	set fill_start_time [clock seconds]
#@ 	puts $LAUNCHSCRIPT  "#!/bin/tcsh -f"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_DISABLE_RUNSET_CACHE"
#@ 	puts $LAUNCHSCRIPT "setenv ICV_MW_WRITE_FILL_POLY_AS_RECT 1"
#@ 	puts $LAUNCHSCRIPT "setenv PDSSTM ./"
#@ 	puts $LAUNCHSCRIPT "cd $rundir/"
#@ 	puts $LAUNCHSCRIPT "if ( -d icv_fill_implant ) rm -rf icv_fill_implant/*"
#@ 	puts $LAUNCHSCRIPT "sleep 5"
#@ 	puts $LAUNCHSCRIPT "mkdir -p icv_fill_implant"
#@ 	puts $LAUNCHSCRIPT "cd icv_fill_implant"
#@ 	puts $LAUNCHSCRIPT "$icv_command >& fill_implant.log"
#@ 	
#@ 
#@ 	set curdir [pwd]
#@ 	puts $LAUNCHSCRIPT "cd $curdir"
#@ 	puts $LAUNCHSCRIPT "exit 0"
#@ 	#  set cmd "perl $runsetpath/scripts/run_icv.pl $nbflag -f \"metviafill\" -c $DESIGN_NAME -lay $lay_file $cfg_flag $mw_flag"
#@ 	close $LAUNCHSCRIPT
#@ 	exec chmod +x $rundir/${DESIGN_NAME}_launch_implant.csh
#@ 	set cmd "$rundir/${DESIGN_NAME}_launch_implant.csh"
#@ 	puts "Running: $cmd"
#@ 
#@ 	exec $rundir/${DESIGN_NAME}_launch_implant.csh
#@ 	set elapsed_time [expr [clock seconds] - $fill_start_time]
#@ 	set clock_hours [expr $elapsed_time / 3600]
#@ 	set clock_secs [expr $elapsed_time - (3600 * $clock_hours)]
#@ 	set fill_clock_elapsed [format "%02.2d:%02.2d:%02.2d" $clock_hours [expr $clock_secs / 60] [expr $clock_secs % 60]]
#@ 
#@ 	puts ""
#@ 	puts ""
#@ 	puts "ICV Fill job Runtime(hh:mm:ss) $fill_clock_elapsed "
#@ 	puts ""
#@ 	puts ""
#@ 	exec sleep 10
#@ 	if { $library_open != ""} {
#@ 		open_mw_cel -lib $libpath/${libname} $DESIGN_NAME
#@ 	}
#@ }
#@ 
#@ if { [llength [info command ::parseOpt::cmdSpec]] > 0 } {
#@    ::parseOpt::cmdSpec apr_layer_fill_implant {
#@    -help "apr_layer_fill_implant - Creates a folder named <block name>_icv. Creates a shell script and executes the ICV command in the shell script."
#@    -opt {
#@       {-optname fill_release_dir	-type string -default "not_set"             -required 0 -help "The directory which points to the fill release path. This folder will contain folders such as PXL and flexfill which is necessary for the ICV command to run."}
#@       {-optname rundir 	-type string -default "not_set"             -required 0 -help "Directory where Folder is created and ICV executes."}
#@       {-optname uindir 	-type string -default "not_set"             -required 0 -help "uin file directory that ICV command points to"}
#@       {-optname input_format		-type one_of_string   -default "not_set" -values {{gds} {oas} {milkyway}}  -required 0 -help "Input format for fill flow"}
#@      {-optname milkyway_variables	-type list  -default {not_set} -required 0 -help "Specify Milkyway variables such as libname and libpath I.e. {<libname> <libpath> }"}
#@       }
#@    }
#@    }
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s//asicflows/synopsys/fill/fill_icv_procs.tcl

#@ 
#@ ###################################################
#@ # Sourcing setup fill procedures
#@ ###################################################
#@ 
#@ # This procedure reads the INTEL_MAX_ROUTING_LAYER to set layers for fill automatically.
#@ # Please use INTEL_DFM_M*_FILL variable to separately control layers for fill.
#@ # Via fill is truned off by default. To turn on via fill "set INTEL_DFM_NO_VIA_FILL false"
#@ set_fill_layers
#@ 
#@ # This procedures sets up the keepout cells. Use INTEL_DFM_M*_KEEPOUT_CELLS to control the procedure.
#@ set_cell_keepout_variables
#@ 
#@ # Purges the existing fill view
#@ fill_view_purge
#@ 
#@ # Creates new uin dir according to specified layers to fill
#@ create_uin_dir
#@ if {![info exists INTEL_XN_LIBRARY]||([info exists INTEL_XN_LIBRARY]&&!$INTEL_XN_LIBRARY)} {
#@   create_uin_dir_implant
#@ }
#@ 
#@ ###################################################
#@ # Run Metal-Via and Implant Fill insertion
#@ ###################################################
#@ apr_layer_fill
#@ if {![info exists INTEL_XN_LIBRARY]||([info exists INTEL_XN_LIBRARY]&&!$INTEL_XN_LIBRARY)} {
#@   apr_layer_fill_implant
#@ }
#@ 
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/metal_via_fill.tcl

#@ # -- Starting source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/create_port_layer.tcl

#@ ##############################################################################
#@ 
#@ #
#@ # Script creates port layers over I/O ports in the design
#@ #
#@ 
#@ suppress_message MWUI-031
#@ set_object_snap_type -enabled false
#@ 
#@ if {[sizeof_collection [get_net_shapes -filter {datatype_number==2} -quiet]]>0} {
#@   echo "Removing previously created port layer texts";
#@   remove_net_shape [get_net_shapes -filter {datatype_number==2}]
#@   remove_text *
#@ }
#@ 
#@ foreach_in_collection term [get_terminals -of_objects [get_ports -all]] {
#@   set tname [get_attribute -quiet $term name];
#@   set pname [get_attribute -quiet $term owner_port];
#@   set layer [get_attribute -quiet $term layer];
#@   set dtype 2;
#@ 
#@   # if no layer specified for empty terminal skip
#@   if {$layer eq "" || $layer eq "c4b"} {
#@     continue
#@   }
#@ 
#@   set lx [get_attribute $term bbox_llx];
#@   set ly [get_attribute $term bbox_lly];
#@   set ux [get_attribute $term bbox_urx];
#@   set uy [get_attribute $term bbox_ury];
#@ 
#@   set cx [expr $lx + [expr ($ux-$lx)/2.0]];
#@   set cy [expr $ly + [expr ($uy-$ly)/2.0]];
#@ 
#@   echo "Creating port layer - $layer;$dtype for port $pname";
#@   create_net_shape -net $pname -route_type user_enter -bbox "$lx $ly $ux $uy" -layer $layer -datatype $dtype
#@ 
#@   create_text -origin "$cx $cy" -layer $layer -datatype $dtype $pname
#@   
#@ }
#@ 
#@ 
#@ ## Create text for MIM Flows
#@ foreach_in_collection tm1 [get_net_shapes -filter {layer==tm1}] {
#@   set pname [get_attribute $tm1 owner_net];
#@   set layer tm1;
#@ 
#@   set lx [get_attribute [get_net_shape $tm1] bbox_llx];
#@   set ly [get_attribute [get_net_shape $tm1] bbox_lly];
#@   set ux [get_attribute [get_net_shape $tm1] bbox_urx];
#@   set uy [get_attribute [get_net_shape $tm1] bbox_ury];
#@ 
#@   set cx [expr $lx + [expr ($ux-$lx)/2]];
#@   set cy [expr $ly + [expr ($uy-$ly)/2]];
#@ 
#@   create_text -origin "$cx $cy" -layer tm1 $pname
#@ }
#@ 
#@ unsuppress_message MWUI-031
#@ set_object_snap_type -enabled true
#@ # -- End source /p/fdkgt/adf_qa/nightly_adf_kit_build_regr/builds_regr/nightly/1273/dot3/synopsys/2015-03-31/kit/afdk73_kit_s/asicflows/synopsys/apr/create_port_layer.tcl

#@ exit
